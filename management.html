<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20aria-hidden%3D%22true%22%20role%3D%22img%22%20class%3D%22iconify%20iconify--logos%22%20width%3D%2231.88%22%20height%3D%2232%22%20preserveAspectRatio%3D%22xMidYMid%20meet%22%20viewBox%3D%220%200%20256%20257%22%3E%3Cdefs%3E%3ClinearGradient%20id%3D%22IconifyId1813088fe1fbc01fb466%22%20x1%3D%22-.828%25%22%20x2%3D%2257.636%25%22%20y1%3D%227.652%25%22%20y2%3D%2278.411%25%22%3E%3Cstop%20offset%3D%220%25%22%20stop-color%3D%22%2341D1FF%22%3E%3C%2Fstop%3E%3Cstop%20offset%3D%22100%25%22%20stop-color%3D%22%23BD34FE%22%3E%3C%2Fstop%3E%3C%2FlinearGradient%3E%3ClinearGradient%20id%3D%22IconifyId1813088fe1fbc01fb467%22%20x1%3D%2243.376%25%22%20x2%3D%2250.316%25%22%20y1%3D%222.242%25%22%20y2%3D%2289.03%25%22%3E%3Cstop%20offset%3D%220%25%22%20stop-color%3D%22%23FFEA83%22%3E%3C%2Fstop%3E%3Cstop%20offset%3D%228.333%25%22%20stop-color%3D%22%23FFDD35%22%3E%3C%2Fstop%3E%3Cstop%20offset%3D%22100%25%22%20stop-color%3D%22%23FFA800%22%3E%3C%2Fstop%3E%3C%2FlinearGradient%3E%3C%2Fdefs%3E%3Cpath%20fill%3D%22url(%23IconifyId1813088fe1fbc01fb466)%22%20d%3D%22M255.153%2037.938L134.897%20252.976c-2.483%204.44-8.862%204.466-11.382.048L.875%2037.958c-2.746-4.814%201.371-10.646%206.827-9.67l120.385%2021.517a6.537%206.537%200%200%200%202.322-.004l117.867-21.483c5.438-.991%209.574%204.796%206.877%209.62Z%22%3E%3C%2Fpath%3E%3Cpath%20fill%3D%22url(%23IconifyId1813088fe1fbc01fb467)%22%20d%3D%22M185.432.063L96.44%2017.501a3.268%203.268%200%200%200-2.634%203.014l-5.474%2092.456a3.268%203.268%200%200%200%203.997%203.378l24.777-5.718c2.318-.535%204.413%201.507%203.936%203.838l-7.361%2036.047c-.495%202.426%201.782%204.5%204.151%203.78l15.304-4.649c2.372-.72%204.652%201.36%204.15%203.788l-11.698%2056.621c-.732%203.542%203.979%205.473%205.943%202.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505%204.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CLI Proxy API Management Center</title>
    <script type="module" crossorigin>var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")], isAwait = false, method, it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw") throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object)) __typeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
var require_index_001 = __commonJS({
  "index-DycN0IkJ.js"(exports) {
    var _Aa;
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) return;
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") continue;
          for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
        }
      }).observe(document, {
        childList: true,
        subtree: true
      });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity) fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
        else fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep) return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var jsxRuntime = { exports: {} };
    var reactJsxRuntime_production = {};
    var hasRequiredReactJsxRuntime_production;
    function requireReactJsxRuntime_production() {
      if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
      hasRequiredReactJsxRuntime_production = 1;
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      function jsxProd(type, config2, maybeKey) {
        var key = null;
        void 0 !== maybeKey && (key = "" + maybeKey);
        void 0 !== config2.key && (key = "" + config2.key);
        if ("key" in config2) {
          maybeKey = {};
          for (var propName in config2)
            "key" !== propName && (maybeKey[propName] = config2[propName]);
        } else maybeKey = config2;
        config2 = maybeKey.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== config2 ? config2 : null,
          props: maybeKey
        };
      }
      reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
      reactJsxRuntime_production.jsx = jsxProd;
      reactJsxRuntime_production.jsxs = jsxProd;
      return reactJsxRuntime_production;
    }
    var hasRequiredJsxRuntime;
    function requireJsxRuntime() {
      if (hasRequiredJsxRuntime) return jsxRuntime.exports;
      hasRequiredJsxRuntime = 1;
      {
        jsxRuntime.exports = requireReactJsxRuntime_production();
      }
      return jsxRuntime.exports;
    }
    var jsxRuntimeExports = requireJsxRuntime();
    var react = { exports: {} };
    var react_production = {};
    var hasRequiredReact_production;
    function requireReact_production() {
      if (hasRequiredReact_production) return react_production;
      hasRequiredReact_production = 1;
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function() {
        },
        enqueueReplaceState: function() {
        },
        enqueueSetState: function() {
        }
      }, assign = Object.assign, emptyObject = {};
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback2) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback2, "setState");
      };
      Component.prototype.forceUpdate = function(callback2) {
        this.updater.enqueueForceUpdate(this, callback2, "forceUpdate");
      };
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent;
      assign(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      var isArrayImpl = Array.isArray;
      function noop2() {
      }
      var ReactSharedInternals = { H: null, A: null, T: null, S: null }, hasOwnProperty2 = Object.prototype.hasOwnProperty;
      function ReactElement(type, key, props) {
        var refProp = props.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== refProp ? refProp : null,
          props
        };
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        return ReactElement(oldElement.type, newKey, oldElement.props);
      }
      function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape2(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      var userProvidedKeyEscapeRegex = /\/+/g;
      function getElementKey(element, index2) {
        return "object" === typeof element && null !== element && null != element.key ? escape2("" + element.key) : index2.toString(36);
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop2, noop2) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error2) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error2);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback2) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback2
                  );
              }
          }
        if (invokeCallback)
          return callback2 = callback2(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback2) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback2, array, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback2 && (isValidElement(callback2) && (callback2 = cloneAndReplaceKey(
            callback2,
            escapedPrefix + (null == callback2.key || children && children.key === callback2.key ? "" : ("" + callback2.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + invokeCallback
          )), array.push(callback2)), 1;
        invokeCallback = 0;
        var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i2 = 0; i2 < children.length; i2++)
            nameSoFar = children[i2], type = nextNamePrefix + getElementKey(nameSoFar, i2), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback2
            );
        else if (i2 = getIteratorFn(children), "function" === typeof i2)
          for (children = i2.call(children), i2 = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i2++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback2
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback2
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error2) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error2;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status) return payload._result.default;
        throw payload._result;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error2) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error2 && null !== error2 && "string" === typeof error2.message ? String(error2.message) : String(error2),
            error: error2
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error2);
          return;
        }
        console.error(error2);
      }, Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      react_production.Activity = REACT_ACTIVITY_TYPE;
      react_production.Children = Children;
      react_production.Component = Component;
      react_production.Fragment = REACT_FRAGMENT_TYPE;
      react_production.Profiler = REACT_PROFILER_TYPE;
      react_production.PureComponent = PureComponent;
      react_production.StrictMode = REACT_STRICT_MODE_TYPE;
      react_production.Suspense = REACT_SUSPENSE_TYPE;
      react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      react_production.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(size) {
          return ReactSharedInternals.H.useMemoCache(size);
        }
      };
      react_production.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments);
        };
      };
      react_production.cacheSignal = function() {
        return null;
      };
      react_production.cloneElement = function(element, config2, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key;
        if (null != config2)
          for (propName in void 0 !== config2.key && (key = "" + config2.key), config2)
            !hasOwnProperty2.call(config2, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config2.ref || (props[propName] = config2[propName]);
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          for (var childArray = Array(propName), i2 = 0; i2 < propName; i2++)
            childArray[i2] = arguments[i2 + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key, props);
      };
      react_production.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        return defaultValue;
      };
      react_production.createElement = function(type, config2, children) {
        var propName, props = {}, key = null;
        if (null != config2)
          for (propName in void 0 !== config2.key && (key = "" + config2.key), config2)
            hasOwnProperty2.call(config2, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config2[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) props.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), i2 = 0; i2 < childrenLength; i2++)
            childArray[i2] = arguments[i2 + 2];
          props.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === props[propName] && (props[propName] = childrenLength[propName]);
        return ReactElement(type, key, props);
      };
      react_production.createRef = function() {
        return { current: null };
      };
      react_production.forwardRef = function(render) {
        return { $$typeof: REACT_FORWARD_REF_TYPE, render };
      };
      react_production.isValidElement = isValidElement;
      react_production.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      react_production.memo = function(type, compare2) {
        return {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare2 ? null : compare2
        };
      };
      react_production.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop2, reportGlobalError);
        } catch (error2) {
          reportGlobalError(error2);
        } finally {
          null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      };
      react_production.unstable_useCacheRefresh = function() {
        return ReactSharedInternals.H.useCacheRefresh();
      };
      react_production.use = function(usable) {
        return ReactSharedInternals.H.use(usable);
      };
      react_production.useActionState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useActionState(action, initialState, permalink);
      };
      react_production.useCallback = function(callback2, deps) {
        return ReactSharedInternals.H.useCallback(callback2, deps);
      };
      react_production.useContext = function(Context2) {
        return ReactSharedInternals.H.useContext(Context2);
      };
      react_production.useDebugValue = function() {
      };
      react_production.useDeferredValue = function(value, initialValue) {
        return ReactSharedInternals.H.useDeferredValue(value, initialValue);
      };
      react_production.useEffect = function(create2, deps) {
        return ReactSharedInternals.H.useEffect(create2, deps);
      };
      react_production.useEffectEvent = function(callback2) {
        return ReactSharedInternals.H.useEffectEvent(callback2);
      };
      react_production.useId = function() {
        return ReactSharedInternals.H.useId();
      };
      react_production.useImperativeHandle = function(ref, create2, deps) {
        return ReactSharedInternals.H.useImperativeHandle(ref, create2, deps);
      };
      react_production.useInsertionEffect = function(create2, deps) {
        return ReactSharedInternals.H.useInsertionEffect(create2, deps);
      };
      react_production.useLayoutEffect = function(create2, deps) {
        return ReactSharedInternals.H.useLayoutEffect(create2, deps);
      };
      react_production.useMemo = function(create2, deps) {
        return ReactSharedInternals.H.useMemo(create2, deps);
      };
      react_production.useOptimistic = function(passthrough, reducer) {
        return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
      };
      react_production.useReducer = function(reducer, initialArg, init) {
        return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
      };
      react_production.useRef = function(initialValue) {
        return ReactSharedInternals.H.useRef(initialValue);
      };
      react_production.useState = function(initialState) {
        return ReactSharedInternals.H.useState(initialState);
      };
      react_production.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return ReactSharedInternals.H.useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      react_production.useTransition = function() {
        return ReactSharedInternals.H.useTransition();
      };
      react_production.version = "19.2.1";
      return react_production;
    }
    var hasRequiredReact;
    function requireReact() {
      if (hasRequiredReact) return react.exports;
      hasRequiredReact = 1;
      {
        react.exports = requireReact_production();
      }
      return react.exports;
    }
    var reactExports = requireReact();
    const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    var client = { exports: {} };
    var reactDomClient_production = {};
    var scheduler = { exports: {} };
    var scheduler_production = {};
    var hasRequiredScheduler_production;
    function requireScheduler_production() {
      if (hasRequiredScheduler_production) return scheduler_production;
      hasRequiredScheduler_production = 1;
      (function(exports$1) {
        function push(heap, node) {
          var index2 = heap.length;
          heap.push(node);
          a: for (; 0 < index2; ) {
            var parentIndex = index2 - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare2(parent, node))
              heap[parentIndex] = node, heap[index2] = parent, index2 = parentIndex;
            else break a;
          }
        }
        function peek(heap) {
          return 0 === heap.length ? null : heap[0];
        }
        function pop(heap) {
          if (0 === heap.length) return null;
          var first = heap[0], last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            a: for (var index2 = 0, length = heap.length, halfLength = length >>> 1; index2 < halfLength; ) {
              var leftIndex = 2 * (index2 + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
              if (0 > compare2(left, last))
                rightIndex < length && 0 > compare2(right, left) ? (heap[index2] = right, heap[rightIndex] = last, index2 = rightIndex) : (heap[index2] = left, heap[leftIndex] = last, index2 = leftIndex);
              else if (rightIndex < length && 0 > compare2(right, last))
                heap[index2] = right, heap[rightIndex] = last, index2 = rightIndex;
              else break a;
            }
          }
          return first;
        }
        function compare2(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return 0 !== diff ? diff : a.id - b.id;
        }
        exports$1.unstable_now = void 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          exports$1.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date, initialTime = localDate.now();
          exports$1.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
        function advanceTimers(currentTime) {
          for (var timer = peek(timerQueue); null !== timer; ) {
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime)
              pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
            else break;
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled)
            if (null !== peek(taskQueue))
              isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
        }
        var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
        function shouldYieldToHost() {
          return needsPaint ? true : exports$1.unstable_now() - startTime < frameInterval ? false : true;
        }
        function performWorkUntilDeadline() {
          needsPaint = false;
          if (isMessageLoopRunning) {
            var currentTime = exports$1.unstable_now();
            startTime = currentTime;
            var hasMoreWork = true;
            try {
              a: {
                isHostCallbackScheduled = false;
                isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                isPerformingWork = true;
                var previousPriorityLevel = currentPriorityLevel;
                try {
                  b: {
                    advanceTimers(currentTime);
                    for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                      var callback2 = currentTask.callback;
                      if ("function" === typeof callback2) {
                        currentTask.callback = null;
                        currentPriorityLevel = currentTask.priorityLevel;
                        var continuationCallback = callback2(
                          currentTask.expirationTime <= currentTime
                        );
                        currentTime = exports$1.unstable_now();
                        if ("function" === typeof continuationCallback) {
                          currentTask.callback = continuationCallback;
                          advanceTimers(currentTime);
                          hasMoreWork = true;
                          break b;
                        }
                        currentTask === peek(taskQueue) && pop(taskQueue);
                        advanceTimers(currentTime);
                      } else pop(taskQueue);
                      currentTask = peek(taskQueue);
                    }
                    if (null !== currentTask) hasMoreWork = true;
                    else {
                      var firstTimer = peek(timerQueue);
                      null !== firstTimer && requestHostTimeout(
                        handleTimeout,
                        firstTimer.startTime - currentTime
                      );
                      hasMoreWork = false;
                    }
                  }
                  break a;
                } finally {
                  currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
                }
                hasMoreWork = void 0;
              }
            } finally {
              hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
            }
          }
        }
        var schedulePerformWorkUntilDeadline;
        if ("function" === typeof localSetImmediate)
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        else if ("undefined" !== typeof MessageChannel) {
          var channel = new MessageChannel(), port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        function requestHostTimeout(callback2, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback2(exports$1.unstable_now());
          }, ms);
        }
        exports$1.unstable_IdlePriority = 5;
        exports$1.unstable_ImmediatePriority = 1;
        exports$1.unstable_LowPriority = 4;
        exports$1.unstable_NormalPriority = 3;
        exports$1.unstable_Profiling = null;
        exports$1.unstable_UserBlockingPriority = 2;
        exports$1.unstable_cancelCallback = function(task) {
          task.callback = null;
        };
        exports$1.unstable_forceFrameRate = function(fps) {
          0 > fps || 125 < fps ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
        };
        exports$1.unstable_getCurrentPriorityLevel = function() {
          return currentPriorityLevel;
        };
        exports$1.unstable_next = function(eventHandler) {
          switch (currentPriorityLevel) {
            case 1:
            case 2:
            case 3:
              var priorityLevel = 3;
              break;
            default:
              priorityLevel = currentPriorityLevel;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports$1.unstable_requestPaint = function() {
          needsPaint = true;
        };
        exports$1.unstable_runWithPriority = function(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              priorityLevel = 3;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports$1.unstable_scheduleCallback = function(priorityLevel, callback2, options) {
          var currentTime = exports$1.unstable_now();
          "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
          switch (priorityLevel) {
            case 1:
              var timeout = -1;
              break;
            case 2:
              timeout = 250;
              break;
            case 5:
              timeout = 1073741823;
              break;
            case 4:
              timeout = 1e4;
              break;
            default:
              timeout = 5e3;
          }
          timeout = options + timeout;
          priorityLevel = {
            id: taskIdCounter++,
            callback: callback2,
            priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
          };
          options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
          return priorityLevel;
        };
        exports$1.unstable_shouldYield = shouldYieldToHost;
        exports$1.unstable_wrapCallback = function(callback2) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback2.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        };
      })(scheduler_production);
      return scheduler_production;
    }
    var hasRequiredScheduler;
    function requireScheduler() {
      if (hasRequiredScheduler) return scheduler.exports;
      hasRequiredScheduler = 1;
      {
        scheduler.exports = requireScheduler_production();
      }
      return scheduler.exports;
    }
    var reactDom = { exports: {} };
    var reactDom_production = {};
    var hasRequiredReactDom_production;
    function requireReactDom_production() {
      if (hasRequiredReactDom_production) return reactDom_production;
      hasRequiredReactDom_production = 1;
      var React2 = requireReact();
      function formatProdErrorMessage(code2) {
        var url = "https://react.dev/errors/" + code2;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i2 = 2; i2 < arguments.length; i2++)
            url += "&args[]=" + encodeURIComponent(arguments[i2]);
        }
        return "Minified React error #" + code2 + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function noop2() {
      }
      var Internals = {
        d: {
          f: noop2,
          r: function() {
            throw Error(formatProdErrorMessage(522));
          },
          D: noop2,
          C: noop2,
          L: noop2,
          m: noop2,
          X: noop2,
          S: noop2,
          M: noop2
        },
        p: 0,
        findDOMNode: null
      }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      var ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      function getCrossOriginStringAs(as, input) {
        if ("font" === as) return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      reactDom_production.createPortal = function(children, container2) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container2 || 1 !== container2.nodeType && 9 !== container2.nodeType && 11 !== container2.nodeType)
          throw Error(formatProdErrorMessage(299));
        return createPortal$1(children, container2, null, key);
      };
      reactDom_production.flushSync = function(fn) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
        }
      };
      reactDom_production.preconnect = function(href, options) {
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      reactDom_production.prefetchDNS = function(href) {
        "string" === typeof href && Internals.d.D(href);
      };
      reactDom_production.preinit = function(href, options) {
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      reactDom_production.preinitModule = function(href, options) {
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as) {
              var crossOrigin = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              );
              Internals.d.M(href, {
                crossOrigin,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
            }
          } else null == options && Internals.d.M(href);
      };
      reactDom_production.preload = function(href, options) {
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
          Internals.d.L(href, as, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      reactDom_production.preloadModule = function(href, options) {
        if ("string" === typeof href)
          if (options) {
            var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
            Internals.d.m(href, {
              as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0
            });
          } else Internals.d.m(href);
      };
      reactDom_production.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      reactDom_production.unstable_batchedUpdates = function(fn, a) {
        return fn(a);
      };
      reactDom_production.useFormState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useFormState(action, initialState, permalink);
      };
      reactDom_production.useFormStatus = function() {
        return ReactSharedInternals.H.useHostTransitionStatus();
      };
      reactDom_production.version = "19.2.1";
      return reactDom_production;
    }
    var hasRequiredReactDom;
    function requireReactDom() {
      if (hasRequiredReactDom) return reactDom.exports;
      hasRequiredReactDom = 1;
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      {
        checkDCE();
        reactDom.exports = requireReactDom_production();
      }
      return reactDom.exports;
    }
    var hasRequiredReactDomClient_production;
    function requireReactDomClient_production() {
      if (hasRequiredReactDomClient_production) return reactDomClient_production;
      hasRequiredReactDomClient_production = 1;
      var Scheduler2 = requireScheduler(), React2 = requireReact(), ReactDOM = requireReactDom();
      function formatProdErrorMessage(code2) {
        var url = "https://react.dev/errors/" + code2;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i2 = 2; i2 < arguments.length; i2++)
            url += "&args[]=" + encodeURIComponent(arguments[i2]);
        }
        return "Minified React error #" + code2 + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function isValidContainer(node) {
        return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
      }
      function getNearestMountedFiber(fiber) {
        var node = fiber, nearestMounted = fiber;
        if (fiber.alternate) for (; node.return; ) node = node.return;
        else {
          fiber = node;
          do
            node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
          while (fiber);
        }
        return 3 === node.tag ? nearestMounted : null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (13 === fiber.tag) {
          var suspenseState = fiber.memoizedState;
          null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
          if (null !== suspenseState) return suspenseState.dehydrated;
        }
        return null;
      }
      function getActivityInstanceFromFiber(fiber) {
        if (31 === fiber.tag) {
          var activityState = fiber.memoizedState;
          null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
          if (null !== activityState) return activityState.dehydrated;
        }
        return null;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber)
          throw Error(formatProdErrorMessage(188));
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          alternate = getNearestMountedFiber(fiber);
          if (null === alternate) throw Error(formatProdErrorMessage(188));
          return alternate !== fiber ? null : fiber;
        }
        for (var a = fiber, b = alternate; ; ) {
          var parentA = a.return;
          if (null === parentA) break;
          var parentB = parentA.alternate;
          if (null === parentB) {
            b = parentA.return;
            if (null !== b) {
              a = b;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            for (parentB = parentA.child; parentB; ) {
              if (parentB === a) return assertIsMounted(parentA), fiber;
              if (parentB === b) return assertIsMounted(parentA), alternate;
              parentB = parentB.sibling;
            }
            throw Error(formatProdErrorMessage(188));
          }
          if (a.return !== b.return) a = parentA, b = parentB;
          else {
            for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }
              if (child$0 === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) {
              for (child$0 = parentB.child; child$0; ) {
                if (child$0 === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }
                if (child$0 === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }
                child$0 = child$0.sibling;
              }
              if (!didFindChild) throw Error(formatProdErrorMessage(189));
            }
          }
          if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
        }
        if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
        return a.stateNode.current === a ? fiber : alternate;
      }
      function findCurrentHostFiberImpl(node) {
        var tag = node.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
        for (node = node.child; null !== node; ) {
          tag = findCurrentHostFiberImpl(node);
          if (null !== tag) return tag;
          node = node.sibling;
        }
        return null;
      }
      var assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
      var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch (type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      var isArrayImpl = Array.isArray, ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
        pending: false,
        data: null,
        method: null,
        action: null
      }, valueStack = [], index2 = -1;
      function createCursor(defaultValue) {
        return { current: defaultValue };
      }
      function pop(cursor2) {
        0 > index2 || (cursor2.current = valueStack[index2], valueStack[index2] = null, index2--);
      }
      function push(cursor2, value) {
        index2++;
        valueStack[index2] = cursor2.current;
        cursor2.current = value;
      }
      var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance);
        push(contextFiberStackCursor, fiber);
        push(contextStackCursor, null);
        switch (nextRootInstance.nodeType) {
          case 9:
          case 11:
            fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
            break;
          default:
            if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
              nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
            else
              switch (fiber) {
                case "svg":
                  fiber = 1;
                  break;
                case "math":
                  fiber = 2;
                  break;
                default:
                  fiber = 0;
              }
        }
        pop(contextStackCursor);
        push(contextStackCursor, fiber);
      }
      function popHostContainer() {
        pop(contextStackCursor);
        pop(contextFiberStackCursor);
        pop(rootInstanceStackCursor);
      }
      function pushHostContext(fiber) {
        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
        var context = contextStackCursor.current;
        var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
        context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
      }
      function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
      }
      var prefix, suffix;
      function describeBuiltInComponentFrame(name2) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name2 + suffix;
      }
      var reentry = false;
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$1) {
                      control = x$1;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$2) {
                    control = x$2;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample2) {
                if (sample2 && control && "string" === typeof sample2.stack)
                  return [sample2.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
              RunInRootFrame++;
            for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
              for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
                namePropDescriptor--;
            for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
              if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                  do
                    if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                      var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                      fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                      return frame;
                    }
                  while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
                }
                break;
              }
          }
        } finally {
          reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
        }
        return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
      }
      function describeFiber(fiber, childFiber) {
        switch (fiber.tag) {
          case 26:
          case 27:
          case 5:
            return describeBuiltInComponentFrame(fiber.type);
          case 16:
            return describeBuiltInComponentFrame("Lazy");
          case 13:
            return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
          case 19:
            return describeBuiltInComponentFrame("SuspenseList");
          case 0:
          case 15:
            return describeNativeComponentFrame(fiber.type, false);
          case 11:
            return describeNativeComponentFrame(fiber.type.render, false);
          case 1:
            return describeNativeComponentFrame(fiber.type, true);
          case 31:
            return describeBuiltInComponentFrame("Activity");
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "", previous = null;
          do
            info += describeFiber(workInProgress2, previous), previous = workInProgress2, workInProgress2 = workInProgress2.return;
          while (workInProgress2);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      var hasOwnProperty2 = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler2.unstable_scheduleCallback, cancelCallback$1 = Scheduler2.unstable_cancelCallback, shouldYield = Scheduler2.unstable_shouldYield, requestPaint = Scheduler2.unstable_requestPaint, now = Scheduler2.unstable_now, getCurrentPriorityLevel = Scheduler2.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler2.unstable_ImmediatePriority, UserBlockingPriority = Scheduler2.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler2.unstable_NormalPriority, LowPriority = Scheduler2.unstable_LowPriority, IdlePriority = Scheduler2.unstable_IdlePriority, log$1 = Scheduler2.log, unstable_setDisableYieldValue = Scheduler2.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
      function setIsStrictModeForDevtools(newIsStrictMode) {
        "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
        if (injectedHook && "function" === typeof injectedHook.setStrictMode)
          try {
            injectedHook.setStrictMode(rendererID, newIsStrictMode);
          } catch (err) {
          }
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
      function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
      }
      var nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304;
      function getHighestPriorityLanes(lanes) {
        var pendingSyncLanes = lanes & 42;
        if (0 !== pendingSyncLanes) return pendingSyncLanes;
        switch (lanes & -lanes) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
            return 128;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
            return lanes & 261888;
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return lanes & 3932160;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return lanes & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return lanes;
        }
      }
      function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
        var pendingLanes = root2.pendingLanes;
        if (0 === pendingLanes) return 0;
        var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
        root2 = root2.warmLanes;
        var nonIdlePendingLanes = pendingLanes & 134217727;
        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
      }
      function checkIfRootIsPrerendering(root2, renderLanes2) {
        return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case 1:
          case 2:
          case 4:
          case 8:
          case 64:
            return currentTime + 250;
          case 16:
          case 32:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return currentTime + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
        return lane;
      }
      function createLaneMap(initial) {
        for (var laneMap = [], i2 = 0; 31 > i2; i2++) laneMap.push(initial);
        return laneMap;
      }
      function markRootUpdated$1(root2, updateLane) {
        root2.pendingLanes |= updateLane;
        268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
      }
      function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
        var previouslyPendingLanes = root2.pendingLanes;
        root2.pendingLanes = remainingLanes;
        root2.suspendedLanes = 0;
        root2.pingedLanes = 0;
        root2.warmLanes = 0;
        root2.expiredLanes &= remainingLanes;
        root2.entangledLanes &= remainingLanes;
        root2.errorRecoveryDisabledLanes &= remainingLanes;
        root2.shellSuspendCounter = 0;
        var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
        for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
          var index$7 = 31 - clz32(remainingLanes), lane = 1 << index$7;
          entanglements[index$7] = 0;
          expirationTimes[index$7] = -1;
          var hiddenUpdatesForLane = hiddenUpdates[index$7];
          if (null !== hiddenUpdatesForLane)
            for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
              var update = hiddenUpdatesForLane[index$7];
              null !== update && (update.lane &= -536870913);
            }
          remainingLanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
      }
      function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
        root2.pendingLanes |= spawnedLane;
        root2.suspendedLanes &= ~spawnedLane;
        var spawnedLaneIndex = 31 - clz32(spawnedLane);
        root2.entangledLanes |= spawnedLane;
        root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
      }
      function markRootEntangled(root2, entangledLanes) {
        var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
        for (root2 = root2.entanglements; rootEntangledLanes; ) {
          var index$8 = 31 - clz32(rootEntangledLanes), lane = 1 << index$8;
          lane & entangledLanes | root2[index$8] & entangledLanes && (root2[index$8] |= entangledLanes);
          rootEntangledLanes &= ~lane;
        }
      }
      function getBumpedLaneForHydration(root2, renderLanes2) {
        var renderLane = renderLanes2 & -renderLanes2;
        renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
        return 0 !== (renderLane & (root2.suspendedLanes | renderLanes2)) ? 0 : renderLane;
      }
      function getBumpedLaneForHydrationByLane(lane) {
        switch (lane) {
          case 2:
            lane = 1;
            break;
          case 8:
            lane = 4;
            break;
          case 32:
            lane = 16;
            break;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            lane = 128;
            break;
          case 268435456:
            lane = 134217728;
            break;
          default:
            lane = 0;
        }
        return lane;
      }
      function lanesToEventPriority(lanes) {
        lanes &= -lanes;
        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
      }
      function resolveUpdatePriority() {
        var updatePriority = ReactDOMSharedInternals.p;
        if (0 !== updatePriority) return updatePriority;
        updatePriority = window.event;
        return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
      }
      function runWithPriority(priority, fn) {
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          return ReactDOMSharedInternals.p = priority, fn();
        } finally {
          ReactDOMSharedInternals.p = previousPriority;
        }
      }
      var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
      function detachDeletedInstance(node) {
        delete node[internalInstanceKey];
        delete node[internalPropsKey];
        delete node[internalEventHandlersKey];
        delete node[internalEventHandlerListenersKey];
        delete node[internalEventHandlesSetKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) return targetInst;
        for (var parentNode = targetNode.parentNode; parentNode; ) {
          if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
            parentNode = targetInst.alternate;
            if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
              for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
                if (parentNode = targetNode[internalInstanceKey]) return parentNode;
                targetNode = getParentHydrationBoundary(targetNode);
              }
            return targetInst;
          }
          targetNode = parentNode;
          parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node) {
        if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
          var tag = node.tag;
          if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
            return node;
        }
        return null;
      }
      function getNodeFromInstance(inst) {
        var tag = inst.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
        throw Error(formatProdErrorMessage(33));
      }
      function getResourcesFromRoot(root2) {
        var resources = root2[internalRootNodeResourcesKey];
        resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
        return resources;
      }
      function markNodeAsHoistable(node) {
        node[internalHoistableMarker] = true;
      }
      var allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {};
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + "Capture", dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        registrationNameDependencies[registrationName] = dependencies;
        for (registrationName = 0; registrationName < dependencies.length; registrationName++)
          allNativeEvents.add(dependencies[registrationName]);
      }
      var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName)) return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        return false;
      }
      function setValueForAttribute(node, name2, value) {
        if (isAttributeNameSafe(name2))
          if (null === value) node.removeAttribute(name2);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                node.removeAttribute(name2);
                return;
              case "boolean":
                var prefix$10 = name2.toLowerCase().slice(0, 5);
                if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
                  node.removeAttribute(name2);
                  return;
                }
            }
            node.setAttribute(name2, "" + value);
          }
      }
      function setValueForKnownAttribute(node, name2, value) {
        if (null === value) node.removeAttribute(name2);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name2);
              return;
          }
          node.setAttribute(name2, "" + value);
        }
      }
      function setValueForNamespacedAttribute(node, namespace, name2, value) {
        if (null === value) node.removeAttribute(name2);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name2);
              return;
          }
          node.setAttributeNS(namespace, name2, "" + value);
        }
      }
      function getToStringValue(value) {
        switch (typeof value) {
          case "bigint":
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return value;
          case "object":
            return value;
          default:
            return "";
        }
      }
      function isCheckable(elem) {
        var type = elem.type;
        return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
      }
      function trackValueOnNode(node, valueField, currentValue) {
        var descriptor = Object.getOwnPropertyDescriptor(
          node.constructor.prototype,
          valueField
        );
        if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
          var get2 = descriptor.get, set2 = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
              return get2.call(this);
            },
            set: function(value) {
              currentValue = "" + value;
              set2.call(this, value);
            }
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          return {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              currentValue = "" + value;
            },
            stopTracking: function() {
              node._valueTracker = null;
              delete node[valueField];
            }
          };
        }
      }
      function track(node) {
        if (!node._valueTracker) {
          var valueField = isCheckable(node) ? "checked" : "value";
          node._valueTracker = trackValueOnNode(
            node,
            valueField,
            "" + node[valueField]
          );
        }
      }
      function updateValueIfChanged(node) {
        if (!node) return false;
        var tracker = node._valueTracker;
        if (!tracker) return true;
        var lastValue = tracker.getValue();
        var value = "";
        node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
        node = value;
        return node !== lastValue ? (tracker.setValue(node), true) : false;
      }
      function getActiveElement(doc2) {
        doc2 = doc2 || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof doc2) return null;
        try {
          return doc2.activeElement || doc2.body;
        } catch (e) {
          return doc2.body;
        }
      }
      var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
      function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
        return value.replace(
          escapeSelectorAttributeValueInsideDoubleQuotesRegex,
          function(ch) {
            return "\\" + ch.charCodeAt(0).toString(16) + " ";
          }
        );
      }
      function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name2) {
        element.name = "";
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
        if (null != value)
          if ("number" === type) {
            if (0 === value && "" === element.value || element.value != value)
              element.value = "" + getToStringValue(value);
          } else
            element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
        else
          "submit" !== type && "reset" !== type || element.removeAttribute("value");
        null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
        null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
        null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
        null != name2 && "function" !== typeof name2 && "symbol" !== typeof name2 && "boolean" !== typeof name2 ? element.name = "" + getToStringValue(name2) : element.removeAttribute("name");
      }
      function initInput(element, value, defaultValue, checked, defaultChecked, type, name2, isHydrating2) {
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
        if (null != value || null != defaultValue) {
          if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
            track(element);
            return;
          }
          defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
          value = null != value ? "" + getToStringValue(value) : defaultValue;
          isHydrating2 || value === element.value || (element.value = value);
          element.defaultValue = value;
        }
        checked = null != checked ? checked : defaultChecked;
        checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
        element.checked = isHydrating2 ? element.checked : !!checked;
        element.defaultChecked = !!checked;
        null != name2 && "function" !== typeof name2 && "symbol" !== typeof name2 && "boolean" !== typeof name2 && (element.name = name2);
        track(element);
      }
      function setDefaultValue(node, type, value) {
        "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
      }
      function updateOptions(node, multiple, propValue, setDefaultSelected) {
        node = node.options;
        if (multiple) {
          multiple = {};
          for (var i2 = 0; i2 < propValue.length; i2++)
            multiple["$" + propValue[i2]] = true;
          for (propValue = 0; propValue < node.length; propValue++)
            i2 = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i2 && (node[propValue].selected = i2), i2 && setDefaultSelected && (node[propValue].defaultSelected = true);
        } else {
          propValue = "" + getToStringValue(propValue);
          multiple = null;
          for (i2 = 0; i2 < node.length; i2++) {
            if (node[i2].value === propValue) {
              node[i2].selected = true;
              setDefaultSelected && (node[i2].defaultSelected = true);
              return;
            }
            null !== multiple || node[i2].disabled || (multiple = node[i2]);
          }
          null !== multiple && (multiple.selected = true);
        }
      }
      function updateTextarea(element, value, defaultValue) {
        if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
          element.defaultValue !== value && (element.defaultValue = value);
          return;
        }
        element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
      }
      function initTextarea(element, value, defaultValue, children) {
        if (null == value) {
          if (null != children) {
            if (null != defaultValue) throw Error(formatProdErrorMessage(92));
            if (isArrayImpl(children)) {
              if (1 < children.length) throw Error(formatProdErrorMessage(93));
              children = children[0];
            }
            defaultValue = children;
          }
          null == defaultValue && (defaultValue = "");
          value = defaultValue;
        }
        defaultValue = getToStringValue(value);
        element.defaultValue = defaultValue;
        children = element.textContent;
        children === defaultValue && "" !== children && null !== children && (element.value = children);
        track(element);
      }
      function setTextContent(node, text) {
        if (text) {
          var firstChild = node.firstChild;
          if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
            firstChild.nodeValue = text;
            return;
          }
        }
        node.textContent = text;
      }
      var unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      );
      function setValueForStyle(style2, styleName, value) {
        var isCustomProperty = 0 === styleName.indexOf("--");
        null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
      }
      function setValueForStyles(node, styles2, prevStyles) {
        if (null != styles2 && "object" !== typeof styles2)
          throw Error(formatProdErrorMessage(62));
        node = node.style;
        if (null != prevStyles) {
          for (var styleName in prevStyles)
            !prevStyles.hasOwnProperty(styleName) || null != styles2 && styles2.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
          for (var styleName$16 in styles2)
            styleName = styles2[styleName$16], styles2.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
        } else
          for (var styleName$17 in styles2)
            styles2.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles2[styleName$17]);
      }
      function isCustomElement(tagName) {
        if (-1 === tagName.indexOf("-")) return false;
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var aliases = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
      }
      function noop$12() {
      }
      var currentReplayingEvent = null;
      function getEventTarget(nativeEvent) {
        nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
        nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
        return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
      }
      var restoreTarget = null, restoreQueue = null;
      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (internalInstance && (target = internalInstance.stateNode)) {
          var props = target[internalPropsKey] || null;
          a: switch (target = internalInstance.stateNode, internalInstance.type) {
            case "input":
              updateInput(
                target,
                props.value,
                props.defaultValue,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name
              );
              internalInstance = props.name;
              if ("radio" === props.type && null != internalInstance) {
                for (props = target; props.parentNode; ) props = props.parentNode;
                props = props.querySelectorAll(
                  'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                    "" + internalInstance
                  ) + '"][type="radio"]'
                );
                for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                  var otherNode = props[internalInstance];
                  if (otherNode !== target && otherNode.form === target.form) {
                    var otherProps = otherNode[internalPropsKey] || null;
                    if (!otherProps) throw Error(formatProdErrorMessage(90));
                    updateInput(
                      otherNode,
                      otherProps.value,
                      otherProps.defaultValue,
                      otherProps.defaultValue,
                      otherProps.checked,
                      otherProps.defaultChecked,
                      otherProps.type,
                      otherProps.name
                    );
                  }
                }
                for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                  otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
              }
              break a;
            case "textarea":
              updateTextarea(target, props.value, props.defaultValue);
              break a;
            case "select":
              internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
          }
        }
      }
      var isInsideEventHandler = false;
      function batchedUpdates$1(fn, a, b) {
        if (isInsideEventHandler) return fn(a, b);
        isInsideEventHandler = true;
        try {
          var JSCompiler_inline_result = fn(a);
          return JSCompiler_inline_result;
        } finally {
          if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
            if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
              for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
          }
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (null === stateNode) return null;
        var props = stateNode[internalPropsKey] || null;
        if (null === props) return null;
        stateNode = props[registrationName];
        a: switch (registrationName) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
            inst = !props;
            break a;
          default:
            inst = false;
        }
        if (inst) return null;
        if (stateNode && "function" !== typeof stateNode)
          throw Error(
            formatProdErrorMessage(231, registrationName, typeof stateNode)
          );
        return stateNode;
      }
      var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
      if (canUseDOM)
        try {
          var options = {};
          Object.defineProperty(options, "passive", {
            get: function() {
              passiveBrowserEventsSupported = true;
            }
          });
          window.addEventListener("test", options, options);
          window.removeEventListener("test", options, options);
        } catch (e) {
          passiveBrowserEventsSupported = false;
        }
      var root = null, startText = null, fallbackText = null;
      function getData() {
        if (fallbackText) return fallbackText;
        var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
        for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
        var minEnd = startLength - start;
        for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
        return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
      }
      function getEventCharCode(nativeEvent) {
        var keyCode = nativeEvent.keyCode;
        "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
        10 === nativeEvent && (nativeEvent = 13);
        return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
      }
      function functionThatReturnsTrue() {
        return true;
      }
      function functionThatReturnsFalse() {
        return false;
      }
      function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
          this._reactName = reactName;
          this._targetInst = targetInst;
          this.type = reactEventType;
          this.nativeEvent = nativeEvent;
          this.target = nativeEventTarget;
          this.currentTarget = null;
          for (var propName in Interface)
            Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
          this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        assign(SyntheticBaseEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var event = this.nativeEvent;
            event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
          },
          stopPropagation: function() {
            var event = this.nativeEvent;
            event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
          },
          persist: function() {
          },
          isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
      }
      var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
          return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
        },
        movementX: function(event) {
          if ("movementX" in event) return event.movementX;
          event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
          return lastMovementX;
        },
        movementY: function(event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function(event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      }, translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      }, modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function modifierStateGetter(keyArg) {
        var nativeEvent = this.nativeEvent;
        return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
      }
      function getEventModifierState() {
        return modifierStateGetter;
      }
      var KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function(nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key) return key;
          }
          return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function(event) {
          return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        },
        which: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        }
      }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function(event) {
          return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function(event) {
          return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0
      }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
      canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
      var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case "keyup":
            return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
          case "keydown":
            return 229 !== nativeEvent.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        nativeEvent = nativeEvent.detail;
        return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
      }
      var isComposing = false;
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case "compositionend":
            return getDataFromCustomEvent(nativeEvent);
          case "keypress":
            if (32 !== nativeEvent.which) return null;
            hasSpaceKeypress = true;
            return SPACEBAR_CHAR;
          case "textInput":
            return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing)
          return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
        switch (domEventName) {
          case "paste":
            return null;
          case "keypress":
            if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
              if (nativeEvent.char && 1 < nativeEvent.char.length)
                return nativeEvent.char;
              if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
            }
            return null;
          case "compositionend":
            return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
          default:
            return null;
        }
      }
      var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
        inst = accumulateTwoPhaseListeners(inst, "onChange");
        0 < inst.length && (nativeEvent = new SyntheticEvent(
          "onChange",
          "change",
          null,
          nativeEvent,
          target
        ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
      }
      var activeElement$1 = null, activeElementInst$1 = null;
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) return targetInst;
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if ("change" === domEventName) return targetInst;
      }
      var isInputEventSupported = false;
      if (canUseDOM) {
        var JSCompiler_inline_result$jscomp$286;
        if (canUseDOM) {
          var isSupported$jscomp$inline_427 = "oninput" in document;
          if (!isSupported$jscomp$inline_427) {
            var element$jscomp$inline_428 = document.createElement("div");
            element$jscomp$inline_428.setAttribute("oninput", "return;");
            isSupported$jscomp$inline_427 = "function" === typeof element$jscomp$inline_428.oninput;
          }
          JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
        } else JSCompiler_inline_result$jscomp$286 = false;
        isInputEventSupported = JSCompiler_inline_result$jscomp$286 && (!document.documentMode || 9 < document.documentMode);
      }
      function stopWatchingForValueChange() {
        activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
      }
      function handlePropertyChange(nativeEvent) {
        if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(
            dispatchQueue,
            activeElementInst$1,
            nativeEvent,
            getEventTarget(nativeEvent)
          );
          batchedUpdates$1(runEventInBatch, dispatchQueue);
        }
      }
      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
      }
      function getTargetInstForInputEventPolyfill(domEventName) {
        if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
          return getInstIfValueChanged(activeElementInst$1);
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if ("click" === domEventName) return getInstIfValueChanged(targetInst);
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if ("input" === domEventName || "change" === domEventName)
          return getInstIfValueChanged(targetInst);
      }
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is;
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) return true;
        if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
          return false;
        var keysA = Object.keys(objA), keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return false;
        for (keysB = 0; keysB < keysA.length; keysB++) {
          var currentKey = keysA[keysB];
          if (!hasOwnProperty2.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
            return false;
        }
        return true;
      }
      function getLeafNode(node) {
        for (; node && node.firstChild; ) node = node.firstChild;
        return node;
      }
      function getNodeForCharacterOffset(root2, offset) {
        var node = getLeafNode(root2);
        root2 = 0;
        for (var nodeEnd; node; ) {
          if (3 === node.nodeType) {
            nodeEnd = root2 + node.textContent.length;
            if (root2 <= offset && nodeEnd >= offset)
              return { node, offset: offset - root2 };
            root2 = nodeEnd;
          }
          a: {
            for (; node; ) {
              if (node.nextSibling) {
                node = node.nextSibling;
                break a;
              }
              node = node.parentNode;
            }
            node = void 0;
          }
          node = getLeafNode(node);
        }
      }
      function containsNode(outerNode, innerNode) {
        return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
      }
      function getActiveElementDeep(containerInfo) {
        containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
        for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
          try {
            var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
          } catch (err) {
            JSCompiler_inline_result = false;
          }
          if (JSCompiler_inline_result) containerInfo = element.contentWindow;
          else break;
          element = getActiveElement(containerInfo.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
      }
      var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc2 = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
        mouseDown || null == activeElement || activeElement !== getActiveElement(doc2) || (doc2 = activeElement, "selectionStart" in doc2 && hasSelectionCapabilities(doc2) ? doc2 = { start: doc2.selectionStart, end: doc2.selectionEnd } : (doc2 = (doc2.ownerDocument && doc2.ownerDocument.defaultView || window).getSelection(), doc2 = {
          anchorNode: doc2.anchorNode,
          anchorOffset: doc2.anchorOffset,
          focusNode: doc2.focusNode,
          focusOffset: doc2.focusOffset
        }), lastSelection && shallowEqual(lastSelection, doc2) || (lastSelection = doc2, doc2 = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc2.length && (nativeEvent = new SyntheticEvent(
          "onSelect",
          "select",
          null,
          nativeEvent,
          nativeEventTarget
        ), dispatchQueue.push({ event: nativeEvent, listeners: doc2 }), nativeEvent.target = activeElement)));
      }
      function makePrefixMap(styleProp, eventName) {
        var prefixes = {};
        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes["Webkit" + styleProp] = "webkit" + eventName;
        prefixes["Moz" + styleProp] = "moz" + eventName;
        return prefixes;
      }
      var vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      }, prefixedEventNames = {}, style = {};
      canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
        if (!vendorPrefixes[eventName]) return eventName;
        var prefixMap = vendorPrefixes[eventName], styleProp;
        for (styleProp in prefixMap)
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
            return prefixedEventNames[eventName] = prefixMap[styleProp];
        return eventName;
      }
      var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
      simpleEventPluginEvents.push("scrollEnd");
      function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [domEventName]);
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error2) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error2 && null !== error2 && "string" === typeof error2.message ? String(error2.message) : String(error2),
            error: error2
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error2);
          return;
        }
        console.error(error2);
      }, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
      function finishQueueingConcurrentUpdates() {
        for (var endIndex = concurrentQueuesIndex, i2 = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i2 < endIndex; ) {
          var fiber = concurrentQueues[i2];
          concurrentQueues[i2++] = null;
          var queue = concurrentQueues[i2];
          concurrentQueues[i2++] = null;
          var update = concurrentQueues[i2];
          concurrentQueues[i2++] = null;
          var lane = concurrentQueues[i2];
          concurrentQueues[i2++] = null;
          if (null !== queue && null !== update) {
            var pending = queue.pending;
            null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
            queue.pending = update;
          }
          0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
        }
      }
      function enqueueUpdate$1(fiber, queue, update, lane) {
        concurrentQueues[concurrentQueuesIndex++] = fiber;
        concurrentQueues[concurrentQueuesIndex++] = queue;
        concurrentQueues[concurrentQueuesIndex++] = update;
        concurrentQueues[concurrentQueuesIndex++] = lane;
        concurrentlyUpdatedLanes |= lane;
        fiber.lanes |= lane;
        fiber = fiber.alternate;
        null !== fiber && (fiber.lanes |= lane);
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        enqueueUpdate$1(fiber, queue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        enqueueUpdate$1(fiber, null, null, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
        sourceFiber.lanes |= lane;
        var alternate = sourceFiber.alternate;
        null !== alternate && (alternate.lanes |= lane);
        for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
          parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
        return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
      }
      function getRootForUpdatedFiber(sourceFiber) {
        if (50 < nestedUpdateCount)
          throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
        for (var parent = sourceFiber.return; null !== parent; )
          sourceFiber = parent, parent = sourceFiber.return;
        return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
      }
      var emptyContextObject = {};
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.refCleanup = this.ref = null;
        this.pendingProps = pendingProps;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = mode;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function createFiberImplClass(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      }
      function shouldConstruct(Component) {
        Component = Component.prototype;
        return !(!Component || !Component.isReactComponent);
      }
      function createWorkInProgress(current, pendingProps) {
        var workInProgress2 = current.alternate;
        null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
          current.tag,
          pendingProps,
          current.key,
          current.mode
        ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
        workInProgress2.flags = current.flags & 65011712;
        workInProgress2.childLanes = current.childLanes;
        workInProgress2.lanes = current.lanes;
        workInProgress2.child = current.child;
        workInProgress2.memoizedProps = current.memoizedProps;
        workInProgress2.memoizedState = current.memoizedState;
        workInProgress2.updateQueue = current.updateQueue;
        pendingProps = current.dependencies;
        workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
        workInProgress2.sibling = current.sibling;
        workInProgress2.index = current.index;
        workInProgress2.ref = current.ref;
        workInProgress2.refCleanup = current.refCleanup;
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= 65011714;
        var current = workInProgress2.alternate;
        null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
          lanes: renderLanes2.lanes,
          firstContext: renderLanes2.firstContext
        });
        return workInProgress2;
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = 0;
        owner = type;
        if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
        else if ("string" === typeof type)
          fiberTag = isHostHoistableType(
            type,
            pendingProps,
            contextStackCursor.current
          ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
        else
          a: switch (type) {
            case REACT_ACTIVITY_TYPE:
              return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = 8;
              mode |= 24;
              break;
            case REACT_PROFILER_TYPE:
              return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_TYPE:
              return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_LIST_TYPE:
              return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
            default:
              if ("object" === typeof type && null !== type)
                switch (type.$$typeof) {
                  case REACT_CONTEXT_TYPE:
                    fiberTag = 10;
                    break a;
                  case REACT_CONSUMER_TYPE:
                    fiberTag = 9;
                    break a;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = 11;
                    break a;
                  case REACT_MEMO_TYPE:
                    fiberTag = 14;
                    break a;
                  case REACT_LAZY_TYPE:
                    fiberTag = 16;
                    owner = null;
                    break a;
                }
              fiberTag = 29;
              pendingProps = Error(
                formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
              );
              owner = null;
          }
        key = createFiberImplClass(fiberTag, pendingProps, key, mode);
        key.elementType = type;
        key.type = owner;
        key.lanes = lanes;
        return key;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        elements = createFiberImplClass(7, elements, key, mode);
        elements.lanes = lanes;
        return elements;
      }
      function createFiberFromText(content2, mode, lanes) {
        content2 = createFiberImplClass(6, content2, null, mode);
        content2.lanes = lanes;
        return content2;
      }
      function createFiberFromDehydratedFragment(dehydratedNode) {
        var fiber = createFiberImplClass(18, null, null, 0);
        fiber.stateNode = dehydratedNode;
        return fiber;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        mode = createFiberImplClass(
          4,
          null !== portal.children ? portal.children : [],
          portal.key,
          mode
        );
        mode.lanes = lanes;
        mode.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return mode;
      }
      var CapturedStacks = /* @__PURE__ */ new WeakMap();
      function createCapturedValueAtFiber(value, source2) {
        if ("object" === typeof value && null !== value) {
          var existing = CapturedStacks.get(value);
          if (void 0 !== existing) return existing;
          source2 = {
            value,
            source: source2,
            stack: getStackByFiberInDevAndProd(source2)
          };
          CapturedStacks.set(value, source2);
          return source2;
        }
        return {
          value,
          source: source2,
          stack: getStackByFiberInDevAndProd(source2)
        };
      }
      var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
      function pushTreeFork(workInProgress2, totalChildren) {
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index3) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        workInProgress2 = treeContextOverflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index3 += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index3 << baseLength | baseIdWithLeadingBit;
          treeContextOverflow = length + workInProgress2;
        } else
          treeContextId = 1 << length | index3 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
      }
      function pushMaterializedTreeId(workInProgress2) {
        null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
      }
      function popTreeContext(workInProgress2) {
        for (; workInProgress2 === treeForkProvider; )
          treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
        for (; workInProgress2 === treeContextProvider; )
          treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
      }
      function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextId = suspendedContext.id;
        treeContextOverflow = suspendedContext.overflow;
        treeContextProvider = workInProgress2;
      }
      var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
      function throwOnHydrationMismatch(fiber) {
        var error2 = Error(
          formatProdErrorMessage(
            418,
            1 < arguments.length && void 0 !== arguments[1] && arguments[1] ? "text" : "HTML",
            ""
          )
        );
        queueHydrationError(createCapturedValueAtFiber(error2, fiber));
        throw HydrationMismatchException;
      }
      function prepareToHydrateHostInstance(fiber) {
        var instance2 = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
        instance2[internalInstanceKey] = fiber;
        instance2[internalPropsKey] = props;
        switch (type) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", instance2);
            listenToNonDelegatedEvent("close", instance2);
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", instance2);
            break;
          case "video":
          case "audio":
            for (type = 0; type < mediaEventTypes.length; type++)
              listenToNonDelegatedEvent(mediaEventTypes[type], instance2);
            break;
          case "source":
            listenToNonDelegatedEvent("error", instance2);
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", instance2);
            listenToNonDelegatedEvent("load", instance2);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", instance2);
            break;
          case "input":
            listenToNonDelegatedEvent("invalid", instance2);
            initInput(
              instance2,
              props.value,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name,
              true
            );
            break;
          case "select":
            listenToNonDelegatedEvent("invalid", instance2);
            break;
          case "textarea":
            listenToNonDelegatedEvent("invalid", instance2), initTextarea(instance2, props.value, props.defaultValue, props.children);
        }
        type = props.children;
        "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance2.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance2.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance2), listenToNonDelegatedEvent("toggle", instance2)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance2), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance2), null != props.onClick && (instance2.onclick = noop$12), instance2 = true) : instance2 = false;
        instance2 || throwOnHydrationMismatch(fiber, true);
      }
      function popToNextHostParent(fiber) {
        for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
          switch (hydrationParentFiber.tag) {
            case 5:
            case 31:
            case 13:
              rootOrSingletonContext = false;
              return;
            case 27:
            case 3:
              rootOrSingletonContext = true;
              return;
            default:
              hydrationParentFiber = hydrationParentFiber.return;
          }
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) return false;
        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
        var tag = fiber.tag, JSCompiler_temp;
        if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
          if (JSCompiler_temp = 5 === tag)
            JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
          JSCompiler_temp = !JSCompiler_temp;
        }
        JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
        popToNextHostParent(fiber);
        if (13 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber) throw Error(formatProdErrorMessage(317));
          nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
        } else if (31 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber) throw Error(formatProdErrorMessage(317));
          nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
        } else
          27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
        return true;
      }
      function resetHydrationState() {
        nextHydratableInstance = hydrationParentFiber = null;
        isHydrating = false;
      }
      function upgradeHydrationErrorsToRecoverable() {
        var queuedErrors = hydrationErrors;
        null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
          workInProgressRootRecoverableErrors,
          queuedErrors
        ), hydrationErrors = null);
        return queuedErrors;
      }
      function queueHydrationError(error2) {
        null === hydrationErrors ? hydrationErrors = [error2] : hydrationErrors.push(error2);
      }
      var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null;
      function pushProvider(providerFiber, context, nextValue) {
        push(valueCursor, context._currentValue);
        context._currentValue = nextValue;
      }
      function popProvider(context) {
        context._currentValue = valueCursor.current;
        pop(valueCursor);
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        for (; null !== parent; ) {
          var alternate = parent.alternate;
          (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
          if (parent === propagationRoot) break;
          parent = parent.return;
        }
      }
      function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
        var fiber = workInProgress2.child;
        null !== fiber && (fiber.return = workInProgress2);
        for (; null !== fiber; ) {
          var list = fiber.dependencies;
          if (null !== list) {
            var nextFiber = fiber.child;
            list = list.firstContext;
            a: for (; null !== list; ) {
              var dependency = list;
              list = fiber;
              for (var i2 = 0; i2 < contexts.length; i2++)
                if (dependency.context === contexts[i2]) {
                  list.lanes |= renderLanes2;
                  dependency = list.alternate;
                  null !== dependency && (dependency.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(
                    list.return,
                    renderLanes2,
                    workInProgress2
                  );
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
          } else if (18 === fiber.tag) {
            nextFiber = fiber.return;
            if (null === nextFiber) throw Error(formatProdErrorMessage(341));
            nextFiber.lanes |= renderLanes2;
            list = nextFiber.alternate;
            null !== list && (list.lanes |= renderLanes2);
            scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
            nextFiber = null;
          } else nextFiber = fiber.child;
          if (null !== nextFiber) nextFiber.return = fiber;
          else
            for (nextFiber = fiber; null !== nextFiber; ) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              fiber = nextFiber.sibling;
              if (null !== fiber) {
                fiber.return = nextFiber.return;
                nextFiber = fiber;
                break;
              }
              nextFiber = nextFiber.return;
            }
          fiber = nextFiber;
        }
      }
      function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
        current = null;
        for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
          if (!isInsidePropagationBailout) {
            if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
            else if (0 !== (parent.flags & 262144)) break;
          }
          if (10 === parent.tag) {
            var currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent = currentParent.memoizedProps;
            if (null !== currentParent) {
              var context = parent.type;
              objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
            }
          } else if (parent === hostTransitionProviderCursor.current) {
            currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
          }
          parent = parent.return;
        }
        null !== current && propagateContextChanges(
          workInProgress2,
          current,
          renderLanes2,
          forcePropagateEntireTree
        );
        workInProgress2.flags |= 262144;
      }
      function checkIfContextChanged(currentDependencies) {
        for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
          if (!objectIs(
            currentDependencies.context._currentValue,
            currentDependencies.memoizedValue
          ))
            return true;
          currentDependencies = currentDependencies.next;
        }
        return false;
      }
      function prepareToReadContext(workInProgress2) {
        currentlyRenderingFiber$1 = workInProgress2;
        lastContextDependency = null;
        workInProgress2 = workInProgress2.dependencies;
        null !== workInProgress2 && (workInProgress2.firstContext = null);
      }
      function readContext(context) {
        return readContextForConsumer(currentlyRenderingFiber$1, context);
      }
      function readContextDuringReconciliation(consumer, context) {
        null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
        return readContextForConsumer(consumer, context);
      }
      function readContextForConsumer(consumer, context) {
        var value = context._currentValue;
        context = { context, memoizedValue: value, next: null };
        if (null === lastContextDependency) {
          if (null === consumer) throw Error(formatProdErrorMessage(308));
          lastContextDependency = context;
          consumer.dependencies = { lanes: 0, firstContext: context };
          consumer.flags |= 524288;
        } else lastContextDependency = lastContextDependency.next = context;
        return value;
      }
      var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
        var listeners = [], signal = this.signal = {
          aborted: false,
          addEventListener: function(type, listener) {
            listeners.push(listener);
          }
        };
        this.abort = function() {
          signal.aborted = true;
          listeners.forEach(function(listener) {
            return listener();
          });
        };
      }, scheduleCallback$2 = Scheduler2.unstable_scheduleCallback, NormalPriority = Scheduler2.unstable_NormalPriority, CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
      };
      function createCache() {
        return {
          controller: new AbortControllerLocal(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function releaseCache(cache) {
        cache.refCount--;
        0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
          cache.controller.abort();
        });
      }
      var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
      function entangleAsyncAction(transition, thenable) {
        if (null === currentEntangledListeners) {
          var entangledListeners = currentEntangledListeners = [];
          currentEntangledPendingCount = 0;
          currentEntangledLane = requestTransitionLane();
          currentEntangledActionThenable = {
            status: "pending",
            value: void 0,
            then: function(resolve2) {
              entangledListeners.push(resolve2);
            }
          };
        }
        currentEntangledPendingCount++;
        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
        return thenable;
      }
      function pingEngtangledActionScope() {
        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
          null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
          var listeners = currentEntangledListeners;
          currentEntangledListeners = null;
          currentEntangledLane = 0;
          currentEntangledActionThenable = null;
          for (var i2 = 0; i2 < listeners.length; i2++) (0, listeners[i2])();
        }
      }
      function chainThenableValue(thenable, result) {
        var listeners = [], thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function(resolve2) {
            listeners.push(resolve2);
          }
        };
        thenable.then(
          function() {
            thenableWithOverride.status = "fulfilled";
            thenableWithOverride.value = result;
            for (var i2 = 0; i2 < listeners.length; i2++) (0, listeners[i2])(result);
          },
          function(error2) {
            thenableWithOverride.status = "rejected";
            thenableWithOverride.reason = error2;
            for (error2 = 0; error2 < listeners.length; error2++)
              (0, listeners[error2])(void 0);
          }
        );
        return thenableWithOverride;
      }
      var prevOnStartTransitionFinish = ReactSharedInternals.S;
      ReactSharedInternals.S = function(transition, returnValue) {
        globalMostRecentTransitionTime = now();
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
      };
      var resumedCache = createCursor(null);
      function peekCacheFromPool() {
        var cacheResumedFromPreviousRender = resumedCache.current;
        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
      }
      function pushTransition(offscreenWorkInProgress, prevCachePool) {
        null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
      }
      function getSuspendedCache() {
        var cacheFromPool = peekCacheFromPool();
        return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
      }
      var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {
      } };
      function isThenableResolved(thenable) {
        thenable = thenable.status;
        return "fulfilled" === thenable || "rejected" === thenable;
      }
      function trackUsedThenable(thenableState2, thenable, index3) {
        index3 = thenableState2[index3];
        void 0 === index3 ? thenableState2.push(thenable) : index3 !== thenable && (thenable.then(noop$12, noop$12), thenable = index3);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          default:
            if ("string" === typeof thenable.status) thenable.then(noop$12, noop$12);
            else {
              thenableState2 = workInProgressRoot;
              if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                throw Error(formatProdErrorMessage(482));
              thenableState2 = thenable;
              thenableState2.status = "pending";
              thenableState2.then(
                function(fulfilledValue) {
                  if ("pending" === thenable.status) {
                    var fulfilledThenable = thenable;
                    fulfilledThenable.status = "fulfilled";
                    fulfilledThenable.value = fulfilledValue;
                  }
                },
                function(error2) {
                  if ("pending" === thenable.status) {
                    var rejectedThenable = thenable;
                    rejectedThenable.status = "rejected";
                    rejectedThenable.reason = error2;
                  }
                }
              );
            }
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      function resolveLazy(lazyType) {
        try {
          var init = lazyType._init;
          return init(lazyType._payload);
        } catch (x) {
          if (null !== x && "object" === typeof x && "function" === typeof x.then)
            throw suspendedThenable = x, SuspenseException;
          throw x;
        }
      }
      var suspendedThenable = null;
      function getSuspendedThenable() {
        if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      function checkIfUseWrappedInAsyncCatch(rejectedReason) {
        if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
          throw Error(formatProdErrorMessage(483));
      }
      var thenableState$1 = null, thenableIndexCounter$1 = 0;
      function unwrapThenable(thenable) {
        var index3 = thenableIndexCounter$1;
        thenableIndexCounter$1 += 1;
        null === thenableState$1 && (thenableState$1 = []);
        return trackUsedThenable(thenableState$1, thenable, index3);
      }
      function coerceRef(workInProgress2, element) {
        element = element.props.ref;
        workInProgress2.ref = void 0 !== element ? element : null;
      }
      function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
          throw Error(formatProdErrorMessage(525));
        returnFiber = Object.prototype.toString.call(newChild);
        throw Error(
          formatProdErrorMessage(
            31,
            "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
          )
        );
      }
      function createChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (shouldTrackSideEffects) {
            var deletions = returnFiber.deletions;
            null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) return null;
          for (; null !== currentFirstChild; )
            deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return null;
        }
        function mapRemainingChildren(currentFirstChild) {
          for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
            null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          fiber = createWorkInProgress(fiber, pendingProps);
          fiber.index = 0;
          fiber.sibling = null;
          return fiber;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects)
            return newFiber.flags |= 1048576, lastPlacedIndex;
          newIndex = newFiber.alternate;
          if (null !== newIndex)
            return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
          newFiber.flags |= 67108866;
          return lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
          shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
          return newFiber;
        }
        function updateTextNode(returnFiber, current, textContent, lanes) {
          if (null === current || 6 !== current.tag)
            return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, textContent);
          current.return = returnFiber;
          return current;
        }
        function updateElement(returnFiber, current, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE)
            return updateFragment(
              returnFiber,
              current,
              element.props.children,
              lanes,
              element.key
            );
          if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
            return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
          current = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            null,
            returnFiber.mode,
            lanes
          );
          coerceRef(current, element);
          current.return = returnFiber;
          return current;
        }
        function updatePortal(returnFiber, current, portal, lanes) {
          if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
            return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, portal.children || []);
          current.return = returnFiber;
          return current;
        }
        function updateFragment(returnFiber, current, fragment, lanes, key) {
          if (null === current || 7 !== current.tag)
            return current = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key
            ), current.return = returnFiber, current;
          current = useFiber(current, fragment);
          current.return = returnFiber;
          return current;
        }
        function createChild(returnFiber, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes
            ), newChild.return = returnFiber, newChild;
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
              case REACT_PORTAL_TYPE:
                return newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes
                ), newChild.return = returnFiber, newChild;
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), createChild(returnFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return newChild = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null
              ), newChild.return = returnFiber, newChild;
            if ("function" === typeof newChild.then)
              return createChild(returnFiber, unwrapThenable(newChild), lanes);
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return createChild(
                returnFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = null !== oldFiber ? oldFiber.key : null;
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_PORTAL_TYPE:
                return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), updateSlot(returnFiber, oldFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateSlot(
                returnFiber,
                oldFiber,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateSlot(
                returnFiber,
                oldFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
              case REACT_PORTAL_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return null;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(
              returnFiber,
              oldFiber,
              newChildren[newIdx],
              lanes
            );
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; newIdx < newChildren.length; newIdx++)
              oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
                oldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
            nextOldFiber = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              newChildren[newIdx],
              lanes
            ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ), currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
          if (null == newChildren) throw Error(formatProdErrorMessage(151));
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; !step.done; newIdx++, step = newChildren.next())
              step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
            step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
          "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                a: {
                  for (var key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key) {
                      key = newChild.type;
                      if (key === REACT_FRAGMENT_TYPE) {
                        if (7 === currentFirstChild.tag) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            newChild.props.children
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        }
                      } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.props);
                        coerceRef(lanes, newChild);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    } else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                    newChild.props.children,
                    returnFiber.mode,
                    lanes,
                    newChild.key
                  ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                    newChild.type,
                    newChild.key,
                    newChild.props,
                    null,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
                }
                return placeSingleChild(returnFiber);
              case REACT_PORTAL_TYPE:
                a: {
                  for (key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key)
                      if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.children || []);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      } else {
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      }
                    else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                }
                return placeSingleChild(returnFiber);
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild))
              return reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            if (getIteratorFn(newChild)) {
              key = getIteratorFn(newChild);
              if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
              newChild = key.call(newChild);
              return reconcileChildrenIterator(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            }
            if ("function" === typeof newChild.then)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return function(returnFiber, currentFirstChild, newChild, lanes) {
          try {
            thenableIndexCounter$1 = 0;
            var firstChildFiber = reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
            thenableState$1 = null;
            return firstChildFiber;
          } catch (x) {
            if (x === SuspenseException || x === SuspenseActionException) throw x;
            var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
            fiber.lanes = lanes;
            fiber.return = returnFiber;
            return fiber;
          } finally {
          }
        };
      }
      var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), hasForceUpdate = false;
      function initializeUpdateQueue(fiber) {
        fiber.updateQueue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function cloneUpdateQueue(current, workInProgress2) {
        current = current.updateQueue;
        workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
          baseState: current.baseState,
          firstBaseUpdate: current.firstBaseUpdate,
          lastBaseUpdate: current.lastBaseUpdate,
          shared: current.shared,
          callbacks: null
        });
      }
      function createUpdate(lane) {
        return { lane, tag: 0, payload: null, callback: null, next: null };
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (null === updateQueue) return null;
        updateQueue = updateQueue.shared;
        if (0 !== (executionContext & 2)) {
          var pending = updateQueue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          updateQueue.pending = update;
          update = getRootForUpdatedFiber(fiber);
          markUpdateLaneFromFiberToRoot(fiber, null, lane);
          return update;
        }
        enqueueUpdate$1(fiber, updateQueue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function entangleTransitions(root2, fiber, lane) {
        fiber = fiber.updateQueue;
        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
          var queueLanes = fiber.lanes;
          queueLanes &= root2.pendingLanes;
          lane |= queueLanes;
          fiber.lanes = lane;
          markRootEntangled(root2, lane);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
        if (null !== current && (current = current.updateQueue, queue === current)) {
          var newFirst = null, newLast = null;
          queue = queue.firstBaseUpdate;
          if (null !== queue) {
            do {
              var clone2 = {
                lane: queue.lane,
                tag: queue.tag,
                payload: queue.payload,
                callback: null,
                next: null
              };
              null === newLast ? newFirst = newLast = clone2 : newLast = newLast.next = clone2;
              queue = queue.next;
            } while (null !== queue);
            null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
          } else newFirst = newLast = capturedUpdate;
          queue = {
            baseState: current.baseState,
            firstBaseUpdate: newFirst,
            lastBaseUpdate: newLast,
            shared: current.shared,
            callbacks: current.callbacks
          };
          workInProgress2.updateQueue = queue;
          return;
        }
        workInProgress2 = queue.lastBaseUpdate;
        null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
        queue.lastBaseUpdate = capturedUpdate;
      }
      var didReadFromEntangledAsyncAction = false;
      function suspendIfUpdateReadFromEntangledAsyncAction() {
        if (didReadFromEntangledAsyncAction) {
          var entangledActionThenable = currentEntangledActionThenable;
          if (null !== entangledActionThenable) throw entangledActionThenable;
        }
      }
      function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
        didReadFromEntangledAsyncAction = false;
        var queue = workInProgress$jscomp$0.updateQueue;
        hasForceUpdate = false;
        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
        if (null !== pendingQueue) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
          lastBaseUpdate = lastPendingUpdate;
          var current = workInProgress$jscomp$0.alternate;
          null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
        }
        if (null !== firstBaseUpdate) {
          var newState = queue.baseState;
          lastBaseUpdate = 0;
          current = firstPendingUpdate = lastPendingUpdate = null;
          pendingQueue = firstBaseUpdate;
          do {
            var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
            if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
              0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
              null !== current && (current = current.next = {
                lane: 0,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: null,
                next: null
              });
              a: {
                var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
                updateLane = props;
                var instance2 = instance$jscomp$0;
                switch (update.tag) {
                  case 1:
                    workInProgress2 = update.payload;
                    if ("function" === typeof workInProgress2) {
                      newState = workInProgress2.call(instance2, newState, updateLane);
                      break a;
                    }
                    newState = workInProgress2;
                    break a;
                  case 3:
                    workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                  case 0:
                    workInProgress2 = update.payload;
                    updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance2, newState, updateLane) : workInProgress2;
                    if (null === updateLane || void 0 === updateLane) break a;
                    newState = assign({}, newState, updateLane);
                    break a;
                  case 2:
                    hasForceUpdate = true;
                }
              }
              updateLane = pendingQueue.callback;
              null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
            } else
              isHiddenUpdate = {
                lane: updateLane,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: pendingQueue.callback,
                next: null
              }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
            pendingQueue = pendingQueue.next;
            if (null === pendingQueue)
              if (pendingQueue = queue.shared.pending, null === pendingQueue)
                break;
              else
                isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
          } while (1);
          null === current && (lastPendingUpdate = newState);
          queue.baseState = lastPendingUpdate;
          queue.firstBaseUpdate = firstPendingUpdate;
          queue.lastBaseUpdate = current;
          null === firstBaseUpdate && (queue.shared.lanes = 0);
          workInProgressRootSkippedLanes |= lastBaseUpdate;
          workInProgress$jscomp$0.lanes = lastBaseUpdate;
          workInProgress$jscomp$0.memoizedState = newState;
        }
      }
      function callCallback(callback2, context) {
        if ("function" !== typeof callback2)
          throw Error(formatProdErrorMessage(191, callback2));
        callback2.call(context);
      }
      function commitCallbacks(updateQueue, context) {
        var callbacks = updateQueue.callbacks;
        if (null !== callbacks)
          for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
            callCallback(callbacks[updateQueue], context);
      }
      var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
      function pushHiddenContext(fiber, context) {
        fiber = entangledRenderLanes;
        push(prevEntangledRenderLanesCursor, fiber);
        push(currentTreeHiddenStackCursor, context);
        entangledRenderLanes = fiber | context.baseLanes;
      }
      function reuseHiddenContextOnStack() {
        push(prevEntangledRenderLanesCursor, entangledRenderLanes);
        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
      }
      function popHiddenContext() {
        entangledRenderLanes = prevEntangledRenderLanesCursor.current;
        pop(currentTreeHiddenStackCursor);
        pop(prevEntangledRenderLanesCursor);
      }
      var suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
      function pushPrimaryTreeSuspenseHandler(handler) {
        var current = handler.alternate;
        push(suspenseStackCursor, suspenseStackCursor.current & 1);
        push(suspenseHandlerStackCursor, handler);
        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
      }
      function pushDehydratedActivitySuspenseHandler(fiber) {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, fiber);
        null === shellBoundary && (shellBoundary = fiber);
      }
      function pushOffscreenSuspenseHandler(fiber) {
        22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack();
      }
      function reuseSuspenseHandlerOnStack() {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
      }
      function popSuspenseHandler(fiber) {
        pop(suspenseHandlerStackCursor);
        shellBoundary === fiber && (shellBoundary = null);
        pop(suspenseStackCursor);
      }
      var suspenseStackCursor = createCursor(0);
      function findFirstSuspended(row) {
        for (var node = row; null !== node; ) {
          if (13 === node.tag) {
            var state = node.memoizedState;
            if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
              return node;
          } else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
            if (0 !== (node.flags & 128)) return node;
          } else if (null !== node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === row) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === row) return null;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return null;
      }
      var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0;
      function throwInvalidHookError() {
        throw Error(formatProdErrorMessage(321));
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (null === prevDeps) return false;
        for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++)
          if (!objectIs(nextDeps[i2], prevDeps[i2])) return false;
        return true;
      }
      function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber = workInProgress2;
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = 0;
        ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        nextRenderLanes = Component(props, secondArg);
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
          workInProgress2,
          Component,
          props,
          secondArg
        ));
        finishRenderingHooks(current);
        return nextRenderLanes;
      }
      function finishRenderingHooks(current) {
        ReactSharedInternals.H = ContextOnlyDispatcher;
        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdate = false;
        thenableIndexCounter = 0;
        thenableState = null;
        if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
      }
      function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
        currentlyRenderingFiber = workInProgress2;
        var numberOfReRenders = 0;
        do {
          didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
          thenableIndexCounter = 0;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
          numberOfReRenders += 1;
          workInProgressHook = currentHook = null;
          if (null != workInProgress2.updateQueue) {
            var children = workInProgress2.updateQueue;
            children.lastEffect = null;
            children.events = null;
            children.stores = null;
            null != children.memoCache && (children.memoCache.index = 0);
          }
          ReactSharedInternals.H = HooksDispatcherOnRerender;
          children = Component(props, secondArg);
        } while (didScheduleRenderPhaseUpdateDuringThisPass);
        return children;
      }
      function TransitionAwareHostComponent() {
        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
        maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
        dispatcher = dispatcher.useState()[0];
        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
        return maybeThenable;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = 0 !== localIdCounter;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current, workInProgress2, lanes) {
        workInProgress2.updateQueue = current.updateQueue;
        workInProgress2.flags &= -2053;
        current.lanes &= ~lanes;
      }
      function resetHooksOnUnwind(workInProgress2) {
        if (didScheduleRenderPhaseUpdate) {
          for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
            var queue = workInProgress2.queue;
            null !== queue && (queue.pending = null);
            workInProgress2 = workInProgress2.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        thenableIndexCounter = localIdCounter = 0;
        thenableState = null;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        if (null === currentHook) {
          var nextCurrentHook = currentlyRenderingFiber.alternate;
          nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
        } else nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
        if (null !== nextWorkInProgressHook)
          workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
        else {
          if (null === nextCurrentHook) {
            if (null === currentlyRenderingFiber.alternate)
              throw Error(formatProdErrorMessage(467));
            throw Error(formatProdErrorMessage(310));
          }
          currentHook = nextCurrentHook;
          nextCurrentHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }
      function useThenable(thenable) {
        var index3 = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        thenable = trackUsedThenable(thenableState, thenable, index3);
        index3 = currentlyRenderingFiber;
        null === (null === workInProgressHook ? index3.memoizedState : workInProgressHook.next) && (index3 = index3.alternate, ReactSharedInternals.H = null === index3 || null === index3.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
        return thenable;
      }
      function use(usable) {
        if (null !== usable && "object" === typeof usable) {
          if ("function" === typeof usable.then) return useThenable(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
        }
        throw Error(formatProdErrorMessage(438, String(usable)));
      }
      function useMemoCache(size) {
        var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
        null !== updateQueue && (memoCache = updateQueue.memoCache);
        if (null == memoCache) {
          var current = currentlyRenderingFiber.alternate;
          null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
            data: current.data.map(function(array) {
              return array.slice();
            }),
            index: 0
          })));
        }
        null == memoCache && (memoCache = { data: [], index: 0 });
        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
        updateQueue.memoCache = memoCache;
        updateQueue = memoCache.data[memoCache.index];
        if (void 0 === updateQueue)
          for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
            updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
        memoCache.index++;
        return updateQueue;
      }
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      function updateReducer(reducer) {
        var hook = updateWorkInProgressHook();
        return updateReducerImpl(hook, currentHook, reducer);
      }
      function updateReducerImpl(hook, current, reducer) {
        var queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
        if (null !== pendingQueue) {
          if (null !== baseQueue) {
            var baseFirst = baseQueue.next;
            baseQueue.next = pendingQueue.next;
            pendingQueue.next = baseFirst;
          }
          current.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        pendingQueue = hook.baseState;
        if (null === baseQueue) hook.memoizedState = pendingQueue;
        else {
          current = baseQueue.next;
          var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$60 = false;
          do {
            var updateLane = update.lane & -536870913;
            if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
              var revertLane = update.revertLane;
              if (0 === revertLane)
                null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                  lane: 0,
                  revertLane: 0,
                  gesture: null,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
              else if ((renderLanes & revertLane) === revertLane) {
                update = update.next;
                revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
                continue;
              } else
                updateLane = {
                  lane: 0,
                  revertLane: update.revertLane,
                  gesture: null,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
              updateLane = update.action;
              shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
              pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
            } else
              revertLane = {
                lane: updateLane,
                revertLane: update.revertLane,
                gesture: update.gesture,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
            update = update.next;
          } while (null !== update && update !== current);
          null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
          if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$60 && (reducer = currentEntangledActionThenable, null !== reducer)))
            throw reducer;
          hook.memoizedState = pendingQueue;
          hook.baseState = baseFirst;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = pendingQueue;
        }
        null === baseQueue && (queue.lanes = 0);
        return [hook.memoizedState, queue.dispatch];
      }
      function rerenderReducer(reducer) {
        var hook = updateWorkInProgressHook(), queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
        if (null !== lastRenderPhaseUpdate) {
          queue.pending = null;
          var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          do
            newState = reducer(newState, update.action), update = update.next;
          while (update !== lastRenderPhaseUpdate);
          objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
          hook.memoizedState = newState;
          null === hook.baseQueue && (hook.baseState = newState);
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
        if (isHydrating$jscomp$0) {
          if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else getServerSnapshot = getSnapshot();
        var snapshotChanged = !objectIs(
          (currentHook || hook).memoizedState,
          getServerSnapshot
        );
        snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
        hook = hook.queue;
        updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
          subscribe
        ]);
        if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              hook,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
          isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        return getServerSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= 16384;
        fiber = { getSnapshot, value: renderedSnapshot };
        getSnapshot = currentlyRenderingFiber.updateQueue;
        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      }
      function subscribeToStore(fiber, inst, subscribe) {
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        });
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error2) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root2 = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
      }
      function mountStateImpl(initialState) {
        var hook = mountWorkInProgressHook();
        if ("function" === typeof initialState) {
          var initialStateInitializer = initialState;
          initialState = initialStateInitializer();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              initialStateInitializer();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        hook.memoizedState = hook.baseState = initialState;
        hook.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        };
        return hook;
      }
      function updateOptimisticImpl(hook, current, passthrough, reducer) {
        hook.baseState = passthrough;
        return updateReducerImpl(
          hook,
          currentHook,
          "function" === typeof reducer ? reducer : basicStateReducer
        );
      }
      function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
        if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
        fiber = actionQueue.action;
        if (null !== fiber) {
          var actionNode = {
            payload,
            action: fiber,
            next: null,
            isTransition: true,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(listener) {
              actionNode.listeners.push(listener);
            }
          };
          null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
          setState(actionNode);
          setPendingState = actionQueue.pending;
          null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
        }
      }
      function runActionStateAction(actionQueue, node) {
        var action = node.action, payload = node.payload, prevState = actionQueue.state;
        if (node.isTransition) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            handleActionReturnValue(actionQueue, node, returnValue);
          } catch (error2) {
            onActionError(actionQueue, node, error2);
          } finally {
            null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
          }
        } else
          try {
            prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
          } catch (error$66) {
            onActionError(actionQueue, node, error$66);
          }
      }
      function handleActionReturnValue(actionQueue, node, returnValue) {
        null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
          function(nextState) {
            onActionSuccess(actionQueue, node, nextState);
          },
          function(error2) {
            return onActionError(actionQueue, node, error2);
          }
        ) : onActionSuccess(actionQueue, node, returnValue);
      }
      function onActionSuccess(actionQueue, actionNode, nextState) {
        actionNode.status = "fulfilled";
        actionNode.value = nextState;
        notifyActionListeners(actionNode);
        actionQueue.state = nextState;
        actionNode = actionQueue.pending;
        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
      }
      function onActionError(actionQueue, actionNode, error2) {
        var last = actionQueue.pending;
        actionQueue.pending = null;
        if (null !== last) {
          last = last.next;
          do
            actionNode.status = "rejected", actionNode.reason = error2, notifyActionListeners(actionNode), actionNode = actionNode.next;
          while (actionNode !== last);
        }
        actionQueue.action = null;
      }
      function notifyActionListeners(actionNode) {
        actionNode = actionNode.listeners;
        for (var i2 = 0; i2 < actionNode.length; i2++) (0, actionNode[i2])();
      }
      function actionStateReducer(oldState, newState) {
        return newState;
      }
      function mountActionState(action, initialStateProp) {
        if (isHydrating) {
          var ssrFormState = workInProgressRoot.formState;
          if (null !== ssrFormState) {
            a: {
              var JSCompiler_inline_result = currentlyRenderingFiber;
              if (isHydrating) {
                if (nextHydratableInstance) {
                  b: {
                    var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                    for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                      if (!inRootOrSingleton) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                      JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                        JSCompiler_inline_result$jscomp$0.nextSibling
                      );
                      if (null === JSCompiler_inline_result$jscomp$0) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                    }
                    inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                    JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                  }
                  if (JSCompiler_inline_result$jscomp$0) {
                    nextHydratableInstance = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                    break a;
                  }
                }
                throwOnHydrationMismatch(JSCompiler_inline_result);
              }
              JSCompiler_inline_result = false;
            }
            JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
          }
        }
        ssrFormState = mountWorkInProgressHook();
        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
        JSCompiler_inline_result = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: actionStateReducer,
          lastRenderedState: initialStateProp
        };
        ssrFormState.queue = JSCompiler_inline_result;
        ssrFormState = dispatchSetState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result
        );
        JSCompiler_inline_result.dispatch = ssrFormState;
        JSCompiler_inline_result = mountStateImpl(false);
        inRootOrSingleton = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          false,
          JSCompiler_inline_result.queue
        );
        JSCompiler_inline_result = mountWorkInProgressHook();
        JSCompiler_inline_result$jscomp$0 = {
          state: initialStateProp,
          dispatch: null,
          action,
          pending: null
        };
        JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
        ssrFormState = dispatchActionState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result$jscomp$0,
          inRootOrSingleton,
          ssrFormState
        );
        JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
        JSCompiler_inline_result.memoizedState = action;
        return [initialStateProp, ssrFormState, false];
      }
      function updateActionState(action) {
        var stateHook = updateWorkInProgressHook();
        return updateActionStateImpl(stateHook, currentHook, action);
      }
      function updateActionStateImpl(stateHook, currentStateHook, action) {
        currentStateHook = updateReducerImpl(
          stateHook,
          currentStateHook,
          actionStateReducer
        )[0];
        stateHook = updateReducer(basicStateReducer)[0];
        if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
          try {
            var state = useThenable(currentStateHook);
          } catch (x) {
            if (x === SuspenseException) throw SuspenseActionException;
            throw x;
          }
        else state = currentStateHook;
        currentStateHook = updateWorkInProgressHook();
        var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
        action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
          9,
          { destroy: void 0 },
          actionStateActionEffect.bind(null, actionQueue, action),
          null
        ));
        return [state, dispatch, stateHook];
      }
      function actionStateActionEffect(actionQueue, action) {
        actionQueue.action = action;
      }
      function rerenderActionState(action) {
        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
        if (null !== currentStateHook)
          return updateActionStateImpl(stateHook, currentStateHook, action);
        updateWorkInProgressHook();
        stateHook = stateHook.memoizedState;
        currentStateHook = updateWorkInProgressHook();
        var dispatch = currentStateHook.queue.dispatch;
        currentStateHook.memoizedState = action;
        return [stateHook, dispatch, false];
      }
      function pushSimpleEffect(tag, inst, create2, deps) {
        tag = { tag, create: create2, deps, inst, next: null };
        inst = currentlyRenderingFiber.updateQueue;
        null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
        create2 = inst.lastEffect;
        null === create2 ? inst.lastEffect = tag.next = tag : (deps = create2.next, create2.next = tag, tag.next = deps, inst.lastEffect = tag);
        return tag;
      }
      function updateRef() {
        return updateWorkInProgressHook().memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create2, deps) {
        var hook = mountWorkInProgressHook();
        currentlyRenderingFiber.flags |= fiberFlags;
        hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          { destroy: void 0 },
          create2,
          void 0 === deps ? null : deps
        );
      }
      function updateEffectImpl(fiberFlags, hookFlags, create2, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var inst = hook.memoizedState.inst;
        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create2, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          inst,
          create2,
          deps
        ));
      }
      function mountEffect(create2, deps) {
        mountEffectImpl(8390656, 8, create2, deps);
      }
      function updateEffect(create2, deps) {
        updateEffectImpl(2048, 8, create2, deps);
      }
      function useEffectEventImpl(payload) {
        currentlyRenderingFiber.flags |= 4;
        var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
        if (null === componentUpdateQueue)
          componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
        else {
          var events = componentUpdateQueue.events;
          null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
        }
      }
      function updateEvent(callback2) {
        var ref = updateWorkInProgressHook().memoizedState;
        useEffectEventImpl({ ref, nextImpl: callback2 });
        return function() {
          if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
          return ref.impl.apply(void 0, arguments);
        };
      }
      function updateInsertionEffect(create2, deps) {
        return updateEffectImpl(4, 2, create2, deps);
      }
      function updateLayoutEffect(create2, deps) {
        return updateEffectImpl(4, 4, create2, deps);
      }
      function imperativeHandleEffect(create2, ref) {
        if ("function" === typeof ref) {
          create2 = create2();
          var refCleanup = ref(create2);
          return function() {
            "function" === typeof refCleanup ? refCleanup() : ref(null);
          };
        }
        if (null !== ref && void 0 !== ref)
          return create2 = create2(), ref.current = create2, function() {
            ref.current = null;
          };
      }
      function updateImperativeHandle(ref, create2, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create2, ref), deps);
      }
      function mountDebugValue() {
      }
      function updateCallback(callback2, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        hook.memoizedState = [callback2, deps];
        return callback2;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        prevState = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [prevState, deps];
        return prevState;
      }
      function mountDeferredValueImpl(hook, value, initialValue) {
        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
          return hook.memoizedState = value;
        hook.memoizedState = initialValue;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return initialValue;
      }
      function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
        if (objectIs(value, prevValue)) return value;
        if (null !== currentTreeHiddenStackCursor.current)
          return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
        if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
          return didReceiveUpdate = true, hook.memoizedState = value;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return prevValue;
      }
      function startTransition(fiber, queue, pendingState, finishedState, callback2) {
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        dispatchOptimisticSetState(fiber, false, queue, pendingState);
        try {
          var returnValue = callback2(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
            var thenableForFinishedState = chainThenableValue(
              returnValue,
              finishedState
            );
            dispatchSetStateInternal(
              fiber,
              queue,
              thenableForFinishedState,
              requestUpdateLane(fiber)
            );
          } else
            dispatchSetStateInternal(
              fiber,
              queue,
              finishedState,
              requestUpdateLane(fiber)
            );
        } catch (error2) {
          dispatchSetStateInternal(
            fiber,
            queue,
            { then: function() {
            }, status: "rejected", reason: error2 },
            requestUpdateLane()
          );
        } finally {
          ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      }
      function noop2() {
      }
      function startHostTransition(formFiber, pendingState, action, formData) {
        if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
        var queue = ensureFormComponentIsStateful(formFiber).queue;
        startTransition(
          formFiber,
          queue,
          pendingState,
          sharedNotPendingObject,
          null === action ? noop2 : function() {
            requestFormReset$1(formFiber);
            return action(formData);
          }
        );
      }
      function ensureFormComponentIsStateful(formFiber) {
        var existingStateHook = formFiber.memoizedState;
        if (null !== existingStateHook) return existingStateHook;
        existingStateHook = {
          memoizedState: sharedNotPendingObject,
          baseState: sharedNotPendingObject,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: sharedNotPendingObject
          },
          next: null
        };
        var initialResetState = {};
        existingStateHook.next = {
          memoizedState: initialResetState,
          baseState: initialResetState,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialResetState
          },
          next: null
        };
        formFiber.memoizedState = existingStateHook;
        formFiber = formFiber.alternate;
        null !== formFiber && (formFiber.memoizedState = existingStateHook);
        return existingStateHook;
      }
      function requestFormReset$1(formFiber) {
        var stateHook = ensureFormComponentIsStateful(formFiber);
        null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
        dispatchSetStateInternal(
          formFiber,
          stateHook.next.queue,
          {},
          requestUpdateLane()
        );
      }
      function useHostTransitionStatus() {
        return readContext(HostTransitionContext);
      }
      function updateId() {
        return updateWorkInProgressHook().memoizedState;
      }
      function updateRefresh() {
        return updateWorkInProgressHook().memoizedState;
      }
      function refreshCache(fiber) {
        for (var provider = fiber.return; null !== provider; ) {
          switch (provider.tag) {
            case 24:
            case 3:
              var lane = requestUpdateLane();
              fiber = createUpdate(lane);
              var root$69 = enqueueUpdate(provider, fiber, lane);
              null !== root$69 && (scheduleUpdateOnFiber(root$69, provider, lane), entangleTransitions(root$69, provider, lane));
              provider = { cache: createCache() };
              fiber.payload = provider;
              return;
          }
          provider = provider.return;
        }
      }
      function dispatchReducerAction(fiber, queue, action) {
        var lane = requestUpdateLane();
        action = {
          lane,
          revertLane: 0,
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
      }
      function dispatchSetState(fiber, queue, action) {
        var lane = requestUpdateLane();
        dispatchSetStateInternal(fiber, queue, action, lane);
      }
      function dispatchSetStateInternal(fiber, queue, action, lane) {
        var update = {
          lane,
          revertLane: 0,
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
        else {
          var alternate = fiber.alternate;
          if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
            try {
              var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
              update.hasEagerState = true;
              update.eagerState = eagerState;
              if (objectIs(eagerState, currentState))
                return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
            } catch (error2) {
            } finally {
            }
          action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (null !== action)
            return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
        }
        return false;
      }
      function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
        action = {
          lane: 2,
          revertLane: requestTransitionLane(),
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
        } else
          throwIfDuringRender = enqueueConcurrentHookUpdate(
            fiber,
            queue,
            action,
            2
          ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      function entangleTransitionUpdate(root2, queue, lane) {
        if (0 !== (lane & 4194048)) {
          var queueLanes = queue.lanes;
          queueLanes &= root2.pendingLanes;
          lane |= queueLanes;
          queue.lanes = lane;
          markRootEntangled(root2, lane);
        }
      }
      var ContextOnlyDispatcher = {
        readContext,
        use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError
      };
      ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
      var HooksDispatcherOnMount = {
        readContext,
        use,
        useCallback: function(callback2, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback2,
            void 0 === deps ? null : deps
          ];
          return callback2;
        },
        useContext: readContext,
        useEffect: mountEffect,
        useImperativeHandle: function(ref, create2, deps) {
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          mountEffectImpl(
            4194308,
            4,
            imperativeHandleEffect.bind(null, create2, ref),
            deps
          );
        },
        useLayoutEffect: function(create2, deps) {
          return mountEffectImpl(4194308, 4, create2, deps);
        },
        useInsertionEffect: function(create2, deps) {
          mountEffectImpl(4, 2, create2, deps);
        },
        useMemo: function(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        },
        useReducer: function(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        },
        useRef: function(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        },
        useState: function(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        },
        useTransition: function() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(formatProdErrorMessage(407));
            getServerSnapshot = getServerSnapshot();
          } else {
            getServerSnapshot = getSnapshot();
            if (null === workInProgressRoot)
              throw Error(formatProdErrorMessage(349));
            0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          hook.memoizedState = getServerSnapshot;
          var inst = { value: getServerSnapshot, getSnapshot };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
            subscribe
          ]);
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              inst,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          return getServerSnapshot;
        },
        useId: function() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var JSCompiler_inline_result = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
            identifierPrefix = "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
            JSCompiler_inline_result = localIdCounter++;
            0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
            identifierPrefix += "_";
          } else
            JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + JSCompiler_inline_result.toString(32) + "_";
          return hook.memoizedState = identifierPrefix;
        },
        useHostTransitionStatus,
        useFormState: mountActionState,
        useActionState: mountActionState,
        useOptimistic: function(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        },
        useMemoCache,
        useCacheRefresh: function() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        },
        useEffectEvent: function(callback2) {
          var hook = mountWorkInProgressHook(), ref = { impl: callback2 };
          hook.memoizedState = ref;
          return function() {
            if (0 !== (executionContext & 2))
              throw Error(formatProdErrorMessage(440));
            return ref.impl.apply(void 0, arguments);
          };
        }
      }, HooksDispatcherOnUpdate = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: updateReducer,
        useRef: updateRef,
        useState: function() {
          return updateReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: updateActionState,
        useActionState: updateActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
      var HooksDispatcherOnRerender = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: rerenderReducer,
        useRef: updateRef,
        useState: function() {
          return rerenderReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: rerenderActionState,
        useActionState: rerenderActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      HooksDispatcherOnRerender.useEffectEvent = updateEvent;
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        ctor = workInProgress2.memoizedState;
        getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
        getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
        workInProgress2.memoizedState = getDerivedStateFromProps;
        0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
      }
      var classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback2) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback2 && null !== callback2 && (update.callback = callback2);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueReplaceState: function(inst, payload, callback2) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 1;
          update.payload = payload;
          void 0 !== callback2 && null !== callback2 && (update.callback = callback2);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueForceUpdate: function(inst, callback2) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 2;
          void 0 !== callback2 && null !== callback2 && (update.callback = callback2);
          callback2 = enqueueUpdate(inst, update, lane);
          null !== callback2 && (scheduleUpdateOnFiber(callback2, inst, lane), entangleTransitions(callback2, inst, lane));
        }
      };
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        workInProgress2 = workInProgress2.stateNode;
        return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
      }
      function callComponentWillReceiveProps(workInProgress2, instance2, newProps, nextContext) {
        workInProgress2 = instance2.state;
        "function" === typeof instance2.componentWillReceiveProps && instance2.componentWillReceiveProps(newProps, nextContext);
        "function" === typeof instance2.UNSAFE_componentWillReceiveProps && instance2.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        instance2.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance2, instance2.state, null);
      }
      function resolveClassComponentProps(Component, baseProps) {
        var newProps = baseProps;
        if ("ref" in baseProps) {
          newProps = {};
          for (var propName in baseProps)
            "ref" !== propName && (newProps[propName] = baseProps[propName]);
        }
        if (Component = Component.defaultProps) {
          newProps === baseProps && (newProps = assign({}, newProps));
          for (var propName$73 in Component)
            void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
        }
        return newProps;
      }
      function defaultOnUncaughtError(error2) {
        reportGlobalError(error2);
      }
      function defaultOnCaughtError(error2) {
        console.error(error2);
      }
      function defaultOnRecoverableError(error2) {
        reportGlobalError(error2);
      }
      function logUncaughtError(root2, errorInfo) {
        try {
          var onUncaughtError = root2.onUncaughtError;
          onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
        } catch (e$74) {
          setTimeout(function() {
            throw e$74;
          });
        }
      }
      function logCaughtError(root2, boundary, errorInfo) {
        try {
          var onCaughtError = root2.onCaughtError;
          onCaughtError(errorInfo.value, {
            componentStack: errorInfo.stack,
            errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
          });
        } catch (e$75) {
          setTimeout(function() {
            throw e$75;
          });
        }
      }
      function createRootErrorUpdate(root2, errorInfo, lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        lane.payload = { element: null };
        lane.callback = function() {
          logUncaughtError(root2, errorInfo);
        };
        return lane;
      }
      function createClassErrorUpdate(lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        return lane;
      }
      function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if ("function" === typeof getDerivedStateFromError) {
          var error2 = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error2);
          };
          update.callback = function() {
            logCaughtError(root2, fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
          logCaughtError(root2, fiber, errorInfo);
          "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
          var stack = errorInfo.stack;
          this.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        });
      }
      function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= 32768;
        if (null !== value && "object" === typeof value && "function" === typeof value.then) {
          returnFiber = sourceFiber.alternate;
          null !== returnFiber && propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            true
          );
          sourceFiber = suspenseHandlerStackCursor.current;
          if (null !== sourceFiber) {
            switch (sourceFiber.tag) {
              case 31:
              case 13:
                return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
              case 22:
                return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([value])
                }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
            }
            throw Error(formatProdErrorMessage(435, sourceFiber.tag));
          }
          attachPingListener(root2, value, rootRenderLanes);
          renderDidSuspendDelayIfPossible();
          return false;
        }
        if (isHydrating)
          return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
            cause: value
          }), queueHydrationError(
            createCapturedValueAtFiber(returnFiber, sourceFiber)
          )), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
            root2.stateNode,
            value,
            rootRenderLanes
          ), enqueueCapturedUpdate(root2, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
        var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
        wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
        4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
        if (null === returnFiber) return true;
        value = createCapturedValueAtFiber(value, sourceFiber);
        sourceFiber = returnFiber;
        do {
          switch (sourceFiber.tag) {
            case 3:
              return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
            case 1:
              if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
                return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                  rootRenderLanes,
                  root2,
                  sourceFiber,
                  value
                ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
          }
          sourceFiber = sourceFiber.return;
        } while (null !== sourceFiber);
        return false;
      }
      var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
      function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
          workInProgress2,
          current.child,
          nextChildren,
          renderLanes2
        );
      }
      function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
        Component = Component.render;
        var ref = workInProgress2.ref;
        if ("ref" in nextProps) {
          var propsWithoutRef = {};
          for (var key in nextProps)
            "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
        } else propsWithoutRef = nextProps;
        prepareToReadContext(workInProgress2);
        nextProps = renderWithHooks(
          current,
          workInProgress2,
          Component,
          propsWithoutRef,
          ref,
          renderLanes2
        );
        key = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && key && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null === current) {
          var type = Component.type;
          if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
            return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
              current,
              workInProgress2,
              type,
              nextProps,
              renderLanes2
            );
          current = createFiberFromTypeAndProps(
            Component.type,
            null,
            nextProps,
            workInProgress2,
            workInProgress2.mode,
            renderLanes2
          );
          current.ref = workInProgress2.ref;
          current.return = workInProgress2;
          return workInProgress2.child = current;
        }
        type = current.child;
        if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
          var prevProps = type.memoizedProps;
          Component = Component.compare;
          Component = null !== Component ? Component : shallowEqual;
          if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
            return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        workInProgress2.flags |= 1;
        current = createWorkInProgress(type, nextProps);
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null !== current) {
          var prevProps = current.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
            if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
              0 !== (current.flags & 131072) && (didReceiveUpdate = true);
            else
              return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        return updateFunctionComponent(
          current,
          workInProgress2,
          Component,
          nextProps,
          renderLanes2
        );
      }
      function updateOffscreenComponent(current, workInProgress2, renderLanes2, nextProps) {
        var nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
        null === current && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        });
        if ("hidden" === nextProps.mode) {
          if (0 !== (workInProgress2.flags & 128)) {
            prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
            if (null !== current) {
              nextProps = workInProgress2.child = current.child;
              for (nextChildren = 0; null !== nextProps; )
                nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
              nextProps = nextChildren & ~prevState;
            } else nextProps = 0, workInProgress2.child = null;
            return deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              prevState,
              renderLanes2,
              nextProps
            );
          }
          if (0 !== (renderLanes2 & 536870912))
            workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
              workInProgress2,
              null !== prevState ? prevState.cachePool : null
            ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
          else
            return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
              renderLanes2,
              nextProps
            );
        } else
          null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack());
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function bailoutOffscreenComponent(current, workInProgress2) {
        null !== current && 22 === current.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        });
        return workInProgress2.sibling;
      }
      function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
        var JSCompiler_inline_result = peekCacheFromPool();
        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
        workInProgress2.memoizedState = {
          baseLanes: nextBaseLanes,
          cachePool: JSCompiler_inline_result
        };
        null !== current && pushTransition(workInProgress2, null);
        reuseHiddenContextOnStack();
        pushOffscreenSuspenseHandler(workInProgress2);
        null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
        workInProgress2.childLanes = remainingChildLanes;
        return null;
      }
      function mountActivityChildren(workInProgress2, nextProps) {
        nextProps = mountWorkInProgressOffscreenFiber(
          { mode: nextProps.mode, children: nextProps.children },
          workInProgress2.mode
        );
        nextProps.ref = workInProgress2.ref;
        workInProgress2.child = nextProps;
        nextProps.return = workInProgress2;
        return nextProps;
      }
      function retryActivityComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
        current = mountActivityChildren(workInProgress2, workInProgress2.pendingProps);
        current.flags |= 2;
        popSuspenseHandler(workInProgress2);
        workInProgress2.memoizedState = null;
        return current;
      }
      function updateActivityComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
        workInProgress2.flags &= -129;
        if (null === current) {
          if (isHydrating) {
            if ("hidden" === nextProps.mode)
              return current = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current);
            pushDehydratedActivitySuspenseHandler(workInProgress2);
            (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
              current,
              rootOrSingletonContext
            ), current = null !== current && "&" === current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
              dehydrated: current,
              treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
            if (null === current) throw throwOnHydrationMismatch(workInProgress2);
            workInProgress2.lanes = 536870912;
            return null;
          }
          return mountActivityChildren(workInProgress2, nextProps);
        }
        var prevState = current.memoizedState;
        if (null !== prevState) {
          var dehydrated = prevState.dehydrated;
          pushDehydratedActivitySuspenseHandler(workInProgress2);
          if (didSuspend)
            if (workInProgress2.flags & 256)
              workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
                current,
                workInProgress2,
                renderLanes2
              );
            else if (null !== workInProgress2.memoizedState)
              workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null;
            else throw Error(formatProdErrorMessage(558));
          else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), didSuspend = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || didSuspend) {
            nextProps = workInProgressRoot;
            if (null !== nextProps && (dehydrated = getBumpedLaneForHydration(nextProps, renderLanes2), 0 !== dehydrated && dehydrated !== prevState.retryLane))
              throw prevState.retryLane = dehydrated, enqueueConcurrentRenderForLane(current, dehydrated), scheduleUpdateOnFiber(nextProps, current, dehydrated), SelectiveHydrationException;
            renderDidSuspendDelayIfPossible();
            workInProgress2 = retryActivityComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else
            current = prevState.treeContext, nextHydratableInstance = getNextHydratable(dehydrated.nextSibling), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
          return workInProgress2;
        }
        current = createWorkInProgress(current.child, {
          mode: nextProps.mode,
          children: nextProps.children
        });
        current.ref = workInProgress2.ref;
        workInProgress2.child = current;
        current.return = workInProgress2;
        return current;
      }
      function markRef(current, workInProgress2) {
        var ref = workInProgress2.ref;
        if (null === ref)
          null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
        else {
          if ("function" !== typeof ref && "object" !== typeof ref)
            throw Error(formatProdErrorMessage(284));
          if (null === current || current.ref !== ref)
            workInProgress2.flags |= 4194816;
        }
      }
      function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        Component = renderWithHooks(
          current,
          workInProgress2,
          Component,
          nextProps,
          void 0,
          renderLanes2
        );
        nextProps = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, Component, renderLanes2);
        return workInProgress2.child;
      }
      function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
        prepareToReadContext(workInProgress2);
        workInProgress2.updateQueue = null;
        nextProps = renderWithHooksAgain(
          workInProgress2,
          Component,
          nextProps,
          secondArg
        );
        finishRenderingHooks(current);
        Component = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && Component && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        if (null === workInProgress2.stateNode) {
          var context = emptyContextObject, contextType = Component.contextType;
          "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
          context = new Component(nextProps, context);
          workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
          context.updater = classComponentUpdater;
          workInProgress2.stateNode = context;
          context._reactInternals = workInProgress2;
          context = workInProgress2.stateNode;
          context.props = nextProps;
          context.state = workInProgress2.memoizedState;
          context.refs = {};
          initializeUpdateQueue(workInProgress2);
          contextType = Component.contextType;
          context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
          context.state = workInProgress2.memoizedState;
          contextType = Component.getDerivedStateFromProps;
          "function" === typeof contextType && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            contextType,
            nextProps
          ), context.state = workInProgress2.memoizedState);
          "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
          "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
          nextProps = true;
        } else if (null === current) {
          context = workInProgress2.stateNode;
          var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
          context.props = oldProps;
          var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
          contextType = emptyContextObject;
          "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
          var getDerivedStateFromProps = Component.getDerivedStateFromProps;
          contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
          unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
          contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            contextType
          );
          hasForceUpdate = false;
          var oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          oldContext = workInProgress2.memoizedState;
          unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            getDerivedStateFromProps,
            nextProps
          ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            oldProps,
            nextProps,
            oldState,
            oldContext,
            contextType
          )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
        } else {
          context = workInProgress2.stateNode;
          cloneUpdateQueue(current, workInProgress2);
          contextType = workInProgress2.memoizedProps;
          contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
          context.props = contextType$jscomp$0;
          getDerivedStateFromProps = workInProgress2.pendingProps;
          oldState = context.context;
          oldContext = Component.contextType;
          oldProps = emptyContextObject;
          "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
          unresolvedOldProps = Component.getDerivedStateFromProps;
          (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            oldProps
          );
          hasForceUpdate = false;
          oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          var newState = workInProgress2.memoizedState;
          contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            unresolvedOldProps,
            nextProps
          ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            contextType$jscomp$0,
            nextProps,
            oldState,
            newState,
            oldProps
          ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
            nextProps,
            newState,
            oldProps
          )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
        }
        context = nextProps;
        markRef(current, workInProgress2);
        nextProps = 0 !== (workInProgress2.flags & 128);
        context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          current.child,
          null,
          renderLanes2
        ), workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          null,
          Component,
          renderLanes2
        )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress2,
          renderLanes2
        );
        return current;
      }
      function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
        resetHydrationState();
        workInProgress2.flags |= 256;
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
      };
      function mountSuspenseOffscreenState(renderLanes2) {
        return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
      }
      function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
        current = null !== current ? current.childLanes & ~renderLanes2 : 0;
        primaryTreeDidDefer && (current |= workInProgressDeferredLane);
        return current;
      }
      function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
        JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
        JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
        workInProgress2.flags &= -33;
        if (null === current) {
          if (isHydrating) {
            showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack();
            (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
              current,
              rootOrSingletonContext
            ), current = null !== current && "&" !== current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
              dehydrated: current,
              treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
            if (null === current) throw throwOnHydrationMismatch(workInProgress2);
            isSuspenseInstanceFallback(current) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
            return null;
          }
          var nextPrimaryChildren = nextProps.children;
          nextProps = nextProps.fallback;
          if (showFallback)
            return reuseSuspenseHandlerOnStack(), showFallback = workInProgress2.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
              { mode: "hidden", children: nextPrimaryChildren },
              showFallback
            ), nextProps = createFiberFromFragment(
              nextProps,
              showFallback,
              renderLanes2,
              null
            ), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextPrimaryChildren.sibling = nextProps, workInProgress2.child = nextPrimaryChildren, nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
        }
        var prevState = current.memoizedState;
        if (null !== prevState && (nextPrimaryChildren = prevState.dehydrated, null !== nextPrimaryChildren)) {
          if (didSuspend)
            workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              showFallback
            ), nextPrimaryChildren = createFiberFromFragment(
              nextPrimaryChildren,
              showFallback,
              renderLanes2,
              null
            ), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, reconcileChildFibers(
              workInProgress2,
              current.child,
              null,
              renderLanes2
            ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(null, nextProps));
          else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextPrimaryChildren)) {
            JSCompiler_temp = nextPrimaryChildren.nextSibling && nextPrimaryChildren.nextSibling.dataset;
            if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
            JSCompiler_temp = digest;
            nextProps = Error(formatProdErrorMessage(419));
            nextProps.stack = "";
            nextProps.digest = JSCompiler_temp;
            queueHydrationError({ value: nextProps, source: null, stack: null });
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
            JSCompiler_temp = workInProgressRoot;
            if (null !== JSCompiler_temp && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes2), 0 !== nextProps && nextProps !== prevState.retryLane))
              throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
            isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else
            isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(
              nextPrimaryChildren.nextSibling
            ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountSuspensePrimaryChildren(
              workInProgress2,
              nextProps.children
            ), workInProgress2.flags |= 4096);
          return workInProgress2;
        }
        if (showFallback)
          return reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, prevState = current.child, digest = prevState.sibling, nextProps = createWorkInProgress(prevState, {
            mode: "hidden",
            children: nextProps.children
          }), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, null !== digest ? nextPrimaryChildren = createWorkInProgress(
            digest,
            nextPrimaryChildren
          ) : (nextPrimaryChildren = createFiberFromFragment(
            nextPrimaryChildren,
            showFallback,
            renderLanes2,
            null
          ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress2.child, nextPrimaryChildren = current.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (showFallback = nextPrimaryChildren.cachePool, null !== showFallback ? (prevState = CacheContext._currentValue, showFallback = showFallback.parent !== prevState ? { parent: prevState, pool: prevState } : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {
            baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
            cachePool: showFallback
          }), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current.child, nextProps);
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        renderLanes2 = current.child;
        current = renderLanes2.sibling;
        renderLanes2 = createWorkInProgress(renderLanes2, {
          mode: "visible",
          children: nextProps.children
        });
        renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
        null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
        workInProgress2.child = renderLanes2;
        workInProgress2.memoizedState = null;
        return renderLanes2;
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
        primaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "visible", children: primaryChildren },
          workInProgress2.mode
        );
        primaryChildren.return = workInProgress2;
        return workInProgress2.child = primaryChildren;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
        offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
        offscreenProps.lanes = 0;
        return offscreenProps;
      }
      function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
        current = mountSuspensePrimaryChildren(
          workInProgress2,
          workInProgress2.pendingProps.children
        );
        current.flags |= 2;
        workInProgress2.memoizedState = null;
        return current;
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes |= renderLanes2;
        var alternate = fiber.alternate;
        null !== alternate && (alternate.lanes |= renderLanes2);
        scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
        var renderState = workInProgress2.memoizedState;
        null === renderState ? workInProgress2.memoizedState = {
          isBackwards,
          rendering: null,
          renderingStartTime: 0,
          last: lastContentRow,
          tail,
          tailMode,
          treeForkCount: treeForkCount2
        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
      }
      function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
        nextProps = nextProps.children;
        var suspenseContext = suspenseStackCursor.current, shouldForceFallback = 0 !== (suspenseContext & 2);
        shouldForceFallback ? (suspenseContext = suspenseContext & 1 | 2, workInProgress2.flags |= 128) : suspenseContext &= 1;
        push(suspenseStackCursor, suspenseContext);
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        nextProps = isHydrating ? treeForkCount : 0;
        if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128))
          a: for (current = workInProgress2.child; null !== current; ) {
            if (13 === current.tag)
              null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
            else if (19 === current.tag)
              scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
            else if (null !== current.child) {
              current.child.return = current;
              current = current.child;
              continue;
            }
            if (current === workInProgress2) break a;
            for (; null === current.sibling; ) {
              if (null === current.return || current.return === workInProgress2)
                break a;
              current = current.return;
            }
            current.sibling.return = current.return;
            current = current.sibling;
          }
        switch (revealOrder) {
          case "forwards":
            renderLanes2 = workInProgress2.child;
            for (revealOrder = null; null !== renderLanes2; )
              current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
            renderLanes2 = revealOrder;
            null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
            initSuspenseListRenderState(
              workInProgress2,
              false,
              revealOrder,
              renderLanes2,
              tailMode,
              nextProps
            );
            break;
          case "backwards":
          case "unstable_legacy-backwards":
            renderLanes2 = null;
            revealOrder = workInProgress2.child;
            for (workInProgress2.child = null; null !== revealOrder; ) {
              current = revealOrder.alternate;
              if (null !== current && null === findFirstSuspended(current)) {
                workInProgress2.child = revealOrder;
                break;
              }
              current = revealOrder.sibling;
              revealOrder.sibling = renderLanes2;
              renderLanes2 = revealOrder;
              revealOrder = current;
            }
            initSuspenseListRenderState(
              workInProgress2,
              true,
              renderLanes2,
              null,
              tailMode,
              nextProps
            );
            break;
          case "together":
            initSuspenseListRenderState(
              workInProgress2,
              false,
              null,
              null,
              void 0,
              nextProps
            );
            break;
          default:
            workInProgress2.memoizedState = null;
        }
        return workInProgress2.child;
      }
      function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
        null !== current && (workInProgress2.dependencies = current.dependencies);
        workInProgressRootSkippedLanes |= workInProgress2.lanes;
        if (0 === (renderLanes2 & workInProgress2.childLanes))
          if (null !== current) {
            if (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), 0 === (renderLanes2 & workInProgress2.childLanes))
              return null;
          } else return null;
        if (null !== current && workInProgress2.child !== current.child)
          throw Error(formatProdErrorMessage(153));
        if (null !== workInProgress2.child) {
          current = workInProgress2.child;
          renderLanes2 = createWorkInProgress(current, current.pendingProps);
          workInProgress2.child = renderLanes2;
          for (renderLanes2.return = workInProgress2; null !== current.sibling; )
            current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
        }
        return workInProgress2.child;
      }
      function checkScheduledUpdateOrContext(current, renderLanes2) {
        if (0 !== (current.lanes & renderLanes2)) return true;
        current = current.dependencies;
        return null !== current && checkIfContextChanged(current) ? true : false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case 3:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
            resetHydrationState();
            break;
          case 27:
          case 5:
            pushHostContext(workInProgress2);
            break;
          case 4:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            break;
          case 10:
            pushProvider(
              workInProgress2,
              workInProgress2.type,
              workInProgress2.memoizedProps.value
            );
            break;
          case 31:
            if (null !== workInProgress2.memoizedState)
              return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
            break;
          case 13:
            var state$102 = workInProgress2.memoizedState;
            if (null !== state$102) {
              if (null !== state$102.dehydrated)
                return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
              if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                return updateSuspenseComponent(current, workInProgress2, renderLanes2);
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              current = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress2,
                renderLanes2
              );
              return null !== current ? current.sibling : null;
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            break;
          case 19:
            var didSuspendBefore = 0 !== (current.flags & 128);
            state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes);
            state$102 || (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes));
            if (didSuspendBefore) {
              if (state$102)
                return updateSuspenseListComponent(
                  current,
                  workInProgress2,
                  renderLanes2
                );
              workInProgress2.flags |= 128;
            }
            didSuspendBefore = workInProgress2.memoizedState;
            null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
            push(suspenseStackCursor, suspenseStackCursor.current);
            if (state$102) break;
            else return null;
          case 22:
            return workInProgress2.lanes = 0, updateOffscreenComponent(
              current,
              workInProgress2,
              renderLanes2,
              workInProgress2.pendingProps
            );
          case 24:
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
        }
        return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      function beginWork(current, workInProgress2, renderLanes2) {
        if (null !== current)
          if (current.memoizedProps !== workInProgress2.pendingProps)
            didReceiveUpdate = true;
          else {
            if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
              return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                current,
                workInProgress2,
                renderLanes2
              );
            didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
          }
        else
          didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
        workInProgress2.lanes = 0;
        switch (workInProgress2.tag) {
          case 16:
            a: {
              var props = workInProgress2.pendingProps;
              current = resolveLazy(workInProgress2.elementType);
              workInProgress2.type = current;
              if ("function" === typeof current)
                shouldConstruct(current) ? (props = resolveClassComponentProps(current, props), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  current,
                  props,
                  renderLanes2
                )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  current,
                  props,
                  renderLanes2
                ));
              else {
                if (void 0 !== current && null !== current) {
                  var $$typeof = current.$$typeof;
                  if ($$typeof === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      current,
                      props,
                      renderLanes2
                    );
                    break a;
                  } else if ($$typeof === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      current,
                      props,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = getComponentNameFromType(current) || current;
                throw Error(formatProdErrorMessage(306, workInProgress2, ""));
              }
            }
            return workInProgress2;
          case 0:
            return updateFunctionComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 1:
            return props = workInProgress2.type, $$typeof = resolveClassComponentProps(
              props,
              workInProgress2.pendingProps
            ), updateClassComponent(
              current,
              workInProgress2,
              props,
              $$typeof,
              renderLanes2
            );
          case 3:
            a: {
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              if (null === current) throw Error(formatProdErrorMessage(387));
              props = workInProgress2.pendingProps;
              var prevState = workInProgress2.memoizedState;
              $$typeof = prevState.element;
              cloneUpdateQueue(current, workInProgress2);
              processUpdateQueue(workInProgress2, props, null, renderLanes2);
              var nextState = workInProgress2.memoizedState;
              props = nextState.cache;
              pushProvider(workInProgress2, CacheContext, props);
              props !== prevState.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              );
              suspendIfUpdateReadFromEntangledAsyncAction();
              props = nextState.element;
              if (prevState.isDehydrated)
                if (prevState = {
                  element: props,
                  isDehydrated: false,
                  cache: nextState.cache
                }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    props,
                    renderLanes2
                  );
                  break a;
                } else if (props !== $$typeof) {
                  $$typeof = createCapturedValueAtFiber(
                    Error(formatProdErrorMessage(424)),
                    workInProgress2
                  );
                  queueHydrationError($$typeof);
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    props,
                    renderLanes2
                  );
                  break a;
                } else {
                  current = workInProgress2.stateNode.containerInfo;
                  switch (current.nodeType) {
                    case 9:
                      current = current.body;
                      break;
                    default:
                      current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                  }
                  nextHydratableInstance = getNextHydratable(current.firstChild);
                  hydrationParentFiber = workInProgress2;
                  isHydrating = true;
                  hydrationErrors = null;
                  rootOrSingletonContext = true;
                  renderLanes2 = mountChildFibers(
                    workInProgress2,
                    null,
                    props,
                    renderLanes2
                  );
                  for (workInProgress2.child = renderLanes2; renderLanes2; )
                    renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                }
              else {
                resetHydrationState();
                if (props === $$typeof) {
                  workInProgress2 = bailoutOnAlreadyFinishedWork(
                    current,
                    workInProgress2,
                    renderLanes2
                  );
                  break a;
                }
                reconcileChildren(current, workInProgress2, props, renderLanes2);
              }
              workInProgress2 = workInProgress2.child;
            }
            return workInProgress2;
          case 26:
            return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
              workInProgress2.type,
              null,
              workInProgress2.pendingProps,
              null
            )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, props = getOwnerDocumentFromRootContainer(
              rootInstanceStackCursor.current
            ).createElement(renderLanes2), props[internalInstanceKey] = workInProgress2, props[internalPropsKey] = current, setInitialProperties(props, renderLanes2, current), markNodeAsHoistable(props), workInProgress2.stateNode = props) : workInProgress2.memoizedState = getResource(
              workInProgress2.type,
              current.memoizedProps,
              workInProgress2.pendingProps,
              current.memoizedState
            ), null;
          case 27:
            return pushHostContext(workInProgress2), null === current && isHydrating && (props = workInProgress2.stateNode = resolveSingletonInstance(
              workInProgress2.type,
              workInProgress2.pendingProps,
              rootInstanceStackCursor.current
            ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, $$typeof = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = $$typeof, nextHydratableInstance = getNextHydratable(props.firstChild)) : nextHydratableInstance = $$typeof), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
          case 5:
            if (null === current && isHydrating) {
              if ($$typeof = props = nextHydratableInstance)
                props = canHydrateInstance(
                  props,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== props ? (workInProgress2.stateNode = props, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(props.firstChild), rootOrSingletonContext = false, $$typeof = true) : $$typeof = false;
              $$typeof || throwOnHydrationMismatch(workInProgress2);
            }
            pushHostContext(workInProgress2);
            $$typeof = workInProgress2.type;
            prevState = workInProgress2.pendingProps;
            nextState = null !== current ? current.memoizedProps : null;
            props = prevState.children;
            shouldSetTextContent($$typeof, prevState) ? props = null : null !== nextState && shouldSetTextContent($$typeof, nextState) && (workInProgress2.flags |= 32);
            null !== workInProgress2.memoizedState && ($$typeof = renderWithHooks(
              current,
              workInProgress2,
              TransitionAwareHostComponent,
              null,
              null,
              renderLanes2
            ), HostTransitionContext._currentValue = $$typeof);
            markRef(current, workInProgress2);
            reconcileChildren(current, workInProgress2, props, renderLanes2);
            return workInProgress2.child;
          case 6:
            if (null === current && isHydrating) {
              if (current = renderLanes2 = nextHydratableInstance)
                renderLanes2 = canHydrateTextInstance(
                  renderLanes2,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
              current || throwOnHydrationMismatch(workInProgress2);
            }
            return null;
          case 13:
            return updateSuspenseComponent(current, workInProgress2, renderLanes2);
          case 4:
            return pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            ), props = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              props,
              renderLanes2
            ) : reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
          case 11:
            return updateForwardRef(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 7:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps,
              renderLanes2
            ), workInProgress2.child;
          case 8:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 12:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 10:
            return props = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, props.value), reconcileChildren(current, workInProgress2, props.children, renderLanes2), workInProgress2.child;
          case 9:
            return $$typeof = workInProgress2.type._context, props = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), $$typeof = readContext($$typeof), props = props($$typeof), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
          case 14:
            return updateMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 15:
            return updateSimpleMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 19:
            return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
          case 31:
            return updateActivityComponent(current, workInProgress2, renderLanes2);
          case 22:
            return updateOffscreenComponent(
              current,
              workInProgress2,
              renderLanes2,
              workInProgress2.pendingProps
            );
          case 24:
            return prepareToReadContext(workInProgress2), props = readContext(CacheContext), null === current ? ($$typeof = peekCacheFromPool(), null === $$typeof && ($$typeof = workInProgressRoot, prevState = createCache(), $$typeof.pooledCache = prevState, prevState.refCount++, null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes2), $$typeof = prevState), workInProgress2.memoizedState = { parent: props, cache: $$typeof }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, $$typeof)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), $$typeof = current.memoizedState, prevState = workInProgress2.memoizedState, $$typeof.parent !== props ? ($$typeof = { parent: props, cache: props }, workInProgress2.memoizedState = $$typeof, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = $$typeof), pushProvider(workInProgress2, CacheContext, props)) : (props = prevState.cache, pushProvider(workInProgress2, CacheContext, props), props !== $$typeof.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            ))), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 29:
            throw workInProgress2.pendingProps;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= 4;
      }
      function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
        if (type = 0 !== (workInProgress2.mode & 32)) type = false;
        if (type) {
          if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
            if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
            else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
            else
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        } else workInProgress2.flags &= -16777217;
      }
      function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
        if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
          workInProgress2.flags &= -16777217;
        else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
          if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
          else
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      }
      function scheduleRetryEffect(workInProgress2, retryQueue) {
        null !== retryQueue && (workInProgress2.flags |= 4);
        workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!isHydrating)
          switch (renderState.tailMode) {
            case "hidden":
              hasRenderedATailFallback = renderState.tail;
              for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
              null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
              break;
            case "collapsed":
              lastTailNode = renderState.tail;
              for (var lastTailNode$106 = null; null !== lastTailNode; )
                null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode), lastTailNode = lastTailNode.sibling;
              null === lastTailNode$106 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$106.sibling = null;
          }
      }
      function bubbleProperties(completedWork) {
        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
        if (didBailout)
          for (var child$107 = completedWork.child; null !== child$107; )
            newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags & 65011712, subtreeFlags |= child$107.flags & 65011712, child$107.return = completedWork, child$107 = child$107.sibling;
        else
          for (child$107 = completedWork.child; null !== child$107; )
            newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags, subtreeFlags |= child$107.flags, child$107.return = completedWork, child$107 = child$107.sibling;
        completedWork.subtreeFlags |= subtreeFlags;
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeWork(current, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return bubbleProperties(workInProgress2), null;
          case 1:
            return bubbleProperties(workInProgress2), null;
          case 3:
            renderLanes2 = workInProgress2.stateNode;
            newProps = null;
            null !== current && (newProps = current.memoizedState.cache);
            workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
            popProvider(CacheContext);
            popHostContainer();
            renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
            if (null === current || null === current.child)
              popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
            bubbleProperties(workInProgress2);
            return null;
          case 26:
            var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
            null === current ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              type,
              null,
              newProps,
              renderLanes2
            ))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current = current.memoizedProps, current !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              type,
              current,
              newProps,
              renderLanes2
            ));
            return null;
          case 27:
            popHostContext(workInProgress2);
            renderLanes2 = rootInstanceStackCursor.current;
            type = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              current = contextStackCursor.current;
              popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
            }
            bubbleProperties(workInProgress2);
            return null;
          case 5:
            popHostContext(workInProgress2);
            type = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              nextResource = contextStackCursor.current;
              if (popHydrationState(workInProgress2))
                prepareToHydrateHostInstance(workInProgress2);
              else {
                var ownerDocument = getOwnerDocumentFromRootContainer(
                  rootInstanceStackCursor.current
                );
                switch (nextResource) {
                  case 1:
                    nextResource = ownerDocument.createElementNS(
                      "http://www.w3.org/2000/svg",
                      type
                    );
                    break;
                  case 2:
                    nextResource = ownerDocument.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      type
                    );
                    break;
                  default:
                    switch (type) {
                      case "svg":
                        nextResource = ownerDocument.createElementNS(
                          "http://www.w3.org/2000/svg",
                          type
                        );
                        break;
                      case "math":
                        nextResource = ownerDocument.createElementNS(
                          "http://www.w3.org/1998/Math/MathML",
                          type
                        );
                        break;
                      case "script":
                        nextResource = ownerDocument.createElement("div");
                        nextResource.innerHTML = "<script><\/script>";
                        nextResource = nextResource.removeChild(
                          nextResource.firstChild
                        );
                        break;
                      case "select":
                        nextResource = "string" === typeof newProps.is ? ownerDocument.createElement("select", {
                          is: newProps.is
                        }) : ownerDocument.createElement("select");
                        newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                        break;
                      default:
                        nextResource = "string" === typeof newProps.is ? ownerDocument.createElement(type, { is: newProps.is }) : ownerDocument.createElement(type);
                    }
                }
                nextResource[internalInstanceKey] = workInProgress2;
                nextResource[internalPropsKey] = newProps;
                a: for (ownerDocument = workInProgress2.child; null !== ownerDocument; ) {
                  if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
                    nextResource.appendChild(ownerDocument.stateNode);
                  else if (4 !== ownerDocument.tag && 27 !== ownerDocument.tag && null !== ownerDocument.child) {
                    ownerDocument.child.return = ownerDocument;
                    ownerDocument = ownerDocument.child;
                    continue;
                  }
                  if (ownerDocument === workInProgress2) break a;
                  for (; null === ownerDocument.sibling; ) {
                    if (null === ownerDocument.return || ownerDocument.return === workInProgress2)
                      break a;
                    ownerDocument = ownerDocument.return;
                  }
                  ownerDocument.sibling.return = ownerDocument.return;
                  ownerDocument = ownerDocument.sibling;
                }
                workInProgress2.stateNode = nextResource;
                a: switch (setInitialProperties(nextResource, type, newProps), type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    newProps = !!newProps.autoFocus;
                    break a;
                  case "img":
                    newProps = true;
                    break a;
                  default:
                    newProps = false;
                }
                newProps && markUpdate(workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              workInProgress2.type,
              null === current ? null : current.memoizedProps,
              workInProgress2.pendingProps,
              renderLanes2
            );
            return null;
          case 6:
            if (current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              current = rootInstanceStackCursor.current;
              if (popHydrationState(workInProgress2)) {
                current = workInProgress2.stateNode;
                renderLanes2 = workInProgress2.memoizedProps;
                newProps = null;
                type = hydrationParentFiber;
                if (null !== type)
                  switch (type.tag) {
                    case 27:
                    case 5:
                      newProps = type.memoizedProps;
                  }
                current[internalInstanceKey] = workInProgress2;
                current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
                current || throwOnHydrationMismatch(workInProgress2, true);
              } else
                current = getOwnerDocumentFromRootContainer(current).createTextNode(
                  newProps
                ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
            }
            bubbleProperties(workInProgress2);
            return null;
          case 31:
            renderLanes2 = workInProgress2.memoizedState;
            if (null === current || null !== current.memoizedState) {
              newProps = popHydrationState(workInProgress2);
              if (null !== renderLanes2) {
                if (null === current) {
                  if (!newProps) throw Error(formatProdErrorMessage(318));
                  current = workInProgress2.memoizedState;
                  current = null !== current ? current.dehydrated : null;
                  if (!current) throw Error(formatProdErrorMessage(557));
                  current[internalInstanceKey] = workInProgress2;
                } else
                  resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                bubbleProperties(workInProgress2);
                current = false;
              } else
                renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = renderLanes2), current = true;
              if (!current) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
              if (0 !== (workInProgress2.flags & 128))
                throw Error(formatProdErrorMessage(558));
            }
            bubbleProperties(workInProgress2);
            return null;
          case 13:
            newProps = workInProgress2.memoizedState;
            if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
              type = popHydrationState(workInProgress2);
              if (null !== newProps && null !== newProps.dehydrated) {
                if (null === current) {
                  if (!type) throw Error(formatProdErrorMessage(318));
                  type = workInProgress2.memoizedState;
                  type = null !== type ? type.dehydrated : null;
                  if (!type) throw Error(formatProdErrorMessage(317));
                  type[internalInstanceKey] = workInProgress2;
                } else
                  resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                bubbleProperties(workInProgress2);
                type = false;
              } else
                type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
              if (!type) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
            }
            popSuspenseHandler(workInProgress2);
            if (0 !== (workInProgress2.flags & 128))
              return workInProgress2.lanes = renderLanes2, workInProgress2;
            renderLanes2 = null !== newProps;
            current = null !== current && null !== current.memoizedState;
            renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
            renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
            scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
            bubbleProperties(workInProgress2);
            return null;
          case 4:
            return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
          case 10:
            return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
          case 19:
            pop(suspenseStackCursor);
            newProps = workInProgress2.memoizedState;
            if (null === newProps) return bubbleProperties(workInProgress2), null;
            type = 0 !== (workInProgress2.flags & 128);
            nextResource = newProps.rendering;
            if (null === nextResource)
              if (type) cutOffTailIfNeeded(newProps, false);
              else {
                if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                  for (current = workInProgress2.child; null !== current; ) {
                    nextResource = findFirstSuspended(current);
                    if (null !== nextResource) {
                      workInProgress2.flags |= 128;
                      cutOffTailIfNeeded(newProps, false);
                      current = nextResource.updateQueue;
                      workInProgress2.updateQueue = current;
                      scheduleRetryEffect(workInProgress2, current);
                      workInProgress2.subtreeFlags = 0;
                      current = renderLanes2;
                      for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                        resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                      push(
                        suspenseStackCursor,
                        suspenseStackCursor.current & 1 | 2
                      );
                      isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                      return workInProgress2.child;
                    }
                    current = current.sibling;
                  }
                null !== newProps.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
              }
            else {
              if (!type)
                if (current = findFirstSuspended(nextResource), null !== current) {
                  if (workInProgress2.flags |= 128, type = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                    return bubbleProperties(workInProgress2), null;
                } else
                  2 * now() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
              newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current = newProps.last, null !== current ? current.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
            }
            if (null !== newProps.tail)
              return current = newProps.tail, newProps.rendering = current, newProps.tail = current.sibling, newProps.renderingStartTime = now(), current.sibling = null, renderLanes2 = suspenseStackCursor.current, push(
                suspenseStackCursor,
                type ? renderLanes2 & 1 | 2 : renderLanes2 & 1
              ), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current;
            bubbleProperties(workInProgress2);
            return null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
          case 24:
            return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
          case 25:
            return null;
          case 30:
            return null;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function unwindWork(current, workInProgress2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 1:
            return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 3:
            return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 26:
          case 27:
          case 5:
            return popHostContext(workInProgress2), null;
          case 31:
            if (null !== workInProgress2.memoizedState) {
              popSuspenseHandler(workInProgress2);
              if (null === workInProgress2.alternate)
                throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress2.flags;
            return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 13:
            popSuspenseHandler(workInProgress2);
            current = workInProgress2.memoizedState;
            if (null !== current && null !== current.dehydrated) {
              if (null === workInProgress2.alternate)
                throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress2.flags;
            return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 19:
            return pop(suspenseStackCursor), null;
          case 4:
            return popHostContainer(), null;
          case 10:
            return popProvider(workInProgress2.type), null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 24:
            return popProvider(CacheContext), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current, interruptedWork) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case 3:
            popProvider(CacheContext);
            popHostContainer();
            break;
          case 26:
          case 27:
          case 5:
            popHostContext(interruptedWork);
            break;
          case 4:
            popHostContainer();
            break;
          case 31:
            null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
            break;
          case 13:
            popSuspenseHandler(interruptedWork);
            break;
          case 19:
            pop(suspenseStackCursor);
            break;
          case 10:
            popProvider(interruptedWork.type);
            break;
          case 22:
          case 23:
            popSuspenseHandler(interruptedWork);
            popHiddenContext();
            null !== current && pop(resumedCache);
            break;
          case 24:
            popProvider(CacheContext);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                lastEffect = void 0;
                var create2 = updateQueue.create, inst = updateQueue.inst;
                lastEffect = create2();
                inst.destroy = lastEffect;
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error2) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                var inst = updateQueue.inst, destroy = inst.destroy;
                if (void 0 !== destroy) {
                  inst.destroy = void 0;
                  lastEffect = finishedWork;
                  var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                  try {
                    destroy_();
                  } catch (error2) {
                    captureCommitPhaseError(
                      lastEffect,
                      nearestMountedAncestor,
                      error2
                    );
                  }
                }
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error2) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
        }
      }
      function commitClassCallbacks(finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        if (null !== updateQueue) {
          var instance2 = finishedWork.stateNode;
          try {
            commitCallbacks(updateQueue, instance2);
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
        }
      }
      function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance2) {
        instance2.props = resolveClassComponentProps(
          current.type,
          current.memoizedProps
        );
        instance2.state = current.memoizedState;
        try {
          instance2.componentWillUnmount();
        } catch (error2) {
          captureCommitPhaseError(current, nearestMountedAncestor, error2);
        }
      }
      function safelyAttachRef(current, nearestMountedAncestor) {
        try {
          var ref = current.ref;
          if (null !== ref) {
            switch (current.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = current.stateNode;
                break;
              case 30:
                instanceToUse = current.stateNode;
                break;
              default:
                instanceToUse = current.stateNode;
            }
            "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
          }
        } catch (error2) {
          captureCommitPhaseError(current, nearestMountedAncestor, error2);
        }
      }
      function safelyDetachRef(current, nearestMountedAncestor) {
        var ref = current.ref, refCleanup = current.refCleanup;
        if (null !== ref)
          if ("function" === typeof refCleanup)
            try {
              refCleanup();
            } catch (error2) {
              captureCommitPhaseError(current, nearestMountedAncestor, error2);
            } finally {
              current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
            }
          else if ("function" === typeof ref)
            try {
              ref(null);
            } catch (error$140) {
              captureCommitPhaseError(current, nearestMountedAncestor, error$140);
            }
          else ref.current = null;
      }
      function commitHostMount(finishedWork) {
        var type = finishedWork.type, props = finishedWork.memoizedProps, instance2 = finishedWork.stateNode;
        try {
          a: switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              props.autoFocus && instance2.focus();
              break a;
            case "img":
              props.src ? instance2.src = props.src : props.srcSet && (instance2.srcset = props.srcSet);
          }
        } catch (error2) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
        }
      }
      function commitHostUpdate(finishedWork, newProps, oldProps) {
        try {
          var domElement = finishedWork.stateNode;
          updateProperties(domElement, finishedWork.type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        } catch (error2) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
        }
      }
      function isHostParent(fiber) {
        return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
      }
      function getHostSibling(fiber) {
        a: for (; ; ) {
          for (; null === fiber.sibling; ) {
            if (null === fiber.return || isHostParent(fiber.return)) return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
            if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
            if (fiber.flags & 2) continue a;
            if (null === fiber.child || 4 === fiber.tag) continue a;
            else fiber.child.return = fiber, fiber = fiber.child;
          }
          if (!(fiber.flags & 2)) return fiber.stateNode;
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$12));
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
          for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
          for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      }
      function commitHostSingletonAcquisition(finishedWork) {
        var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
        try {
          for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
            singleton.removeAttributeNode(attributes[0]);
          setInitialProperties(singleton, type, props);
          singleton[internalInstanceKey] = finishedWork;
          singleton[internalPropsKey] = props;
        } catch (error2) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
        }
      }
      var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null;
      function commitBeforeMutationEffects(root2, firstChild) {
        root2 = root2.containerInfo;
        eventsEnabled = _enabled;
        root2 = getActiveElementDeep(root2);
        if (hasSelectionCapabilities(root2)) {
          if ("selectionStart" in root2)
            var JSCompiler_temp = {
              start: root2.selectionStart,
              end: root2.selectionEnd
            };
          else
            a: {
              JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
              var selection2 = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
              if (selection2 && 0 !== selection2.rangeCount) {
                JSCompiler_temp = selection2.anchorNode;
                var anchorOffset = selection2.anchorOffset, focusNode = selection2.focusNode;
                selection2 = selection2.focusOffset;
                try {
                  JSCompiler_temp.nodeType, focusNode.nodeType;
                } catch (e$20) {
                  JSCompiler_temp = null;
                  break a;
                }
                var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
                b: for (; ; ) {
                  for (var next; ; ) {
                    node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                    node !== focusNode || 0 !== selection2 && 3 !== node.nodeType || (end = length + selection2);
                    3 === node.nodeType && (length += node.nodeValue.length);
                    if (null === (next = node.firstChild)) break;
                    parentNode = node;
                    node = next;
                  }
                  for (; ; ) {
                    if (node === root2) break b;
                    parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                    parentNode === focusNode && ++indexWithinFocus === selection2 && (end = length);
                    if (null !== (next = node.nextSibling)) break;
                    node = parentNode;
                    parentNode = node.parentNode;
                  }
                  node = next;
                }
                JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
              } else JSCompiler_temp = null;
            }
          JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
        } else JSCompiler_temp = null;
        selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
        _enabled = false;
        for (nextEffect = firstChild; null !== nextEffect; )
          if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root2)
            root2.return = firstChild, nextEffect = root2;
          else
            for (; null !== nextEffect; ) {
              firstChild = nextEffect;
              focusNode = firstChild.alternate;
              root2 = firstChild.flags;
              switch (firstChild.tag) {
                case 0:
                  if (0 !== (root2 & 4) && (root2 = firstChild.updateQueue, root2 = null !== root2 ? root2.events : null, null !== root2))
                    for (JSCompiler_temp = 0; JSCompiler_temp < root2.length; JSCompiler_temp++)
                      anchorOffset = root2[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  if (0 !== (root2 & 1024) && null !== focusNode) {
                    root2 = void 0;
                    JSCompiler_temp = firstChild;
                    anchorOffset = focusNode.memoizedProps;
                    focusNode = focusNode.memoizedState;
                    selection2 = JSCompiler_temp.stateNode;
                    try {
                      var resolvedPrevProps = resolveClassComponentProps(
                        JSCompiler_temp.type,
                        anchorOffset
                      );
                      root2 = selection2.getSnapshotBeforeUpdate(
                        resolvedPrevProps,
                        focusNode
                      );
                      selection2.__reactInternalSnapshotBeforeUpdate = root2;
                    } catch (error2) {
                      captureCommitPhaseError(
                        JSCompiler_temp,
                        JSCompiler_temp.return,
                        error2
                      );
                    }
                  }
                  break;
                case 3:
                  if (0 !== (root2 & 1024)) {
                    if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                      clearContainerSparingly(root2);
                    else if (1 === JSCompiler_temp)
                      switch (root2.nodeName) {
                        case "HEAD":
                        case "HTML":
                        case "BODY":
                          clearContainerSparingly(root2);
                          break;
                        default:
                          root2.textContent = "";
                      }
                  }
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if (0 !== (root2 & 1024)) throw Error(formatProdErrorMessage(163));
              }
              root2 = firstChild.sibling;
              if (null !== root2) {
                root2.return = firstChild.return;
                nextEffect = root2;
                break;
              }
              nextEffect = firstChild.return;
            }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitHookEffectListMount(5, finishedWork);
            break;
          case 1:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 4)
              if (finishedRoot = finishedWork.stateNode, null === current)
                try {
                  finishedRoot.componentDidMount();
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              else {
                var prevProps = resolveClassComponentProps(
                  finishedWork.type,
                  current.memoizedProps
                );
                current = current.memoizedState;
                try {
                  finishedRoot.componentDidUpdate(
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                } catch (error$139) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error$139
                  );
                }
              }
            flags & 64 && commitClassCallbacks(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
              current = null;
              if (null !== finishedWork.child)
                switch (finishedWork.child.tag) {
                  case 27:
                  case 5:
                    current = finishedWork.child.stateNode;
                    break;
                  case 1:
                    current = finishedWork.child.stateNode;
                }
              try {
                commitCallbacks(finishedRoot, current);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
            }
            break;
          case 27:
            null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            null === current && flags & 4 && commitHostMount(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            break;
          case 31:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
            break;
          case 22:
            flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
            if (!flags) {
              current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
              prevProps = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = flags;
              (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                0 !== (finishedWork.subtreeFlags & 8772)
              ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              offscreenSubtreeIsHidden = prevProps;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            }
            break;
          case 30:
            break;
          default:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        }
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
        fiber.child = null;
        fiber.deletions = null;
        fiber.sibling = null;
        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
        fiber.stateNode = null;
        fiber.return = null;
        fiber.dependencies = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.stateNode = null;
        fiber.updateQueue = null;
      }
      var hostParent = null, hostParentIsContainer = false;
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        for (parent = parent.child; null !== parent; )
          commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
          try {
            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
          } catch (err) {
          }
        switch (deletedFiber.tag) {
          case 26:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
            break;
          case 27:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
            isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            releaseSingletonInstance(deletedFiber.stateNode);
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 5:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          case 6:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = null;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            if (null !== hostParent)
              if (hostParentIsContainer)
                try {
                  (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
                } catch (error2) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error2
                  );
                }
              else
                try {
                  hostParent.removeChild(deletedFiber.stateNode);
                } catch (error2) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error2
                  );
                }
            break;
          case 18:
            null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
              9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
              deletedFiber.stateNode
            ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
            break;
          case 4:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = deletedFiber.stateNode.containerInfo;
            hostParentIsContainer = true;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 1:
            offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
              deletedFiber,
              nearestMountedAncestor,
              prevHostParent
            ));
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 21:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 22:
            offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            offscreenSubtreeWasHidden = prevHostParent;
            break;
          default:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
        }
      }
      function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
          finishedRoot = finishedRoot.dehydrated;
          try {
            retryIfBlockedOn(finishedRoot);
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
        }
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
          try {
            retryIfBlockedOn(finishedRoot);
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
      }
      function getRetryCache(finishedWork) {
        switch (finishedWork.tag) {
          case 31:
          case 13:
          case 19:
            var retryCache = finishedWork.stateNode;
            null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
            return retryCache;
          case 22:
            return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
          default:
            throw Error(formatProdErrorMessage(435, finishedWork.tag));
        }
      }
      function attachSuspenseRetryListeners(finishedWork, wakeables) {
        var retryCache = getRetryCache(finishedWork);
        wakeables.forEach(function(wakeable) {
          if (!retryCache.has(wakeable)) {
            retryCache.add(wakeable);
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            wakeable.then(retry, retry);
          }
        });
      }
      function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
        var deletions = parentFiber.deletions;
        if (null !== deletions)
          for (var i2 = 0; i2 < deletions.length; i2++) {
            var childToDelete = deletions[i2], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
            a: for (; null !== parent; ) {
              switch (parent.tag) {
                case 27:
                  if (isSingletonScope(parent.type)) {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  }
                  break;
                case 5:
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                case 3:
                case 4:
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break a;
              }
              parent = parent.return;
            }
            if (null === hostParent) throw Error(formatProdErrorMessage(160));
            commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
            hostParent = null;
            hostParentIsContainer = false;
            root2 = childToDelete.alternate;
            null !== root2 && (root2.return = null);
            childToDelete.return = null;
          }
        if (parentFiber.subtreeFlags & 13886)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
      }
      var currentHoistableRoot = null;
      function commitMutationEffectsOnFiber(finishedWork, root2) {
        var current = finishedWork.alternate, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
            break;
          case 1:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
            break;
          case 26:
            var hoistableRoot = currentHoistableRoot;
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (flags & 4) {
              var currentResource = null !== current ? current.memoizedState : null;
              flags = finishedWork.memoizedState;
              if (null === current)
                if (null === flags)
                  if (null === finishedWork.stateNode) {
                    a: {
                      flags = finishedWork.type;
                      current = finishedWork.memoizedProps;
                      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                      b: switch (flags) {
                        case "title":
                          currentResource = hoistableRoot.getElementsByTagName("title")[0];
                          if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                            currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                              currentResource,
                              hoistableRoot.querySelector("head > title")
                            );
                          setInitialProperties(currentResource, flags, current);
                          currentResource[internalInstanceKey] = finishedWork;
                          markNodeAsHoistable(currentResource);
                          flags = currentResource;
                          break a;
                        case "link":
                          var maybeNodes = getHydratableHoistableCache(
                            "link",
                            "href",
                            hoistableRoot
                          ).get(flags + (current.href || ""));
                          if (maybeNodes) {
                            for (var i2 = 0; i2 < maybeNodes.length; i2++)
                              if (currentResource = maybeNodes[i2], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                                maybeNodes.splice(i2, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        case "meta":
                          if (maybeNodes = getHydratableHoistableCache(
                            "meta",
                            "content",
                            hoistableRoot
                          ).get(flags + (current.content || ""))) {
                            for (i2 = 0; i2 < maybeNodes.length; i2++)
                              if (currentResource = maybeNodes[i2], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                                maybeNodes.splice(i2, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        default:
                          throw Error(formatProdErrorMessage(468, flags));
                      }
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                    }
                    finishedWork.stateNode = flags;
                  } else
                    mountHoistable(
                      hoistableRoot,
                      finishedWork.type,
                      finishedWork.stateNode
                    );
                else
                  finishedWork.stateNode = acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  );
              else
                currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.stateNode
                ) : acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                  finishedWork,
                  finishedWork.memoizedProps,
                  current.memoizedProps
                );
            }
            break;
          case 27:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            null !== current && flags & 4 && commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current.memoizedProps
            );
            break;
          case 5:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (finishedWork.flags & 32) {
              hoistableRoot = finishedWork.stateNode;
              try {
                setTextContent(hoistableRoot, "");
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
            }
            flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
              finishedWork,
              hoistableRoot,
              null !== current ? current.memoizedProps : hoistableRoot
            ));
            flags & 1024 && (needsFormReset = true);
            break;
          case 6:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & 4) {
              if (null === finishedWork.stateNode)
                throw Error(formatProdErrorMessage(162));
              flags = finishedWork.memoizedProps;
              current = finishedWork.stateNode;
              try {
                current.nodeValue = flags;
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
            }
            break;
          case 3:
            tagCaches = null;
            hoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(root2.containerInfo);
            recursivelyTraverseMutationEffects(root2, finishedWork);
            currentHoistableRoot = hoistableRoot;
            commitReconciliationEffects(finishedWork);
            if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
              try {
                retryIfBlockedOn(root2.containerInfo);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
            needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
            break;
          case 4:
            flags = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(
              finishedWork.stateNode.containerInfo
            );
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            currentHoistableRoot = flags;
            break;
          case 12:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            break;
          case 31:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 13:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 22:
            hoistableRoot = null !== finishedWork.memoizedState;
            var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
            recursivelyTraverseMutationEffects(root2, finishedWork);
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            commitReconciliationEffects(finishedWork);
            if (flags & 8192)
              a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & -2 : root2._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root2 = finishedWork; ; ) {
                if (5 === root2.tag || 26 === root2.tag) {
                  if (null === current) {
                    wasHidden = current = root2;
                    try {
                      if (currentResource = wasHidden.stateNode, hoistableRoot)
                        maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                      else {
                        i2 = wasHidden.stateNode;
                        var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                        i2.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                      }
                    } catch (error2) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error2);
                    }
                  }
                } else if (6 === root2.tag) {
                  if (null === current) {
                    wasHidden = root2;
                    try {
                      wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                    } catch (error2) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error2);
                    }
                  }
                } else if (18 === root2.tag) {
                  if (null === current) {
                    wasHidden = root2;
                    try {
                      var instance2 = wasHidden.stateNode;
                      hoistableRoot ? hideOrUnhideDehydratedBoundary(instance2, true) : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, false);
                    } catch (error2) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error2);
                    }
                  }
                } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                  root2.child.return = root2;
                  root2 = root2.child;
                  continue;
                }
                if (root2 === finishedWork) break a;
                for (; null === root2.sibling; ) {
                  if (null === root2.return || root2.return === finishedWork) break a;
                  current === root2 && (current = null);
                  root2 = root2.return;
                }
                current === root2 && (current = null);
                root2.sibling.return = root2.return;
                root2 = root2.sibling;
              }
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
            break;
          case 19:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 30:
            break;
          case 21:
            break;
          default:
            recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & 2) {
          try {
            for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
              if (isHostParent(parentFiber)) {
                hostParentFiber = parentFiber;
                break;
              }
              parentFiber = parentFiber.return;
            }
            if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
            switch (hostParentFiber.tag) {
              case 27:
                var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              case 5:
                var parent$141 = hostParentFiber.stateNode;
                hostParentFiber.flags & 32 && (setTextContent(parent$141, ""), hostParentFiber.flags &= -33);
                var before$142 = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
                break;
              case 3:
              case 4:
                var parent$143 = hostParentFiber.stateNode.containerInfo, before$144 = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(
                  finishedWork,
                  before$144,
                  parent$143
                );
                break;
              default:
                throw Error(formatProdErrorMessage(161));
            }
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
          finishedWork.flags &= -3;
        }
        flags & 4096 && (finishedWork.flags &= -4097);
      }
      function recursivelyResetForms(parentFiber) {
        if (parentFiber.subtreeFlags & 1024)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var fiber = parentFiber;
            recursivelyResetForms(fiber);
            5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
            parentFiber = parentFiber.sibling;
          }
      }
      function recursivelyTraverseLayoutEffects(root2, parentFiber) {
        if (parentFiber.subtreeFlags & 8772)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
      }
      function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedWork = parentFiber;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance2 = finishedWork.stateNode;
              "function" === typeof instance2.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance2
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              releaseSingletonInstance(finishedWork.stateNode);
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(4, finishedWork);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current = finishedWork;
              finishedRoot = current.stateNode;
              if ("function" === typeof finishedRoot.componentDidMount)
                try {
                  finishedRoot.componentDidMount();
                } catch (error2) {
                  captureCommitPhaseError(current, current.return, error2);
                }
              current = finishedWork;
              finishedRoot = current.updateQueue;
              if (null !== finishedRoot) {
                var instance2 = current.stateNode;
                try {
                  var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                  if (null !== hiddenCallbacks)
                    for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                      callCallback(hiddenCallbacks[finishedRoot], instance2);
                } catch (error2) {
                  captureCommitPhaseError(current, current.return, error2);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              break;
            case 31:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitOffscreenPassiveMountEffects(current, finishedWork) {
        var previousCache = null;
        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
        current = null;
        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
        current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
      }
      function commitCachePassiveMountEffect(current, finishedWork) {
        current = null;
        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
        finishedWork = finishedWork.memoizedState.cache;
        finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
      }
      function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveMountOnFiber(
              root2,
              parentFiber,
              committedLanes,
              committedTransitions
            ), parentFiber = parentFiber.sibling;
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitHookEffectListMount(9, finishedWork);
            break;
          case 1:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 3:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
            break;
          case 12:
            if (flags & 2048) {
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              finishedRoot = finishedWork.stateNode;
              try {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, id2 = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
                "function" === typeof onPostCommit && onPostCommit(
                  id2,
                  null === finishedWork.alternate ? "mount" : "update",
                  finishedRoot.passiveEffectDuration,
                  -0
                );
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
            } else
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
            break;
          case 31:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 13:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 23:
            break;
          case 22:
            _finishedWork$memoize2 = finishedWork.stateNode;
            id2 = finishedWork.alternate;
            null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256) || false
            ));
            flags & 2048 && commitOffscreenPassiveMountEffects(id2, finishedWork);
            break;
          case 24:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
        }
      }
      function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || false);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(8, finishedWork);
              break;
            case 23:
              break;
            case 22:
              var instance2 = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? instance2._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : (instance2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 22:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitOffscreenPassiveMountEffects(
                  finishedWork.alternate,
                  finishedWork
                );
                break;
              case 24:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                break;
              default:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            }
            parentFiber = parentFiber.sibling;
          }
      }
      var suspenseyCommitFlag = 8192;
      function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
        if (parentFiber.subtreeFlags & suspenseyCommitFlag)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            accumulateSuspenseyCommitOnFiber(
              parentFiber,
              committedLanes,
              suspendedState
            ), parentFiber = parentFiber.sibling;
      }
      function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
        switch (fiber.tag) {
          case 26:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
              suspendedState,
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps
            );
            break;
          case 5:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            break;
          case 3:
          case 4:
            var previousHoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            currentHoistableRoot = previousHoistableRoot;
            break;
          case 22:
            null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ));
            break;
          default:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
        }
      }
      function detachAlternateSiblings(parentFiber) {
        var previousFiber = parentFiber.alternate;
        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
          previousFiber.child = null;
          do
            previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
          while (null !== parentFiber);
        }
      }
      function recursivelyTraversePassiveUnmountEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i2 = 0; i2 < deletions.length; i2++) {
              var childToDelete = deletions[i2];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 12:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 22:
            var instance2 = finishedWork.stateNode;
            null !== finishedWork.memoizedState && instance2._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance2._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          default:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
        }
      }
      function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i2 = 0; i2 < deletions.length; i2++) {
              var childToDelete = deletions[i2];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          deletions = parentFiber;
          switch (deletions.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, deletions, deletions.return);
              recursivelyTraverseDisconnectPassiveEffects(deletions);
              break;
            case 22:
              i2 = deletions.stateNode;
              i2._visibility & 2 && (i2._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(deletions);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        for (; null !== nextEffect; ) {
          var fiber = nextEffect;
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
              break;
            case 23:
            case 22:
              if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
                var cache = fiber.memoizedState.cachePool.pool;
                null != cache && cache.refCount++;
              }
              break;
            case 24:
              releaseCache(fiber.memoizedState.cache);
          }
          cache = fiber.child;
          if (null !== cache) cache.return = fiber, nextEffect = cache;
          else
            a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
              cache = nextEffect;
              var sibling = cache.sibling, returnFiber = cache.return;
              detachFiberAfterEffects(cache);
              if (cache === fiber) {
                nextEffect = null;
                break a;
              }
              if (null !== sibling) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                break a;
              }
              nextEffect = returnFiber;
            }
        }
      }
      var DefaultAsyncDispatcher = {
        getCacheForType: function(resourceType) {
          var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
          return cacheForType;
        },
        cacheSignal: function() {
          return readContext(CacheContext).controller.signal;
        }
      }, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
      function requestUpdateLane() {
        return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes : null !== ReactSharedInternals.T ? requestTransitionLane() : resolveUpdatePriority();
      }
      function requestDeferredLane() {
        if (0 === workInProgressDeferredLane)
          if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
            var lane = nextTransitionDeferredLane;
            nextTransitionDeferredLane <<= 1;
            0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
            workInProgressDeferredLane = lane;
          } else workInProgressDeferredLane = 536870912;
        lane = suspenseHandlerStackCursor.current;
        null !== lane && (lane.flags |= 32);
        return workInProgressDeferredLane;
      }
      function scheduleUpdateOnFiber(root2, fiber, lane) {
        if (root2 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
          prepareFreshStack(root2, 0), markRootSuspended(
            root2,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        markRootUpdated$1(root2, lane);
        if (0 === (executionContext & 2) || root2 !== workInProgressRoot)
          root2 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
            root2,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          )), ensureRootIsScheduled(root2);
      }
      function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        var shouldTimeSlice = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
        do {
          if (0 === exitStatus) {
            workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
            break;
          } else {
            forceSync = root$jscomp$0.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
              exitStatus = renderRootSync(root$jscomp$0, lanes, false);
              renderWasConcurrent = false;
              continue;
            }
            if (2 === exitStatus) {
              renderWasConcurrent = lanes;
              if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
                var JSCompiler_inline_result = 0;
              else
                JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
              if (0 !== JSCompiler_inline_result) {
                lanes = JSCompiler_inline_result;
                a: {
                  var root2 = root$jscomp$0;
                  exitStatus = workInProgressRootConcurrentErrors;
                  var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
                  wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
                  JSCompiler_inline_result = renderRootSync(
                    root2,
                    JSCompiler_inline_result,
                    false
                  );
                  if (2 !== JSCompiler_inline_result) {
                    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                      root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
                      workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                      exitStatus = 4;
                      break a;
                    }
                    renderWasConcurrent = workInProgressRootRecoverableErrors;
                    workInProgressRootRecoverableErrors = exitStatus;
                    null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                      workInProgressRootRecoverableErrors,
                      renderWasConcurrent
                    ));
                  }
                  exitStatus = JSCompiler_inline_result;
                }
                renderWasConcurrent = false;
                if (2 !== exitStatus) continue;
              }
            }
            if (1 === exitStatus) {
              prepareFreshStack(root$jscomp$0, 0);
              markRootSuspended(root$jscomp$0, lanes, 0, true);
              break;
            }
            a: {
              shouldTimeSlice = root$jscomp$0;
              renderWasConcurrent = exitStatus;
              switch (renderWasConcurrent) {
                case 0:
                case 1:
                  throw Error(formatProdErrorMessage(345));
                case 4:
                  if ((lanes & 4194048) !== lanes) break;
                case 6:
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  break a;
                case 2:
                  workInProgressRootRecoverableErrors = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(formatProdErrorMessage(329));
              }
              if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
                pendingEffectsLanes = lanes;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(
                  commitRootWhenReady.bind(
                    null,
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    renderWasConcurrent,
                    "Throttled",
                    -0,
                    0
                  ),
                  exitStatus
                );
                break a;
              }
              commitRootWhenReady(
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                renderWasConcurrent,
                null,
                -0,
                0
              );
            }
          }
          break;
        } while (1);
        ensureRootIsScheduled(root$jscomp$0);
      }
      function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
        root2.timeoutHandle = -1;
        suspendedCommitReason = finishedWork.subtreeFlags;
        if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
          suspendedCommitReason = {
            stylesheets: null,
            count: 0,
            imgCount: 0,
            imgBytes: 0,
            suspenseyImages: [],
            waitingForImages: true,
            waitingForViewTransition: false,
            unsuspend: noop$12
          };
          accumulateSuspenseyCommitOnFiber(
            finishedWork,
            lanes,
            suspendedCommitReason
          );
          var timeoutOffset = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now() : 0;
          timeoutOffset = waitForCommitToBeReady(
            suspendedCommitReason,
            timeoutOffset
          );
          if (null !== timeoutOffset) {
            pendingEffectsLanes = lanes;
            root2.cancelPendingCommit = timeoutOffset(
              commitRoot.bind(
                null,
                root2,
                finishedWork,
                lanes,
                recoverableErrors,
                transitions,
                didIncludeRenderPhaseUpdate,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes,
                exitStatus,
                suspendedCommitReason,
                null,
                completedRenderStartTime,
                completedRenderEndTime
              )
            );
            markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
            return;
          }
        }
        commitRoot(
          root2,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        for (var node = finishedWork; ; ) {
          var tag = node.tag;
          if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
            for (var i2 = 0; i2 < tag.length; i2++) {
              var check = tag[i2], getSnapshot = check.getSnapshot;
              check = check.value;
              try {
                if (!objectIs(getSnapshot(), check)) return false;
              } catch (error2) {
                return false;
              }
            }
          tag = node.child;
          if (node.subtreeFlags & 16384 && null !== tag)
            tag.return = node, node = tag;
          else {
            if (node === finishedWork) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === finishedWork) return true;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return true;
      }
      function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
        suspendedLanes &= ~workInProgressRootPingedLanes;
        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
        root2.suspendedLanes |= suspendedLanes;
        root2.pingedLanes &= ~suspendedLanes;
        didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
        didAttemptEntireTree = root2.expirationTimes;
        for (var lanes = suspendedLanes; 0 < lanes; ) {
          var index$6 = 31 - clz32(lanes), lane = 1 << index$6;
          didAttemptEntireTree[index$6] = -1;
          lanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
      }
      function flushSyncWork$1() {
        return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
      }
      function resetWorkInProgressStack() {
        if (null !== workInProgress) {
          if (0 === workInProgressSuspendedReason)
            var interruptedWork = workInProgress.return;
          else
            interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
          for (; null !== interruptedWork; )
            unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
          workInProgress = null;
        }
      }
      function prepareFreshStack(root2, lanes) {
        var timeoutHandle = root2.timeoutHandle;
        -1 !== timeoutHandle && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
        timeoutHandle = root2.cancelPendingCommit;
        null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
        pendingEffectsLanes = 0;
        resetWorkInProgressStack();
        workInProgressRoot = root2;
        workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
        workInProgressRootRenderLanes = lanes;
        workInProgressSuspendedReason = 0;
        workInProgressThrownValue = null;
        workInProgressRootDidSkipSuspendedSiblings = false;
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
        workInProgressRootDidAttachPingListener = false;
        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
        workInProgressRootDidIncludeRecursiveRenderUpdate = false;
        0 !== (lanes & 8) && (lanes |= lanes & 32);
        var allEntangledLanes = root2.entangledLanes;
        if (0 !== allEntangledLanes)
          for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
            var index$4 = 31 - clz32(allEntangledLanes), lane = 1 << index$4;
            lanes |= root2[index$4];
            allEntangledLanes &= ~lane;
          }
        entangledRenderLanes = lanes;
        finishQueueingConcurrentUpdates();
        return timeoutHandle;
      }
      function handleThrow(root2, thrownValue) {
        currentlyRenderingFiber = null;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
        workInProgressThrownValue = thrownValue;
        null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
          root2,
          createCapturedValueAtFiber(thrownValue, root2.current)
        ));
      }
      function shouldRemainOnPreviousScreen() {
        var handler = suspenseHandlerStackCursor.current;
        return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
      }
      function pushDispatcher() {
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
      }
      function pushAsyncDispatcher() {
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        return prevAsyncDispatcher;
      }
      function renderDidSuspendDelayIfPossible() {
        workInProgressRootExitStatus = 4;
        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      }
      function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
          workInProgressTransitions = null, prepareFreshStack(root2, lanes);
        lanes = false;
        var exitStatus = workInProgressRootExitStatus;
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case 8:
                  resetWorkInProgressStack();
                  exitStatus = 6;
                  break a;
                case 3:
                case 2:
                case 9:
                case 6:
                  null === suspenseHandlerStackCursor.current && (lanes = true);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    exitStatus = 0;
                    break a;
                  }
                  break;
                default:
                  reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
              }
            }
            workLoopSync();
            exitStatus = workInProgressRootExitStatus;
            break;
          } catch (thrownValue$165) {
            handleThrow(root2, thrownValue$165);
          }
        while (1);
        lanes && root2.shellSuspendCounter++;
        lastContextDependency = currentlyRenderingFiber$1 = null;
        executionContext = prevExecutionContext;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
        return exitStatus;
      }
      function workLoopSync() {
        for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
      }
      function renderRootConcurrent(root2, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
          root2,
          lanes
        );
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              lanes = workInProgress;
              var thrownValue = workInProgressThrownValue;
              b: switch (workInProgressSuspendedReason) {
                case 1:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
                  break;
                case 2:
                case 9:
                  if (isThenableResolved(thrownValue)) {
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    replaySuspendedUnitOfWork(lanes);
                    break;
                  }
                  lanes = function() {
                    2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root2 || (workInProgressSuspendedReason = 7);
                    ensureRootIsScheduled(root2);
                  };
                  thrownValue.then(lanes, lanes);
                  break a;
                case 3:
                  workInProgressSuspendedReason = 7;
                  break a;
                case 4:
                  workInProgressSuspendedReason = 5;
                  break a;
                case 7:
                  isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
                  break;
                case 5:
                  var resource = null;
                  switch (workInProgress.tag) {
                    case 26:
                      resource = workInProgress.memoizedState;
                    case 5:
                    case 27:
                      var hostFiber = workInProgress;
                      if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                        workInProgressSuspendedReason = 0;
                        workInProgressThrownValue = null;
                        var sibling = hostFiber.sibling;
                        if (null !== sibling) workInProgress = sibling;
                        else {
                          var returnFiber = hostFiber.return;
                          null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                        }
                        break b;
                      }
                  }
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
                  break;
                case 6:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
                  break;
                case 8:
                  resetWorkInProgressStack();
                  workInProgressRootExitStatus = 6;
                  break a;
                default:
                  throw Error(formatProdErrorMessage(462));
              }
            }
            workLoopConcurrentByScheduler();
            break;
          } catch (thrownValue$167) {
            handleThrow(root2, thrownValue$167);
          }
        while (1);
        lastContextDependency = currentlyRenderingFiber$1 = null;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        executionContext = prevExecutionContext;
        if (null !== workInProgress) return 0;
        workInProgressRoot = null;
        workInProgressRootRenderLanes = 0;
        finishQueueingConcurrentUpdates();
        return workInProgressRootExitStatus;
      }
      function workLoopConcurrentByScheduler() {
        for (; null !== workInProgress && !shouldYield(); )
          performUnitOfWork(workInProgress);
      }
      function performUnitOfWork(unitOfWork) {
        var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function replaySuspendedUnitOfWork(unitOfWork) {
        var next = unitOfWork;
        var current = next.alternate;
        switch (next.tag) {
          case 15:
          case 0:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type,
              void 0,
              workInProgressRootRenderLanes
            );
            break;
          case 11:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type.render,
              next.ref,
              workInProgressRootRenderLanes
            );
            break;
          case 5:
            resetHooksOnUnwind(next);
          default:
            unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
        }
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
        lastContextDependency = currentlyRenderingFiber$1 = null;
        resetHooksOnUnwind(unitOfWork);
        thenableState$1 = null;
        thenableIndexCounter$1 = 0;
        var returnFiber = unitOfWork.return;
        try {
          if (throwException(
            root2,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes
          )) {
            workInProgressRootExitStatus = 1;
            logUncaughtError(
              root2,
              createCapturedValueAtFiber(thrownValue, root2.current)
            );
            workInProgress = null;
            return;
          }
        } catch (error2) {
          if (null !== returnFiber) throw workInProgress = returnFiber, error2;
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root2,
            createCapturedValueAtFiber(thrownValue, root2.current)
          );
          workInProgress = null;
          return;
        }
        if (unitOfWork.flags & 32768) {
          if (isHydrating || 1 === suspendedReason) root2 = true;
          else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
            root2 = false;
          else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
            suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
          unwindUnitOfWork(unitOfWork, root2);
        } else completeUnitOfWork(unitOfWork);
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          if (0 !== (completedWork.flags & 32768)) {
            unwindUnitOfWork(
              completedWork,
              workInProgressRootDidSkipSuspendedSiblings
            );
            return;
          }
          unitOfWork = completedWork.return;
          var next = completeWork(
            completedWork.alternate,
            completedWork,
            entangledRenderLanes
          );
          if (null !== next) {
            workInProgress = next;
            return;
          }
          completedWork = completedWork.sibling;
          if (null !== completedWork) {
            workInProgress = completedWork;
            return;
          }
          workInProgress = completedWork = unitOfWork;
        } while (null !== completedWork);
        0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
      }
      function unwindUnitOfWork(unitOfWork, skipSiblings) {
        do {
          var next = unwindWork(unitOfWork.alternate, unitOfWork);
          if (null !== next) {
            next.flags &= 32767;
            workInProgress = next;
            return;
          }
          next = unitOfWork.return;
          null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
          if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
            workInProgress = unitOfWork;
            return;
          }
          workInProgress = unitOfWork = next;
        } while (null !== unitOfWork);
        workInProgressRootExitStatus = 6;
        workInProgress = null;
      }
      function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
        root2.cancelPendingCommit = null;
        do
          flushPendingEffects();
        while (0 !== pendingEffectsStatus);
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        if (null !== finishedWork) {
          if (finishedWork === root2.current) throw Error(formatProdErrorMessage(177));
          didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
          didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
          markRootFinished(
            root2,
            lanes,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
          root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
          pendingFinishedWork = finishedWork;
          pendingEffectsRoot = root2;
          pendingEffectsLanes = lanes;
          pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
          pendingPassiveTransitions = transitions;
          pendingRecoverableErrors = recoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
            flushPassiveEffects();
            return null;
          })) : (root2.callbackNode = null, root2.callbackPriority = 0);
          recoverableErrors = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
            recoverableErrors = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            transitions = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            spawnedLane = executionContext;
            executionContext |= 4;
            try {
              commitBeforeMutationEffects(root2, finishedWork, lanes);
            } finally {
              executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
            }
          }
          pendingEffectsStatus = 1;
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
        }
      }
      function flushMutationEffects() {
        if (1 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
            rootMutationHasEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitMutationEffectsOnFiber(finishedWork, root2);
              var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
              if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                priorFocusedElem.ownerDocument.documentElement,
                priorFocusedElem
              )) {
                if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                  var start = priorSelectionRange.start, end = priorSelectionRange.end;
                  void 0 === end && (end = start);
                  if ("selectionStart" in priorFocusedElem)
                    priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                      end,
                      priorFocusedElem.value.length
                    );
                  else {
                    var doc2 = priorFocusedElem.ownerDocument || document, win = doc2 && doc2.defaultView || window;
                    if (win.getSelection) {
                      var selection2 = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                      !selection2.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                      var startMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        start$jscomp$0
                      ), endMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        end$jscomp$0
                      );
                      if (startMarker && endMarker && (1 !== selection2.rangeCount || selection2.anchorNode !== startMarker.node || selection2.anchorOffset !== startMarker.offset || selection2.focusNode !== endMarker.node || selection2.focusOffset !== endMarker.offset)) {
                        var range = doc2.createRange();
                        range.setStart(startMarker.node, startMarker.offset);
                        selection2.removeAllRanges();
                        start$jscomp$0 > end$jscomp$0 ? (selection2.addRange(range), selection2.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection2.addRange(range));
                      }
                    }
                  }
                }
                doc2 = [];
                for (selection2 = priorFocusedElem; selection2 = selection2.parentNode; )
                  1 === selection2.nodeType && doc2.push({
                    element: selection2,
                    left: selection2.scrollLeft,
                    top: selection2.scrollTop
                  });
                "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                for (priorFocusedElem = 0; priorFocusedElem < doc2.length; priorFocusedElem++) {
                  var info = doc2[priorFocusedElem];
                  info.element.scrollLeft = info.left;
                  info.element.scrollTop = info.top;
                }
              }
              _enabled = !!eventsEnabled;
              selectionInformation = eventsEnabled = null;
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
            }
          }
          root2.current = finishedWork;
          pendingEffectsStatus = 2;
        }
      }
      function flushLayoutEffects() {
        if (2 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
          if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
            rootHasLayoutEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork);
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
            }
          }
          pendingEffectsStatus = 3;
        }
      }
      function flushSpawnedWork() {
        if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          requestPaint();
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes));
          var remainingLanes = root2.pendingLanes;
          0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
          lanesToEventPriority(lanes);
          finishedWork = finishedWork.stateNode;
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
            try {
              injectedHook.onCommitFiberRoot(
                rendererID,
                finishedWork,
                void 0,
                128 === (finishedWork.current.flags & 128)
              );
            } catch (err) {
            }
          if (null !== recoverableErrors) {
            finishedWork = ReactSharedInternals.T;
            remainingLanes = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            ReactSharedInternals.T = null;
            try {
              for (var onRecoverableError = root2.onRecoverableError, i2 = 0; i2 < recoverableErrors.length; i2++) {
                var recoverableError = recoverableErrors[i2];
                onRecoverableError(recoverableError.value, {
                  componentStack: recoverableError.stack
                });
              }
            } finally {
              ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
            }
          }
          0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
          ensureRootIsScheduled(root2);
          remainingLanes = root2.pendingLanes;
          0 !== (lanes & 261930) && 0 !== (remainingLanes & 42) ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
          flushSyncWorkAcrossRoots_impl(0);
        }
      }
      function releaseRootPooledCache(root2, remainingLanes) {
        0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
      }
      function flushPendingEffects() {
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
        return flushPassiveEffects();
      }
      function flushPassiveEffects() {
        if (5 !== pendingEffectsStatus) return false;
        var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
        pendingEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
          ReactSharedInternals.T = null;
          renderPriority = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
          pendingEffectsStatus = 0;
          pendingFinishedWork = pendingEffectsRoot = null;
          pendingEffectsLanes = 0;
          if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          commitPassiveUnmountOnFiber(root$jscomp$0.current);
          commitPassiveMountOnFiber(
            root$jscomp$0,
            root$jscomp$0.current,
            lanes,
            renderPriority
          );
          executionContext = prevExecutionContext;
          flushSyncWorkAcrossRoots_impl(0, false);
          if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
            } catch (err) {
            }
          return true;
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root2, remainingLanes);
        }
      }
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
        sourceFiber = createCapturedValueAtFiber(error2, sourceFiber);
        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error2) {
        if (3 === sourceFiber.tag)
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error2);
        else
          for (; null !== nearestMountedAncestor; ) {
            if (3 === nearestMountedAncestor.tag) {
              captureCommitPhaseErrorOnRoot(
                nearestMountedAncestor,
                sourceFiber,
                error2
              );
              break;
            } else if (1 === nearestMountedAncestor.tag) {
              var instance2 = nearestMountedAncestor.stateNode;
              if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance2.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance2))) {
                sourceFiber = createCapturedValueAtFiber(error2, sourceFiber);
                error2 = createClassErrorUpdate(2);
                instance2 = enqueueUpdate(nearestMountedAncestor, error2, 2);
                null !== instance2 && (initializeClassErrorUpdate(
                  error2,
                  instance2,
                  nearestMountedAncestor,
                  sourceFiber
                ), markRootUpdated$1(instance2, 2), ensureRootIsScheduled(instance2));
                break;
              }
            }
            nearestMountedAncestor = nearestMountedAncestor.return;
          }
      }
      function attachPingListener(root2, wakeable, lanes) {
        var pingCache = root2.pingCache;
        if (null === pingCache) {
          pingCache = root2.pingCache = new PossiblyWeakMap();
          var threadIDs = /* @__PURE__ */ new Set();
          pingCache.set(wakeable, threadIDs);
        } else
          threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
      }
      function pingSuspendedRoot(root2, wakeable, pingedLanes) {
        var pingCache = root2.pingCache;
        null !== pingCache && pingCache.delete(wakeable);
        root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
        root2.warmLanes &= ~pingedLanes;
        workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
        ensureRootIsScheduled(root2);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        0 === retryLane && (retryLane = claimNextRetryLane());
        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = 0;
        switch (boundaryFiber.tag) {
          case 31:
          case 13:
            var retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            null !== suspenseState && (retryLane = suspenseState.retryLane);
            break;
          case 19:
            retryCache = boundaryFiber.stateNode;
            break;
          case 22:
            retryCache = boundaryFiber.stateNode._retryCache;
            break;
          default:
            throw Error(formatProdErrorMessage(314));
        }
        null !== retryCache && retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function scheduleCallback$1(priorityLevel, callback2) {
        return scheduleCallback$3(priorityLevel, callback2);
      }
      var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
      function ensureRootIsScheduled(root2) {
        root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
        mightHavePendingSyncWork = true;
        didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
      }
      function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
        if (!isFlushingWork && mightHavePendingSyncWork) {
          isFlushingWork = true;
          do {
            var didPerformSomeWork = false;
            for (var root$170 = firstScheduledRoot; null !== root$170; ) {
              if (0 !== syncTransitionLanes) {
                var pendingLanes = root$170.pendingLanes;
                if (0 === pendingLanes) var JSCompiler_inline_result = 0;
                else {
                  var suspendedLanes = root$170.suspendedLanes, pingedLanes = root$170.pingedLanes;
                  JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                  JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                  JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
                }
                0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
              } else
                JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                  root$170,
                  root$170 === workInProgressRoot ? JSCompiler_inline_result : 0,
                  null !== root$170.cancelPendingCommit || -1 !== root$170.timeoutHandle
                ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
              root$170 = root$170.next;
            }
          } while (didPerformSomeWork);
          isFlushingWork = false;
        }
      }
      function processRootScheduleInImmediateTask() {
        processRootScheduleInMicrotask();
      }
      function processRootScheduleInMicrotask() {
        mightHavePendingSyncWork = didScheduleMicrotask = false;
        var syncTransitionLanes = 0;
        0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
        for (var currentTime = now(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
          var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
          if (0 === nextLanes)
            root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
          else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
            mightHavePendingSyncWork = true;
          root2 = next;
        }
        0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus || flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
        0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
      }
      function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
        for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
          var index$5 = 31 - clz32(lanes), lane = 1 << index$5, expirationTime = expirationTimes[index$5];
          if (-1 === expirationTime) {
            if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
              expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
          } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
          lanes &= ~lane;
        }
        currentTime = workInProgressRoot;
        suspendedLanes = workInProgressRootRenderLanes;
        suspendedLanes = getNextLanes(
          root2,
          root2 === currentTime ? suspendedLanes : 0,
          null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
        );
        pingedLanes = root2.callbackNode;
        if (0 === suspendedLanes || root2 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
          return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
          currentTime = suspendedLanes & -suspendedLanes;
          if (currentTime === root2.callbackPriority) return currentTime;
          null !== pingedLanes && cancelCallback$1(pingedLanes);
          switch (lanesToEventPriority(suspendedLanes)) {
            case 2:
            case 8:
              suspendedLanes = UserBlockingPriority;
              break;
            case 32:
              suspendedLanes = NormalPriority$1;
              break;
            case 268435456:
              suspendedLanes = IdlePriority;
              break;
            default:
              suspendedLanes = NormalPriority$1;
          }
          pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
          suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
          root2.callbackPriority = currentTime;
          root2.callbackNode = suspendedLanes;
          return currentTime;
        }
        null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
        root2.callbackPriority = 2;
        root2.callbackNode = null;
        return 2;
      }
      function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
        if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
          return root2.callbackNode = null, root2.callbackPriority = 0, null;
        var originalCallbackNode = root2.callbackNode;
        if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
          return null;
        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
          root2,
          root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
          null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
        );
        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
        performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
        scheduleTaskForRootDuringMicrotask(root2, now());
        return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
      }
      function performSyncWorkOnRoot(root2, lanes) {
        if (flushPendingEffects()) return null;
        performWorkOnRoot(root2, lanes, true);
      }
      function scheduleImmediateRootScheduleTask() {
        scheduleMicrotask(function() {
          0 !== (executionContext & 6) ? scheduleCallback$3(
            ImmediatePriority,
            processRootScheduleInImmediateTask
          ) : processRootScheduleInMicrotask();
        });
      }
      function requestTransitionLane() {
        if (0 === currentEventTransitionLane) {
          var actionScopeLane = currentEntangledLane;
          0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
          currentEventTransitionLane = actionScopeLane;
        }
        return currentEventTransitionLane;
      }
      function coerceFormActionProp(actionProp) {
        return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
      }
      function createFormDataWithSubmitter(form, submitter) {
        var temp = submitter.ownerDocument.createElement("input");
        temp.name = submitter.name;
        temp.value = submitter.value;
        form.id && temp.setAttribute("form", form.id);
        submitter.parentNode.insertBefore(temp, submitter);
        form = new FormData(form);
        temp.parentNode.removeChild(temp);
        return form;
      }
      function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
        if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
          var action = coerceFormActionProp(
            (nativeEventTarget[internalPropsKey] || null).action
          ), submitter = nativeEvent.submitter;
          submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
          var event = new SyntheticEvent(
            "action",
            "action",
            null,
            nativeEvent,
            nativeEventTarget
          );
          dispatchQueue.push({
            event,
            listeners: [
              {
                instance: null,
                listener: function() {
                  if (nativeEvent.defaultPrevented) {
                    if (0 !== currentEventTransitionLane) {
                      var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                      startHostTransition(
                        maybeTargetInst,
                        {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        },
                        null,
                        formData
                      );
                    }
                  } else
                    "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      },
                      action,
                      formData
                    ));
                },
                currentTarget: nativeEventTarget
              }
            ]
          });
        }
      }
      for (var i$jscomp$inline_1577 = 0; i$jscomp$inline_1577 < simpleEventPluginEvents.length; i$jscomp$inline_1577++) {
        var eventName$jscomp$inline_1578 = simpleEventPluginEvents[i$jscomp$inline_1577], domEventName$jscomp$inline_1579 = eventName$jscomp$inline_1578.toLowerCase(), capitalizedEvent$jscomp$inline_1580 = eventName$jscomp$inline_1578[0].toUpperCase() + eventName$jscomp$inline_1578.slice(1);
        registerSimpleEvent(
          domEventName$jscomp$inline_1579,
          "on" + capitalizedEvent$jscomp$inline_1580
        );
      }
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
      registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
      registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
      registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
      registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
      registerTwoPhaseEvent(
        "onChange",
        "change click focusin focusout input keydown keyup selectionchange".split(" ")
      );
      registerTwoPhaseEvent(
        "onSelect",
        "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
          " "
        )
      );
      registerTwoPhaseEvent("onBeforeInput", [
        "compositionend",
        "keypress",
        "textInput",
        "paste"
      ]);
      registerTwoPhaseEvent(
        "onCompositionEnd",
        "compositionend focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionStart",
        "compositionstart focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionUpdate",
        "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
      );
      var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      ), nonDelegatedEvents = new Set(
        "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
      );
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        eventSystemFlags = 0 !== (eventSystemFlags & 4);
        for (var i2 = 0; i2 < dispatchQueue.length; i2++) {
          var _dispatchQueue$i = dispatchQueue[i2], event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          a: {
            var previousInstance = void 0;
            if (eventSystemFlags)
              for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance2 = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance2 !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error2) {
                  reportGlobalError(error2);
                }
                event.currentTarget = null;
                previousInstance = instance2;
              }
            else
              for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                instance2 = _dispatchListeners$i.instance;
                currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance2 !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error2) {
                  reportGlobalError(error2);
                }
                event.currentTarget = null;
                previousInstance = instance2;
              }
          }
        }
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
        void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
        var listenerSetKey = domEventName + "__bubble";
        JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
        var eventSystemFlags = 0;
        isCapturePhaseListener && (eventSystemFlags |= 4);
        addTrappedEventListener(
          target,
          domEventName,
          eventSystemFlags,
          isCapturePhaseListener
        );
      }
      var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
      function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
          rootContainerElement[listeningMarker] = true;
          allNativeEvents.forEach(function(domEventName) {
            "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
          });
          var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
          null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
        }
      }
      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
        switch (getEventPriority(domEventName)) {
          case 2:
            var listenerWrapper = dispatchDiscreteEvent;
            break;
          case 8:
            listenerWrapper = dispatchContinuousEvent;
            break;
          default:
            listenerWrapper = dispatchEvent;
        }
        eventSystemFlags = listenerWrapper.bind(
          null,
          domEventName,
          eventSystemFlags,
          targetContainer
        );
        listenerWrapper = void 0;
        !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
        isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          capture: true,
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
      }
      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
        var ancestorInst = targetInst$jscomp$0;
        if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
          a: for (; ; ) {
            if (null === targetInst$jscomp$0) return;
            var nodeTag = targetInst$jscomp$0.tag;
            if (3 === nodeTag || 4 === nodeTag) {
              var container2 = targetInst$jscomp$0.stateNode.containerInfo;
              if (container2 === targetContainer) break;
              if (4 === nodeTag)
                for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                  var grandTag = nodeTag.tag;
                  if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                    return;
                  nodeTag = nodeTag.return;
                }
              for (; null !== container2; ) {
                nodeTag = getClosestInstanceFromNode(container2);
                if (null === nodeTag) return;
                grandTag = nodeTag.tag;
                if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                  targetInst$jscomp$0 = ancestorInst = nodeTag;
                  continue a;
                }
                container2 = container2.parentNode;
              }
            }
            targetInst$jscomp$0 = targetInst$jscomp$0.return;
          }
        batchedUpdates$1(function() {
          var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
          a: {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (void 0 !== reactName) {
              var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
              switch (domEventName) {
                case "keypress":
                  if (0 === getEventCharCode(nativeEvent)) break a;
                case "keydown":
                case "keyup":
                  SyntheticEventCtor = SyntheticKeyboardEvent;
                  break;
                case "focusin":
                  reactEventType = "focus";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "focusout":
                  reactEventType = "blur";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "beforeblur":
                case "afterblur":
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "click":
                  if (2 === nativeEvent.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  SyntheticEventCtor = SyntheticMouseEvent;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  SyntheticEventCtor = SyntheticDragEvent;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  SyntheticEventCtor = SyntheticTouchEvent;
                  break;
                case ANIMATION_END:
                case ANIMATION_ITERATION:
                case ANIMATION_START:
                  SyntheticEventCtor = SyntheticAnimationEvent;
                  break;
                case TRANSITION_END:
                  SyntheticEventCtor = SyntheticTransitionEvent;
                  break;
                case "scroll":
                case "scrollend":
                  SyntheticEventCtor = SyntheticUIEvent;
                  break;
                case "wheel":
                  SyntheticEventCtor = SyntheticWheelEvent;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  SyntheticEventCtor = SyntheticClipboardEvent;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  SyntheticEventCtor = SyntheticPointerEvent;
                  break;
                case "toggle":
                case "beforetoggle":
                  SyntheticEventCtor = SyntheticToggleEvent;
              }
              var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
              inCapturePhase = [];
              for (var instance2 = targetInst, lastHostComponent; null !== instance2; ) {
                var _instance = instance2;
                lastHostComponent = _instance.stateNode;
                _instance = _instance.tag;
                5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance2, reactEventName), null != _instance && inCapturePhase.push(
                  createDispatchListener(instance2, _instance, lastHostComponent)
                ));
                if (accumulateTargetOnly) break;
                instance2 = instance2.return;
              }
              0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                reactName,
                reactEventType,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
            }
          }
          if (0 === (eventSystemFlags & 7)) {
            a: {
              reactName = "mouseover" === domEventName || "pointerover" === domEventName;
              SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
              if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                break a;
              if (SyntheticEventCtor || reactName) {
                reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                if (SyntheticEventCtor) {
                  if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                    reactEventType = null;
                } else SyntheticEventCtor = null, reactEventType = targetInst;
                if (SyntheticEventCtor !== reactEventType) {
                  inCapturePhase = SyntheticMouseEvent;
                  _instance = "onMouseLeave";
                  reactEventName = "onMouseEnter";
                  instance2 = "mouse";
                  if ("pointerout" === domEventName || "pointerover" === domEventName)
                    inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance2 = "pointer";
                  accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                  lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                  reactName = new inCapturePhase(
                    _instance,
                    instance2 + "leave",
                    SyntheticEventCtor,
                    nativeEvent,
                    nativeEventTarget
                  );
                  reactName.target = accumulateTargetOnly;
                  reactName.relatedTarget = lastHostComponent;
                  _instance = null;
                  getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                    reactEventName,
                    instance2 + "enter",
                    reactEventType,
                    nativeEvent,
                    nativeEventTarget
                  ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                  accumulateTargetOnly = _instance;
                  if (SyntheticEventCtor && reactEventType)
                    b: {
                      inCapturePhase = getParent;
                      reactEventName = SyntheticEventCtor;
                      instance2 = reactEventType;
                      lastHostComponent = 0;
                      for (_instance = reactEventName; _instance; _instance = inCapturePhase(_instance))
                        lastHostComponent++;
                      _instance = 0;
                      for (var tempB = instance2; tempB; tempB = inCapturePhase(tempB))
                        _instance++;
                      for (; 0 < lastHostComponent - _instance; )
                        reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                      for (; 0 < _instance - lastHostComponent; )
                        instance2 = inCapturePhase(instance2), _instance--;
                      for (; lastHostComponent--; ) {
                        if (reactEventName === instance2 || null !== instance2 && reactEventName === instance2.alternate) {
                          inCapturePhase = reactEventName;
                          break b;
                        }
                        reactEventName = inCapturePhase(reactEventName);
                        instance2 = inCapturePhase(instance2);
                      }
                      inCapturePhase = null;
                    }
                  else inCapturePhase = null;
                  null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    reactName,
                    SyntheticEventCtor,
                    inCapturePhase,
                    false
                  );
                  null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    accumulateTargetOnly,
                    reactEventType,
                    inCapturePhase,
                    true
                  );
                }
              }
            }
            a: {
              reactName = targetInst ? getNodeFromInstance(targetInst) : window;
              SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
              if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                var getTargetInstFunc = getTargetInstForChangeEvent;
              else if (isTextInputElement(reactName))
                if (isInputEventSupported)
                  getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                else {
                  getTargetInstFunc = getTargetInstForInputEventPolyfill;
                  var handleEventFunc = handleEventsForInputEventPolyfill;
                }
              else
                SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
              if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                createAndAccumulateChangeEvent(
                  dispatchQueue,
                  getTargetInstFunc,
                  nativeEvent,
                  nativeEventTarget
                );
                break a;
              }
              handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
              "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
            }
            handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                  activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                break;
              case "focusout":
                lastSelection = activeElementInst = activeElement = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) break;
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
            var fallbackData;
            if (canUseCompositionEvent)
              b: {
                switch (domEventName) {
                  case "compositionstart":
                    var eventType = "onCompositionStart";
                    break b;
                  case "compositionend":
                    eventType = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    eventType = "onCompositionUpdate";
                    break b;
                }
                eventType = void 0;
              }
            else
              isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
            eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
              eventType,
              domEventName,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
            if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
              eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
                "onBeforeInput",
                "beforeinput",
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: handleEventFunc,
                listeners: eventType
              }), handleEventFunc.data = fallbackData);
            extractEvents$1(
              dispatchQueue,
              domEventName,
              targetInst,
              nativeEvent,
              nativeEventTarget
            );
          }
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        });
      }
      function createDispatchListener(instance2, listener, currentTarget) {
        return {
          instance: instance2,
          listener,
          currentTarget
        };
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
          var _instance2 = targetFiber, stateNode = _instance2.stateNode;
          _instance2 = _instance2.tag;
          5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ));
          if (3 === targetFiber.tag) return listeners;
          targetFiber = targetFiber.return;
        }
        return [];
      }
      function getParent(inst) {
        if (null === inst) return null;
        do
          inst = inst.return;
        while (inst && 5 !== inst.tag && 27 !== inst.tag);
        return inst ? inst : null;
      }
      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common2, inCapturePhase) {
        for (var registrationName = event._reactName, listeners = []; null !== target && target !== common2; ) {
          var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
          _instance3 = _instance3.tag;
          if (null !== alternate && alternate === common2) break;
          5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
            createDispatchListener(target, stateNode, alternate)
          )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
            createDispatchListener(target, stateNode, alternate)
          )));
          target = target.return;
        }
        0 !== listeners.length && dispatchQueue.push({ event, listeners });
      }
      var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
      function normalizeMarkupForTextOrAttribute(markup) {
        return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
      }
      function checkForUnmatchedText(serverText, clientText) {
        clientText = normalizeMarkupForTextOrAttribute(clientText);
        return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
      }
      function setProp(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "children":
            "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
            break;
          case "className":
            setValueForKnownAttribute(domElement, "class", value);
            break;
          case "tabIndex":
            setValueForKnownAttribute(domElement, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            setValueForKnownAttribute(domElement, key, value);
            break;
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "data":
            if ("object" !== tag) {
              setValueForKnownAttribute(domElement, "data", value);
              break;
            }
          case "src":
          case "href":
            if ("" === value && ("a" !== tag || "href" !== key)) {
              domElement.removeAttribute(key);
              break;
            }
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "action":
          case "formAction":
            if ("function" === typeof value) {
              domElement.setAttribute(
                key,
                "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
              );
              break;
            } else
              "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                domElement,
                tag,
                "formEncType",
                props.formEncType,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formMethod",
                props.formMethod,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formTarget",
                props.formTarget,
                props,
                null
              )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
            if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$12);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "multiple":
            domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "muted":
            domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            break;
          case "autoFocus":
            break;
          case "xlinkHref":
            if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
              domElement.removeAttribute("xlink:href");
              break;
            }
            key = sanitizeURL("" + value);
            domElement.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "xlink:href",
              key
            );
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
            break;
          case "inert":
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
            break;
          case "capture":
          case "download":
            true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "rowSpan":
          case "start":
            null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
            break;
          case "popover":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            setValueForAttribute(domElement, "popover", value);
            break;
          case "xlinkActuate":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:actuate",
              value
            );
            break;
          case "xlinkArcrole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:arcrole",
              value
            );
            break;
          case "xlinkRole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:role",
              value
            );
            break;
          case "xlinkShow":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:show",
              value
            );
            break;
          case "xlinkTitle":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:title",
              value
            );
            break;
          case "xlinkType":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:type",
              value
            );
            break;
          case "xmlBase":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:base",
              value
            );
            break;
          case "xmlLang":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:lang",
              value
            );
            break;
          case "xmlSpace":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:space",
              value
            );
            break;
          case "is":
            setValueForAttribute(domElement, "is", value);
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
              key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
        }
      }
      function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "children":
            "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$12);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "innerHTML":
          case "ref":
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!registrationNameDependencies.hasOwnProperty(key))
              a: {
                if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                  "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                  domElement.addEventListener(tag, value, props);
                  break a;
                }
                key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
              }
        }
      }
      function setInitialProperties(domElement, tag, props) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "img":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            var hasSrc = false, hasSrcSet = false, propKey;
            for (propKey in props)
              if (props.hasOwnProperty(propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "src":
                      hasSrc = true;
                      break;
                    case "srcSet":
                      hasSrcSet = true;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(formatProdErrorMessage(137, tag));
                    default:
                      setProp(domElement, tag, propKey, propValue, props, null);
                  }
              }
            hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
            hasSrc && setProp(domElement, tag, "src", props.src, props, null);
            return;
          case "input":
            listenToNonDelegatedEvent("invalid", domElement);
            var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
            for (hasSrc in props)
              if (props.hasOwnProperty(hasSrc)) {
                var propValue$184 = props[hasSrc];
                if (null != propValue$184)
                  switch (hasSrc) {
                    case "name":
                      hasSrcSet = propValue$184;
                      break;
                    case "type":
                      propValue = propValue$184;
                      break;
                    case "checked":
                      checked = propValue$184;
                      break;
                    case "defaultChecked":
                      defaultChecked = propValue$184;
                      break;
                    case "value":
                      propKey = propValue$184;
                      break;
                    case "defaultValue":
                      defaultValue = propValue$184;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propValue$184)
                        throw Error(formatProdErrorMessage(137, tag));
                      break;
                    default:
                      setProp(domElement, tag, hasSrc, propValue$184, props, null);
                  }
              }
            initInput(
              domElement,
              propKey,
              defaultValue,
              checked,
              defaultChecked,
              propValue,
              hasSrcSet,
              false
            );
            return;
          case "select":
            listenToNonDelegatedEvent("invalid", domElement);
            hasSrc = propValue = propKey = null;
            for (hasSrcSet in props)
              if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                switch (hasSrcSet) {
                  case "value":
                    propKey = defaultValue;
                    break;
                  case "defaultValue":
                    propValue = defaultValue;
                    break;
                  case "multiple":
                    hasSrc = defaultValue;
                  default:
                    setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
                }
            tag = propKey;
            props = propValue;
            domElement.multiple = !!hasSrc;
            null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
            return;
          case "textarea":
            listenToNonDelegatedEvent("invalid", domElement);
            propKey = hasSrcSet = hasSrc = null;
            for (propValue in props)
              if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                switch (propValue) {
                  case "value":
                    hasSrc = defaultValue;
                    break;
                  case "defaultValue":
                    hasSrcSet = defaultValue;
                    break;
                  case "children":
                    propKey = defaultValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    setProp(domElement, tag, propValue, defaultValue, props, null);
                }
            initTextarea(domElement, hasSrc, hasSrcSet, propKey);
            return;
          case "option":
            for (checked in props)
              if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                switch (checked) {
                  case "selected":
                    domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                    break;
                  default:
                    setProp(domElement, tag, checked, hasSrc, props, null);
                }
            return;
          case "dialog":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            break;
          case "iframe":
          case "object":
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "video":
          case "audio":
            for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
              listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
            break;
          case "image":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            break;
          case "embed":
          case "source":
          case "link":
            listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
          case "area":
          case "base":
          case "br":
          case "col":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "track":
          case "wbr":
          case "menuitem":
            for (defaultChecked in props)
              if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                switch (defaultChecked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (propValue$184 in props)
                props.hasOwnProperty(propValue$184) && (hasSrc = props[propValue$184], void 0 !== hasSrc && setPropOnCustomElement(
                  domElement,
                  tag,
                  propValue$184,
                  hasSrc,
                  props,
                  void 0
                ));
              return;
            }
        }
        for (defaultValue in props)
          props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
      }
      function updateProperties(domElement, tag, lastProps, nextProps) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "input":
            var name2 = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
            for (propKey in lastProps) {
              var lastProp = lastProps[propKey];
              if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                switch (propKey) {
                  case "checked":
                    break;
                  case "value":
                    break;
                  case "defaultValue":
                    lastDefaultValue = lastProp;
                  default:
                    nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
                }
            }
            for (var propKey$201 in nextProps) {
              var propKey = nextProps[propKey$201];
              lastProp = lastProps[propKey$201];
              if (nextProps.hasOwnProperty(propKey$201) && (null != propKey || null != lastProp))
                switch (propKey$201) {
                  case "type":
                    type = propKey;
                    break;
                  case "name":
                    name2 = propKey;
                    break;
                  case "checked":
                    checked = propKey;
                    break;
                  case "defaultChecked":
                    defaultChecked = propKey;
                    break;
                  case "value":
                    value = propKey;
                    break;
                  case "defaultValue":
                    defaultValue = propKey;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    propKey !== lastProp && setProp(
                      domElement,
                      tag,
                      propKey$201,
                      propKey,
                      nextProps,
                      lastProp
                    );
                }
            }
            updateInput(
              domElement,
              value,
              defaultValue,
              lastDefaultValue,
              checked,
              defaultChecked,
              type,
              name2
            );
            return;
          case "select":
            propKey = value = defaultValue = propKey$201 = null;
            for (type in lastProps)
              if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                switch (type) {
                  case "value":
                    break;
                  case "multiple":
                    propKey = lastDefaultValue;
                  default:
                    nextProps.hasOwnProperty(type) || setProp(
                      domElement,
                      tag,
                      type,
                      null,
                      nextProps,
                      lastDefaultValue
                    );
                }
            for (name2 in nextProps)
              if (type = nextProps[name2], lastDefaultValue = lastProps[name2], nextProps.hasOwnProperty(name2) && (null != type || null != lastDefaultValue))
                switch (name2) {
                  case "value":
                    propKey$201 = type;
                    break;
                  case "defaultValue":
                    defaultValue = type;
                    break;
                  case "multiple":
                    value = type;
                  default:
                    type !== lastDefaultValue && setProp(
                      domElement,
                      tag,
                      name2,
                      type,
                      nextProps,
                      lastDefaultValue
                    );
                }
            tag = defaultValue;
            lastProps = value;
            nextProps = propKey;
            null != propKey$201 ? updateOptions(domElement, !!lastProps, propKey$201, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
            return;
          case "textarea":
            propKey = propKey$201 = null;
            for (defaultValue in lastProps)
              if (name2 = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name2 && !nextProps.hasOwnProperty(defaultValue))
                switch (defaultValue) {
                  case "value":
                    break;
                  case "children":
                    break;
                  default:
                    setProp(domElement, tag, defaultValue, null, nextProps, name2);
                }
            for (value in nextProps)
              if (name2 = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name2 || null != type))
                switch (value) {
                  case "value":
                    propKey$201 = name2;
                    break;
                  case "defaultValue":
                    propKey = name2;
                    break;
                  case "children":
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != name2) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    name2 !== type && setProp(domElement, tag, value, name2, nextProps, type);
                }
            updateTextarea(domElement, propKey$201, propKey);
            return;
          case "option":
            for (var propKey$217 in lastProps)
              if (propKey$201 = lastProps[propKey$217], lastProps.hasOwnProperty(propKey$217) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$217))
                switch (propKey$217) {
                  case "selected":
                    domElement.selected = false;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      propKey$217,
                      null,
                      nextProps,
                      propKey$201
                    );
                }
            for (lastDefaultValue in nextProps)
              if (propKey$201 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
                switch (lastDefaultValue) {
                  case "selected":
                    domElement.selected = propKey$201 && "function" !== typeof propKey$201 && "symbol" !== typeof propKey$201;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      lastDefaultValue,
                      propKey$201,
                      nextProps,
                      propKey
                    );
                }
            return;
          case "img":
          case "link":
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
          case "menuitem":
            for (var propKey$222 in lastProps)
              propKey$201 = lastProps[propKey$222], lastProps.hasOwnProperty(propKey$222) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$222) && setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
            for (checked in nextProps)
              if (propKey$201 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
                switch (checked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey$201)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      checked,
                      propKey$201,
                      nextProps,
                      propKey
                    );
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (var propKey$227 in lastProps)
                propKey$201 = lastProps[propKey$227], lastProps.hasOwnProperty(propKey$227) && void 0 !== propKey$201 && !nextProps.hasOwnProperty(propKey$227) && setPropOnCustomElement(
                  domElement,
                  tag,
                  propKey$227,
                  void 0,
                  nextProps,
                  propKey$201
                );
              for (defaultChecked in nextProps)
                propKey$201 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$201 === propKey || void 0 === propKey$201 && void 0 === propKey || setPropOnCustomElement(
                  domElement,
                  tag,
                  defaultChecked,
                  propKey$201,
                  nextProps,
                  propKey
                );
              return;
            }
        }
        for (var propKey$232 in lastProps)
          propKey$201 = lastProps[propKey$232], lastProps.hasOwnProperty(propKey$232) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$232) && setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
        for (lastProp in nextProps)
          propKey$201 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$201 === propKey || null == propKey$201 && null == propKey || setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
      }
      function isLikelyStaticResource(initiatorType) {
        switch (initiatorType) {
          case "css":
          case "script":
          case "font":
          case "img":
          case "image":
          case "input":
          case "link":
            return true;
          default:
            return false;
        }
      }
      function estimateBandwidth() {
        if ("function" === typeof performance.getEntriesByType) {
          for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i2 = 0; i2 < resourceEntries.length; i2++) {
            var entry = resourceEntries[i2], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
            if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
              initiatorType = 0;
              duration = entry.responseEnd;
              for (i2 += 1; i2 < resourceEntries.length; i2++) {
                var overlapEntry = resourceEntries[i2], overlapStartTime = overlapEntry.startTime;
                if (overlapStartTime > duration) break;
                var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
                overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
              }
              --i2;
              bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
              count++;
              if (10 < count) break;
            }
          }
          if (0 < count) return bits / count / 1e6;
        }
        return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
      }
      var eventsEnabled = null, selectionInformation = null;
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
      }
      function getOwnHostContext(namespaceURI) {
        switch (namespaceURI) {
          case "http://www.w3.org/2000/svg":
            return 1;
          case "http://www.w3.org/1998/Math/MathML":
            return 2;
          default:
            return 0;
        }
      }
      function getChildHostContextProd(parentNamespace, type) {
        if (0 === parentNamespace)
          switch (type) {
            case "svg":
              return 1;
            case "math":
              return 2;
            default:
              return 0;
          }
        return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
      }
      function shouldSetTextContent(type, props) {
        return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
      }
      var currentPopstateTransitionEvent = null;
      function shouldAttemptEagerTransition() {
        var event = window.event;
        if (event && "popstate" === event.type) {
          if (event === currentPopstateTransitionEvent) return false;
          currentPopstateTransitionEvent = event;
          return true;
        }
        currentPopstateTransitionEvent = null;
        return false;
      }
      var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback2) {
        return localPromise.resolve(null).then(callback2).catch(handleErrorInNextTick);
      } : scheduleTimeout;
      function handleErrorInNextTick(error2) {
        setTimeout(function() {
          throw error2;
        });
      }
      function isSingletonScope(type) {
        return "head" === type;
      }
      function clearHydrationBoundary(parentInstance, hydrationInstance) {
        var node = hydrationInstance, depth = 0;
        do {
          var nextNode = node.nextSibling;
          parentInstance.removeChild(node);
          if (nextNode && 8 === nextNode.nodeType)
            if (node = nextNode.data, "/$" === node || "/&" === node) {
              if (0 === depth) {
                parentInstance.removeChild(nextNode);
                retryIfBlockedOn(hydrationInstance);
                return;
              }
              depth--;
            } else if ("$" === node || "$?" === node || "$~" === node || "$!" === node || "&" === node)
              depth++;
            else if ("html" === node)
              releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
            else if ("head" === node) {
              node = parentInstance.ownerDocument.head;
              releaseSingletonInstance(node);
              for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
                var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
                node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
                node$jscomp$0 = nextNode$jscomp$0;
              }
            } else
              "body" === node && releaseSingletonInstance(parentInstance.ownerDocument.body);
          node = nextNode;
        } while (node);
        retryIfBlockedOn(hydrationInstance);
      }
      function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
        var node = suspenseInstance;
        suspenseInstance = 0;
        do {
          var nextNode = node.nextSibling;
          1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
          if (nextNode && 8 === nextNode.nodeType)
            if (node = nextNode.data, "/$" === node)
              if (0 === suspenseInstance) break;
              else suspenseInstance--;
            else
              "$" !== node && "$?" !== node && "$~" !== node && "$!" !== node || suspenseInstance++;
          node = nextNode;
        } while (node);
      }
      function clearContainerSparingly(container2) {
        var nextNode = container2.firstChild;
        nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
        for (; nextNode; ) {
          var node = nextNode;
          nextNode = nextNode.nextSibling;
          switch (node.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
              clearContainerSparingly(node);
              detachDeletedInstance(node);
              continue;
            case "SCRIPT":
            case "STYLE":
              continue;
            case "LINK":
              if ("stylesheet" === node.rel.toLowerCase()) continue;
          }
          container2.removeChild(node);
        }
      }
      function canHydrateInstance(instance2, type, props, inRootOrSingleton) {
        for (; 1 === instance2.nodeType; ) {
          var anyProps = props;
          if (instance2.nodeName.toLowerCase() !== type.toLowerCase()) {
            if (!inRootOrSingleton && ("INPUT" !== instance2.nodeName || "hidden" !== instance2.type))
              break;
          } else if (!inRootOrSingleton)
            if ("input" === type && "hidden" === instance2.type) {
              var name2 = null == anyProps.name ? null : "" + anyProps.name;
              if ("hidden" === anyProps.type && instance2.getAttribute("name") === name2)
                return instance2;
            } else return instance2;
          else if (!instance2[internalHoistableMarker])
            switch (type) {
              case "meta":
                if (!instance2.hasAttribute("itemprop")) break;
                return instance2;
              case "link":
                name2 = instance2.getAttribute("rel");
                if ("stylesheet" === name2 && instance2.hasAttribute("data-precedence"))
                  break;
                else if (name2 !== anyProps.rel || instance2.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance2.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance2.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                  break;
                return instance2;
              case "style":
                if (instance2.hasAttribute("data-precedence")) break;
                return instance2;
              case "script":
                name2 = instance2.getAttribute("src");
                if ((name2 !== (null == anyProps.src ? null : anyProps.src) || instance2.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance2.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name2 && instance2.hasAttribute("async") && !instance2.hasAttribute("itemprop"))
                  break;
                return instance2;
              default:
                return instance2;
            }
          instance2 = getNextHydratable(instance2.nextSibling);
          if (null === instance2) break;
        }
        return null;
      }
      function canHydrateTextInstance(instance2, text, inRootOrSingleton) {
        if ("" === text) return null;
        for (; 3 !== instance2.nodeType; ) {
          if ((1 !== instance2.nodeType || "INPUT" !== instance2.nodeName || "hidden" !== instance2.type) && !inRootOrSingleton)
            return null;
          instance2 = getNextHydratable(instance2.nextSibling);
          if (null === instance2) return null;
        }
        return instance2;
      }
      function canHydrateHydrationBoundary(instance2, inRootOrSingleton) {
        for (; 8 !== instance2.nodeType; ) {
          if ((1 !== instance2.nodeType || "INPUT" !== instance2.nodeName || "hidden" !== instance2.type) && !inRootOrSingleton)
            return null;
          instance2 = getNextHydratable(instance2.nextSibling);
          if (null === instance2) return null;
        }
        return instance2;
      }
      function isSuspenseInstancePending(instance2) {
        return "$?" === instance2.data || "$~" === instance2.data;
      }
      function isSuspenseInstanceFallback(instance2) {
        return "$!" === instance2.data || "$?" === instance2.data && "loading" !== instance2.ownerDocument.readyState;
      }
      function registerSuspenseInstanceRetry(instance2, callback2) {
        var ownerDocument = instance2.ownerDocument;
        if ("$~" === instance2.data) instance2._reactRetry = callback2;
        else if ("$?" !== instance2.data || "loading" !== ownerDocument.readyState)
          callback2();
        else {
          var listener = function() {
            callback2();
            ownerDocument.removeEventListener("DOMContentLoaded", listener);
          };
          ownerDocument.addEventListener("DOMContentLoaded", listener);
          instance2._reactRetry = listener;
        }
      }
      function getNextHydratable(node) {
        for (; null != node; node = node.nextSibling) {
          var nodeType = node.nodeType;
          if (1 === nodeType || 3 === nodeType) break;
          if (8 === nodeType) {
            nodeType = node.data;
            if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "$~" === nodeType || "&" === nodeType || "F!" === nodeType || "F" === nodeType)
              break;
            if ("/$" === nodeType || "/&" === nodeType) return null;
          }
        }
        return node;
      }
      var previousHydratableOnEnteringScopedSingleton = null;
      function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
        hydrationInstance = hydrationInstance.nextSibling;
        for (var depth = 0; hydrationInstance; ) {
          if (8 === hydrationInstance.nodeType) {
            var data = hydrationInstance.data;
            if ("/$" === data || "/&" === data) {
              if (0 === depth)
                return getNextHydratable(hydrationInstance.nextSibling);
              depth--;
            } else
              "$" !== data && "$!" !== data && "$?" !== data && "$~" !== data && "&" !== data || depth++;
          }
          hydrationInstance = hydrationInstance.nextSibling;
        }
        return null;
      }
      function getParentHydrationBoundary(targetInstance) {
        targetInstance = targetInstance.previousSibling;
        for (var depth = 0; targetInstance; ) {
          if (8 === targetInstance.nodeType) {
            var data = targetInstance.data;
            if ("$" === data || "$!" === data || "$?" === data || "$~" === data || "&" === data) {
              if (0 === depth) return targetInstance;
              depth--;
            } else "/$" !== data && "/&" !== data || depth++;
          }
          targetInstance = targetInstance.previousSibling;
        }
        return null;
      }
      function resolveSingletonInstance(type, props, rootContainerInstance) {
        props = getOwnerDocumentFromRootContainer(rootContainerInstance);
        switch (type) {
          case "html":
            type = props.documentElement;
            if (!type) throw Error(formatProdErrorMessage(452));
            return type;
          case "head":
            type = props.head;
            if (!type) throw Error(formatProdErrorMessage(453));
            return type;
          case "body":
            type = props.body;
            if (!type) throw Error(formatProdErrorMessage(454));
            return type;
          default:
            throw Error(formatProdErrorMessage(451));
        }
      }
      function releaseSingletonInstance(instance2) {
        for (var attributes = instance2.attributes; attributes.length; )
          instance2.removeAttributeNode(attributes[0]);
        detachDeletedInstance(instance2);
      }
      var preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set();
      function getHoistableRoot(container2) {
        return "function" === typeof container2.getRootNode ? container2.getRootNode() : 9 === container2.nodeType ? container2 : container2.ownerDocument;
      }
      var previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: flushSyncWork,
        r: requestFormReset,
        D: prefetchDNS,
        C: preconnect,
        L: preload,
        m: preloadModule,
        X: preinitScript,
        S: preinitStyle,
        M: preinitModuleScript
      };
      function flushSyncWork() {
        var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      }
      function requestFormReset(form) {
        var formInst = getInstanceFromNode(form);
        null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
      }
      var globalDocument = "undefined" === typeof document ? null : document;
      function preconnectAs(rel, href, crossOrigin) {
        var ownerDocument = globalDocument;
        if (ownerDocument && "string" === typeof href && href) {
          var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
          limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
          "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
          preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
        }
      }
      function prefetchDNS(href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      }
      function preconnect(href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      }
      function preload(href, as, options2) {
        previousDispatcher.L(href, as, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
          "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSrcSet
          ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSizes
          ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
          var key = preloadSelector;
          switch (as) {
            case "style":
              key = getStyleKey(href);
              break;
            case "script":
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) || (href = assign(
            {
              rel: "preload",
              href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
              as
            },
            options2
          ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
        }
      }
      function preloadModule(href, options2) {
        previousDispatcher.m(href, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              key = getScriptKey(href);
          }
          if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                  return;
            }
            as = ownerDocument.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument.head.appendChild(as);
          }
        }
      }
      function preinitStyle(href, precedence, options2) {
        previousDispatcher.S(href, precedence, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var styles2 = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
          precedence = precedence || "default";
          var resource = styles2.get(key);
          if (!resource) {
            var state = { loading: 0, preload: null };
            if (resource = ownerDocument.querySelector(
              getStylesheetSelectorFromKey(key)
            ))
              state.loading = 5;
            else {
              href = assign(
                { rel: "stylesheet", href, "data-precedence": precedence },
                options2
              );
              (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
              var link = resource = ownerDocument.createElement("link");
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function(resolve2, reject) {
                link.onload = resolve2;
                link.onerror = reject;
              });
              link.addEventListener("load", function() {
                state.loading |= 1;
              });
              link.addEventListener("error", function() {
                state.loading |= 2;
              });
              state.loading |= 4;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state
            };
            styles2.set(key, resource);
          }
        }
      }
      function preinitScript(src, options2) {
        previousDispatcher.X(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function preinitModuleScript(src, options2) {
        previousDispatcher.M(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function getResource(type, currentProps, pendingProps, currentResource) {
        var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
        if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
        switch (type) {
          case "meta":
          case "title":
            return null;
          case "style":
            return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          case "link":
            if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
              type = getStyleKey(pendingProps.href);
              var styles$243 = getResourcesFromRoot(
                JSCompiler_inline_result
              ).hoistableStyles, resource$244 = styles$243.get(type);
              resource$244 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$244 = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: 0, preload: null }
              }, styles$243.set(type, resource$244), (styles$243 = JSCompiler_inline_result.querySelector(
                getStylesheetSelectorFromKey(type)
              )) && !styles$243._p && (resource$244.instance = styles$243, resource$244.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
                rel: "preload",
                as: "style",
                href: pendingProps.href,
                crossOrigin: pendingProps.crossOrigin,
                integrity: pendingProps.integrity,
                media: pendingProps.media,
                hrefLang: pendingProps.hrefLang,
                referrerPolicy: pendingProps.referrerPolicy
              }, preloadPropsMap.set(type, pendingProps), styles$243 || preloadStylesheet(
                JSCompiler_inline_result,
                type,
                pendingProps,
                resource$244.state
              )));
              if (currentProps && null === currentResource)
                throw Error(formatProdErrorMessage(528, ""));
              return resource$244;
            }
            if (currentProps && null !== currentResource)
              throw Error(formatProdErrorMessage(529, ""));
            return null;
          case "script":
            return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "script",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          default:
            throw Error(formatProdErrorMessage(444, type));
        }
      }
      function getStyleKey(href) {
        return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
      }
      function getStylesheetSelectorFromKey(key) {
        return 'link[rel="stylesheet"][' + key + "]";
      }
      function stylesheetPropsFromRawProps(rawProps) {
        return assign({}, rawProps, {
          "data-precedence": rawProps.precedence,
          precedence: null
        });
      }
      function preloadStylesheet(ownerDocument, key, preloadProps, state) {
        ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
          return state.loading |= 1;
        }), key.addEventListener("error", function() {
          return state.loading |= 2;
        }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
      }
      function getScriptKey(src) {
        return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
      }
      function getScriptSelectorFromKey(key) {
        return "script[async]" + key;
      }
      function acquireResource(hoistableRoot, resource, props) {
        resource.count++;
        if (null === resource.instance)
          switch (resource.type) {
            case "style":
              var instance2 = hoistableRoot.querySelector(
                'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
              );
              if (instance2)
                return resource.instance = instance2, markNodeAsHoistable(instance2), instance2;
              var styleProps = assign({}, props, {
                "data-href": props.href,
                "data-precedence": props.precedence,
                href: null,
                precedence: null
              });
              instance2 = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
                "style"
              );
              markNodeAsHoistable(instance2);
              setInitialProperties(instance2, "style", styleProps);
              insertStylesheet(instance2, props.precedence, hoistableRoot);
              return resource.instance = instance2;
            case "stylesheet":
              styleProps = getStyleKey(props.href);
              var instance$249 = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(styleProps)
              );
              if (instance$249)
                return resource.state.loading |= 4, resource.instance = instance$249, markNodeAsHoistable(instance$249), instance$249;
              instance2 = stylesheetPropsFromRawProps(props);
              (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance2, styleProps);
              instance$249 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
              markNodeAsHoistable(instance$249);
              var linkInstance = instance$249;
              linkInstance._p = new Promise(function(resolve2, reject) {
                linkInstance.onload = resolve2;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance$249, "link", instance2);
              resource.state.loading |= 4;
              insertStylesheet(instance$249, props.precedence, hoistableRoot);
              return resource.instance = instance$249;
            case "script":
              instance$249 = getScriptKey(props.src);
              if (styleProps = hoistableRoot.querySelector(
                getScriptSelectorFromKey(instance$249)
              ))
                return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
              instance2 = props;
              if (styleProps = preloadPropsMap.get(instance$249))
                instance2 = assign({}, props), adoptPreloadPropsForScript(instance2, styleProps);
              hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
              styleProps = hoistableRoot.createElement("script");
              markNodeAsHoistable(styleProps);
              setInitialProperties(styleProps, "link", instance2);
              hoistableRoot.head.appendChild(styleProps);
              return resource.instance = styleProps;
            case "void":
              return null;
            default:
              throw Error(formatProdErrorMessage(443, resource.type));
          }
        else
          "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance2 = resource.instance, resource.state.loading |= 4, insertStylesheet(instance2, props.precedence, hoistableRoot));
        return resource.instance;
      }
      function insertStylesheet(instance2, precedence, root2) {
        for (var nodes = root2.querySelectorAll(
          'link[rel="stylesheet"][data-precedence],style[data-precedence]'
        ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i2 = 0; i2 < nodes.length; i2++) {
          var node = nodes[i2];
          if (node.dataset.precedence === precedence) prior = node;
          else if (prior !== last) break;
        }
        prior ? prior.parentNode.insertBefore(instance2, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance2, precedence.firstChild));
      }
      function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
        null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
        null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
        null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
      }
      function adoptPreloadPropsForScript(scriptProps, preloadProps) {
        null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
        null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
        null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
      }
      var tagCaches = null;
      function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
        if (null === tagCaches) {
          var cache = /* @__PURE__ */ new Map();
          var caches = tagCaches = /* @__PURE__ */ new Map();
          caches.set(ownerDocument, cache);
        } else
          caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
        if (cache.has(type)) return cache;
        cache.set(type, null);
        ownerDocument = ownerDocument.getElementsByTagName(type);
        for (caches = 0; caches < ownerDocument.length; caches++) {
          var node = ownerDocument[caches];
          if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
            var nodeKey = node.getAttribute(keyAttribute) || "";
            nodeKey = type + nodeKey;
            var existing = cache.get(nodeKey);
            existing ? existing.push(node) : cache.set(nodeKey, [node]);
          }
        }
        return cache;
      }
      function mountHoistable(hoistableRoot, type, instance2) {
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        hoistableRoot.head.insertBefore(
          instance2,
          "title" === type ? hoistableRoot.querySelector("head > title") : null
        );
      }
      function isHostHoistableType(type, props, hostContext) {
        if (1 === hostContext || null != props.itemProp) return false;
        switch (type) {
          case "meta":
          case "title":
            return true;
          case "style":
            if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
              break;
            return true;
          case "link":
            if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
              break;
            switch (props.rel) {
              case "stylesheet":
                return type = props.disabled, "string" === typeof props.precedence && null == type;
              default:
                return true;
            }
          case "script":
            if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
              return true;
        }
        return false;
      }
      function preloadResource(resource) {
        return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
      }
      function suspendResource(state, hoistableRoot, resource, props) {
        if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
          if (null === resource.instance) {
            var key = getStyleKey(props.href), instance2 = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(key)
            );
            if (instance2) {
              hoistableRoot = instance2._p;
              null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
              resource.state.loading |= 4;
              resource.instance = instance2;
              markNodeAsHoistable(instance2);
              return;
            }
            instance2 = hoistableRoot.ownerDocument || hoistableRoot;
            props = stylesheetPropsFromRawProps(props);
            (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
            instance2 = instance2.createElement("link");
            markNodeAsHoistable(instance2);
            var linkInstance = instance2;
            linkInstance._p = new Promise(function(resolve2, reject) {
              linkInstance.onload = resolve2;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance2, "link", props);
            resource.instance = instance2;
          }
          null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
          state.stylesheets.set(resource, hoistableRoot);
          (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
        }
      }
      var estimatedBytesWithinLimit = 0;
      function waitForCommitToBeReady(state, timeoutOffset) {
        state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
        return 0 < state.count || 0 < state.imgCount ? function(commit) {
          var stylesheetTimer = setTimeout(function() {
            state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
            if (state.unsuspend) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          }, 6e4 + timeoutOffset);
          0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
          var imgTimer = setTimeout(
            function() {
              state.waitingForImages = false;
              if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            },
            (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) + timeoutOffset
          );
          state.unsuspend = commit;
          return function() {
            state.unsuspend = null;
            clearTimeout(stylesheetTimer);
            clearTimeout(imgTimer);
          };
        } : null;
      }
      function onUnsuspend() {
        this.count--;
        if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
          if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
          else if (this.unsuspend) {
            var unsuspend = this.unsuspend;
            this.unsuspend = null;
            unsuspend();
          }
        }
      }
      var precedencesByRoot = null;
      function insertSuspendedStylesheets(state, resources) {
        state.stylesheets = null;
        null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
      }
      function insertStylesheetIntoRoot(root2, resource) {
        if (!(resource.state.loading & 4)) {
          var precedences = precedencesByRoot.get(root2);
          if (precedences) var last = precedences.get(null);
          else {
            precedences = /* @__PURE__ */ new Map();
            precedencesByRoot.set(root2, precedences);
            for (var nodes = root2.querySelectorAll(
              "link[data-precedence],style[data-precedence]"
            ), i2 = 0; i2 < nodes.length; i2++) {
              var node = nodes[i2];
              if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                precedences.set(node.dataset.precedence, node), last = node;
            }
            last && precedences.set(null, last);
          }
          nodes = resource.instance;
          node = nodes.getAttribute("data-precedence");
          i2 = precedences.get(node) || last;
          i2 === last && precedences.set(null, nodes);
          precedences.set(node, nodes);
          this.count++;
          last = onUnsuspend.bind(this);
          nodes.addEventListener("load", last);
          nodes.addEventListener("error", last);
          i2 ? i2.parentNode.insertBefore(nodes, i2.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
          resource.state.loading |= 4;
        }
      }
      var HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: sharedNotPendingObject,
        _currentValue2: sharedNotPendingObject,
        _threadCount: 0
      };
      function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
        this.tag = 1;
        this.containerInfo = containerInfo;
        this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
        this.callbackPriority = 0;
        this.expirationTimes = createLaneMap(-1);
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = createLaneMap(0);
        this.hiddenUpdates = createLaneMap(null);
        this.identifierPrefix = identifierPrefix;
        this.onUncaughtError = onUncaughtError;
        this.onCaughtError = onCaughtError;
        this.onRecoverableError = onRecoverableError;
        this.pooledCache = null;
        this.pooledCacheLanes = 0;
        this.formState = formState;
        this.incompleteTransitions = /* @__PURE__ */ new Map();
      }
      function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
        containerInfo = new FiberRootNode(
          containerInfo,
          tag,
          hydrate,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          onDefaultTransitionIndicator,
          formState
        );
        tag = 1;
        true === isStrictMode && (tag |= 24);
        isStrictMode = createFiberImplClass(3, null, null, tag);
        containerInfo.current = isStrictMode;
        isStrictMode.stateNode = containerInfo;
        tag = createCache();
        tag.refCount++;
        containerInfo.pooledCache = tag;
        tag.refCount++;
        isStrictMode.memoizedState = {
          element: initialChildren,
          isDehydrated: hydrate,
          cache: tag
        };
        initializeUpdateQueue(isStrictMode);
        return containerInfo;
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) return emptyContextObject;
        parentComponent = emptyContextObject;
        return parentComponent;
      }
      function updateContainerImpl(rootFiber, lane, element, container2, parentComponent, callback2) {
        parentComponent = getContextForSubtree(parentComponent);
        null === container2.context ? container2.context = parentComponent : container2.pendingContext = parentComponent;
        container2 = createUpdate(lane);
        container2.payload = { element };
        callback2 = void 0 === callback2 ? null : callback2;
        null !== callback2 && (container2.callback = callback2);
        element = enqueueUpdate(rootFiber, container2, lane);
        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
      }
      function markRetryLaneImpl(fiber, retryLane) {
        fiber = fiber.memoizedState;
        if (null !== fiber && null !== fiber.dehydrated) {
          var a = fiber.retryLane;
          fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
      }
      function attemptContinuousHydration(fiber) {
        if (13 === fiber.tag || 31 === fiber.tag) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
          markRetryLaneIfNotHydrated(fiber, 67108864);
        }
      }
      function attemptHydrationAtCurrentPriority(fiber) {
        if (13 === fiber.tag || 31 === fiber.tag) {
          var lane = requestUpdateLane();
          lane = getBumpedLaneForHydrationByLane(lane);
          var root2 = enqueueConcurrentRenderForLane(fiber, lane);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, lane);
          markRetryLaneIfNotHydrated(fiber, lane);
        }
      }
      var _enabled = true;
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchContinuousEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (_enabled) {
          var blockedOn = findInstanceBlockingEvent(nativeEvent);
          if (null === blockedOn)
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            ), clearIfContinuousEvent(domEventName, nativeEvent);
          else if (queueIfContinuousEvent(
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ))
            nativeEvent.stopPropagation();
          else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
            for (; null !== blockedOn; ) {
              var fiber = getInstanceFromNode(blockedOn);
              if (null !== fiber)
                switch (fiber.tag) {
                  case 3:
                    fiber = fiber.stateNode;
                    if (fiber.current.memoizedState.isDehydrated) {
                      var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                      if (0 !== lanes) {
                        var root2 = fiber;
                        root2.pendingLanes |= 2;
                        for (root2.entangledLanes |= 2; lanes; ) {
                          var lane = 1 << 31 - clz32(lanes);
                          root2.entanglements[1] |= lane;
                          lanes &= ~lane;
                        }
                        ensureRootIsScheduled(fiber);
                        0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0));
                      }
                    }
                    break;
                  case 31:
                  case 13:
                    root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                }
              fiber = findInstanceBlockingEvent(nativeEvent);
              null === fiber && dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              );
              if (fiber === blockedOn) break;
              blockedOn = fiber;
            }
            null !== blockedOn && nativeEvent.stopPropagation();
          } else
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              null,
              targetContainer
            );
        }
      }
      function findInstanceBlockingEvent(nativeEvent) {
        nativeEvent = getEventTarget(nativeEvent);
        return findInstanceBlockingTarget(nativeEvent);
      }
      var return_targetInst = null;
      function findInstanceBlockingTarget(targetNode) {
        return_targetInst = null;
        targetNode = getClosestInstanceFromNode(targetNode);
        if (null !== targetNode) {
          var nearestMounted = getNearestMountedFiber(targetNode);
          if (null === nearestMounted) targetNode = null;
          else {
            var tag = nearestMounted.tag;
            if (13 === tag) {
              targetNode = getSuspenseInstanceFromFiber(nearestMounted);
              if (null !== targetNode) return targetNode;
              targetNode = null;
            } else if (31 === tag) {
              targetNode = getActivityInstanceFromFiber(nearestMounted);
              if (null !== targetNode) return targetNode;
              targetNode = null;
            } else if (3 === tag) {
              if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              targetNode = null;
            } else nearestMounted !== targetNode && (targetNode = null);
          }
        }
        return_targetInst = targetNode;
        return null;
      }
      function getEventPriority(domEventName) {
        switch (domEventName) {
          case "beforetoggle":
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "toggle":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 2;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 8;
          case "message":
            switch (getCurrentPriorityLevel()) {
              case ImmediatePriority:
                return 2;
              case UserBlockingPriority:
                return 8;
              case NormalPriority$1:
              case LowPriority:
                return 32;
              case IdlePriority:
                return 268435456;
              default:
                return 32;
            }
          default:
            return 32;
        }
      }
      var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
        " "
      );
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case "focusin":
          case "focusout":
            queuedFocus = null;
            break;
          case "dragenter":
          case "dragleave":
            queuedDrag = null;
            break;
          case "mouseover":
          case "mouseout":
            queuedMouse = null;
            break;
          case "pointerover":
          case "pointerout":
            queuedPointers.delete(nativeEvent.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            queuedPointerCaptures.delete(nativeEvent.pointerId);
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
          return existingQueuedEvent = {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        blockedOn = existingQueuedEvent.targetContainers;
        null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
        return existingQueuedEvent;
      }
      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch (domEventName) {
          case "focusin":
            return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedFocus,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "dragenter":
            return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedDrag,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "mouseover":
            return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedMouse,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "pointerover":
            var pointerId = nativeEvent.pointerId;
            queuedPointers.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointers.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            );
            return true;
          case "gotpointercapture":
            return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointerCaptures.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            ), true;
        }
        return false;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (null !== targetInst) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (null !== nearestMounted) {
            if (targetInst = nearestMounted.tag, 13 === targetInst) {
              if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  attemptHydrationAtCurrentPriority(nearestMounted);
                });
                return;
              }
            } else if (31 === targetInst) {
              if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  attemptHydrationAtCurrentPriority(nearestMounted);
                });
                return;
              }
            } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
              queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              return;
            }
          }
        }
        queuedTarget.blockedOn = null;
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (null !== queuedEvent.blockedOn) return false;
        for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
          if (null === nextBlockedOn) {
            nextBlockedOn = queuedEvent.nativeEvent;
            var nativeEventClone = new nextBlockedOn.constructor(
              nextBlockedOn.type,
              nextBlockedOn
            );
            currentReplayingEvent = nativeEventClone;
            nextBlockedOn.target.dispatchEvent(nativeEventClone);
            currentReplayingEvent = null;
          } else
            return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
          targetContainers.shift();
        }
        return true;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map2) {
        attemptReplayContinuousQueuedEvent(queuedEvent) && map2.delete(key);
      }
      function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false;
        null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
        null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
        null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler2.unstable_scheduleCallback(
          Scheduler2.unstable_NormalPriority,
          replayUnblockedEvents
        )));
      }
      var lastScheduledReplayQueue = null;
      function scheduleReplayQueueIfNeeded(formReplayingQueue) {
        lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler2.unstable_scheduleCallback(
          Scheduler2.unstable_NormalPriority,
          function() {
            lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
            for (var i2 = 0; i2 < formReplayingQueue.length; i2 += 3) {
              var form = formReplayingQueue[i2], submitterOrAction = formReplayingQueue[i2 + 1], formData = formReplayingQueue[i2 + 2];
              if ("function" !== typeof submitterOrAction)
                if (null === findInstanceBlockingTarget(submitterOrAction || form))
                  continue;
                else break;
              var formInst = getInstanceFromNode(form);
              null !== formInst && (formReplayingQueue.splice(i2, 3), i2 -= 3, startHostTransition(
                formInst,
                {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                },
                submitterOrAction,
                formData
              ));
            }
          }
        ));
      }
      function retryIfBlockedOn(unblocked) {
        function unblock(queuedEvent) {
          return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
        }
        null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for (var i2 = 0; i2 < queuedExplicitHydrationTargets.length; i2++) {
          var queuedTarget = queuedExplicitHydrationTargets[i2];
          queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
        }
        for (; 0 < queuedExplicitHydrationTargets.length && (i2 = queuedExplicitHydrationTargets[0], null === i2.blockedOn); )
          attemptExplicitHydrationTarget(i2), null === i2.blockedOn && queuedExplicitHydrationTargets.shift();
        i2 = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
        if (null != i2)
          for (queuedTarget = 0; queuedTarget < i2.length; queuedTarget += 3) {
            var form = i2[queuedTarget], submitterOrAction = i2[queuedTarget + 1], formProps = form[internalPropsKey] || null;
            if ("function" === typeof submitterOrAction)
              formProps || scheduleReplayQueueIfNeeded(i2);
            else if (formProps) {
              var action = null;
              if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                  action = formProps.formAction;
                else {
                  if (null !== findInstanceBlockingTarget(form)) continue;
                }
              else action = formProps.action;
              "function" === typeof action ? i2[queuedTarget + 1] = action : (i2.splice(queuedTarget, 3), queuedTarget -= 3);
              scheduleReplayQueueIfNeeded(i2);
            }
          }
      }
      function defaultOnDefaultTransitionIndicator() {
        function handleNavigate(event) {
          event.canIntercept && "react-transition" === event.info && event.intercept({
            handler: function() {
              return new Promise(function(resolve2) {
                return pendingResolve = resolve2;
              });
            },
            focusReset: "manual",
            scroll: "manual"
          });
        }
        function handleNavigateComplete() {
          null !== pendingResolve && (pendingResolve(), pendingResolve = null);
          isCancelled || setTimeout(startFakeNavigation, 20);
        }
        function startFakeNavigation() {
          if (!isCancelled && !navigation.transition) {
            var currentEntry = navigation.currentEntry;
            currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
              state: currentEntry.getState(),
              info: "react-transition",
              history: "replace"
            });
          }
        }
        if ("object" === typeof navigation) {
          var isCancelled = false, pendingResolve = null;
          navigation.addEventListener("navigate", handleNavigate);
          navigation.addEventListener("navigatesuccess", handleNavigateComplete);
          navigation.addEventListener("navigateerror", handleNavigateComplete);
          setTimeout(startFakeNavigation, 100);
          return function() {
            isCancelled = true;
            navigation.removeEventListener("navigate", handleNavigate);
            navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
            navigation.removeEventListener("navigateerror", handleNavigateComplete);
            null !== pendingResolve && (pendingResolve(), pendingResolve = null);
          };
        }
      }
      function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
        var root2 = this._internalRoot;
        if (null === root2) throw Error(formatProdErrorMessage(409));
        var current = root2.current, lane = requestUpdateLane();
        updateContainerImpl(current, lane, children, root2, null, null);
      };
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
        var root2 = this._internalRoot;
        if (null !== root2) {
          this._internalRoot = null;
          var container2 = root2.containerInfo;
          updateContainerImpl(root2.current, 2, null, root2, null, null);
          flushSyncWork$1();
          container2[internalContainerInstanceKey] = null;
        }
      };
      function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
        if (target) {
          var updatePriority = resolveUpdatePriority();
          target = { blockedOn: null, target, priority: updatePriority };
          for (var i2 = 0; i2 < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i2].priority; i2++) ;
          queuedExplicitHydrationTargets.splice(i2, 0, target);
          0 === i2 && attemptExplicitHydrationTarget(target);
        }
      };
      var isomorphicReactPackageVersion$jscomp$inline_1840 = React2.version;
      if ("19.2.1" !== isomorphicReactPackageVersion$jscomp$inline_1840)
        throw Error(
          formatProdErrorMessage(
            527,
            isomorphicReactPackageVersion$jscomp$inline_1840,
            "19.2.1"
          )
        );
      ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
        var fiber = componentOrElement._reactInternals;
        if (void 0 === fiber) {
          if ("function" === typeof componentOrElement.render)
            throw Error(formatProdErrorMessage(188));
          componentOrElement = Object.keys(componentOrElement).join(",");
          throw Error(formatProdErrorMessage(268, componentOrElement));
        }
        componentOrElement = findCurrentFiberUsingSlowPath(fiber);
        componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
        componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
        return componentOrElement;
      };
      var internals$jscomp$inline_2347 = {
        bundleType: 0,
        version: "19.2.1",
        rendererPackageName: "react-dom",
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: "19.2.1"
      };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        var hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!hook$jscomp$inline_2348.isDisabled && hook$jscomp$inline_2348.supportsFiber)
          try {
            rendererID = hook$jscomp$inline_2348.inject(
              internals$jscomp$inline_2347
            ), injectedHook = hook$jscomp$inline_2348;
          } catch (err) {
          }
      }
      reactDomClient_production.createRoot = function(container2, options2) {
        if (!isValidContainer(container2)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError));
        options2 = createFiberRoot(
          container2,
          1,
          false,
          null,
          null,
          isStrictMode,
          identifierPrefix,
          null,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          defaultOnDefaultTransitionIndicator
        );
        container2[internalContainerInstanceKey] = options2.current;
        listenToAllSupportedEvents(container2);
        return new ReactDOMRoot(options2);
      };
      reactDomClient_production.hydrateRoot = function(container2, initialChildren, options2) {
        if (!isValidContainer(container2)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.formState && (formState = options2.formState));
        initialChildren = createFiberRoot(
          container2,
          1,
          true,
          initialChildren,
          null != options2 ? options2 : null,
          isStrictMode,
          identifierPrefix,
          formState,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          defaultOnDefaultTransitionIndicator
        );
        initialChildren.context = getContextForSubtree(null);
        options2 = initialChildren.current;
        isStrictMode = requestUpdateLane();
        isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
        identifierPrefix = createUpdate(isStrictMode);
        identifierPrefix.callback = null;
        enqueueUpdate(options2, identifierPrefix, isStrictMode);
        options2 = isStrictMode;
        initialChildren.current.lanes = options2;
        markRootUpdated$1(initialChildren, options2);
        ensureRootIsScheduled(initialChildren);
        container2[internalContainerInstanceKey] = initialChildren.current;
        listenToAllSupportedEvents(container2);
        return new ReactDOMHydrationRoot(initialChildren);
      };
      reactDomClient_production.version = "19.2.1";
      return reactDomClient_production;
    }
    var hasRequiredClient;
    function requireClient() {
      if (hasRequiredClient) return client.exports;
      hasRequiredClient = 1;
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      {
        checkDCE();
        client.exports = requireReactDomClient_production();
      }
      return client.exports;
    }
    var clientExports = requireClient();
    const INLINE_LOGO_JPEG = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAKlAzkDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD7TwaULilor+Sas3U0R9NGHKFB6GjNJniroYdvUUpDDSUpNJXt06XKjDmCiiiifYQq9adTV606sGWFFITimlqhRuNOw7NBPFR76TfW8aLJcxWNRGlLU0mtVTsc7dxvrQBmkp/Sly2GmFPHFIBijOKnlLQ4GlyKj3UA1PIUOoUUDmnAYo2JHL0pabnFGTUcppcdRTcmjJqeULjqKbk0ZNLlC46im5NGTS5QuJRRRRYLjxzRSKaWosMcvelpo4p1TYaClU4FJRUWKHUUm6lyKLAFFAOaKiw0woooqbDCiiiosO4UUUVm4juFFFFZcowooopNFhRRRWTQBRRRWdi1oFFFFZtFIKKKK55ItBQehoormaKRGaSnEcU2uSSNkNPWkp+OKZXJKJaYUUUVyyRomFFFFccolhRRRWLiMKKKK53EoKKKKycSwooornaKCiiis+UsKKKKzaHcKKKKyaGFFFFZ2GFFFFUAUUUUAFFFFSUFFFFIAooooAKKKKACiiigAooooAnzSFqaWphav6Po4a7Pip1R5am7qYWpK9qFFQRzc9x+TRk0g5FFDRKlqLk0ZNJRXLKFzoix9GcUzIppfFSqTYnKxIW61Ez9aYZOtRNJXXToGMqhIXpN9QlqFNdippIw57k+6gc0xTUi9DWMolxYAYpaTNITWHKUmPzikzUe6lHNTyWLTHdaUUAU8L6VDKuC06m4xRk1lyiuOooop8pVwooopcoXCiiilyhcKKKKXKFwooorPlLuL0pwOaZSg4qeUaY6lBxTQc0tRyjuOHNLTKAcVPKVcfRSZFGRU8ori0ZNIDmlqeUdxQeOaXIptFTyjTHUU2jOKnlKuOooopcorhRRRWTiNMKKKKycTVMKKKKxcSgoooqeULhRRRUOJSYUUUVzyiWmFFFFc7gVcbSEUtFc8oGiYyjFOxSba5JUy0xm2jBp1Fc0qZomNxRg06iuSVM0TGUUUVzygWmFFFFczgWmFFFFYuJSYUUUVzOJdwooorLlC4UUUVm4lJhRRRWLiUmFFFFZWHcKKKKmwXCiiipsUFFFFSNBRRRSGFFFFABRRRQAUUUUAFFFFACFqZupu6kzX9ZU4WPzfmuOpw5FMU8U4HFOaHcdRRRXPYpaC7qTfSHpUZbrVxpNj9pZDi3FRPJimtJgGoHk613U8Oc0qo9paZvzUJanJzXT7JRRnz3Jl709RTYxUqjiuaehrFijinZFMzSZrlauaXH7qSm5NKORUuNhpi09RTVFPAxWTNEx6in0wdKXPvWfIO4ppKTdTaXKK5KvSim0U+Udx1FNopcoXHUU2ip5QuOoptFLlGmGacDTaKnlLUh1FNBxTsip5SuYKUGkoqOUdx2RRkU2ip5R3H0U3Jpcio5R3FoBxSZFLU8o0xcmlyKbRUco7jsil60yip5R3H0UUVFhjqKKKysWFFFFJodwooorFo0Ciiip5RXCiiio5SkwooorFxLTCiiisHAq4m2jbS0Vk4DTG4NFOoxXNKmWmNpu2n7aSueVM0TGYop2KTFcsqZomN20m2nUVxSpmqkNxRinUVyygUpDKKdtFJtrnlAtSEopcUYrlcCriUUUVlyBcKKKKxcCkwooorBxNEwooorFxLuFFFFRyjCiiio5RrQKKKKixQUUUVFgCiiipKCiiigAooooAKKKKAKYbNPU5qFakQ1/YLikfl0WSdKN1JRmuaSudCaHb6TzaYXwKheTGadOlzMznUsVPE+kt4i0S605NSv9HeddovtLlWO4h90LKy5+qmrJk61C1xjPNRGbrXqU6FjjnWJjL15phbNQhsmnoc12ciSMFK48DNSxrTYxUy965ZnVEegwDS5xSA4FJXFKNzROwu6kzSUqis+QpO44c09RSKMCnqOK5mrmqHKKWgdKKXIaJhSZpe1Mpco7jt1ANNoqeUm4/NGabmjNHKO47NGabmjNLlC47NGabmjNLlC47NGabmlU1PKFySikU8UtZ2LuFFFFRYdwyaUNSUVNirjgc0Dmm0oJFRYaYtFFFRylphSg4pKKixVxwal60yiosMfRSKc5pahodx9FFJWdihLm5hs7d555Y4Il6vI2AKo2fiXS7+WOK3voZXk+4Ff7309a+Hv2gPjTq/in433Gh2Vw0Wg6FKsEcEf3Zbgf6yQ+vzfL+FfTfw912LXfDEFvd4kSRBkEV9nh+G1Okqk52b8jRI9YornfAOsSahpd7a3JaS70+4a3eVvvSJ8rRsf+AsP+Bbq6KvjcRQnh6sqU90MKKMijIrjsUFFFFKwkwooopWKQUUUVk0WgooorBooKKKKhxEmFFKtKR1rBxLTG0hHFLRWDiaJjaKKK5ZRNExu2jbTqK5JQLTGkYpKfSYrllAtMbRRRXNKBSYUUUVyygVcZRRRWLgWncKKKKwlEtMKKKK55RNEFFFFYOJoFFFFYuJS1Ciiis2hhRRRWTQ0FFFFZtDCiiisiwooopAFFFFABRRRQBQFPU1FupQ2K/sdxPypMlzTS/WozJUTy4zUxpNslzsPeSoHl61FJN1qu02c161HD2OOdYkdutR5NN35p6DOa7XBROVvmY+OpkFMRakUda4qj7HTBWJUp6nFRr0pwOa5OVs61Ik3ZoXrTBUi9aynoUh6jrTlFIgqRRXK9TpihQMCim5NGTWfKXcdRTcmjJo5SbjqKbk0ZNLlFcdRTcmjJp8orjqKTdRuqLFC0UAiipsNMKKKKmxQUUUVFh3FBxTgc0yis+UY+gcUgb1pRzU8o0PopgOKUNUcpQ8GlyKZkUZqbALRTKcDmlY0uOXvS02l3Vk0O4tFNyaMms+Uu48HGaXdTFOc0tS4hcfWD468V23g3wlrOtXLAR2FrJcEHuVU4H4nArezgV8l/t1/Eg6V4PsPCVrLi51ubzLgKeRbxtkA/7z7f++TXbgMN9ZxEaXcuLPlrwjczar4gutUuT5lzeXDTyv6szbmNfXXwl8SjyI4S33cACvlTwJp5SNWxyAPzNelfD/xcbDxK9qzEKpFfrs49DpgfYPhW6Gn+OzHnEGrWWB6edD83/jylv+/deidjXj8V49zodvqVr891p7pdxqP4wv3k/wCBKWX/AIFXrVleRahZw3UDb4ZoxIjeoIyK/L+IcM6eI9r0kJjiaN1B6mkr5W2hI4HNLTKcDmosVccvelptKGosFxaKMijIrJxKTCiiis+Uu42ijBpdtRygKtFA4orNxLQUUUVzSiWmFFFFcziUhuKKdSbaxlAsSijFFcsoFpjSKSn03bXNKBSYlFLikrllAtDKKfik2iuaUTVDaKdtFG2uaUS0NopcGjFYOBaYlFFFcziUmFFFFZOJqgooorFxAKKKcoqeUYtFFFYuADKKdijFcjiUNop2KMVnYobRTsUYoWgxtFOxRimVcyd1NL0wvULy9a/tKEOY/I3OxI0uKrSTdeajkm61WeXOea9Slh+pw1KxI8uc1FuzTM5qSNa9BRUUcHM2yWMVYjFRxpU6CuKqztpIkUdafSL0pa4bXOkAcU4c00DNPUVnJWLiPUVIi0iLUgGK45e8dcRyjilBxTQcCjdWPLY2vYM0bqSijlI5hd1G6koo5Q5hd1G6kopcori7qN1JRRYVxd1LuFM3UoOaysXcdSjimdKcDU8o7jgaWm0oOKixVxaKAc0VPKO4UUUVFirhRRRU2HcUHFLuptFRYdx2RS5plFTYq4+imjinCoaKuOBzS0zpTgazcR3FooorPlLTCjNFFKwXK9/crbwO7uEjUZZj2FfmV8UPGMnxi+Kmra4rtJpqt9msQegt0yFP/AuW/wCB19X/ALYfxRPhHwO3h6zmxq2v7rZQDzHB/wAtm/8AZf8AgX+zXyT4K0xYYlO3Axj8K+54fwTpQeKnu9F/mdNONzqdLsU0uyLsMAc15qvjH+zvG15KkpCrIoxXa+OfEsWjaRcys2FiQsfrXzFo2sahca/N/aEUkUtx/pUOfl/dn7tfZU4c92a1Jcuh+nHwT8bpq2nRRM4YFRxntXuPgO7W0F3oxPFs3m2+e8Emdv5NuX8q+Dv2evGhsb2KFn+8QMGvszTtUYQWutW4Ly2QJZF6yQH/AFifX+L/AHhXzub4L63h5RXxLVFvVXPUaKZFOk0ayRuskTgMjqchhTuxr8k5TLmG0UnOaWosTccDmlpnSnilYLhRRRUtFpiqaWm0qmsrFpi0UUVNirhRRRUNFJhRRRXPKJaYUUUVzuJSYUUUVlKJaYUm2lormlEpMbiinUYFc8oFpjaTFO20ba5ZQKTGbaMU6iuaUDVMZRT6btrmlAtMSkxS0VhKBaY0jFJT6TaK5nApMbRT8UYFYSiapjKUDNOxRXM4juIBS0UUlELhRRRUuOg0FFFFcMoGiYUUUVg4jCiiisrDuFFFFSM5lpcA1VlmxmmPNwaqSS5zX94UMNrqfhlXED3mzmmhsmoMkmpolzXreyUUcMajkyeNc1ZjWoolqxGMVwVGdkESoKkHFRpT689q7OuLsiQHFOHNRr0qWMVnJcqNYu45VqRVpUFOrik+Y7IoBxTt1NJpu6s+WxXNYfuoyaZk0oNLkuHOOyaMmkzRmp5RcwuTRk0maM0uUfMLk0ZNJmjNTyhcXJoyaTNGamw7hRRmiosXcUHFOplKDipsO48HFKDmmA0tRYdx9FMzS7qnlHcfmlzTM0tZWNLjqKbQDiosO46ikDetLU2GmFFFFRYdwoooqbFBSg0lFKwD6KKKz5TVDs1Q1rV7XRNNur68nW3tbaNpZZHOAqqCSatZ96+Rf20fi6WVPh9pk376bbNqrIekfWOH/gXDN/s7fWuzB4SWLqKETRK54T8RPHVx8XviPqPiGcv9iJ+y2MTZ/d26khf+BN95vdq07OFNNsckYIGcVj+GNJSNVbbiOMAKKi8a68LC1kEZzIw2Rr71+nxhGnBU47I9KnHlic1JpF38WfiDYeGLcMbBJPtGoyqfuxryR+Vd5+0l8G4p/DNt4g0m38u/0cCMIg+/bD+H/gP3v++q9r/Zo+B3/CJ+DG1jUY86vrH76QsPmSLqq/j1/D3r0LXfDyPC6MgKkYxjg181ic09nil7N6R/HuclSXNI/Pz4d+KGtLmCZG2sCMjPf0r7y+DHj+PVdPiUsG3DoT145H4ivgf4t+CJvhZ4/vLVFZdLnfzrZu20np+GMV6Z8E/iU+lXkUbykRsR36e9fUNxrQVWGzNKcrrlZ+i3gy9+yzT6M75SIefaMe8X8Sf8BP8A46611VeQeGdd/tvS7a9tJFW8tyJ4GJ43D+FvZlyv/Aq9O0bVotYsI7mE4DcMh6o3dW9xX5hnOAdCq6q2ZM/dL9FFFfM2RkmFFFFTYtD6KZRUNGiY+imUVk0O5LkUZptFRYdx1FNBxS7qlopMWigHNFYSiWmFFFFYOJaYUUUVk0WmFFFFc7RSYUUUVg4lphRRRXO4lJhSbaWisJQNExuKKdSba5pQKTG4pNtOxRWEoFpjMUU+iuaUC0xlFO20m2uWUDRMSijFFcrgUmFFFFTylXCiiipaKTCiiiuaUC7hRRRXNKIwooorncR3Ciiio5R3PPzLmoic1GDmpIxmv9CvZqJ/Ork5DkTJq1CmKZElWY1rkqTtodlGBIgwDUg6U0DFOHSvOlqd2xIvepV5qJBUyDrXM9DaGo5VqVBimqOKeveuSbudMVYepp26o80VzpG6dkOJptFFNohsVT2p1Mpc0JCTFzRmmZFGRRyl3H5ozTMilqOUaY7NGabRUcpSY7NFNoqHEdySlFNpVrKxVxaKKKmw0wpRxSUVFihcmjdSUVNhofmgUyis7GiJAcUBvWmqaWpsUmPopoOKdUWGKGpcim0VLQ0OooorPlNAoooo5RhRRVXVNUs9F065v7+5is7K2jMs08zBUjUdSSaXKWjiPjZ8U7T4U+CrrV5Qst6/7ixtyf8AXTtwox/dH3m9FU1+fdtb3fiHVrrVdRne71C7kM088p3MzEknJ+tdb8XfijdfGfx1JqaF00W0Jg06BsjCZ5kI/vN/8Sv8NZ9sgt1wBg/Sv0DLcCsJTu/iZ6FGnpdhqF7HpVkwyEVV5Pp/9etH9nj4YP8AF3x3Dq2oxs2i6cwfkcSc9P8AgR/8dFcha6Ze/ETxVbaHp6s4eQCVlHAXP3fq1foL8LPhzY/D3wpaaVaRqGRQ00gGC796yzPGLDU+VfEy6k+XRG8tisUaogwg6Vj6xpgeNvlyD1FdbsHpVS7tQykYr88uciZ8r/tBfCVPHnha4SKIHUbUGS3YDk/3o/8AgX/oSiviHQr248P6s9pNlJYXxzx3r9Utf0gfOduR3FfDn7UvwefSdVHibTotsEzfvlVcBX53D/db7y/7X+9X2+RY5NPDzfoNPld0eu/s+fFFdkNrPJnAxgnqvpX05oevJpt2l7vH9m3W1Zj2R/urJ+P3W/4Cf4a/Lv4c+OZdGvoZRIQVI5r7r+EHxAj8Q6UkEzLIrrt2E9Ceo/Gvcx2EjiKTpT2Z2aVYn0xTsiuT8L6wYV/s24fOF3Wrn+NB/wAs/wDeX/0H/daumUnNfkeJws8LUdKe6OZxsSUUDkUVy2AfRTcmjJrNodx1FNyaVTmsmguSUUg5FLU8paYUUUVLiWgoyaKKycSkLuo3UlFYuJQ6iiiueUTRMKKKK53EpBRRRWTiWgooorncSgoooqHEtBRRRXNKJSCjFFFYOBaDApNtLRXNKBaG0UUVyygaJhSEUtFczgUhlFKetJWLiWmFFFFYNFphRRRWTiXcKKKK5pIYUUUVg4jQUUUVHKM81XqasRDNQoOatQrX+g1R6H87U0TxLVhKijHFSDivInqepDREi96etRrUqCuZ6Gy1JEFSoMUxBUgGBXJPU6oaDx0opuTRk1z8ptcdRTcmjJpcouYdRTcmjJpcpNx1LmmZNGTS5RXF3UbqSilymlxd1KORTaVTU2GmLRRRUWKuFKvekoqLDuSr0optFZcpdx2aKbRU8pSY+lU0wHFKDmo5S0x9FNBxS7qnlKTFopN1KDmo5RqQo4NLkU2ip5B8w/IoplFQ4jUh9Lk1HTl71HKVzElFIDxRkUrGiYtFJmlpWGmFfF/7V3xvfxTrE3grQrgtpVq4GozxH5biZT/qQe6r/F/tf7telftS/Hg+DtLbwroFxjxHfx/vp0OTZQHgt/10b+H0+9/dz8h6VpyxLnGW7k19LlWXp/7RVXov1/yPQoU7+8y3p0H2eHmqWr6u4kitLXL3Ny/lxheTmjWtVjsLd8tgAdv89a9U/Zf+Cr+KNYPiXXExGq/JE3ZTysX/AAL7zf8AAVr6OtVjRg5y2R1ynyI9k/ZZ+CyeENETWr+LdqN0NyFhyN33pP8AgX8P+z/vV9ExwCNcYAqlp9uQc1pV+ZYmvPEVXOR57nzO5F5dMkiytWKCMiuOw0zm9Vst6txXmfjfwla67pl5p95CJbW4QoykdPp7jrXss8W6uY1vSwwbjINaUpypyU47ou5+Wvxd+Gt78M/Fs3moxs3bcZAOCjH5ZP8A4r/aruvg38SZdE1CNZZTgYHXqK+qfi98LrXx7oM1nKireRgm3mYdD/dP+yehr4Gv9LvfAHiKWxuVeNQ58ot9/wCU/Mrf7S1+mYDGxxtGz+JGlOXKz9MvBfie38TaVGRLh8BldT8ysOjD3Feo6Dqn9o2zJL8t9FhZYh3/ALrL/sn/AOtX5/8AwP8Ais2nXEMEk37skbTnpX2N4b14arbQXdo6/aox8uTw4P3kP+y1eZmmX/Wafu/EtjonG6uj0+nVQ0rU4tVs1niOP4Xjb70bd1I7GrtfmsqcoPlZzDqKKKmxQUUUVjYY+im5pQaiwC0UUVm0UgHFPplOBrJotC0UUVlYocOaKaDinA5rJxNAooorncSkKcUlFFYuJaCiiiudxKCiiis3EsKKKKwcS0FFFFZuJSCiiiueUSxtFFFcsoloKKKK5nEtBRRRWEolJhRRRXM4al3CkIpaKznDQpMZRSkYpK4uUtBRRSgZqXAdxVHWlo6UVnyCuecIlWYlpirU0YxX95zdz8BpqxKvanjmmL2qVBXDI7ojkFTxrUaLU6DFck2dMR6ilptJmublNLi5ozTcmjJpWDmHZozTcmjJpcoXHZozTcmjJpWFcdmjNNyaMmlyhckyKWmUVNjRMfRTQaXIqLDuOB4pabRU2KuOopuTShqiw7jsmikyKTNZ2NExaXpTd1ANTYpMeG9aXrTKUcVHKUmPBxS5FN60VNirjgc0tNXrTqmw7iqaWm0oPrUco72FoooqHEaYUUUVHKPmFBxRupKKOU0UhcmvMPjv8ZrP4U+Ht6MlzrN2pSwsm67v+erf7K/+PfdrY+K3xY0f4UeG59S1OQNOw22toD+8uH7Ko9P7zfw18Faz4p1Tx74lude1m5a4vJznk/Ki/wAKKP4VFepgcCqz557Hbh6PtXd7FWWe917VLrU9Sne7v7uQyzzv1dj/AE9BU15cpp9ueRux1PanT3EVuDWZ4f8AD+ofFDxBFpNp5n2XevnSR/x/7A/2v5CvsFZLTY9nRI2/hD8N734p+KIZWjP9nRPuUsPlO0/PKf8AZX0/ibAr7+8H+GLXw5pVvZ2sWyKJcKD1Pqx9z1rA+FXw3s/AegQ2kUaeeVXz3QcE9kX/AGV7V6FHGEHHWvhsyxzxMuSHwr8TyK1XmloSxjaKmXvUSjrUq968GxkmLRRRUWNUxjrkGqF3AJUYYrSqCROtSO5w2s6XuDYXkV8wftIfBmLxdpM+qWcRW+hG6Xyx8xVRxKP9pf8Ax4fSvsS/tA6k4rjNe0USK7BR7jHWu/CYmWFqKcTRM/LTSNTvPDGqNaXWY5Yz1HRh6j2r6r+B/wAYihitbibjgAk1yX7SXwIMDP4h0iLYmSzoo+WFj3P+w3/jrV4d4N8RS6ZeKrExujYKnqCO1fpFKrDF0lUgdlKfRn6m6HrwAW/tf3jkAXNqv/LVfVfdf4fUfL/u99Z3Ud3AksTh43GVYd6+Qvgn8V4r+3itJ5R5ygBCT19q+jtC1wWI+1wnfaS8zxDt/wBNE/8AZl/i/wB773y2a5X7VOpSXvfn/wAEqcL6o7anVFHKk0aSxussTjcjocginZr4M5Lj6KbRWVirjqKKKnlKuKDinA5plKDis3EaY6ikBpaycS0xQcUbqSis+Uq4+gHFIDmlrNo0THDmimg4p1YOJSYUUUVk4lphRRRXO4lJhRRRWTiaJhRRRWDiUmFFFFZuJaYUUUVg4lXG4oxTqK5pRLTG4oxTqK5ZRKTG4oxTqKxcS0xuKMU6isHAq42il20mMVnOGhaYU3bTqK4nAtMbtp1FFTyjuFFAGaXbU+zFc4EDNPQU1RUqCv7iZ+E2HoKmRaYgqVelcNQ6KY9elPDVGDijdXNa50XsSbvejIqPdS5FPlJUh+RRkUzIoyKysXzD8ijIpmRRkUuULj8ijIpmRRkUrDuPyKMimZFGRS5R3JMmjJpmTS7qzsXcfupcio91KDmpsVcf0pc0wHFGaiw7km6jIpm6gGpsO5JRSbqTdWdguOopu6gNU8pSY4HFOpmc0oOKmxSY8HFKCKaDRU2LTH0Um6jdU2LuLSg4pu6gHNKwXJKKQGjIrOxQtFFFTYsdXLfEn4jaR8MPC9xreryYiT5YoU/1k8h6Ig7k0/4gfEPSfhx4duNa1q4EdrEMLGP9ZPJ2SNe5r4B+JvxO1f4ueKn1PVHMcCEi1slO5IE/9mY/xNXZhsHLESu9jrw9B1XfoVfHHjjWfin4mm1jWJixY4gth9y2i7RqP5t/FVCSeOzj2IAD7VC8iWkW1OXx1rmby7u9a1GPT9PHm3Un/fKL3Zvavq4QjTjyrZH0EYqCstjWtVv/ABhqsel2AJaU/vJwMiJO5+v90V9wfAX4NW3gXRIJ5oQt46cBh80at13f7TdWrkf2bfgRB4SsYdSvoQ9w2HiDjkv/AH2/9lX+GvpK2gxmvnswxntL0obHl4jE/YgWbeIKvSp1FIowMUoOK+ZscCJFHFKOKaDindazcTRMcOaKQHFLWbiO4UhXIpaKzcSlIqyx5BFY9/ZBg3HFdAy5FVJoQwIIoSLUjzDxL4diuYJo5IhJBICroRkYNfEHx++BM/g/UpNW0aJmsnbKhR/5Db/a/ut/F92v0T1CxDBgRmuC8UeF7fUrOe2uYVmtpQVZGGa9rL8bLCT8mbQmfnV4J8azaXcxukjIynkdCDX2p8GPi5DrVpHb3EoL4AIJ/Wvkz48fB3UPh/r0uo6dE09lKdw2jh0/+OL/AOPda53wF8QLjR7qKWKUrg+tfepwr0+eGzO+nU6M/UrRdaj0rkEy6dIcyqOfszf3h/s/3h/D97+9XZbq+Xvg/wDF+DxDaxRSygXAABBP3q9w0HXl09FR3zp54Vz/AMu/sf8AY/8AQf8Ad+78VmuWc169Fa9V+pNSnfVHZ0UDpRXxljjH5pd1JRRyl3HA5opvSlBqHEpMWlBxSUVi4lpjs0tMpc1nylJjqVTSUVi4mlx9KppoOaWsHEpMdRQvSiocS0wooorBxKTCiiisHEu4UUUVi4lJhRRRWTiWmFFFFYOJaYUUUVhKJaYUUUVySiUmFFFFZcpaYUUUVm4FJhRRRWMolJibaTFOoxXFOJaY3FKFpcUVmkVcKKKK05BXODUVNGKaq1IgxX9pNn4bHUevenZxTOlFczVzoWg7OaKaOKdWfLYd7ig4pd1NpN1TYVx+6jdTaKnlDmHbqN1NopcpSY7dRuptFTYdx26jdTaKXKVckyaN1JRWdi+YcDmlplKDipsNMcDilDUlFRYq44EUU2ipsO5LkUm4U3IoyKjlC47dRmm5FGRS5S0x9KDimdKcORUcpSY4HNLTKVT61Fi0SUUgPrS5FZ2LuFFFFKw0xc0bqSlFRYsdXP8Aj7x7pHw58OXGtazcLDbR/KkYP72dz0jjX+Jj6VS+I3xN0b4ZeHrjVtWnEcSjbDAD+8nk7Ko718C/ET4m638WPEb6rqzmOFCVtLJT+6t4/wD2Zv7zV14bCOu9VoduHous7Im+JvxR1r4v+JW1PVGNvZRErZacjZS2T+rnu3+TzymOBagLrCuBgmsa5u57q6jtbWJp7iVtqIv8zX08aapx5Yn0cYKC5US3t1caperp+nqZbmTg46KPU+gr6p/Z0/Z4j0e2j1rVIRczvtlAkUDzmH3Xdf7q9lH+9Vf9nb9ndLCGLW9ahLvPsdVccuf4Sf8AY9v4vvV9T2VokMYRFAAGOBwK8XHYrlTpw3PKxWK+xATTbBLaJY0UKqgAAVrRJsFMgi2ipq+aszy0OooopWNLj6UHFIDmis3Edx4opq96dWTQXHA5opo4p1LkLQUx0yKfRWbjY0joZ9xBvU1g6jYB1Yba6mRM5qhdW4dScVJseM+PvBVpr+mXFldwiWCUenKnsRXwN8X/AIRan8MtbmnhjZrKVjKhUcSD++v+1/eX/gVfp9qmmiWNgRXlvj3wDZeJ9Ln07UYBLA4O1scoezA9jXuZdj5YWXLL4WbQl0Pg74e/EKfSLmKWKUrtIyM9K+3fhH8W7fxFZxwzSr52ACCfvV8V/Fr4O6n8M9ckkjRns2O5JFHysP7y/wC1/eWpPhv4/m0W8iIkKgEcZ6V9naNaPPTZ2wn0Z+nuga+umokMz7tNPCSE/wDHv/sn/Y9/4f8Ad+72NfM3wq+KsGu2kcUsqmTAGCfvV7LoeutpChctPph6KOWt/cf9M/8AZ/hr5HMsq3rUF6oJ076o7eimhs06vjrHFsFFFFZtFIUGlptOHIrFotBRRRWdihQadTKcvSs3E0THLTqZTsisXEpCg4p1NpVPFQ4lpi0UUVi4lBRRRWDiWmFFFFc7iUgooorNxLQUUUVi4lBRT8UYrGUTRMZRT8UYrjlEpDKKfijFZ8paGUU/FGKlxKDFNIp1GK5HEpDKKKK4pxNEwooorKMR3FUZp2KAMUV0JEnEAD1pcim5ozX9iWZ+JJjs0ZpuaM1PKPmHZozTc0Zpco0x2aM03NGaXKO4+imUVPKO4+imUuTU2HcdSg0zNG6o5Rpj91LkVHupd1TyjuPopuaAcVFg5h1KDim7qXIqeUpMfmimUuTUWKTHUU3dS7qnlLuO3UbqSipsVcXdRupKKVh3HinKeKjU04HFRylKQ/NLupgNLUcpSkO3UbqbRS5EPmJQ1O3VEvSng1DiXF3H1wPxa+MGjfCPQ3v9UlEk8gItLBT+9uG9vRf7zfw1R+NPxy0n4S6O5mdbzWrhSLXT1b5j/tSf3V/ytfCPizxZq/j7xBc61rV813dSHgfdVF/hVF/hArrw+E9o+aWx6uFwzravYf47+ImvfE3X5NV1qYs+T5NsDiO3j/uqv9f4qwWuDbqfWmSTpCCF61zGoahLPPHFDF5ssn3I/wC//wDY19DCMacbRPpacYUo8sS9davPc3C21oplnkOFUV9Vfs2/s7rZRxa94ii8yWbDJE4/1n93jsv+z/F3qr+zb+zOukRReIPEsPmajNh4oHHK91JX+7/s/wDfVfW1jp62qrwN2McdB9K8fF4xK9OnueLjMb9imWrSzCqAAFUDGB2q9HEEFEK7Up9fPtXPHTuSr90UtIv3RRmosaJj6KKKzsO4U+ql/qNrpdnNeXtzHaWkK75biZsJGvck14jr/wC0jDqNxLbeGiIrQZU6pcJzJ7wxNz/wJv8Avk1pSoSquyOmlSlVdke26nq9no8Pm3t1DaxngNK+3P0rEPjmHJ+yWlxOP+eko8pf/Hvm/wDHa+eZviN5c5uC73N4etzcSGWX8CeF/wB0Vx3iD44xaeD++82vWp5bH7Z6cMFb4mfWb+M7nkNPpsH+88r/APxNSjxFct01Ow/8Bn/+OV8G3n7S8sBbysD8ay5P2otU/havRjgKKWx1Rw9NI/QlNZ1Aji+06X/tnJH/AOzNVuPV74A+bpwlX1tbhW/Rtpr4C0X9rbUYCBMc475r0jwr+2DZSyBLo7T3OaynllGWyJeGh0Prq11u1nk8rzjDMf8Aljcq0TH/AHd33v8AgNXq8o8K/GPQPF9qqGeGZWHKS4Nd1Z2g2BtEvfIXtYzlntz/ALo+9H/wE7f9lq8erlEo602YvDNbGpcWiyqSBzXP6no6yqwK1s2uvLd3H2C6ibTdSxn7NIeHX1jb7rr/AOPf3lWrE8PmKQfvCvDqUp0pcs1Yws46M8X8a+B7LxBps+n6jbie2kHccqexB7H3r4V+MHwe1H4X6w88CNJp7sSkijgj/wBlb+8v/fNfpjqumiVG45rzPxv4Js9d064sb6BZbWQENuHT3Hoa9fAY6WHdnsaRl0Z8J/D/AOI0+kXMbLKVwRkZ6V9gfCr40QapDFDcTANwMk18g/GD4Pat8N9Ye8s0a60+RsxyqOHHp7Sf7P8AF2rE8F+PpNOlSSGXawPK5619qnGtHngdtKpbRn6l6D4h+xIpiJntD1hHJT3j/wDif++ffurWZLq3jmidZIpF3I6nIIr41+EPxpivYYoLiTI4HJ5FfRPhrxP5YFzaN50EnM1tng+6/wB1v/Qq+QzLK1NurRWv5jrUeb3o7no1FV9Ov4b+382CUSxHv/d/2W/2qsV8a4nCrrcKKKK5Wih1FFFQWgoooqbGiYUu6korNoEx9KDikBzRWDRqmPopAaWsmh3HUUUVi4lBRRRWLiUgoooqHEtBRRRWLiUmFFFFZSiaIcvQ0tIvQ0tcs4lJhRRRXMolofRRRSlEq4yiiiuWUS0Mop+KMVxziaoZRT8UYrBRGFFFFaqJFzg91G6m5FGRX9jWPw647dRupuRRkUrDuO3UbqbkUZFKw7jt1G6m5FGRU8o7j6KMijIpWKuLmjdSZoqeUq44GlplFRyjuPopuaMmp5R3HZpcmmbqUNUcorjg1LkU0HNFTYpMfRk0zpShqjlLTH7qN1NzmlqbFJkm6jdTaKxsXcduo3U2ilYdx4OacpzTF70o4pWGmPoooqbFXF3UbqSilyjuOFeK/Hj9pHT/AIYW82k6SY9R8TyD5I/vRWv+1J7/AOzXE/H/AParTRFufDvgqaK51XlJ9VHKQeqx/wB5v9r7q/71fIs93Nd3Ek88jSyyMWaSQ5Zj7mu2hhOf3p7Hu4TBOXv1NuxqavrF94i1SfU9Vu5L/UZ23SzynJJqnNfLCpUct61Qmv8AyBWfHJd63qEem6XC93qEzBVVVyFz3NepyqKsj6GKUVZDbu9m1C/isLZTdXk/yRw9gP8Aa9q+u/2bv2XovDHleIPEsX2vVpNuyOT+D/P92tX9nX9mK08DW8Wsa3GLvXpQGw4z5f8A9f8A9Br6Tt7evKxGJv7kDwsXjOZ8lNjLGxS1GRhnx97HT2FaCDpXnXxW+N/hr4SWwivZG1HWpk3W+lWfMrjsXP8AyzX/AGmGP7u6vmLxd8Z/E/xIaSLV7wWWkE5XS7BikJH/AE0b70h/3vl9FWvPjh5T1Oahhp19j631n4x+FdJuHtlvzqF0nBg01PtDZ9Cy/Kp/3mFc/J8Z5rh2FrpkFsnaS+ud5/74T/4qvkr/AITtNITZAyxqOyiuZ1n40tAzLGzM/qTXbDBxW+p7lPAUofFqfccPxMun+/qmnx/9c7Rv/ZpK0o/HTSL/AMhy3/8AARf/AIuvzjufjbqrk7WI/GmQfHPV4zjefzrq+opq/Kb/AFWj/Kj9LrHxVPJ9zULCfP8AejKf+zNW1BrkxGZbLzF/v2rpLn8PlNfm7o/7R2qWxXfJ0969K8N/tTyIFEsh+oNYSwMHuiHgqEttC58afizrPxJ8QNaXRbT9CtJcwaUp4Zl6PKf4m9vur/49XF3HiH+z7c4NUNX8VWesa/czQyL5c8pcAnkZHArf034Hat8TxjT7u3tMf8/H3a6KVKNNcsUdkIwoxtFHk/iP4jz3DNHE28k4GDx+f+Fcjb3l5r9wVthNfMf4LZd1egeHv2ZvENx44m0nxt/xJJbd2dNP3/8AH3GP44pfuyL/ALS/d/i219TeBfhNp/h+38nT7SO0i/8AHqdXE06Om7OKpWaZ8i6R8GvF2thTFo5tkb/lpePj9K3If2bfFjn5pdPj+gNfcdh4MiUD93uPqRWmvg2IjmFfyrzJZjK/uo43Xn0Pgm5/Zy8XQZ2W9lcj1WQr/OuX1f4W+JvDpP2vRbuID+OIb1/76H+Nfo2/guHB/cise/8AB4Xdsynt2qI5pJP3kNYia3Pzj03xXqmhXH7i4mgdT91iQRX0F8KP2r9Q0d4rbV2M0IIG8nkV6X43+BWheJkkN3pqxTHpcWw2n/gQ6NXyh8T/AIM6/wDD26eaFDeaYT8k8I+UD0cfwmvVoYulX0W52U8QpaM/SHwx8RdC+JGjxiSVJEIQq6nZJGf4WVl+ZW/2q39L8Rywaimk6s4Mkr7LO/HC3B/55yf3ZP8Ax1v4fm+Wvy9+Fvxd1HwrfxjznEasA0bHkV9x+BPiVpnxE0Nre4kVpCoD5PIP972Nc2NwUa8Xbc1nTVRaHvc8G4EEcisLUtLWZGG38Kzvh94uk1B5dA1Ry2rWUQeKY/8AL3b/APPQH+8v3W/4C38VddLbiQcCvi505UpOEjz9YuzPGPGfga21iyuLa8t1uLWUYaNh/Kvh342/AnU/AOqPqOnI0thIchgPv/7Lf3ZP9r7rfz/TO+05ZVYFa4bxR4Pt9RtJre4gW4t5BteN1yCK9PBY+eGdnrEuMrH5teDPGc2nzoyyFSDg54/A+9fVnwm+MnEccsuegIJ615N8dP2d7rwzdT67ocZexzuZFH+r6/K/+z/00/76/vV5X4c8TT6VcYJaN0OGQ8FTX2UJwxMOeB3U6mlmfqD4Y8UCbbd2Uo3sBvjJ+WYejeje9eiaXq9vqkLPESrpxJE/3oz7/wCNfBfwn+Nr27xwSzccDk19PeFvF0OrRx3NrOI7hRxIPmyv91h/EtfO47LVXTlD4iZwUj2Sisfw/wCJYNWTyXXyLpRlomOfxU91rYr4arSlTk4yRySvHcTIoBptKveuflEpEg5ooXpRU2NbhRRRWTQ0wpymm0Vg0apj6UHFIORRWLQ7jwcUoNJRUuJdxwNFNpQcVi4lJi0UUVDiWmFFFFZOJVwooorJxNExy9DS0i9DS1zTiUmFFFFcnKWmPoooocblXE20baXBornnEpMZRRRXnzRtFhRRRWaiVcdto20tGDW6gZ3PPKKZmjNf2BY/DLj6KZmjNLlHcfRTM0ZqbFXH0UzNGaXKO5Luo3VHmjJqbBck3CjIqPJoyanlHck3e9Lu96i3Uu6o5R3JMmjJqPdQDmp5R3JqKYOaUHFTylpjqXNN3UuRU8pSY4HNLTKXOKixaY6im7qXdU8pVx4OaUHFRg5pwNZ8g+Yfuo3U0GlqeQfMOVutLuplGfeosMlp9Qg1jeMPG2j+AtEl1fW7xLOxi6sT8zHsFXufakos0im9jYvr2DTrOa7u5o7a1hXfLPK21EXuSa+M/jv+1NceMXuPD/hGR7TRBlbm/wA4e89l/ux/+PN/s1xnxo/aH1b4uXslrCz6Z4cRsRWaNgzj+9Mf4v8Ad+6teT/aBzXbSo296R9Ng8Cqfv1dx/SqVzfLECF5NQ3eoZyqHA9a3vh18Hdf+K2qR29pE9vYP8zzOcEJ6n+6P/Qv4a7laKPbnKMI3kzltB0PXPiBry6VoUTTTMcPJ/DGO5J/zivuj4Afs86X8LLKK6liW61mQAtOwztP+z/8VXVfCj4L6J8M9JjstOtlNxgedcsMtIfb+6v+zXptvb+QDXmYivze7HY+ZxWOdT3KeiJ7aCvD/wBoD9pmL4fiXwz4Z8q68V/8t7j70WnKf73rJ/dX/gTf3af+018d4/hH4ZFnprJN4q1NSlkh+cW6dGuHX/Z/hX+Jv91q+GbO4mknluLiaS6uJmaSWeZtzyOxyWY9zWVDD83vSNMDhPa+/PY6SW9uL69uL69upb2+uHMk9zcNukkb1Y9zVDVPE/2VCBIvHYVk6jrIiQxxnnpmt74cfCHxD8TbxDZwGDTw2Hu2HyrXqe7Ban0kpxguZnFXWp3epy7U3fMcDgkn6Ctnw/8ACnxL4mj8y10aeSI/8tZhtQ/p/WvsL4ffs0+HfB6pM1sdQv8Agtc3XzYP+ytepW/g6LH/ANauWWJUfhR5c8cr2R8Paf8Asw+JpwDJNZWq+0e41e/4ZY1vvqtt/wCA9fcEXhGEfwk/hSS+EoucAj8Kwljqi2Ob61Le58D6n+zZ4nstxhawuwPRyh/KvPPEPg3XfCsjLfaddW2OjqDtNfpLe+DdwOAG+orl9b8ERzwvFNAssZ6pIu4GnDHyT95GkcU+rPzptfEd1btgTbgP4ZBXt3wn+OlzoFzCGcqAQDk11nxA/ZcsNVMtxog+wXXXyj9xj7f3f/Hq+fPE/gPX/Al60Op2ksYU/K4HB9wR1/CvShOjXWmjO+niU9z9EfDfxA8M/FnSk0/XoIb8ZDp5hw8b/wB+N1wyN/tLtauv07w/qPh/mGaTxNpX/Af7Ri/9BWf/AMdk/wCulfml4R+It/oE6PHOxVSOQeRX1X8Jf2nVkWKDUJd3Qb88iuevhuZWkdLjCqrM+sdKey1CB7ixuVniQ4faMNGf7rp95W/2WGa0vsvHXP4Vwek+J9K8XhL+2uzaaiVCi/tSBKR/dkHSRf8AZdW/4DW3D4mutET/AIn8SC1PA1SyU+Sf+uq/eh+vzL/tLXzdbBzpu61R5lTDShqtjeNmOap3WmrIDxWpFLHcxLLE4eNhkMpyDQVzXA0crdjjr7ReG+XIrh/Evg+K+glRolkRwQ0bDIYV7HJbBgax7/SVlDYGDVRlyscZH5r/AB8+BE/gW5k1zR42Oms2ZEA/1R9D7f5+mZ8HPiPd6BqMMvmnAIDIT1HpX3/4p8I2+p209tdQLNBKpWSNhwwr89/ip8Orn4R+Prix5/s+ZvNtJSOGQnp9R0r6nBYlV48st0epQq82jPuCx1yXWdJ07XdGlUarYEXFsSeHGDvib2Zdyn/ez/DX0H4f1m18S6FaatZZNndRLKm77wH91v8AaH3f+A18Nfs++OPPsP7Plk5A3Jk/mP8APvX0T8A/E62fiDxB4Pkb92P+JrZg/wB2Rtsyj/dk2tj0krzMzw11zroVXhdcyPYJLYSKTWVeaeJFYYrdKFCfSo5YQykjrXy55tzzTXfDoZZPkDKeqkV8ifHf9nCRXn1rwvAeMtLaxjJT1KL/ABL/ALP8P8P92vvC9s/MU8Vx2taCJA7KvPcetejhMTPDyvHY1hNo/LXT9VutJvPKlDQ3CHp2PuK9w+Fvxon0u4ijlmIwRyTXovx2/Z4g8Uw3Gp6TCINXXLPGowly395f7sn+191v4v71fIV7bX/hu/ktr+KS2mifYxdSpB9GB6GvsqFenio80NzuhUufpT4K+INn4jt4iJRG45jeJsFD/s161oHi77UUttQZVkbiK4XhJPY+h9vyr8zfhj8VrnRLmOOSU7c+vWvrjwF8TrXXrVEeVX3AAhu/1rz8flscRHmS1OiUI1Y2Pp2n1w3hzxebZFjvHM9nwBcE5eD/AK6f3l/2v++v71dvC6zRh423Ke9fBYjDTw8uWaPPlBwdmS0UUVw2IF3UbqSisrGiHA5optKprFxuaJjwcCjIptFZOBVyQNSg5ptFZuJdx9FNBp1YuJSYqmlptOXpUNFphRRRWLiUmFFFFRymiY5ehpaRehpa55xKTCiiiuOUSkx9FFFEY3KuOppFOorCpEtMZijFLRXmyWpsmJijFLRRGI7gozTqBxRXQoEXPNMijIpmRSg5r+veU/CbjsijIptFLlGmOyKMim0UuUq47IoyKbRU8o7j6KKKnlKuGacOaaOTTqnlC4UUUVDiUmFFFFTyjuPozTc4oBqeUq48NS7qaOaKnlKTH0ZplKDio5SlIfuo3U0HNLU2LuOB9KcDmmL3pw4qGh3HUUUVFhpjs8VHnmjNfPvxz/aosPBMc+jeFWTVPEGNstz/AMsLY/8Aszf7P/fX92pVO510KM68uWCO/wDi58btC+EulvLfSi81KRf9G02Bsyuf7zf3V96+D/iP8VfEHxO1eS+1q8eRMsYLJTiGAf3QP/Zutc9rOt3+v6jPqOqXMl3fXDbpJZWyxrLnuMcV1U6aR9jhMFHDq8tyf7Tgc1UuLstlV4FR2ljeaxciC0jMjnv0A+pr6c+Bv7NBdrfV9dVtmAyxuMNJ/u/3V/8AHm/2RzWsmoK7OqtWhQjzSZw3wY/Z51Dxrcx32oI1vp6sMsw3Ivt/tN/s/dX+Kvtzwf4N07wppsdlp1usMSgZIHzMfUmtLR9Fg0+2jghhWGGMBVjQYAFbUcIUcCuCc3M+TxOMdd+QQwrGmMVmeJtfs/C+g6jq+oyiGxsYHuJpD2RQSf5Vr4r5a/br+Iv9keDNL8I2k2Jtbn8+7CnkW8JztP8AvSbf+/bVjClzyRz0I+1qKB8neNfGmofE3x5qXiXUjmS9k/cxZ4ghXiOMewXH/AtzfxVUuJxb25pdKswIt+OvA+lXNH8H3fjjxRp/h60/5eP9d/1z/i/+Jr1opJH3MIqnBQR0vwJ+DF/8WNeW9vEaHQoGBZiMeZ7Cvvfwt4TstA0+KysLdLeCMABUGBVf4dfDy08FaBa6ZZxBFiQAkDqa7u2sFiHSvJr1HJ6Hy2KxjrStHYq21iFHSr8dqqjoKmRAop1chxplcwhegqNoAwPFXdqJHJLI6xxRjc7ucBRXleu/tCaGNSXS/DYTWLluGvnbbZx/RvvSf8B+X/apqDnsdNKnOq+WCO/azU54qhd6WsgIKgiq2mar4jFql09nY+ILYjMkemhobhP92J2ZZP8AvpW/3q2dK1bT/EccpsblZZYjtmtmQxTwMOqyRt8ykehqZUZI3lRq0vjicfqHhlJASq4NcX4j8Fwajbvb3tpHdwHgrIua9pmsuDkVlXmlLJkFcisk3B6Exm1sfCnxK/ZcktfOvvC7FyMsbF/vf8BP8VeA3f8AaPhu+aG5ilsrhDghwRzX6har4bDBtq59q8r+IXwl0bxjbyRapYrI+MLOoxIv49/xr1KGOlHSeqO2niLHyT4J+M+q+HZ0IuHAHcNX1j8Kf2m7XVIo4Lq4HmEAMT/UV8tfED9nXW/CrS3WjE6nYrkmMD51H0/z/wABrzvTdUudIu9yFopYzhkPBBr00qdZXgetSrqWh+qOi3lncAXWgXy6ZM/LWrjfay+vyf8ALNjz80e31ZWrrNM8VRzzrZ6jEdL1KX/VQud8U/vG4+V/935W/wBmvzr+Hnx9vtFkSOSYlOAVY8V9beAfjfo/jTTxaXvk3Ebj57efkH6V5VfAxnfSzHOhCotNGe+4FRSwBwcVwzeM08HWQvjfG98PxcXEc5Mk9pH/AM9EPVkX+JW+bH3W/hrvDKh2lHWRCoYOhyDXzlSjKlK0jyKkJUnZmBqmniRSccivmD9sP4et4h+Hs2qwRbr3SX8/Kjlozwy/+zf8Br60u0yCfUV5x8SNETWPDmrWDrlLm1eEjHXKmtMNUdGopIKdW0j88fg/4rbTdSt3D4KsM819N6B4ifw58TPCHiFWxbG6FncNnA8m4Hl5PsrNG3/Aa+K/CbPYan5LZBjlKkfQ1+gPwB1HSl0qKa7NvN8o/wBZ81fXYinzRsz3o2nGx9SUzHBrmLUabIDJpd1JpTk52wsDGT6mNvlJ/CrL+IbjTVC6nEPs/bUbVSUH/XSPll/3vmX/AHa+KrYCtR1WqPNqYecX5GvImc1m3mniQMQPwrQguUnhWRHSaFvuyxncp/KnOn5V56djms4nB6vookRxtyK8L+L3wM03xzZys0a2+oBSI7pV+U+0i/xL/wCPLX1Hd2ImUkDmuc1HRRIG+XmumjWnSlzwZop21Py18VeA9Z+Hery2t3bSIE529fl/vIf4l/2v++q3/BPxBuNHnjZJjtz619u+Pvhpp3inT3s9Qt96DmOReJIW9VPb6V8Z/FT4Kar4Av3nhQzWbt8k8a/JJ7f7Lf7Pf+GvtcHjoYiNpaM7qVVH0x8MPjJDqEcccsoDcDk17l4Y8XtZbXtG861bl7bPT3T+79Pu/wC73/MPQ/Fd1pM4+do3U/Svon4VfG7cYoLuXDcAMT1oxOFhVi4zV0dvu1FqffOm6tbaxbCe2k3A8MpGGU+hHUGrleIeFvGC3Gy9tJwk2Ah53LKv92Re9eq6B4qg1hPIYfZr1RloCchh6q38S/5avg8bls8M3KOsThqUXHVG1RRRXiWMRV706mr1p1ZtFoVT2pabTlOaz5Sh9FAorNxLCnA5FNpVOM1jylJjqVTSUL1qHEtDqKKKxcSkwoooqbGg5ehpaRehpa55RKQUUUVxziWh9FFFEIlJjqKKKxqR0KQ09TRQeporypR1NkFA60UL1rSER3HUUUV0qJFzy7dQG9aSiv64sfgtx1FNHFKGpWKuLSg4pARRSsO4+imUuTSsO4/dQGpu6jdWdh8w/IozTMilzS5Skx1LTKKixaY+imZozU8pVyWim5ozU2FcdRTc0ZosO46lBxSZFGRWdi0x6ml3VHS5rPlL5iRTTt1RKeKcDWbQcxJVTWtbsPD2mT6jqd3FY2MA3SXEzbVUVxPxX+NGgfCbS2m1Sbzb11JtrCE5lnPr/sr7mvhj4rfGvxF8WdTMuqXJh09G/cadASIYx9P4j7mpjG57OEy+piNXoj0343ftW3/jLz9J8KmTS9G5VrvOLi5H1/5Zr7fe/lXz5PdcsSdzk5JJ/WqryhQec1UeYtmuqMUkfZ4ejDDx5YIsS3Oc85NbXg/wFqPja6CwhhbZ2+YRkt7KO9dn8MPgTqXiu9jluEOzIPln5Qi/3i39K+y/h/8ADHTfB9qi28Mc1yBzPsxj2UdhSb5Uc2Lx1PDabs4f4N/s96b4Wgiu9RhWW74ZYm+cK395v7zf+O17vY6alug4GfpUtnZrEuSOat4NedNuTuz4+tip4iXNNiIgAqUcCmAYFP8A4amxz3IppsAgV+bf7VXjN/FPx21xRJ5lppSppkWDwNo3N/4+zV+jV5KEVj6DNfkTr2qtr3jbX9TZtzXmoTzZPvIxFdWHje572VQUqjZ2ukQ7rVjX0n+xZ4Dju7nWvFdzHlWl+y2+4fwL8ufx+avnKzYW+lSP6ITX3R+yrpI034M6GSMPcJ55993NaTdlY+hzCahRZ7DbwrGMKOKnpF6VjeLfGmieBNJfUte1CKwtRwoY5klP92NOrt7CvNcb7HxcVfY3K88+JXx48N/DZxazSnVNXA40qx+aVP8Aro33Y1/3v+Ahq8C+KP7T2ueK1m07w0snh3SWyrXCNi9nX/eH+p/4D83+0teEicWwP+WdvU1pDDp7nvYbLZv3qh6X8RPjP4h+JEzLqtyLXSw2V0m0LLCvoZP4pD/vfL6Ktcf/AMJj/ZOZa4PUfFYAYRmuXv8AVpbtiWcgV3RpJaI+lpxp0I2ifXXwv/aZW1mjt7uTEYwA4bpX0JYeKPDnxDiiuZH+z6oqgRatZyeXcR/7O4feX/Zbcv8As1+WPnXFvn5pIvZ/vV2XhD4w6r4ZnTFw/lAjoaHSuhucZaNH6XjxJqfh2PGtR/2tpoH/ACGtOjwyD1mgX5l/3o9w77Vrfsry11eyivLKeK7tZhujnhbcjj1Br5M+Gn7Ty3SxpdzbumWzzXtmhS2GsyvqXh7Uf7E1OY+Y7RAS2l23rNF6/wC0u1v9qvMq4aS1R5lfARn71I9AubMODgfhWJfaMkykNHn8Kn03xX9lu4bLxBaf2NfSELDPu82zuj/0zm6bj/ck2t/vV0v2UdDz+FcLg1ueJOEqbtJHlmpeEUkDMqgn3rxn4mfs+aN4vEkhtv7Nv8cXVuvU/wC0vevqy60tJASBtPqK5nVNIDhlZeacJypu8WEKjjqj81fHvwt1/wCG9y3262M9iT+7voATG31PY+xqLwP4wutHvkeOZgoI5Br7q8W+Hh9mmjaJZYZAQyOMg+496/PXRedUn7/v2/8AQjXv4eq68Wpnv4Wt7RWPo3V/ibqk/hm5t2uHMcsDqw3dRivs/wCBepSax8GPBF3KcyPotoT/AN+1r88tTydII9q/QP8AZxH/ABYrwN/2BbX/ANAWvHzKNoxZGPdoxZ30i7k5rmfEVqHgf6V1L/dNc9rnMLj2rxqUbs8iO5+UCW4h8U6h3P26b/0Nq9G/4SDUtAsBJaSsqqABg154zZ8X6rz/AMv83/obV6BcskmkAEZyoNfbSdz6GlojV8M/tLa3ozKsszlQfWvon4cftMWmsJGl3IqM2Mknj8q+DZfBXi630qPXBZjVtKuE87Nt/rUz7d6h0TxNLay5tpmjdTzG3BH4UlTUkXGrrZn6n6XrTCQ6hoMsUbu3mTWMjD7Lc+//AEzk/wBpf+BK1d/4e8Q2niOwkntg8EsOI7i1mwJLd/7rL3z/AHvut95a+Bvgp8cGgaO0vJeOAQxr6Ss/FZS5h1rRZ1a+giwEJ/d3EfeCT1X+638Lc/3g3g43L4zTlHRk1qCnG8dz3kqMGqU8O7PFN8NeIbLxZosGpWJYQyZVon+/C4+8jDsQauuma+WcZQbizx3daM5nU9JEqsQvNcL4k8J2+o2k9tc26XFtKNrxSLlWFesvCCDmsq/0tZVYgc1pGVi4ux8C/Gb9nebSPO1LR0e4shlm4zJD/vf3l/2vvL/tV4ELm60W82PujdTuH90/7Qr9R9X0HcHwg5HKkcGvnb4s/s92Ouxz3OlRJbXvLNb9ElP95T/yzb/x1v4v71fT4LMrL2dbbudtOq46M8o+Ffxkm06WOG4l+XgZJ4NfU3hD4hWutQRZl+YYKsrYZT6g9q+A9e8Mah4Rv5VeN1RGw2V2lD6MvVTXYeAPidc6PNGrynYDjr0r2Z0VKN46o9GMlJH6XeG/HqsqQapIrI2Fjvv4W9pP7rf7X3T/ALPftK+OfAPxYgv4kVpQQwAIJ4Ne2eEPHJs41UMbix4zEDloveP1X/Z/75218Zj8pd3UofcYVKW7ietU+s7TNWttUgE1rMs0bcZU8hv7rDs3tV4c18w6bjoziTH0UUVjYq46iiioaKuFKDikorJoLj+lOBzTRyKVetYyiaRkPDUuRTaKxcS0x1FIppaysaJhTl6U2isXEtD6VetNBzS1g4miHinU2nVnYsbRRRUTjoOIq96WhRxRXlzjqbphRRRThElsVe9OpAMUtd0Y6GZ5PRTMijPvX9Zcp+CXJM0u6owaXdS5R3H5FLmo9wpc+9TyjuSZNG6mZNG6lyjuP3UbqZuo3VPKO4/dSg0zIpanlKTHUU2gHFRylpj80Zpu6jdU2KuSZozTc0ZqOUdx2aM03NGaVguP3UA5pKKzsaJko6UU2szxN4o0zwfo0+q6xew2FjCMtLM2M+gUdz7VNi6alN2ia1fOvxs/azsPCH2jR/CbR6trQyj3eM21of8A2o3/AI7/ACryL41/tT6p43M+l+Hmk0jQySplQ4uLof7TDov+yPxrwA3AwayaufX4DKL/ALyv9xf13X9Q8R6lPqGqXkt7eSnLSysST/gKyXuMZGaZNOWyF4Fbvg34d6l4tvY0jilSJzjdtyW/3fWqirH1Kioqy2MfTtNvNbuRBaxPNIxwFQZJr6Q+DX7Pcl00eoX6DygQfNYct7Rr/wCzV6N8KvgBYeGreOa7gVpeCYTzz/tN/F/u/dr3XTNMjtIlSNAoAA4GKUn2PmcZmqi3To/eZvhnwna6NaJDDEI4x2HVvc11MMQUAAYApIodtWFXFZNNnzDnKb5pMlj6GpMVGvepKysQAGKOxoozU8oXOf8AEDEW04/6Zt/6DX5Cacd99IfWVj+pr9e9aIkjcHuCK/JC/sv7G8TalZY2/ZryaLH+7Iw/pXTh1Zs+nyeVpS+X6np8diZNCl/64Mf/AB2vuj9ny8gsfgv4ZubmaO3torCJ5JZm2ooA5JNfH/wntbDxKYbO/l8uBxsYg9e1J4l1S9ECeHDrFzf6BpZFvZ2kmBEFU8FgMbm/2j61M1d2Po8ZQ+s0+ROx9NfEf9rTTtMM1j4Pt11a5XKnU5g32aM/9M1+9KfyX6181eIfFN94n1STU9b1CfULxxj7RdPuwv8AdUfdVfYcVyd7rENqpBYZ/uiucvvEEtySqHC0RgkRh8HRwy01fc6HV/EscAZICCem7/P/AOquT1DWJbpmLOeepPJqzoWg6t4q1BbPSrKW/um6JGOB9T2r6O+GX7JiJ5V74tlF3Jww0+DiNf8AePeqbjHVjq4uFPdnz54L+GfiP4iXqw6RYP8AZycPezjEa19OfD79mXRPB/l3l+P7b1QYPn3Q+VD/ALK175ofhC00mzjgtbeO2t0GFiiXCityLT1jHQVyzr30ieDWx85u0NEfP3j34T6V4rtJE1GxinYjCzBcSJ/unt+VfKvxG+A+v+DnkutLibWdOBJKoP38Y/3f4vwr9ILzQoJ1Y7Nreq/4VxuueEFcMfLDD1A4pQrSiTRxc4vU/M/R9aks5BNbSEYPK9MGvYvhv8a7/QLiPFwygHlWPBrW+N/gnwl4p1h30PeNbDHzNQsdv2VG/uyt/wAtG/2V/wCBFa46L4dRaWmTdidh32Y/rXZzKaufS4epKcbtH3H8OPjJp3i/STZX/kzxTpslt7hA8ci9wwPUV3Vja3ujL5nhi+S90/r/AGHqcx2qPSCflo/91ty/7tfnlYeLJ/CQ325I2nOB0r0LwN+05cWcirdSuMe+RWMqSktUbzpwqK0kfcmi+MLHWbo2LiXT9VXl9OvV8ufb/eX+GRf9pGZferV1brKDXknhz4n+H/iJp1vDqGycoQ8TltssL/3o5FO5W/2lZa7Szu9Z0iPKPJ4q0vH+ymoQj/x0T/8Ajrf9dK8yrhmtUeHXy+Ufep6lLxdY79PlwORX5k+HbfOqz/8AXdv/AEI1+oGoa3p+uaTez6fdJcpEpDqRtkiPPyyIeUb2NfmZ4cH/ABM5v+u7f+hGu3ANrmTNcvVnL+u56Bfxf8Sl/wDcr9Av2el2/BDwPj/oC2v/AKLWvgHUnA0l/wDrnX31+z7L/wAWR8D/APYFtf8A0Wtc+OXNT+ZtmH8OPqd+5whrnNfbEJroHb5DXNeIG/dGvEpnjo/KHcf+Ev1X/r/m/wDQ2rv5D/xKV/3B/KvPwM+LdUP/AE/zf+htXfy8aSPZB/Kvr5bH1FGOlj334N+Evt3wk8MTeXuLWSfzrk/il+zRZ+Jkm1DTIEsNYPP7viOU+jf3T/tdK+hfgBoKH4KeDsr9/S4W/MZro9S8N9SF/wAa+eeKqUqrszx/aNM/L9Pt/hbWJLO7R7e8t32lWGCcV9E/CD4qZEdvPJ7YJrp/2k/gsninRJdXsIgmtWgydo/18S/1WvlHwxrNxp99tbMc0TYZTxXu06kcTDmjuelh6t1bofevgT4kx+AvGUNxJKf7E1Zxb32fuxv0juMeq/db/Zb/AGa+oOpr88dG1OLXPDwjmIZWX5v9oY/wr6+/Zx8cv4z+HltDeS+Zq2jS/YLpieZNo/dSf8CjK/iGr5vMMPy++jHF07e8j1EpkVFJDuFWQM0Fa8E8sxLqxWQEEVzGr+HVmVvlz6EV3jxBgapz2oYEYyKSk0awnbRnzt8RfhFp/ii3cTxCK9Awl4i84/uuP4l9jXyD8RvhDqfg3UX8u3KdWCJkxzf9cz6f7J+av0o1TSFkVuMivPfF3gm01uyltL23WeB+xHQ+oPY17WDzGdB8stUdcKrifndofi660q4AjkeCRTgxvxzXvvw0+OHMcF3JtbgZJ61h/GH4DT6S0mowK1zZ55vVH7yL3mX+If7Q/wCBV4jIl5oF35U6mNhyrKchh6qe4/lX1kKlPExvE9GFS5+i/hLxysxS4s7kRTEDJ6hx6MO4r2bwz4uttdQQy4g1FR80BOd3vG3df5V+Z3w/+LV1o0saSSlovrX034G+JNrrMEWZQWGCCGwVPqp/hNeFjcsjXTlHRiqUlPVbn1uKK878L/EcpGkOpv59vwFvFHzL7SD/ANmH/AvWvQIpknjSWJ1licZV0OQa+KrYWdCVpo4ZQcNyaigHIoriaJuFFFFZWC45e9LTV606sZI0ixymlplOU1i0api04cim0A4rNxNEx1FFFZNGiYo4p1Mpy9K52jRMeOlPB4pi9KWsrFphQBmlApaznsVFhRRRXnSjqbphSikp4GKqESGwooorsitCLnkO6jcKZuo3V/WfKfgNx4PvSg4qMEUtLlHck3UbhTMml3UuUq48H3oz70wEUZqeUdyXdQGpm6jdWfKO5IDmimZFKDipsUmPBpQc0wNS1Fikx9FNBxRuqeUu46iiiiwxd1G6koqHEdx1PqjqurWeiafNfX9zHaWkQy80zbVX6mvkf41/tiT6glxo3gYvbQE7ZNWfiRx6Rr/B/vZLf7vfGSselg8LPFycIHtXxh/aL8PfCi1ktDKNV19l/dabE2Sp7NI38I/8er4l+IfxY8Q/FDV2vtduzKFOIrWE7YYR/dVe5/2jXGXV1Ne3Elzdzvc3Dks0kjEkmq7XBGcGsT7vCZfSwkdNX3Lks27PNRR7p5BHGu5icDFP0XR73XbjyraMvnqew+tfTnwc/Z92Qx314hQMATK/329lX+Ff9qlY7qteFCPNNnn3w0+A934jnWS+T5QQTG3ypF/10b1/2a+uvA3wz0/wrbKIolknwA0pXH/AV/uiuj0Hw1a6NbR29pCsMSDhUHA/z610VvbADpRY+Ix2aTxL5YaIjtLJUGcVoRRgdKaiH6CpkGKix4yY9VxTqQdKWnY0H0A4oorOxVx2ajLdaCeDUROc0rAY2qfdY+9fl/8AGK1sJ/iv4ln0u4ju7Ge+d0nh+45OWYj/AIFur6c/ar/aH8qe58DeGbn96fk1S+ib/V+tupH8X97/AL5/vV8q4qo6H12VYeUIupLqWfDPiW40Jg0blSpzxUeoeKZp5HYO3PvWbIACa9R+Hn7PXiDxqsVzPH/ZWnSDKzScyOPVVpvue/Oqqa1Z5VBJcancrFDFJNK5wscY3Ma9y+GP7MGreJvKu/ELHTbBsEW68yMPevoX4afALQfBESNbWatc4+a4mG5z9PSvX9N0WKFRgAH1PWoc0tj57E5l9mmch4F+GeleENPS00qyS0iAALAfO/1Nd3aaWkK/dFW4bYR1cRABXNL3tzw3UlN3kyvHb5GMYFSC2Hrms7xV4v0TwRpbajrmp2+n2gbYGlb5nb+6q9Wb2Ar5q+I/7Uuua95tl4QgbQLA5U6hcBWunH+yvKx/+PN/ums1C524fDVcS7QR7d8Svi94Z+GluU1Gfz9QYZi0u1IkuX99v8C/7TbVr5X+IXxl8QfEh5IbuQaRozcDSrRiQ4/6bSf8tPp8q/7Lda8/uZ8TTXE0rT3Mzb5ZpWJkkb+8zHljXO6j4lVQwjNbRgkfU4fL6dDWWrOjudUhtVIBFcrrXigsGVG/AVhy39zqEuyMMxbgBRkmvVPh1+zb4g8XBbq9QabaMMiScZJ+grZJI7ataNKN2eRmG41RwMOxY4VEGWb6CjUfCGsaKiSXFlPa7+VWdSpNfdHg34DaH4TQG0tQ9zjm5uFzIfoO1b2s/Dy21C1MNzaR3kR6pIN/60/bKJ4zzH3tD4G8LePdS8M3a+XK6FTkxscV9KfDD9ps2/lw3UxHQfMayPiP+zSsqy3WhqSRybSQ4Yf7rf8AxVfPureH7/w7dyQzxyRSRHDK6lWU+4qlKM0elRxEKq0ep+i1p4s8NfEAR3Lym11PYETULR9k4H90t/Gv+yylf9mvhfW/Cp8J+NdV08D5YbuQL/u7iQfyrC8PfEPVNBlUxXLgA9M1003jCPxFcG6uH3zt1zQoKOqOrzF1ad5LUxk8bcV+hP7P3/JEvA3/AGBrX/0WtfnbrMmy0mfsqE5/A1+iX7P3/JEvA3/YGtf/AEWteZjdKdjy8wdoRR3rn5a57Xv+PZ66Bulc9r/FrJXjU4+9Y8Wm7n5RQ8+J9SP/AE+Tf+jGrvLpsaW3+5XBQn/ipdRI/wCfyb/0Y1dveyY0xh/sV9dNaH11P4WfoB+z8m74J+Cf+wTb/wDoFdncQZzxXKfs8Ju+CXgj/sE2/wD6DXfTW4xXx1b+Kz5mc/faOB8QaGlzE5C5B6jHT3r89/2kPAJ+H3xEa6totthqWZY8DhWzytfpjd23Xjivlb9szwb/AGl8PG1CNMzadcq+R12nrXdgKvJU5X1OzC1LSsfPvw21qU2v2Z2yMZXP6ivo/wDZR8Vf2T8UbvSZHxBrNmQoJ486E7l/Eq0n5V8l+A77ypwc8Afoa9S+HHib+wfip4Pv921Y9XhVj/syHY3/AI6xr18XS9pTaPXrLmoyP0ojOakzUMZ60+vh+U+duOPSoyAc1J/DUfrWUogmVri1EgOBWDqGlhw3GRXT1BNbCQHHWpN0zzHV/Dyyq/yggjBBGQRXz18UPgFb6nHPcaRAkUjEs9ixwkrf3o/7h/8AHfpX1/dacHByuDXL6z4fWZW+Xnsa7MPip0JXTNoTcWfmT4h8E33ha7nXy5EjjbDxuuHhP+0P/Zh8taHhHx/d6DcphztB6Zr7T8efDGx8SwMl3D5c4H7u6jH7xf8AZ/2l9mr5O+JPwWv/AAtcPP5YWMn93PGP3Mvsf+ebex/CvrsNjKeJVnoz06dVM9o8AfGaK7VEeUA9wTXvXgr4gyWWHs5RLA3L2rn5T7r6GvzatdSu9Iudp3wSoeVbg17B8OvjNJZvHFcynAIGc1dbCxqx5Zq6Ou0aisz9JdA8SWevQbrZ8SAfPA/30/xH+1WvXyb4P+JcN8I5La42SDGJEbBH+f7te1eEfipDeiO31ZltpDwt2Plgf/e/ut/47XxWNyydBuVPVHFUoNK6PSKKKK8CxyWsFFFFZtFXH0UUVlylofRTVNOrFo0TFU0tNozWEkWmOpV70gOaUcVzSRomPWnUwcU+sLGlx1FFFYyLiwooorkcTdMVRTqKK0jEhsKKKK6EiLnje6lBFNor+tbH8/XHUtMBxTqVguLupcim0UrFXH0U0HFLuqbDuOyaN1MyaUHNTyjuPyKUGmUoOKmxSY8NS0wc0tRylpjwcUu6mA0tTYpMdkUZFR5NQX+o22lWM95e3EdraQIZJZpW2qijqSazLTLsbMBwB9e9ee/FP45eGfhVbkajdrd6owzFptu26V/rj7o92rwT4y/thSXKTab4DPlxHKvrMv3j/wBcV/8AZjXyvfaxc6ndzXF5cSXVxMxaW4lbLSH/AGmrmnOx9dl+Rzm+fE6LsekfFr42+IfiteyHUJzDpoP7rTojiCMf+zN7tXmZ4zSifI9akghac4HA9awTufb0qUKUeWCsisxzkV1vgn4a33iW5jMsbLG/3EHVv8+teg/Cr4I3WvOl1NBshByZXHC/T+83+zX1Z4Q+HWn+G4QLSHbIRh7huXf/AOtTSbPHxuZ0sNotWcZ8MPgZp/h62hlu4UaUAEQ4yoP+1/eNe2WVgltGFVQoHan2lksIzjLepq6q8VfIfDYnF1MTLmmyS3UY6VaUYFRxdKmVuKOU5birxTxTKUH1rOw0ySikDUoOak0TH0UDmjsaiw7hXiH7UHxp/wCFP+B5pbPA8Qai7Wun/wCw38U3/AV/XbXteecV+aP7TvxGb4nfFnUZY5DJpOlt9gtFB+U7W/eSD/ebd+AWhRuevluF+s1tdlueaQGWaWS6uXaWeVvMeRzku5OdzGppb/AwKQDg+9eq/ss/ChfiX4xm1i+hZtF004Ct92Z+4NK1j7ydSFCGp6j+zl+zmrRReJfE0QnupPnt7RjlY/8Aab/ar6osNCS3QJFGqAegqzpenR20KRRIERQAABWvDHsFYyd9D4fEYyVaTuQW2nJEMtyasLGFOcYxUgry74n/ALQ3hn4ciazif+3tdUYGnWbgLG3pNKRtj+nzN/s1lY5qUJ1pcsFc9MuLiKztpbieRIIIlLySyEKqr6k9q+ePiV+1xY6d5lj4Ihj1a66HVboEW0f+4v3pPqdq/wC9XgXxI+K3iP4pXJ/t29/0FG3RaZbEpaQ+mFH+sb/abd/wGuDudRFuDVKNz6jB5Vy+9WfyOo1vxZqPiXVJdW1zUZtU1GTrPcHIVf7qL91V/wBlflrKufEUZ+UEye2eB+HSuK1HxEzFgDisQa1IJupraMFY+hgo0lywVj0uc/b7aovh98JdZ+JGq3KWSYtLdj5s7dF5qvod4J7ZT6ivp39jbS45dK8VS4+9exj/AMcrNvlMMXVdKm5I6D4Y/s8aN4ViSR4Be3fGZJF+XPsK9n0/RI7VQCoGBgADpWta2SxLgLiri2/f+lc8pNnw1SvUqu82Zws4sfdFI1lFtPy1rCLA60GHIrEUXY4nUvD4nZiK858cfCrTfElu0eoWSykD5ZlGHX6GvdJLNWzxWVf6YHDAjIoTaOmnUcXdM/P/AOJP7OV/ozyXOjBr23GSUA/er+H8VeP6JO8N5sbIZTtYV+k/iTw9mGRlXPByK/N+yUHW7rj/AJav/wChV30p8yPpsDWlVTTex3NxzYknrsr9EP2fj/xZLwP/ANga1/8ARa1+d0//AB4f8Ar9Df2fT/xZHwN/2BrX/wBFrXHjF7iJzH4Ynfuetc94iOLeQe1dAx4Nc54kbEL/AO7XlJdjwqeh+UNo/wDxP78/9PUn/obV2F/L/oWM/wANcLaSY16/5/5eZP8A0Jq6++k/0L8K+omfYU37rP0i/Z0H/FkvA/8A2Cbf/wBBr0SUcGvPP2dP+SJeB/8AsE2//oNeiSDOa+NrfxJHy8v4kihcxZU14l+0fpv274UeKosZP2J5B/wE7q9ym+6a8c/aJf7N8LfFT/8AUPmH/juKrD/xYmlF2mj84fBk+4qf9muzkuvKv7CXP+ruI3/JhXEeCkxGp/2f6107P52qWMH/AD0uI0/NhX109j6X7B+t0RqQHFQx8cVKpzmvgrHzNyQH5aZ3pw6U0cmspIEOooorGxqmMkiDg8VnXNnkEEVqUjIGBBqbFpnHajoyTqwK5rg/EnhCO6glimhWaFxgqwzXsE9pnPFZV5pyuCCKcJSg7xNYycT4W+LX7PrWyy3mkRG6th8xt1fdPB/1zP8AEv8AstzXzlqWnXOg3RTkFTgNjGfr6V+oWv8AhYSBnjXB9PWvCPil8DNP8YRSugNhqQB2yoPlc/7Y719Pg80XwVT0KdY+X/BnxIutJnRWkZGHUE9f8a+ivAXxZg1KNIppBuIwQ3INfMPjX4ear4M1B7bULVojn5JV+449VP8ASoNB1250uVPnIweDmvelCFWPPB3R1qbP0f8AAvxMudGRI0Y3unHk2rN80Y9Y27f7p+X/AHete0aF4j0/xHamaxnEm3AeMja8Z9GU8ivzn8BfFt4GSOeTpgZzXtXhj4jlZI7yyuTDOv3ZYmwR/st6j/Zr5jF5VCq3KGjFOlGorrc+wKK818C/Gex1x49P1cpY6iWCxzA/uZz/AHc/wt/s16RXyFbDzoS5Zo89wlB2Y6iiiuewx9OFNpy9KwcTRC0UUVzyiWgU06m06uWSNUPFOHSmL0p69KwaKTH0UUVzyRrEKVRmkpy96x5TdC0UUVpGJDCiiitbE3PF80UzNANf1pyn88XH04HNR7qUGlyBckoBxTAaUNS5SuYkBozTAaM1PIO4+im5xS7qnlKuOBxTqj3UoPpU8pSY+nA1GGpQRUWLUiSimA0uTU8pVx1fLf7d/jC90rwloOiWk3lxahcySXCg8sqBdo/76bd/wGvqPIFeG/tKfCw/FfwqbSKXyNRtJBPZyEfKSAdyn/ZNYzi7aHpZbVp08TGVTVH5+W+ofaOKvWVhcalIY7aMyPjoKzPEPhvVPCOrTWGpWr2d5EcFWHDD1B7il0rVpIZVkRjHIvcV50lY/V4TUjrNX+HHi/w/4VvPEVz4dvZtItSFllhAcJnoW2tuVf8Aar2L9n/4Py+ItPtvEmsmBoplElrZ27blCn1PrWZ8IPjxqHhu5RPOGPutFNzG691I9DXuvg7RdOubyTWPhyYbGab97f8Ag+Q4trju0ls3/LNv9n7p/wBms4zjF+8Y42lXqUJLDuzPVPDnh6Gwto4441iijGFRRxXV28KhRxXOeENetPEdvJ9lLxzwNsuLScbZoG7qynkV1MabRiu+PK1dH5VONSlJwqKzRIiin4xSLgUtVYyuPHFOVqbRWdh8xKDmlBxTKcDmocSkx6tSg+tR04GsnE1TJQaXIqPNIXxSsFzgPjn42bwD8L/E+tRvsuLe1KW5z/y2kPlx4/4Ewr8ydNtwa+0f28/ET2fw00zTY22tqOqJuHqkaO3/AKFtr420UbhzUJ2R99kdO1D2n8xLc2U1wYbe1Qvc3TrBEoH8THbX6KfAr4bW3w4+HulaTDGBN5Yed8cs565r47+A3hc+K/jBosBTdDZK1y/pj7o/9CNfonBCqcAVmzLPcQ4ctKI+3h2CnytsFSgYxVW/kEcZYnAAyTUKJ8cmfL37W3x51Dw5qNt4I0W7fT5Lm3W5vryE4kMbMyqiH+H7rZPPavmL+0YcdRXS/tgTn/hecuP+gfb/AKl684sIWuIqTjY/RstoqGHUo9S9eawTuWPmst2lmz5j4H90feb6V0/w/wDh7qXxD1i4sdM2L9mwbiZ/ux5/nX1V8PP2d9H8Iol1JELy/wAc3V0uWU/7I/hoSsb4jF08OrPc+X/CXwK8S+LtktxG2gaa3O+Rc3Eg/wBkf8s/q2GrhvHvge28CeNbvR7PzDFHHG7NK+5mZl5JP4V+lM3h6NId23mvhL9o6xW1+MV+ijj7Pbkn1+Tk1rB2Z5mExcq1ZpmPoXy2ae1fXv7Ew3eHPEuf+f8AT/0WK+RNHTFsB6HFfXf7E3Hh3xL/ANf6f+ixWVW0mejmP+7M+m0UCpAM01e9PQda5LHwPtLjguRRtqRF607bWZqmQ7BUE8IZTVsio2HaosaJ2OI8TrttZ/8Adavy3tH/AOJzcH/ptJ/6E1fqT4q4trj6GvyrtZv+Jxcc/wDLaT/0KurD7M+lyp6y+X6notwP+Jf/AMAr9Cv2e/8AkhngY/8AUGt//QRXwBBAJ9NX3TFfYnw7+MWleEvhB4SsLeGTVdVi0+OJ7WJtkcLAdJZcFUP+yMt/s1OJg5wsj0cbSlVjFRR7tPPHa28k88iwwoMs7nAFeJ/Ef4xW8tu9p4ejjuW6HUbkfuf+2Y/5af8AoP8AtNXl/jX4m6p4suTJqF6WiB+SyQ4tkH+7/E3u36V5j4g8cfZ1bnmuSnQ6snD5co+9VZ5Trfw+fQ9VnmgmEts8jOePmySTVbV7wR2ZGei1b1/xVLfysqEkE9qk8C/DPxB8WfEEOi6JbNPM5BmlxlLePu7n0Feld21PSqzhCLZ+k37Of/JEvBH/AGCLf/0CvRax/BugQeFfC+laPbKEt7C1itYwPRVA/pWxXzFdKU20fIylzSciCZAc183/ALZniKLRvgzq0TNi4vnS0iHrlvm/QGvou9m8qJznnpXwP+2V48i8V/EOw8M2z77PRVMlxg8NcyfdX/gI/wDQq6MDT5qvodOGi6kzwrw9ZLaWe4jAx+ldP8K9FPij4v8AhLTMbkm1SFnH+yrbm/8AHRWMwENqEH0r2/8AYc8JHXvizea66brfRbVmViP+W0vyr/44Hr6GrNRi5HvVpezp3Pv/ABinL0pgOactfGNWPmObUkU8Uq8U1TTqxaLTHZFFNpy9KyaKTCiiis2jVMCMjFVprfINWaCMiosaJmJc2YYEEVy2t+HUnViF5rvZIQwPFULi1yCMVNjWL7Hz9458EWWrWMtpqVlHeWz9UkXI+tfFnxa+F9x8ONbsxoLrqtpqU/lQ6WWLXgY9Qg/ir7a+IvjOS9v7rRPDEMeo6hGf3+o3P/Hnaf7zfxv/ANM1/wDHa8/0vTNJ8G3MuoiVtT12dds+s3YUzyD+5GvSNP8AZX/x6vq8sVWCbk9D0qEJvV7HzQPhN43sP9dp3k+v79dyfX5q6HTtZ1Hw/wD8fXGK7Pxt8SVtlkVH4+vJrw7WvF11fO2XIX0zXvW5zra5T0DxB8WriWwaANtH1xX6P/BnXr3xR8KvCOraiWN9d6VbyzMxyXYr9/8AHrX5y/AT9nXX/jHrVrPdxPY+F45N8964K+av8UcefvN/tD7tfqDpNhBpen29naxiK2gjWGKNeioowo/IV8fnc6TUYR1kjjqzT0L1FFFfJGQ+ikBzS1DQ0KtOpg4p9c8kWhy9KKRehpa45I2iPooHNFc7Roh9KvQ0lKvQ1g0WhaKKKysaJjx0pV601elLVpAKeppKKKqwrniO6jIpmRS1/W9j+cbjwaUNUYOKcG9aLDuPBpc0wUA4qbDuSbqMimbqXIpWHzD8+9GaZS5xS5Skx4alBpgb1pQc1Nikx4NLupgOKUNUcpaY8GlzTKF61NiriuSBWJqsG8E4rac1XmhDipa0NYM8S+Ifwx0nxpavbanZrIoB8uYDEkZ9jXyV8TvgNrPgh5bu1U6hpgPE0S/Mg/2hX6D6hpiyK3Fcnq2hh1dWQOhGCCOv1rknS5j6HAZnUw3uy1ifm3a3TROCCVYHrXofg34m3/h+4idZ3XYQQysQR9DXrXxW/ZxttX87UNAVbS95Zrfokh9vQ18v6vY6joN9LZ38L288ZwyOMGvLqUnHc/QMHjoV43iz7i8GfG7R/GYtzq10dL1yMAQ6zbjDeyyr/EPevb9F8ZOskNjrSx291IMw3cTbre6H95G/pX5eaH4mmsZFw5GPevoL4W/HqXTbddN1ILqWkuRutZj933Q/wn6VhCU6TvHY1xeAoY+Npq0u591KTmng15x4H8WR3dgbvSp31fSwoM1u53XdoPU/89F+ld9pt/b6larcW0qzRN0Za9OnVjUV0fm+YZZXwDvUXu9y5SrSDgUVseRclXpS1GGp4NHKWmPBzSjiowacGrJxNUyQGq8z4zzUm6qtw3WsrFHxt+3/AHu648D2oPAN3MR+CCvmzw8Nymvon9vmH/TfBlx6LdR/+gH+lfPHhX5gR71hUVkj9Nya31WKPo79juy874karMRxFaxqP/Hq+2Ixivjf9kmJrH4janG3/La0iYfrX2QtZxjc+fz/APjr0J81Q1Fvlq3urN1F8CtOU+aPzv8A2vOfjbN/14W383rh9BH+jCu4/a8/5LZN/wBeFv8AzeuI0H/j2Wspn6hlz/cU4+R9DfsY2Hm6z40lx1+zrn/gLV9cQWQiXgc18yfsUWwNz4xOON9v/Jq+rtgxUHyuazccRKJiXibI29K/Pj9qm5CfHDUB/wBO1v8A+gmv0R1GLMb1+c/7V0ZHxxv/APr2t/8A0E1aReUy5qr9DM8NL9oh/wCBV9cfsWQ7fDviX/r/AE/9FivlX4aQR3UyQyPsDN1xmvt74UaDp3hzTvM8KXg+0XADXVhfnMdyw6upJ/dn/wAdrCWh9VjqE6+Gcae57FinrwaytO8SwXshs5VlsL8dbW4+R/8AeT+8v+0talZqx+dTpTpS5ZqzJ1fApQ+ah3UbsVHKNMnzUTdTRvqnq2p2uj2E17fXMdnaRDLzzNhF+pqOU1jqcx4qX/R7j6GvybtmI1e4/wCu0n/oQr78+Kf7QMeoiaw8KqUXlW1W6Xn/ALZxt0+rf9818caz4Ii02YyxTebEP++q1oq1z7HL8PUormkjtvhjqNtHqVs1+oltowGdSM5Fdj4l8fwS308kUYigkcssa/IB9BXhB1D7PwKo3OpSTZwcCt2rnuqVtzufEvxCaUvHC24+g6CuLNxeazeRwgS3E8rBUhiXc7H0Ve9d38LfgN4m+JM8U0MX9n6SeX1G9T76/wDTOPv/AL33a+zfhP8AAPQPh1bD7BbCfUGUCXULgbpX/wCBdFH+ytZSlGmjzMRjoU9Lnz58Jv2S9T8QCG/8UTNpVk2GFjEf9IkH+038P/oX0r7T8C+BdI8DaPFpmjafDp9ogHyRD5nPq7fxGrlhpMdtgkbmrctgMH8K8urWctD5+pipVvJE68Cn0Vz3jvx1pHw88Oz6zrNx5NrH8qovMkrnoqL3JrkUObQwipTfLE4L9oP4u2Xwl8EXeoSsHv5M29jbk/PPMQdv/Af4m/2RX50Wktzf3V3ql9IZby7la4mkb+KRjkn8Oleg/Ffx1q/xa8W3Gt6p+5tYiY7KxHzLBDk9f9pu5968+1K5SzhWFTjj9K9zDUlSj5n1WFw/sY67lTUtSIyinmv0R/ZE+G3/AAgHwksZriLZqmsEX9zkfMAw/dqfouP++mr4/wD2W/hC/wAWPiAt7fRFtA0l1nvSR8s75/dw/wDAv4vZf9qv0ntx5VcWNrW/do48wrX/AHcS3Tgc0wcinLXiM8RMkHIpwOaYvelrJo0TH05elRqcUuRWbRSY+igHiismjVMKDxmiuJ8e/EzT/B8TQjF5qjD93aIfmHu390U4UpVHZG9OMpuyOi1zxFp/hrT5r7UblLa2jGWkc9a8O8Y/Em/8YRyxRPLo2hyAjAO26ul9QR/q1/WuH8W+NbrWb37bq9yLmaM7oYf+WNv/ALq/xH/aNeV+Lvin9nLgzEn68/8A1q9yhgox1Z7lHCqC5pnf614w0/RLAWtq0dtBH92KE7QPevEPGXxKaZpI7dySeN1cTrvjW51OR1VyEPoa6b4SfA3xH8X9URrOJrHS42xJqcw/dr7L/eNexaNGHNLQ6nVjFWOLitNW8ValHaWVvLfXcx+SGIZY19T/AAQ/YviT7PrPjhlupTh49KjP7sf9dG7/AEFe8/CT4DeH/hbpwi0y1FxdsB5uoXIDTSn/ANlX/Zr1e1sACC5y3vXgYvM5SXJS0R5lWvzOyGeHdGt9JsYre3gSCGNQqRRrhVH0raXimxoETApy9a+Ulqc97kgpaQdKWsS0x1OU02ioaLTH05elMByKctc8kapj160tNHFOrlkjVMcvSlpq96dXO4miY+lXoaYvenL1rBxLTHUUUVlYtMcvQ0tNWnVSRVwoooosTc8MopmaXPvX9e2R/Ntx4NKDmmbqUEUrDuPHFKGpgNKGpWHcfmlqPIpc+9Kw7j+lGTTc0bqjlKuPDUtMDUoPpU2KTHg04HNRhqUEVFi0x9Lk0wGjdU2KuOZqbmjNJWdi1Ihli3ZrPnsw27itbHFQyJ1qOU2jNo47VNGDBio/CvKviT8INK8dWjx38AScD93dIPnT/GveZbYODkVmXelq6njIrKVNSWp2YfFzoy5qbPzd+I3wg1v4d3bG4ia508n93fRDKkf7X901zGl3z20n3iMV+jev+FIL+3lgmgSeCQYaOQZBFfMHxV/ZrlsjNqPhlSycs9g3Uf8AXM9/92vPlh2tj7/L85p1koVNGc18PfivqXhO+hntbuSMoRgq3I/z6V9bfDn4xaZ4zEbxXEWk622N4Jxb3J/2h/C3uK/PJZZrCdoplaORTghhjmun8PeM7jS51eKVkKnsa4JU3F80dGfWXhWh7OqrxZ+o2layt8zQSobe8T78D9fqPUe9aWa+RfhX+0FbahbW+m6/ungjwIp0bE0H+6e49q+idM8WCC1inubhb7TnwIdRh5H+7IP4TXRSxGtpHwuZcPypXq4XWPY64PzT1aqqtk1Khr090fFE26nK1MHSlXvWbLTJB0qrcNwas5wMVUueQazsa3Pkr9u3RmufBfh/VEGTZ6l5Ln0SRG/qq18seD3/ANIYGvv79oXwd/wmXwr8Sacqb5xbm5h9fMj+dcfXbt/4FX52+H7w2t4hPy84I9K46q0P0PJKqnQ5V0Pqv4H3v9i/EXQb0thLhTZP7lvmH/oNfao4r4B8EXR1CyRIG23UZWSJs9HU5X+WK+1Ph34uj8X+F7LUAcOyBJV7q44INRhndtMw4hotKnWW2x1LNWVqT8VoO9ZOpNwa7LI+Jufnx+123/F6ZP8Arwt//Zq4rQj/AKOn0rtv2uoz/wALnkP/AE4W/wD7NXD6IuLZPpXHNan6nlz/AHNN+R9YfsQDc3jE/wDTaH/0GvqfHNfLP7Dgz/wmP/XaH/0GvqgjBrOx8dnEv9skUr1f3b/Svzq/a54+OF1/15W//s1foten9030r86P2uT/AMXwu/8Arxt//ZqpG+Tv9815HCabdTWkSywsQwr0LwL8ddR0G5RJpm2KfWvPtJTfDsPQiuc1iWCy1MwF8E0nFPc+6UnBaH6BeB/j7pnim0itdU8u6QYKlz86H1VuqmvU9G1+7aESWFz/AG9aY/1TsoukHsfuyf8Ajrf71fl9pOu3ukSLJFMyqO4PNe4/Db4+3GmyxrczkYx+9B/mK53T7GdajRxMbVUffWka5Z6vHIbWbzHiO2WJlKyRN6Mp5H41fDZ6V4Z4V+L2i+NY4Xu22XSqFjv7V9kqD0z/ABD/AGW+WuQ+Onj7UVnXSm8RfbtPRMNFap5Pmf75X73/AKD/ALNRr1PnJ5G1L3J6Ho3xC/aM0fw2JbTQ9muaoOC8cn+jQn/ak/i+i/pXzV4v+Jus+NLw3Gs373rA5SAfJBH/ALsY4/4Efm/2q43VfFYVWjQhUH8CdPx/+vn8K4bVvFMl0WEbYHtTULnuYXA0sKr21Ov1jxZFBkGTzHHRQeB/QVxOp+IJ9QYgNhewHSsaSaa7uoreKKa7u5ztitrdd8kp9FXvXvfwp/ZZ1LX/AC77xY/2OzOCulW7/vG/66yD/wBBX/vqtVFRRrWxkKSvJ6HkXhDwHrnj/Ufseh2TX8wO2SXkQxf774PP+zy3tX1b8Kf2RNG8OyQaj4gkGv6mpDKrLi2iP+yn8X1b8hXt3hDwTYaBYQ2WnWcVrbRLtWONQqqPwrtYLJIlHG5vXsK5p1Hsj5jE5lKq+WnojJ07QIoK3ra2WJcAU+KAAZxUoGK4ZXZ5adxq9asJx0rzz4gfGnQPAbyWhdtV1lRkabZnLL6eY33Yx7t+VfOXj74wa742Z49SuxFppPGl2DFIP+Bt96Q/72F/2amNJs9TDYGrX12Xc998cftCaZowmsfDyxazeoCr3hY/Y4z/ALwI8xh/dU/8CU18y/EPxHqfjK7a71S8kvJsFVeTgRqf4UT7qr/nLVyur+MvswPIFcRqHjue7nKhvl+tdtOgkfT0MJSw693fuT+J9RSwhcA5A9O5rC8CeA9d+LXiyDRNFiLzStumlP3LeP8AikY9hV3UANQtvm5r7M/YtsdJf4Tiays4re/S9lhvpEHzSspyjMfXawrWpP2ULonFVXSpuSPUvhR8M9K+F/hOy0TSosQQDc8pX5p5D96Rv9r09q9AiXLc9BUVsBzVgcV89O8ndnyfPzaslHtS0ynA5rJokcppabS7qyaGhwOKN1JkUZFQbIkyaVpUt4mkkOFAzzWP4j8Uad4U0x7/AFO5S2gX+Jzivnf4h/F298Xh4C76fpH8FsjbZJh/009B/s1tSw7rOyPRw+GnW16Hd/ED40uwlsPD0iqBlZtRcZVR6R+p968F1/xRFZ+a4lZ5X+aSeVsySH1Y+ntXM+J/H8djEyK4CqMKo4C/h2rxzxH41udQdwrnYe/XNfQUcLGmrI+hpUYUF5nS+L/iM0zSRwPn1avL7q8vNavVhiSS5uJThIoxlmPtXSeAvhz4j+KetLp2hWbTjIM9y/EcK5+8x9K+5/gj+zLoPwtgiupoU1XX2GXv5UyF9o1P3frSq4inh99WYV8TGK0PDfgT+xpPqRh1jxwrW9scPFpSn53HbzG/hH+zX2r4d8LWehWENrZ20dtbxKAkUS7VUfStKy05IQCRlv5VoKmBXzOJxU6zd2ePKrKbGQQhBVyGPuabGmeT0qcEYry2ShQcU6mUqnFYtDQ8HFOplKDismjVDs04HNNoHFZtGyY8HFOplPHIrCSNEx9OHSmL0py9DXNJGqY4cU6mU8c1g4miYq9acKYKfWDiWmOooHSisbFoVetOplPp2KuFFFFKxNzwbcKXNMor+wOQ/mfmJAcUBqYDinA5pcpXMPB9KUNUdKDU8g+Yfupcim0UuUfMOBpQcUyjNLlKuSBqAaaDmipsWmSA4pd1Rg4p1RylJjgaXNMozU2LuSL3paYp4p4NZtDTCkK5paKysaKZEYwaieDINWqCOKixaZg3NkHzxXP6npAdW+Wu2eENmqNxZ7weKlo3p1GmfNnxU+BGl+NI5LiONbLVAPluUXh/Zx3+vWvkzxb4P1XwPqklnqMDRsp+WT+Fh6g96/Sm+0sOG4rg/Gnw/wBN8U6fLZ6laLcQsO4wy+4PauWpRU9VufX5dnM6PuVdUfBOleIZLOUFXKkGvdvhR8er3w5MImlElu/yyQS/Mjj0INcH8VPgNqvgh5r6xD6jpIOTKq/PF7MP615zpt88DgE4IryqlHoz9Bw+KjVjzU3dH6X+BfHVprNgLnQ3NxEBmbSpWzLH7xN/EvtXoWmapb6rbia3fcOjL0Kn0Ir83/h/8Tb3w3eRSQzsu0g8HpX118OfivpvjCON3uU0zXcAfaycQ3P+zMvZv9qlSrSovlnqjyMxyWjjU6tD3Z/gz3MU+sjStaF3IbadDbXiDLQsc5H95T/EK1a9OMlJXR+a4ihVw0/Z1VZjy1QSnKmlL8VGW61djJMxNZ/1Rr8zPjX4Nl+HXxK1fTolK2csv2qzP/TCTJx/wEll/wCA1+m2oxhyQeRXzR+1Z8I5fHPhZNT0+LdrWjh5oIwOZU/5aR/1X6f7Vc1SF0z6HKMX9Xr2ez0Pn74a+KjBLES+CCAea+sPhl4wTw3qP21WxoOqOEvAP+XS46K/+63evgXQr97C5V8lcHDKex9K+ofgn8RIIT9kuwtxZzgR3ED8iRPf6V5bTg+ZH6U40sXRdGpqmfbZY1Tu135zXG6Drv8AwhlvAlxcNf8AhacgWuosctZE9EmP93/artboq6K8bq6OuQy1306qmj8xxeAqYKp7Oep+f/7Xij/hcsn/AF4W/wD7NXA6QQLVPpXd/teS5+Msn/XhB/7NXnukyf6KlZzP0DLv92pvyPrb9hs5Xxj/ANdof/Qa+pZGr5W/YYbMXjE/9N4R/wCO19Tyc1mlc+Lzd/7bIp3jZif6V+dP7XR/4vfd/wDXjb/+zV+il0f3T/Svzq/a6H/F77v/AK8bf/2aix1ZM/37OP0Qf6OPXFdt8IfB0XibWPFazwR3UKxW6mKVMj/lpXE6J/x7j6V79+yTZ/btb8ZsP4Y7X/2pUJ3dj67MJqFBs8+8Wfs7zWJkn8MSeV3OlXhzGf8Arm3Vfx+WvLr3SLrSL97S8t5tKv16wXAxn/aVvusvutfond+FYpVbdEpB9BiuO8XfDLTPEdi1pqFlHdw/wrKOU91bqDTseBhs0cHyyd0fFWjeL9R8PXIaOR1Of4T1re1H4gXmvgiU8+ldH8Q/gDrXhrzrjQ1k1rTxybeYf6ZEP9k/dkH/AI9/vV5HuMLv94OhwyMu2RD6FahxPpqOJhWV4M62z8Pav4jnSGyheUt/drqR8APFlh4p07SfEEdt4V0+9/1Os3DrPBM39yJ1+XzP9mRl/wB1q4jwv41n0e6RvMKgHIINfTPw+/aBTUNLk0vVoYNS0+4Ty5ra7UNFIvoVNZvQ2lFyVj0v4X/s9eHfh1AGsLUzai4Hm6hdjfNP+P8A7Kvy165p+hrEAZOv615z4LuntoQ3hC/S7ssZbw1q02Sg/wCne4b5l9lk3L23LXpHh/xPY67JLbp5lpqNvgT6ddr5c8P4H7y+jLuU1zOd9D4/G4SvTbm9UbNtCsSBVGAP1q0oqleX1tpdjPe3txFaWkC7pJ53CIg9yeK8E+Iv7TMjebaeDrZGQZVtbvYmEQ9fKjOGk/3m2r/vVha5x4fC1cRK0Ee5eK/HGh+CNNa91nUFsosfu487pJj6Iq/Mx/3RXzx8Qv2htY8R+ba6UkvhnSzxmP8A4/5h7t92H/gO5v8AdrxXWfFE11qE19e3suoajKMPe3ThpCP7q/3V/wBlflri9Z8crlo4iWboWNaxpn1eFyynQ96pqzqtV1+CxhdEIjjJLMM5Lt6sTyx9zXDax4zmbcsZ2j1rn73VZrxyWYn610PgX4Q+JviUSdJszHZH72q3albb/gHeX/gPy/7VdMIKJ6dSpGnHXRHHajrjSbnklwCcbmPf0qhp+orcyyp5U8LRthkuI9jDr2r7B8Jfs06H4EMV7Osus6wuD9vvFB2H/pmv3Y/+A/N/tV80/F6D7J8Xtcgz91Ih/wCOVqpRexw08V7SVkX7GQSWg56gV9b/ALB94G0PxhY5yY7yGbHpvjYf+yV8Y6ddMkIGe1fXP/BP1zIvjljz81l/OWuLE/ATj3eiz69gTAqWkXjNLkV4tj5JMeOaKaDinDms2jZDgc0tMHFPHNZ8tykFcP8AET4q6X4HtniDreaqw/dWaNznsX9BXBfFD49ppxuNL8PyLNecrNfdUh9k9W96+cda8VHzprm5naWeQ7nmkbLsfc120cNfWR7+EwDladXbsdh4v8f32vXzXmqXP2if+CMcRxeyj+teSeKviF5e8JIQPaua8VePWlLxwtwfSuNsbTVPF2qRWGn201/fTHEdvAu5m+gr2oUuVHtynCmuWJJrHii41CR8MVT+dex/A39l3WPiO0Oqa6JdJ0EnK5XE1wPRQein+8a9c+A/7INj4a+zaz4sVNR1TAZLHrBAff8AvN+lfVen6ZHBGsaIAqjAVRgCvNxGNULwp79zx6+LT0ic/wCAvh/pHgnR4dO0iwisbSMDEaDlj/edurN7muyhtwnbn1NSQ2yxD1NTKvtXzs5ubbZ5bk5O7BFqXFA6UVg0NDxx0pQ1JRWVjVEimlptKprJo0Q4HFOplKDisWjREmaWmU+sWjRDl6U5e9MXvTl71izWJIvenL3pi96eveudo1iLTl702nL3rFo0QtPplPrCSLQq9KWkXvS1hYtBTxyKZTl6UWHcWm5NO7GmVIjwTNLTM0A1/Y1j+YOYfSg0zdSg1NilIfSg4pgNKGqLFpj8ilzTAaM1PKVcfSg4pu6lzRYdxwOaWmUoao5SlIeppaYDmlBxU2LUh1FIGpQc1FilIfSg+tIOaKjlLTHil3VHnHejd71HKUmSbqTNMDe9KDU8popCkcU0rwafRUcpSkZs9sGJrLu9MDg8V0RQGo3gBBqeRGqqNHnmr6AkyOjoGVhggjIIr5u+LP7NUNz52o+GVW2u+XewPCSf9c/7v+7X1/e2YYHiue1DShKrArXNUpKSsz2MHmNXCyvBn5ryR3Ok3clvdRtBPGcMrDBzXUeGPG0+jzq6SFcH1r6b+LPwR0/xtbyTKi2upqPkulH3vZv8a+RfF/hDV/BOpy2OpwNEw4D4+SVfVTXkVqDifpuX5lTxkUou0ux9f/DL472ur2NvpussZ4o/9VMGxNEfVW/pXv2j+L/s6QpezLcWM3FvqcZ+R/8AZf8AutX5f+H/ABHNpcy/OQAeDX0V8JfjhLpP+iXTLdWM2Flt5eUcf0PvXHCUqTvE7sXgqOYQ5Kq16M+3C3Wkrzbwp4tihsVu9NmbVdCxmSAnNzY//HEr0GxvYNQtUuLWVZ4HGVdDkGvVpVY1FofmGY5XiMvlaorx79BbmESKT3rnNX01bmJ1ZQciuq7VRvLcEEitrHmwkfCf7SnwOk8P6jN4m0OAnTJT5moWiD/j3f8AvqP7rf8Ajv8Au14zoWvT6NcJJE52A9u1fpJrWkiZJVeNXRwVKsMgg9j7V8kfGX9nSXSXuda8LW7SWfLz6aoy0fqYx3X/AGa46lK60PuMpzOOlKu7eZ2Hwh+P72Sra3TLPaSDbJDJyso/uste1aXfiSH7V4I1KJFIzJ4e1KTEJ/64v1j+jfLX53W2oSW+cV2Phn4o6roci+XMWRegJOR9DXlShKLvE+wn7KvHkrxuja/afu766+LbtqWmT6TdizhV7edlbsfmVl4YH19jXI6Wf3Aq78QfEo8c6vFqlyzPcpAsOWbPC5/xqlpf+oFbJt7l0qcKMVCnsj6x/YWP+g+Lz/09xj/x2vqs9DXyx+wtDjSvFxz/AMvkf/oNfU56V1wV0fnOcu2MkULs/I9fnh+14P8Ai911/wBeNv8A+zV+h93916/PD9rz/kt93/142/8A7NQ4nXkmuIfocZofNuPpX01+xZZZu/G7kc7rUZ/CSvmnwTdWy3aC5/1Q+8K+wvAl74LvLGz/ALGl/wCEY1mNAkeo2fzb/wDZuIj8sw/3vm/utXA3yyufZ4rDSxVFwi9T3b7IrL0FUrrSI5QcrXM2HxJn0KSO28X2sNmrnEWt2O5tOn/3m+9Cx/ut+dd3DIlxEskbrJG33XXkGt4zUtj88r4ephp8lRHD6p4ZDK2FyPpXkHxF+BmieMVd7m28i8A+S8g+WVfTJ/iHs1fSctuHB4rGv9HjnVvl5q9wpV50XeDPzk+IHwf13wHM73kJvtP/AIdStVJA/wCug/hP1+X3rlLO8utMcPE5KjuP6jtX6Oal4XWRXBQMDweOteC/Eb9nHT9Wlku9F26PfclkRcwS890/hPuvrUuKZ9RhM2UvdqHlvgP4yXWjyxh5WAU5HzdPoa+k/Cfx40fxXbW9trMa3vlf6qQt5dxAfVJB8y/jXxr4o8F6p4SvzbaravYS/wAE3WGX3Vuh+n3qyrfULu24z0rlnSTPpadWFRXWqPrD4wfEA6vqxt21S71Ows+IReOu1f8AaZF+Ut/tN81eO6z45X5ljO8+vavOpNevJ+JGYj60/TLO81zUIrOzt5ry6lOEgt03u30FTGmkF401aCsi5qWtTX8h3OWJ6AdKm8KeC9c8b6kbHQ9Om1C4A+d0GIYT/wBNJDwo9uW/2a99+GH7IUt+Ir7xjceSpwy6TaPyf+urj/0Ff++q+qfC3gfT/Dmnw2dhaRW0ES7VjjQKoH4Vq2oo8SvmUaTtDU+e/hZ+yDp1gYb7xbMuu3qkMLQKVsoz/u/8tD7tx/sivpHTtAt9MgSGCJURAFVVXCqB0AFbttYLEMkc1Ls7YrjnUb0PnquJqYiV5vTscX4j05VhJwOa/OD4pOdR+LviWfrtnWPP+6oFfo98S9et/DPhPVtVuseVa20knPqAcV+aFm8uoT3F/cfNPdSNM5PqxzW1Ha57eXRcm5D4x5cJNfan/BP/AEv7P4G8T6iRzd6ksQPtGgP/ALPXxVctsjIr9IP2WPBz+DPgf4ZtZU23NzCb+b3aZi4/8dK1livgsdmYTUaVu567uo3UlFeOfKJj6dUe6uY8c/EvRvh7pRvdUlYu52wW8YzJOw6hRStc6qMJVXyxOg1XW7LQdPlvtRuY7S1iGS8hxXzJ8Vvjpe+LBLZaW76do5+UtnE1wP8A2Va4X4h/FHUfG1+13qdzsgU5is1OI4vr6mvJ/EnjQxhhGxx6+v19K76OHtqz67C4GFFc09WbWs+KEtwyRnLegry7XvFk+oyMquQnrVDVNdlvmZVJSL9T9a9m+Bn7Luo/EJ4NX11ZdN0LOVBGJLgew7L/ALVehaNGPNM6q1eNOOp578M/hB4k+LmsfZdMgMdqrf6ReyAhIh6f73+zX3n8HvgL4f8AhXpypY2/nXzgedfTDMsh+vZfau28HeCdL8JaZDp+lWcdpbRjAWNcZ+tdXDAF5xzXi4nFSq+7HY+arYt1dI7EFtbRqOFX/vmtCKMAcfypUAHapVIry2jjTY9ABT1pgOKUNWVjRD6KAc0VDRaYq06mjinVg0axY5elLSL0NLWbRrEdRQOlFYNGiY8dKcOlMXpT16Vi0aocvenL1pi9aeKxaNEPXvTl601etOFc7Rsh1KvekpV61k0aIdSr1pKBxWDRY+nDpTacOlZWKQ5elLSL0pamxSEPSm0ppKzZSZ8/bqXIpmRS1/ZVj+V7jwaUNUYOKUN61NikyQGlzUYpQcVFi0yTdQDmmbqUHNTYq5LkUU2ilYdx4OKUN60wGlBzU2KTH0oOKYDilDVNi0x+RSg4plFRYpMmBwKM1FupQc1Fi0x+aKaKd0qbFphTxyKaBmnVFikxynilpgOKXdU2LuOpKWis7FJlWWINmqM1mGB4rUYdaiZM5qHE2jI5e+0sMG4yK4Dxx8OdN8V6fJaaharcREHBI+ZD6g9q9fktg+eKyr3TgQeKwlBM7qGInSlzQZ+d/wAVPgtqvw8uXuY4nutFdsJcKM7PZvT61xelanLYuCGO3+VfoxrXh+K7t5oJ4Unt5RteN1yrCvlT4wfs7T6K0+r+Go2nsuWlsurx+6+orya+Gcfeifo+V53HEfu67tLuQ/C/4w3nhy7jeOcgA888Ee9fUPgbxlB4gc6hoEsNnq0p3XOlO222vD/eT/nnJ+h9u/56W9xLaSnGVZTgqeK9D8D/ABFudHuI3SZlKkdDXm8rT5o7n17dOtB0qyumfo3oPiK11+KTyw0F1Cds9rMNskTehH9avSjOa+ePBXxVsvGMcMkt+NL8RRgLbauqbt3+xcL/ABx/+PLXr/h3x2mpXjaRrEKaZr0a5MKvujuF/wCekLfxKa9LD4hT92e5+d5rkksI3Woaw/I2rqBZEIxXK6vpWQ/y5B7Yrr25+lVri1EqniuuUbbHy0ZuLPmf4ofATRvGYlu4oRpurEZF5brguf8Apov8X86+cfFnwg8U+EGZ5bI3dop/4+bMeYoHqy9Vr9D7rRVcH5fyrn9Q8LrID8mfw5rnlSjJao+gwecVsO+WWsex+cwHFbOkNujAr3/9qDwFBF4OTWYII4LuyuQJpI0+Z4zxz+OK+dvDM26cqTXnTjys++wWLhi4c8T7E/Ykn2p4us8/vQ9tNj/ZIZf/AGWvqLPFfFf7OviIeD/iZYuz7NP1ZP7PlJPAf70Z/Qj8a+z8100tj4vPqbp4nnf2ivdfdavm/wDaj+CQ+JFtaarpYEfiCwQxrvGxbiH7xiZv4fm+63+0396vpCYbs1i6zZfaLcttywGCPUVo4niYfETw9RVIPVH5bavp1/oGoS2N/azWN3H9+GYYYVreHfHd/okq4lYqD619r/EX4W6T4xsWh1GyWUgfu5lGJYz7N/Svl/x7+z3rPhsy3GmA6zZLzhR/pKD/AGl/i/4D+Vc0qVz77B5vTruz91no3w5/aClSP7PdSLPbuNskMwDK49CD1r2XwnfiMfbPBWpx6cX+aTQNRlZ9PnP/AExf70DH/vnmvgGCWaxl3RkqQcEeld54P+Kd7osq7J2UDqpPBrkdO2x70uSvHkrRUkfoV4b8f2msagukajbTaF4gxk6dejb5nvE/3ZF91JrqZrQg8rzXy/4M+M2leL9Pj03XYY9UtRgpFOcSRt/ejb7yt/tLXrGg+I9W0GFW025k8ZaGo/4852U6rbj/AGW+7cKPT73+9Uqq4u0j5bGZJa88K7rsd1PYgg8VhaloSzhvl59a1fDnjHRvGFs8ukXi3OziS2cFZ4j3EiH5lNXSAa6ou6uj5dxlTfLJWZ5N4k8FWuq2ktrfWkd1buMMkihga+ePF/7LlwDJc+GphGOv2C9dtn0STGV/4FX2rdaalwDgAH0qtHoYU8gCoc0tGd9DGVaHws+KPB37KfijXp1Oqm10Ky674pVmnb/dX7v/AH1+VfU3wz+Cvh/4eaf5WlWY+0OB5t1L880p9Wf/ANl6V6LZ6YsY+7+JrWgt1QdMVjKemhrWzCrWVnsVLDSljUEitNI1QYApyjAormdzi5r7hTMU+vLPjn8arH4S+HZCCl5rl0hSxsg2Mt/ff0UVly3Z04eEqsuWJ4h+2l8S0uxbeA9Pk/eOVutRZT91B/q0/wCBfeP/AAGvmLAhUip7u7ur+8u9S1G5e81C7kM09xIctI56n6egrJubrJPNd8Vyqx91hqKo01E6v4YeDJPiP8SdA8OxglLy6UTsB9yBTukb/vkGv1Sghit4kiiRY4kUKqKMAAdK+T/2F/hY2laHfePNTg23eqp9m05XHKWqnmQf9dGH5L/tV9Xg8V52IlzOy6HgZhWVSpyroS9jUZNLjNfN/wAZv2jyvn6F4SmWRwuy41X+GP8A2Y/U1xqDZxYbCzxEuWJ2fxb+PeneBopNN08rqWusvy26H5YfeRv4fpXyX4i8Z3er6hLqWo3b3l7Ifvufuj0Ufwj6Vzmp6wYnlbzGkkc5eRzlmPqTXFaz4gkkZlRseprvo0EtWfY4bCwwsfM29e8VfeBfJ7KK5FGvddv47a3ikuJpm2xwxDJJqx4O8Ga38SfEMelaLavd3Tn5n/gjH9527D3r73+Av7OulfC62+1yn+0PEEn+uvf7n+zF/dWumdSNJXMcRjY0dN2ed/AL9k+PTxBr3jCIXN4MPDpjfPHD6GT+83+z92vq/T9MSCNURAiKMKqjAAqe0tViQKowBVuNNteFWqSqu7Pma2InWd5EsUCqOlTqopqdKkXtXLYzjsPUClJxSLSnpUtGiFHSigdKKyaNUPpVNJRWTQ0x1OXpTQc0q1g0aJj1606mDin1m0bJir0paRe9LWDRomOXvT171Gvenr3rNo0THDinU2nDpWMkapjxT6jXpTx0rnaNUx4pRxSL0orJo0TH0UUVztFpj6cOlMXpT16VlYtMcvQ0E4pAcUZpWLTEoyKQmkrJodz58opmaXPvX9lWP5TuPBpQc1HupQRU2KTJBxShqjBpQ1TYtMkzRTMilBqbFXJaXJqPd70ob3pWHckDUoqLdSg1Ni0yUGlBFRhvxoDVFikySlyajDUufepsVceGpwNMpQcVnY05iQHNPBzUIb8KcGqbFJkoOKXIqMN70u6osWmPzRupuRRU2KuPoplFRYpMfSEcU2iixomNK1BNFuU1ZxTSvFQ4I1U7GNcWYYEEVgajoocNhcg9q7KSEEGqc1tkHisJQOmnUad1ufKvxh/Z6t/EIm1LRkW11cfM0QGI5/8ABq+XL/T7zQ7+W1u4XtbqI4aNxgiv0y1HSxIGwOa8g+KvwZ03x3aOZIxb6ig/dXSDn6H1FeXWw19Yn3GWZ44WpV9V3Pkbw74sn024VlkMbA9QetfR/gD4p6f4m02HSPEO9lQg215E22e0f+9G3b3HSvmfxl4I1XwRqj2epQMmD8koHyOPUGotC8QS6fKoLkAHhvSvJnCz13P0GjWjUhdO8Wfop4Y8aXWlT2+l+IZUmScYsdZjGIbwejf3X9RXogt6+M/hb8X4Xs/7H1mEahpFzgSWrHnP95T/AAt/tV9HeEvFX9hWdvHcXx1Tw5IQltqbf6y1J+7HP6f73tXRRxVnyVD43Ncj3r4RadV/kd5JBwaoy2uSeK1GbOaiZcg16tj4VHmPxL8Ir4q8NarpLrn7VbvCpPZsHYf+AsFNfnfBHPoeszWlyhint5WikQ9QQcGv1F1CAEk18K/tZ/D4+G/F8Xie0j22WqP5dztHEdwP4v8AgS/+PK1edXp9UfYZDi1Tqeyk9y14IvYtSt/IMnlvwUkHVHByjD6ECvtL4WeNf+Ez8OQ+ccajaYguk7h/730brX5ueBfFcmmaguW6H86+uPh14jm1D7Pqeg4OtWkYR7ReFvoe8f8Avf3TXHCr7N6n1mZ4D+0MO4w+Jao+ncVBKmQao+FvE1p4s0tLy0bnpJE3DRt3UjsRWqVzXqJKS5kflcoTpScJqzRiXOnJNnK9a5zVPDiuGIX9K7prcHNQSWocEEZqXGxtTm47Hzp8QfgZovi1ZJZrb7Ne44vLcbX/AOBf3vxr5f8AH3wh1rwPOzzwmezz8t3CMr/wIdq/Ra90dXBwPwrjPEPhlbiGRTGrqRgowyDWMqaZ9Bg81qUXyyd0fnpYatd6W4IYgDuK9R8FfHDUNIdFkmaRBjq3I/Gur+IvwEt5TNc6IF065OSbZ/8Aj3b6D+H/AID/AN81886raXWgX5tNStn0+67I/wB2QeqN0YVySpdz7PDY6FbWLPtTQ/iLonxAkhurqaXTdbjULFrVgdlwg9JB92RfZq9N074han4biU+KIEvtK4A8S6WpaDHY3EX3o/8Ae5X6V+d2ieJbvTJlkgmZCvoa+hPhP8ebjTpoUmmwRwVY/K3+FcnLKnrE6cRhaGMjaorPufaen3VpqtrHdWVxFc28gykkLhkYexFX0twPQ14f4f8AEPhq+la80fUJ/CmpyfM8mnhWtp29ZbY/Kf8AgO2u10vxb4hjXaV0fxHH2l0+6+yzEepjk+XPsGqvaKXxHylfJMRCX7r3kd+qgVJXGReP70f63wrrWPWKGOUf+OyVYX4gSOPk8M6vn/pssUX/AKFJR7r6nnf2di07cjOuAzTwM15TrXxiv7OKUwW2laayd729+0Of+2cX+NeJ/EH4q3Wuq0WoatcaihP/AB758i3H0jXr9WZvpUNI7qGT4io/edj1b4sftGaZ4UWaz8PtFrGqJlWmLH7HAR/fbPzMP7q/+O9/i/xj4k1DxLqt3q+rXb3l9McyzyH/AMcUfwr7VZ8T+MoQWiiYOw4CJ91a4PUNSe9kLHj2pxikfU4bA0sKrR1fcbd3xkyAcV2X7P3wXu/jV44MUwki8M6e6yapeD5dy9oVP95v/HR8392qnwm+DGu/GXxF9i00Na6TAR9u1aUfu4l/ur/ekP8Ad7d6/RT4c+AtI+Hfhy10PQ7UWthAMZb78rfxSOe5anUlyxOTHYxUlyRep1ulWsGmWVvZ2sSwW0EaxxxIMBFAwFFT6hrFno1hNe39zHaWkK7pJpWwqiue8X+ONJ8CaJcarq95HbWUQ5Ynlj/dX1PtXxR8VPjZq3xWv385WsfDit/o+mE/NKP703/xNefGDlueLhcJPFyu9u56J8Yv2jL3xx5+k+H5JNO8PnKy3AOJbwf7J/hWvBtT1pbVTHGQAKzdR8ReSGRTk+tctd6hJcs3zda7IwSWh9lThDDw5YKxZ1PWmmZlRvqa6r4S/A3Xvi7qINujWejow8++kXjHcL6mu3+Av7Ml78QJIdY11HstByGRGGJbsf7P91f9qvuTw34asfD+nw2Gn2yWttEAFjjGBSnU5FoeRi8wUE4w3OZ+Fnwg0b4d6PHY6TaiJcDzbhhmSU+pNejW1osGcdxipYUCqABgegqYDFeZNubuz5hzcndixrxUqimqRingjFc7Q0yVehp1RhqeGBrOxqmODUtNpQcVJSY4HFOplKDisjVMcDinA5ptA4rFotMeDinU2nDkVg0aJj6cOlMXpT16Gs2jZMUcU6m04c1g0aIVetPXrUdPrJmiY+nL0ptKvesJI1ix696evSo1709e9YNGqY9e9LSL3payaNLjgaWmU8cismjRDl6U9elMXoacvQ1lYpMWiig9DU2LTG5pu6g0lZ2Hc+edwozTaK/svlP5OUh4OKUNTAcUoOamxaY8H0pQ1MpQaixSY/dRkU2ilylXJN1LuqPdShqVirjw3vTt1R0A4qbFJkganA+9Rg5paixSkP3U5TUQOKcrVNi0yZTxS7qjVuKUNWdi0x+6lBptFTYpMeGpwb0qNTS1Fi0yQNSg5qPJpwNS0UmSjmimg8UZNZWNEx1FNyaMmlY1THUUUUguIVqNkzmpaCKho2jIoTW4YHisi+01ZQeOa6NlzVeWAEHisJQ7HTCdjyfxp8P9O8T2EtpqVqs8TAgEjke4NfG3xW+D9/8ADzUGkRWudJkb9zcgfd/2W9DX6FX1kGB4rkfEHhm21Wzntrm3S4gkGHikGQ1cFbDqovM+my3NqmDlZ6xPz20jVZtPlUhyAOhB6V7v8K/jTcaLKIpZFlgkGySOT5kkX0Yd65b4wfBC68HzTaro8bz6OSTIgGWt/wD7H/aryi0vJLWTKk/SvAq0XF2Z+oYXFU8VDnps/Qzwp46g0iwW7sS114ZGPNgBLTaZnv8A7UP/AKDXqdlewajax3NtKk8EgDJIhyGHsa/Pf4b/ABWvPD9zGVmIUcEHkEehHcV9KeCvHqWEZ1TRGNxpkn7y/wBEByYP700H+z6rVUMTKi+Sex8/m2SLFJ1sMrT7d/8Agntt1GrE5rzn4k+CrHxjoeoaVqEIlt7qMqfVT/Cw9GBwa77TNUtde0+K8s5VmhlGVZf5Vn6nabmIIr3FFTjdbM/PISlSnro0fmX428D6j8OfE1xpF6CQp3QzgYEqZ4IrsPhh8R7nw/qEOZmRlIwc9a+rvir8KdP8f6NJa3aBJ1Ba1vVHzQN/8T/eWvi7xr4D1j4f6w1lqluYnzmKZeY5V9VNeRXouD8j9NynM1XgoSfvI+7fAfjKw8YSjVdG1CLS/EhA84Oc296PSRf4W/2u/evT9K8Y28t0NP1aA6Nq3QW9yfll/wBqN+jCvzT8IePr3w/dRuszIVPDKa+jfBX7TEV9ZLpuuQ2+o2TcGO5Xcv1HdT7iuenUnR+HVHoY7LMPmC5paS7n17UeK8Q8OeP9FmQNo/iG90dj/wAut232y2X2Xd8yj6NXZWfjTV3XMcugasnrBetbMf8AgMi/+zV2RxUH8Wh8bX4dxlL+G1I7aVAc1n3lisynjn1rDHjHUTndoaE/9MtWt2/9mrIvviZd2oO6y0q1HrdaqG/9Fq1P29LucqybHr7H4jfEHh5Z0cbM56ivnr4v+HtKt9PmtNVijlEn3Lb70r/7o+9/wKu48YfFm7keRTrkca/889IttgPsZJdzH/gKrXhfiDxTaG4mmjBE7/fnkdnkk/3nb5jWDrKWiPpcDlFWkuarO3kjze38Iz2BmeRpIoHO6KGY5eNfQn1o+0ixBEfUd6t6prLXbsFJ5NVbPTLjUZlihiaWVyFVVGSTWe59MlYltfFuqWzZhd1x6MRXT6X8Zda00BZC7gdmJNeg+EP2aZX0Uy61dSW2oTfMiRAFYV/usP4jVfUv2bNTjJ+yX9rOPSQNGT/6FS5EzgWY4bmcVMwoP2gtS5BD/rSy/Ha/kBwG/Wobr4A+Kbcnbp0c/wD1znU/+hYpifAzxWemht/4ER//ABVT7OPY6VjaT/5eIoXvxc1W6J2sVrl7/wAQ3+pOxmnY57Zr1DTv2bfF12AWj02xH/TWVnP5KtekeF/2RrXKSa3rF1fsMfurKNYEHtu+Zvy21PIYTzHDw3kfLcVlNcXkVvFHJdXMx2x29ujSSSH0VVBLfhXv/wAJ/wBknVfFbQXvi4SaFpRww06Li7nH+0f+WQ/8e+lfTfgf4UeHPA8O3RdFtdPcgBpgu+Z/95zya7+xsREuerHqaWiPCxGbOd1S2M7w14X0zwppNvpmkWMNhY26hY4IECqv+J9zVD4hfEbRvhl4dl1XWJ9uTsgtk5kuH/uqPWqnxT+LGjfCXRTe6i4mvZRiz05D89w39B718PeNfHGr/EDX5Na12fzbjkQ26n91bJ/dQfzPeuRpzd2RgsDUxL9pV2LPxF+JGt/EzWTqesyGO0jP+h6ap/dQDs2P4m/2q4m/1UIpVTUepanvyM8Vhpa3Oq3cdtbRPcTyttSKMZZj7Ct4RSPsIRjRhyRIJ7lrst82B7V9Qfs6/sqfajF4g8Yw/ufvwaU/8f8AtS//ABNdZ+zx+y9D4TSHXvEiJd61w0NqRmO2/wDij719O2FgIRzRKVj5jHZlzN06T+Y7TtOitIVihQRooAAUYAFa0ECoM96bbxDGe1WK4Jau7PnnNt3Y9FFO6U1e9OrE0TFXrTqavenVk0WmOpQcUlFZNGqZIDTqZTlNYtFJjgcUtNpQcVmzWLJM0Uyn1m0bIcvSnL3pi96evesWjRD1705e9NXvTl71kzZDqVe9JSr3rBosWnjpTKcvSs2jVDx0py96avSlXrWEkaoevWnr3pgpw4rFo1Q9etOpo4pwOaxaKQU5elNpy96yaNUxy96evemL3p696ysWLSGlpDSsUmMPemZNOPemVlYs+d6KbmjJr+zOU/kq48HFOzUYalBpWKTH04H1qMGl3VNi0ySimA0uTS5R8w8NSg0zdRkVnYq4+lHFMBpQ1KxSZIDmimA+lKDiosWpDwcUoNM3UZFTYpMlBpwNRg0oOKzsWmSjmlBxUYPpTg1TYtMeDmlHFMzSg1FjRMkHNKppgPpTgamxaY+lBxTN1KDUWLuPpaYDTgamxSY+lFMBxSg1Fi0ySjtTBS5qbFJ2EIzUbLnNSUYrOxqpFOWEMCCKzLuxznitwrULxZBFZONzeFTocFrOhJcRyKY1ZWGGQjIYV8r/ABl/Z+l0xp9c8OQM9rktcWCjJj9WQf3f9mvtS6sgwOBkVzupaVuDELn1GOtcdWiqisz3cBmNTBT5ovQ/Nu3ma2l69K9D8C+P7rQLuKSOVlCkHg9K9G+NPwEF75+ueHYQlwPmuLKIcP6sn+1/s189QyyWsrI4KuhwQa+erUHB2kfrOBx9PFwU4M+0/h/43+zzy6toce9nxJqOhQnas/8AemhXtL/eH8Ve5aPq9h4p0qLUNPlE0Eg/FT3Ujsa/PTwP49uNEu4pEmZChBVgeV/+tX0n4E8fzec2saMolnkAOpaOpwt4O8sX92UdePvfXqsPiJYd8stYnn5vk8MfF16GlRfie23un5DYGR3FcP4y8D6b4o02Sy1GzS8tmz8rfeQ+qnsa9B0XWrLxNpkV9YyiWCQfQqe6sOxHpTLzTxIDgYNe77tSN1qj81UqtCbtpJHw18Qf2edZ8Nma50LfrWnryYcf6TGPp/EP938q8t+xSxStGweCVTgpINrA1+i9/wCHllySMN2YCuP8TfDDTfEMbLqemwXfGBJt2yD6MvzCuCeFT1ifVYDiCUPdrq58T2mr6ppbBop3GPeuk0z4t6zYcO5ce9ezar+zLYvvbTNRntG6iK4USp+Yww/HNc1d/s367Hnyp7C4HuSn8xXG8PJH1tLOcHNayscXJ8ZtTcHr+v8AjWZcfFLU584Yiu6H7O/iMn/U2P8A3+FW4P2bPED/AHmsY/8Atpn/ANlrP2Mux0vMsLa6qI8hufEOpamx3SOQfeqf2KSUkySGvpLS/wBl2U4+2aqiDulrAT/48f8ACvTvCn7PnhrRSkgsPt0o/wCWl6d5/wC+fu1aos8ytneHp7O/ofMXw/8AgxrXjNlaxsWS1J+a7uBtjH0Y/e/4DX1V8Nvgho/ga2WQIL3UiBuuZVyFP+wvb+dek6Z4fitkVQgAUYCgYA/wragtETjAreNLlPlsXnFbEXjHSJgQ6BG45Vn+vAqGfwvC2f3RH0NdeLbil+zGm4nkRqN7nGR+FYx/B+dWYvDUa/8ALMV1i2g54py2oHasnEvnMG10VI/4QK04NPVf4a0EhC1IFArCSsLmbIIrYIOlcB8ZPjXpPwk0BpLgreavMMWmnIfmkbsW/ur/ALVUvjl8ctN+EOiNyt7rt0pFpYqeWb+83otfB+v+KNS8Ya1ca1rd699qszZMrH5Ik/55ov8ACtYPsfR5Zl8q79pP4TS8TeLtT8Ya3PrOuXTXepSnPzH5YV/uIv8ACtYF3qTSZVTgVTvL/qF/E+tWPCXhvVvGuuQ6VpFo93dzHHHCIP7znsPekon3PuUoXeiRFpOiaj4m1WDTtNtnvL24YJHDGMljX3B8Bf2dLP4aW6ahqMSX/iCQAmYjIg/2U/8Aiq2vgj8B9M+F+nJIiLd61Ko+0XxGf+Ar6CvYoYtgx37mnsj43H5m6rdOlpEisrIQr05q/HH7U6KPNS4xXOzwExY/lFSVGvSnr0rJotMeD6U7dUanFOrLlNkx9Kp60wHFOB9KTiUmPHFOBzTAc0tYOJsh1KpxTQ1LWTiWh44pw5pinNKDisXE2RLRSKaWsWjRDl6U9elMXpT16Vk0bIeOlPpi9KeOlYMtMcOlLSL0paysbRHU5elNpy9KzkjZElOpg5FOU8VzNG0WLSjikoqOU0Q+nKc0xehpRxWbQEq9KcveowcU9TWLRoiRehpy96jzSqajlNEPNMJpScCoi1S4gLSUinNLWDiaI+cs0A+9Mor+zLH8jXJA1LkVGDSg5pWKTJAaUNUYOKUNSsWmSAijPvTAc0tKxVyTdRkU3OaKzsNMf0pQ3rTBxSg+tTYpMeDmlzTKUHFRYtMfuozTcil61NirkgNOBxUYOaVTisrFpkoPpShvWoxxTgamxaY8HNKDimUqmosaJkgPpTgajBxThzU2NEyTdS5FNoqbGqkPHFKG9ajBxTutTYpMeDinA5qMHFOqLFpj6MmmA4pQ1RYpMfmjdTQc0tZmg7rTStAOKcDmoaKTK7x9az7q0DAkCtcrwagePrWLidEJ9GcfqOjLLuZRtf19frXzz8a/gZ/b4n1nRoBHqSZaa3UYE3uPf+f8/qqe1DA4rn9U03ILqPmrlqUVUVmezgcdUwdTmi9D82GWSwuWDAoynDKeoNdl4N8a3Gh3UckUrKFIPB6V7T8dvgiviKOfWtFhEeqIN00CjAnA7j/a/nXzAhe2kKONrDqK+frUHTdmfrWX5hHF0+eD1PsPwL8QmtbuTWNIILSgHUdKBwLkf89UXtIvf+9X0FoWtWfiTTIbyylE0Mq7gw/ka/O/wX4vl0u6jxIVKkbWzX0v8NfiSmlySajaHfbtg6hp4P8A5Gj9/wC8P8nPD13QlyS2OPOMojjoPEUF76/E+hWtyeMVG+mKwOV/KrOn31vq1lDeWsglglUMrLVsLgdK99NSV0flU1KEnGW6MJ9HT0qu2gxnPyj8q6Yxg0CFT2FDRUZtHNx6Eg/hH5VPHoyD+H9K6FYFpwhHpXO0a+0Mq30xV/hAq/FaKnarKoAKeq0rFKpcSOPsBU6Rhfc05BhaWoLTHYFOQcmkpV71k0apj1HFKBikUjFLWTGmFeY/G3436Z8I9A3ki71u6G2zsB1J/vN6LVr4yfGPTPhP4caecrc6lMCtnYKfmkPb6LX59+KPFGpeL9cvNZ1m4a5vpyTyeIx/dX0Fc0tT6nKsteJftavwr8SPxD4h1HxTrN1q2rXb3uo3BzJM5yFH91fQVhzT7QQvFSiXIrc8DeANV+IniCHStJhMkrkGSUj5Yk7s3tUcp903ChDskUvA/gfWPiFrkOmaZA0sshG5gPlQd2PtX338FvgtpXwv0VYLeNbjUJQDc3rD5pW/ugdlqf4TfCTSvhnoKWNhGJLhgDcXbL88zd/oPQV6daW4ijGBWb8j4jMMyliG4Q2FigINXYosCo0GKmR8VB4KY9V20tNDZpwrKxohy9DTl601e9LWbRaH0UgOaWsrGooOacDimU4VLLTH0oNNXpS1gzZMfSqaaKUVmy0x44p1Mp9YM2ix9OHNNpV71i0axY9e9OXvTF609etZNGyY9ehp69KYtOWsGi0x606mU4GsrG0WPpy96Yppw4qGjZMevenUynA1g0aJjgfWlptCnFTY0THg4p1Mpy9KyaKuSUq9DTVHFP6Cudo1QU5elMXvTxwKmxpcGbioC1PdutRDk0mhXJEOKfmogcUb6waLTPnKgHFMzS5r+yrH8h3HhvWlqMNSg0rFJkgOKUGmbqXIqbFpj6OlMB96XJpWKuS0A4pgNLmosO48H1paYDSipsUmPBxSg5pgalyKixaY+imjijJqbFcxLTgc1GDilBzUWLTJAcU6owfWlBqbFpjwcU4HNR7qcDUWNUyRTS0wGlBxU2LTJaUHFMBpd1YtGiY8c0oOKYKUN61NikyQc0oOKYDilBqLFpkg5oplKDipsUpDgcU4Go8mnA5qHE1TuPoBxmmUqnrU2NEySmuOtLnikPNZuJomRFeDWfdw7latMDOaryx5BrDlN1M5LUdMEysQPmr50+OXwN/tkT61osOzUly01ugwJx6j/a/9Cr6pmtgc8VharpYlU8c1zVqKqRsz2MuzCpg6inBn5tRs9tKysCrKcEHgg13/AIB8bTaVeIyyEMOCOzCvS/j18ETcef4g0KDFwoLXsCD74/56KPX+9+dfPFtcfZ+lfN1qLi+WR+xYDHQxVNVaT9T7h+FXxCj0YIyOX0eYgXNoOfszf319q9+inS4iR42WSJ1DK68hl9a/OrwH48l0y4TEnXhlPR1/u19VfCX4mRQRxWNxITp0x/0aVmz9mf8A55t7H+Gqwtd0peznseHnmURxcXicOrTW67/8E9upV60lFfQH5dclXpTlqMcU8Gs2ikx4GTT1FMFPWsmjRMkXpRQvSisi02PoopCcCoN0xN3vXF/Ff4raT8KPCs+r6lIGk+5bWoOGnk7KK0vGvjLTfA3h+71fVLgQWkCktk8sewX3r86Pin8T9T+K/ieXVb92S1QkWtrniNexx6muKpLoj6XKsseLl7Sp8K/Eh8ZeP9X8fa/da1rU/nXcx/dpn5YE7IvoK595i2c96rZ961/CPhnUvGuv2uj6Vbm4up2xx0Re7H2FYLU/Q+aFGHZI0PAfgXVPiBr0Ol6XCZHc/PJj5Y17kmvvz4T/AAo0v4aaElnZoJLlgDcXRHzTt/Rf9mq3wZ+D+mfDDw7HZ26LLeOAbq7I+aVv8BXpsCKowBgVdtD4TMs0eIk4Q2FhhAXhQPwq4OlMUcVJU2R8+hw6U5e9NpQcVm0apki9KcDxUYOKcDWTRqmPBzRTacDmsWi0xwOaWmU4NWTRqmSU5elMBpVOKhlJki9DS00cU6sGbJjh0py96YppwOKzZSY8dadTRxTqwZtFj6BxSKaWs2jeLHU8UxelOXpWTRsiQcU8cVGOlPHSsGi0x9FIvSlrKxtFjxxTqbSr3rNo2THqaWmUoOKysUmOBxThzTQc0q1DRomPXpTl701e9OXrWEkaJkq9qU9Kappc1g4miYq96cThaYDikduDU8pdyNm5pV6GoyeacrYFPlI5hXbFRb6JG61FurJxLUj54zS5plGa/six/ISY/dSgimA+tLRylJkgOKN1MBxSg1Ni0x+RSg0yilylXJgaMmmA0oaosO4/dSg+lMBBoqLFpkgb1pQaYDS1Nikx+aMmmUuTUWLuS5pQc1GDinVnYvmJA3rTgfSmA5o6VNi0yQGlBqMH1p1RY0UiQH1pwOKjBzSqamxakTBqN1NB45oBzWVjZMeKcGqMHFOqLFpjwcU4NUYOKdU2LTHijNMzilU1Nih4NL0ptOBzUNG0WOBpaZTlOazsaokooFFZtFgB1pjJkGpF70EVi0VcqPF1qnNbhgeK1GUGoXj61FjSMrHG6xpeQxAz6ivkv48fBo6NcT6/o0H+hud1zbIP9We7Aeh9K+07233Ka5bWdFjuoZI5Iw6MMMrDgiuWtQjVjZn0OWZjUwVVSi9D86YLhrdhzx/KvUfAXjVrWRYpX3I3BB/iH+NQfGv4SS+B9Xe8sIy2i3DZUj/lif7rV5zY3r2koBJGOh9K+bq0nFuMj9nwuIhiaSq09mfoj8H/AIiLrdlHpd3NvuY1/cSsf9anofcV6fX5/wDw58dyW80SmYxyIQyODyp9a+1fh143g8Y6Kkm4LeRALMme/r9DXXg8TZ+ym/Q+A4jyfkf13DrT7S/U64HIpV70wU4cV67R8JFki96cDimDinZFZtGqZKppcmo1PFLvwKycTRMlqtql/BplnNdXUqw20Kl5JGOAAKU3BzXxz+1Z8ef7cvLjwVoU3+gxN/xMbhTxIw/gX+tcdV2R7eWYKWPrcn2VucF+0P8AGqb4teJHgs3ZPD9ixW2QHiZh/wAtG/8AZa8ixxT6kt7aS6lWOJSzscACvOP1elShRgoQVkg0fRb7xBqkGn2ETT3MzBVRRmvvf4B/BO0+F+hB5kWbWrpQbicjlf8AYHoK579nD4FQ+AtOj1rU4Q+v3SggMP8AUIf4R7+te/29vitoQ7nw2bZn7V+xov3V+JNAgCgDoKuRJUUSYqwuAMVpY+WHU+mU+s7G6HUUZFFZtDTFBxSg5ptFZNGqZKDmlpg4p4rFotMcDmim9KcKyaNUx9OU1GOKd0rNxNESKacDimCnDkVg4myH05Tmo1NPBxWTiWh6nNOU4pgp1YuJtEfT6ZTl6Vm0bxHL3p696YvenL3rJo1TJF6U9elRr3p696wZohy96dTRTqysbRH0DikyKMipsbXH0UgPFLkVHKCYo4pw4plPHNQ4mkWPWnUwU+uaUTZDt1Kpph6GiPvWfKNEpOBUDvUkjYFVWfJNCgO4/NBfApFPFRO3WjlJuKWzRTFOafWbiNM+dKOlJuoyK/sKx/JFx4PrS0ygHFKw7j80u6mg5paVikxd1KrU2gcVNh3JRzR0poOKUNUhccGp1MpQcVFi0xwOKdTaVTipsaJi0q96SlHFRYtMkXpS00HFG6s7FIeDS0wHNOBqbFpjwc0tMBpQ1RY0TJAaUHFMyKKmxaZKGpwNR0oPrUWNUyQU4HNRg4pwqGjRMeOKcDmow1OB9KzaNUyRTxS9KYDTg1Z2NEx+aWmUoOKmxaY9TS0wHNOBxUNFqRIOaVTimA0oOazaNEySimA4pd1Ryl3EoxmgDNOAxWTiUmVposg8VlXVtweK3SuQaqzwgg8cVlY2hOzPOPGHhKz8RaXdWN5CJraddrqf518QfEj4e3ngHXpbCcM9sxLW056Onp9RX6HXlr1GOK8w+K/wztfHWhTWkihbpAWtpsco9cGJoe1jdbn2mS5u8HU5Knws+KND1BrWZTkgqa9/+EHxHl0LUYLlJCVGFlTP3o/8RXz1qum3Oh6nPa3KGKeBzG6njkVseH9cexmV1Y7c818tUg0z9cShVg4y1TP000TV4Na0+K6gcOjqGBFaNfM3wA+KC2d1HpFzLmzuf9WWP+rf0/z/ALVfSoNe/hK3tYWluj8cznLv7OxFl8MtiTpS7qaDmlrvWqPBHg4phbg0+uM+KvxCsfhv4Qvtc1B8RQIdkSn5pX7KvvWFRqEW2dWHozxFRUqe7PMP2nPjqPAGjNoOjzbvEWoIwDIebaP+J/rXxBEMZJO525Zj3PrVrxH4l1Hxl4g1DWtUkMl3eyb2yfuL2Qew/nVNDXgzm5u5+w4DBwwVFUqZYr6m/Zb+CQdovF2swfLkHToXHXn/AFjD/wBBryz9n74RyfErxQsl1Gw0WyYSXMnZ+eEHua+/NLsYrSCNI41iijULHGowFA6cVpSp82rPDzrM/YxeHpPV7/5Fq2tBGBVpRg0wVIorp5T4LmvqSKcVIDUY6U4HNS0WmSL1p1MHIpwNZtGqY7dSg5puaOlZNFoeOKdTAc05TWLRoiQcinL0qMHFOqWjVD6UGmg5paxaNB1PplOXpWTRoh46U5e9NXpSrxWLRrEdTl6U2nL0NYNG8R69DS0i9DS1k0aoevWnr3qOnqazaNESL3p696jXrTwcVg0axHDin0ylU1i0bIkXpRTQcU4HNTymiYu6jdSUVmomnMPDelLupg4pwOaTQJjxUi96iXpT1NZG8WSr0p4OajU04VhJHQmOpw4FMBpssmAazUbjuNmk61XzyaRpMmlHStlGxg5Dt+BUTNnNMeSiM5qHC2pKkTJTt1RlsCmb6y5LmqmfPG6lyKj3Uu6v6/sfyNzDwfSnBvWowfSlDUrD5iSlB9aYDilBzSsPmJKKZS5NTYfMP3UuRUe6lBrOxaZIDilBzUYOKcDmosWmSA4pQc0wH1pRU2NEx4OKXdTA1LkVNi0yTJpQ1M3Uo5qLFXHg5pQajpwOamxaY8GnA+tRjinA5qLGiY8HNFNoziosWmSg0oNR08HIqLFqRIDilFMBzSg4qWjRSJA3rSg+lMBzSg4rJo2UiUH0pQ1Rg4p9RY0Uh1KG9aaDS1Nikx4pQfWmA4p1Q0WmPBxTgc0xTxSjis2jRMeDil3U0c0VFi7j1OKfUY4pynFQ0aKQpNRsMinUVi4miZSuIdwNYl9abgwxXSOmQaz7q33A8Vg1Y6ITtoz5c/aQ+FP9rae/iLToc3tquLqNB9+P+9/vD+VfMNpKYpCpr9ItTsFlR8oGBGGUjhhXw98cfhy3gTxTJJbof7NuyZbduw/vJ/wH+VeHjaH24n6tw3mftYfVar1W3oM8Ha89vIE8wowxhgeh7Gvtn4KfEhPGehLaXMg/tO0UK/PLr2Nfnhp960Tgg8ivWPhZ49n8L67aalA5CxEC4TP+siz83/fP3q8ilN0p3R9TmOAhmOHlRktenqffympB0rN0PVbfXdKt7+1kEsMyhgwrQr6mL5o3R+JVKcqU3CW6HSSiKJpD9xfvH0r4D/aS+LknxS8XvZ2UxGgaa5jgUHiVx9+Q/wDste6fta/GD/hDvDA8NabPt1fV0IZkPzRW/IZv+Bfdr4tWvGxtW8uRdD9D4by90qX1mqtZbeg0Lmt3wb4Ov/G3iC00fTk3XM7Y3EcIvdj7Cs+2tw3Jr7Q/Zk+Eg8J+Hm13UItuqaiqlAw5ig/hX6t94/8AAa4qcHUdkfRZhjo5fQ9p9roepfDjwFp/gXw7a6VYRhYIQC8hHzSv3Y12UfemooAwOAKevWvWjBRVkfkkqjqScpbk0fQ1KOKiTpUgOaVhDgc05ajp46Vm0WmPU4p1NFOHIrNo1TCnKc02lHFZtGiY4cU4c02nL0rFo0THqcinKaYvenDioaNkx1KppKKxaNEyVTSrTBxThWTRqmSLTqYKfWTRpFjhyKcvemL3py96waN4sevenU1e9OrJo2THU5elIKcBWLRsh4p1NFOrFo0TFU4p1Mpy9Kysapj1OaWmU4Glyl3HbqN1NzS0uWxNxwOaVetMXrT161jJGsR696evQ01RwaeBgVzM3iOXpS5xTVOKXIrFq5snYUtiq8suc06V8A1VLZNawgZuYqnk05pMDFMzgVC0mTXSoX1MHMcTuNSpwDUUYzTi2Kzkr6EqQrPTaQcmn7KxasapnztupQabRX9a2P5JuP6U4H1qMHFKDmixVyQHFOBqMHFKDU2HckBxRupgNGTSsO4/dShqjyaUN61Ni7kgOKcDmowcU4HNTYtMkB9acDiowc04HFRY0THg5paZSg4qbFpktFNyaN1ZWKTHg0tMBzTgcVNi0x4OaWmA5pQ1Q0aJjw3rTutR5FLU2LTJAc04HFRg5pwNRYpSJBxTgc1GDinCoaNFIf0pwOajDetOB9KyaNoyJFNKDimA04NUWNFIkoBxTd1KDmpsapj6cpqMHFOBzUNGiY8cU4c0xTSg4rNo0THg4pQaaDmlqLFpjqVeKQHNFZWKH0UgNLSsNMQjNQSx7gasUhWocTdMxbu3BLdq8w+K/wAPrfxt4ZutOlQebgy28ndZB92vXZ4gSaxdTtN6sMe4rnnTUk0z1cLiZUZqpB6o/NS+06fSL65tLhDFPbyGN0PUEGtvw/dBeCa9c/ac+Hv9nalF4ltIsQXJEV0FHCv2b8f6V4haS+XnFfIV6TpzcWfumBxkcXQjWj1PsX9mf4ni1nbwvqE37mTc1kzHp/eT8P6+1e8eJPElp4c0a91G9lWC1tYmmlkJ+6oGTX536Zrt1DClxYzGDUrdhLBL6OOn59K7D4v/ALSo+JvgfR9J0tjDc3Q36yn/ADyZWK+X+YLf7pFb4bFOnBwfQ+czTJvrWNhWh8MviPOPiF4zu/iL401PxBdkg3Eo8iM/8soV+6o/z3rEUE0oFaOkaTcavfQWlqhkuJnCIo7k1xzvKVz6yMVTioR2R6z+zh8Kz4/8Vpc3cRbRtOKyzk9JG/hT8cc+1fdVvBiuK+D/AMP4fh74RsdHRR5iqJbl8f6yQ/ervVFe1hqHs4XfU/Jc4x/13EO3wx0Q9BinL1pB0py961seImPXvTwc1GOKcKVjVMlHSnL3qNTinjismi0yRehpQcU0HFOrJo1THUUZorFotMfTl6GmKc05TWLRpFj170tNBxTqho2TH0UgNLWLRomPpV70wHFOHFZWNEyRelOXvTFp68Vk0axY5aevWmU8Vg0bxY9adTV606srGyY9etPXrTBxTgaycTZMeOKdTAc0oOKycS0x1L0pu6jdUcpakPBzS0wHNKD70cpfMOoBxTcmnVnJDix69akUdajXtUq9q5ZI6Yj1FOpoOKC1YOJsnYdmml8CmF+tRtJ1ojATkEj5zUIODQXzTS2BXXGmczmDvwahHJpc5NKBitGuVGVyRTgU0nNJuoUVyyVjSJLGKlqFTin765nFs64vQ+csmnA5ptC9a/rqx/I46iiilYBwb1pRzTKKVikPozTQaXdSsA7dSg5ptKKiwx4OKcOKZTl6VFi0PpwOaYvSnKcVFjRMcDinUwHNKOKmxaY/OKUNTA1KOaixSY4HNOBxUdOU5qLFpjwc04H1qOnA5qbGiY8Gim0ZqLFXJQaUGo6cDkVNikyUHFKKYppQcVm0aJkgNKD6UwHNKprNo2iyQH0pwNRg4pwOaixomS7qWmUdKmxomSA4pw9qjBzSg4qGjRMlBzSg4plKprNo0TJAc0UynKazaNEySlU00HIpaxsbodSg4pByKKLDH0UUVBpcjlTINZ9zFvU1qEZFVZI+tZyRrTlys888d+FbfxNoV9plygaG5jKZI+6ex/A818E6rpc+g6xd6fcqVlt5DE2fYnmv0h1G13K3FfIv7UPgr+ztWh8QW8eIrv8AdXBA6SL90/iv/oNeJj6N4c66H6NwxjeSq8PJ6PY8csbgxSDB71m6vZQ2+oyyW6CPzj5kmO7Hqf5UQXHOehFS3D+fJuNfNpWP07canQV9I/skfD/+09ZuPEl1Fm2sf3duGHDTH+If7o/nXz1pVhJqF9DbxqWeRgoA9TX6JfCjwbH4G8DaZpIUCWKMPMfV25Nd2Fpe0qa7I+Z4gx/1TDckX70tPl1O3g6Zq0g4qrBVpPu175+R3HhaXpSAjFLWDRqmFKvekpVpWNUyRelOU0xacvWsmi0yRelOBxTFp1ZNGsWPpQaaDmlrJo1THCng5qNehpy96xaNESKc04HFRjin1DRsmOpc01ehpaxaNEPpw6U2nL0rJo0Q8U+mDpT6yaNYj6cKYvSnr0rBo3iPFPpi9qfWVjZChqcDimUqmp5TRMkBpd1MHFLurNxKTHbqN1M3e9Ab8ankKTHhqUGmA5py96XKVckpy9KavSnL0rlmjaNyRalXtUS9akU8VzWOqJJTGagmo3brS5Sm7DGfGahZ+tDt1qEtXRCmc8pjt9JuzTM0V0qFjDmuPXrTs4plGeazlG+pohRyakXpTENOLcVyyjc0TsIXxSeZUbN1pm+pVMrnseA5FGRTMilr+rj+Tbj6M0ylB9aB3HZNLupKKkpMXdSg5ptKvekO5IOaKRelLU2KuOXvS0wcU+paKTHL0pQcUxTinVDRaY4HNLTKcG9amxSZJRSBqWszVMFOKdTacpyKixVxVp1Mp4OamxSYDinA5ptFQUmSg5optKDU2NExymnUynBvWoaNEySlB4qMHFODVm0aJknSlDVGD70oaosWmTA05Tiog1OBrOxqmSg4pciowacDUNGiY+lBxUfSnA5qLGyZIKcDUamnA4rNotMkBpwOKi3U5WrI0TJVOKdUStTgag0TJd1GRTA1LmpY0xxNNIyKQmkqTWLKN2mVNeUfGXwiPFPgzVbELmYxmWHj+NeR/UfjXrkwzmsLVrQSRtxmuarTU4NHrYLEvD1o1F0PzS8po5CGGCDgircSZ5rqPih4aPhnxxq9jt2xrMZI/wDdbkfzrnrRNw+lfEVIOMmmf0BRqKpBTjsz2X9mLwGPE3j62vZ491npg+0uSOCw+4P++v5V9yRQ8V4D+yL4Wk07wbfapKuP7Qn2xH1RDg/+Pbq+g4xgYr38DS5Kd31PyLiTF+3x0qa2hp/mOjTbUw6VGvenA4ruaPmUx+aUc02lXvWDRrFki9KVe9NXoacOtZtG6Y6nL0ptOXpWTRqmPXpSikHSnKOKysbxYtOHSm08VmO45elOXoaaOlOXpWbRpFi0+mU+sWbRHDpTl6GmjpTl6VmaoWnr1plPFZM1RIvenL3pi09etYSRrEcKdTacOlYtG8WPHSikXoaWlY2TCnL0NNxSg4qLF8w8GkzTd1N3VagK47dSqaYDmnL3qJRLiyVOhqVKjTvUinFc7djaJIvSlpoOKUHNcclc64tDl608HFR9KUtWPKacySHlqhd+tNaTFQNJ1rohTuc86grt1qLNG7NJXWocqOZyuPFKFpBTs1ky0IelJQTSFuKhq5onYA2M0GSoWemqSTUqnbVi5iXOc0bDT4VzU+yndRGtT5zooor+oLH8pXHA0tMpQakaY9TjNOplAOKB3H0U3dS5qbDuPpQcU0NSjmkUmPHNKDimDilBzU2KTJOtAOKYDinA5qbFpjxzRTaMmosVcloHFNBpQaixSkPBzS9KZSg+tRYtMkBzSjimUoNTY0THg0tMoqbFpkuc0tMpQcVNi0xw4pwOabQvBrNo0THg4pQc02lWs2jRMdSg0lFRYu5IppwOKZSg+tKxSkSA+lOBzUYOKcD6Vm0aKQ8HFOpgNKDismjZSJAc07NRhqXdUWNFIfk0qmo8mlDVlylRkTKaepqENT1ap5TZSJqcvSoQ9ODis7FKRJRimb/egSVNjWLI5lqhdR7kNabfMKqyJkEVm0dUJHjPxO+DGmfEFFnkdrPU4gViuAM8ejDuK5Twj+yPFHqAm1PVxPaf88oI9pP+FfRD2wbqoNXLKFYkwFxXBUwtOcuZrU+jwueY3CUfYUp+6T6TpltpNlDaWkSwW8ShEjQYAAq9UMbYFSg5quW2iPFvfVklAOKQEUVJZItPWowc04HNZNGsSRaeKjU08HNZtGyH04dKYppymsWjRMkFPHSo1PFOBxWdjeLHU5elMyKcpxWNhpki9KVe9NU04cVm0axHU+mU5elYtHREevSnL0NNXpTl6Vm0bIWnCm0+sWjZD1604cU0cU6s+UtMeOaVTTAcUoOanlNFIkBxThzUYOKXIo5SuYfSZpm6lBzS5LApC5pKUDNOAxUPQ0ixFGKeooUU5RXPJnTEevenr0pi9Kco61zNXN0SCnL3qMHFOyKw5QUrClqieTGaR5MZqrJL1rWFK5LqD3l61EWqMvSr3rsjBRRz81yRTkU8UxelOBwKTNIjt1N3UlJXO4ml7C7qY0lIzYzUfWqjT6sjmuOB3ZqWNKZElWFGBUzfRGiHIdop/mVCWpu6s/Z33K5rHz7RTcmjJr+nD+U0x1FJuozQMd0oyaTNFQNDt1AOabR0oKJRyKWmUob1oKHg+tLTaUHFTYpMeDmlplKDiosWh4alyKbRU2KuS5FFNoBxU2BDwcU4c0wHNKOKmxaHg4p1MBzQDiosaJjwcUoNNBzS1Ni0yQHNLTKUHFTYtMeDinVGGpQfeoaLRIpp3Sot1KGrNo0TJQaXNRb6XfUWLuS7qN1RbxSb6ktE4alD1W8yl82s2aItB6UPVXzfejzfesWaot+ZR5lU/OpPO96yNEXhIKUSe9UfP96PP96DSKZfEtOEvvWd9oFL9p96hm6Roial86s37T70fafesmWomn51KJs96y/tPvSrddeazubxiawkz3pN4rPW7x3pPtY9azbNUjSVhUiOBWWt4PWnreD1rJs1VzXWQYpyy+9ZIvQO9OW9HrWLZsos1xLThL71lLeD1pwvMd6zbNVFmqJRT1lrKF3jvT1u+vNZHRGJqrLTxJWWt171It171mzZI0xJT1krNW596kW4681kykjRV6cHqis/vThPms2apF0PTlaqYmp6ze9ZWNEi6rU4NVRZaestZtGkUW1anqaqLLUiy1k0bRLSmnA4quslOElZNGqJw1OVqr+Z705XrLlNEywrU4NjvUCvTg9HKUmTbqUNUIanBqXKUmSg+hpd1RBqcD71Nikx+acpplOWs2zREq96cvemLTulc0jeI+nL0pgOaUHFc7R0RZKOlOXpUStTt3FRY15h26mNJimNJUDy1cKVzCUx0kvWqzNmhnzmm12xpqKOfmuKvepU6GolGKkU4rOSNYktFMDUu73rDlZd7DqazYBppk4qMtk1pCn1Yua4pOafGmaSNc1Mvy0pvoikKBtFG6mF6ZurFU+rL57ElJupm+jdWqjchu54BkUZFNor+jrH8uj6KaDinUhhThzTaVehpDQtFFFKw7j6KQHNLTFcUHFOplOXpUlJjl70tNpw5qCkxQcUoOabRU2LTJQc0tMpynNKxshacOabSqamwxwOKdTKcpqLFIWlBxSUVJSH0ZNN3Ubqk1Q/NG6o80VDNESbqN9R03dWTNETb6N9Q5NGaixZL5lJ5lQ7qQnioNES+b70nm+9QZpu6smapFnzfek873qtupN9YM1SLBmpDP71VL03fWJtFFnz/ek+0VUL0wyVNzrjEu/auOtNN371QMh5qNpTzWbZvGKNI3nvTftvvWUZTUZmPNYtmsYGx9u96T7f71imdqb9oPrWVzojBG7/AGh70n9o+9YRuDTftB9als1VNHQrqHvTxqHvXOrcH1p4uT61m2aqmdANQ96kXUPeueFwfWpEuD61i2bKCOiW/wDepFv/AHrnkuD61Mk59aybNVE6Bb33qRb33rDSY+tTJIaGUkbaXnvUyXfvWLHIamjkNZs0SNpLr3qZLr3rHjkNTpIaxY0jXS596kS496ykkNSpIazZrFGos9SLP71mpJ1qRZKRqkaST1Ks/vWasnvUqSe9ZspI0VmqRZqzlepUesmi0aCzU8Te9UVc1Ij1nYouiTNPWSqisakRqnlHctq9PV6rI1SKadikywrU8NUCmpFqGjREqmnr3qJelPQ1mWiVelPXvTF6GnL3rnaNkSL0p9Rr3qRa52bRY4DFBNLTD3qbXL5rBvppkpjNjNQu/WtI07kuY9petRF81GWNArrUFFHO5XF609RmmqOtPXoahjQtLSUhrLlNlIXd70FuKYTihTmqUAuBJzUka0irUgwBSl2Q1oOU4zTWemlutRk5qFTvuVzDi3vQDmm05BkU3CwriqM0/bTkXAp2KjYtHzyvQ0tNBxSqc1/Rh/LgtFFFKwBTl6U2nL0qQuLRRRQFx1FAOaKk0QU8dKZTx0pFIBT6ZT6ktBRRRQMdTl702lHFQWOpVpKBUlIfSrSUDioLQ6iiioKQuaVe9Npy9KyZshaKKULUWLTEpu2pNtG2psaJkeKSpNtG2psXci20m2p9lJ5dZ2NIsrlaaVqz5dJ5dZtHRFlUqaaVNWzFSeTWLRtGRSKk0hQ4q75PtSeR9ayaN4yRQMRNM8k1qeRSfZxWLRspoyTAaYYDzWubf2pPsvtWTRvGZim3NRm2PpW59l9qabT2rJxOmM0YZtjTfsp9K3fsftQLL2rOxspowvshPam/ZD6V0Isv9mgWP+zUNGsahzoszT1s29K6AWHtTl0/2rLlNVUMBbQ+lSJaHmt9dOHpT10+pcTRVDCS1NTR2praWx5PFPWx9qy5TT2hlJbkdqmjhNai2XHSnrZ+1ZOJamZ8cRqdI6uraU9bbrxWbiaKZWSOpUjNWktsZ4qVLepcS1IrJGalVKspB7U8QVk4mqmQIlSKhqwkFSrDgVPKWpldIzUqR1KsVPWP2qeUOe5GFIp6KcVMsVPWKpsNMjReDUig09Y6eExS5TVMRelSpSBKkRamxdx6d6kWmqtPArMLj171IvWo1HFSL1rJo0TJF6Gnr3qKnoetZWNUyde9OXvTFPWnZx3qGrmqY+nBsVGG/GkLcVnyGikS+ZUZk61EXppatFSJcxXkqPfk0hNNHU1ooWM3Ik60Ui9KWlyj5h9KvembqN4FTyhzEtRs2CaZ59IPnzRGIlIcBvp6ptpittqQPuptGiYo5o2mkUgUGQYpcpfMBOKaWzTCxanIlHKHMKg61OgwKaowKep4rKSNEPFFGRRkVnYs+d6UcUlFf0RY/l8fRSKaWkAUDg0UUrAPopoOKdUgKvelptKvQ0rFi05elNpV70ikOpw6U2lXvU2LQ6iiikUOoooqSkx9FIvelqWUh9FIvQ0tQy0OopFPWlqRhT6atOqLGiYqinAZpF6U5e9TYtMULRRSrUWNEwwaMGnUVNi0xNtG2nAZpQMVnYuLGhKNlPpQMVm0aqQzZR5dSgZpQMVm4lqRD5VL5VTBc0u2s+U1UyDyaPJqyEpdgrPlKUyr5NL5HtVoJTggNZuJtGZT+zj0pfs4q6IwacIxWLidEahQ+ze1Ktt14q+IqcsQrPlNVUKS23HSlFpkVfWIYpdg6VDiaxqFAWmKkW1x2q6sYp6xjms+U1VRlJbbGacLervligIKlxNVNlMWw9KctuPSrgjAp3l+1Zcpqpsqi3GKcIB6VYAFPVaycTZTKy2/tT1txzVlVFPCAVk4mqmV1gqRYKnCgU8Lik4lqZAsNPWGplWnKtZOJqpkaw09YalUcU9RxWbRpGRAIqcsVThQKdsFZs2REsdOCU+lC1Fi0xoWnBaWlWlY0TALinqtKo4pyisWXcFXFPC0KKWs7DTFUU4U1e9OpNGiY6lXvSUVk0apkqtS76i3Uhb3pKJdyXfSF+OtQ7qTdWigRzEhekpgOaXJq7WJUh1AGKB0o7VBomG7Hejd70wmmlvenyk8xJvpN2aizRk0cocxJtpyttqNXNPUZpOJSZKo30Y20wSbBSeZuoUTRMcZKRcnNNC5pw+WjlFzEirgUuai8w09TmlyjTJlbijdTVHFLWDR0ok3UbqSip0ND58ooor+gT+Ygp45ooqWAUUUUgClBxRRQA6gUUVBQ6lHFFFJlIdSg4oopFodRRRSGOoooqShV606iioLFWnUUVBQUoOaKKkseveloopDQ5e9KOKKKktDqKKKhmiClU0UVJZIvSloorItAvWnUUVLNEOXpS0UVmxj6KKKg0Q4HNFFFQaDlNOU0UVDNIjlNOoorFm8R9FFFZmqH0q9DRRUM0QtPoorM2Q+iiismaodT6KKzNohRRRWbNlsSL3qSiismOO4+nUUVLN4jx0pV60UVkzZEg6UUUVizaOw8HFPoorJm8Qp1FFSWgpV60UUFskHSloorFoqI6n0UVCNQp9FFJmiHUUUVkUw7GozRRWkUJsSiiitGgCiiiswQ+gng0UVMUadCI96iJOaKK2MkOXrUgHFFFQaD8Cm5xRRSKGk5p1FFAkPoooqTQKevWiis5DRIOlLRRWctjoiSL3paKK5kbI//9k=";
    var PopStateEventType = "popstate";
    function createHashHistory(options = {}) {
      function createHashLocation(window2, globalHistory) {
        let {
          pathname = "/",
          search: search2 = "",
          hash = ""
        } = parsePath(window2.location.hash.substring(1));
        if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
          pathname = "/" + pathname;
        }
        return createLocation(
          "",
          { pathname, search: search2, hash },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createHashHref(window2, to2) {
        let base2 = window2.document.querySelector("base");
        let href = "";
        if (base2 && base2.getAttribute("href")) {
          let url = window2.location.href;
          let hashIndex = url.indexOf("#");
          href = hashIndex === -1 ? url : url.slice(0, hashIndex);
        }
        return href + "#" + (typeof to2 === "string" ? to2 : createPath(to2));
      }
      function validateHashLocation(location, to2) {
        warning(
          location.pathname.charAt(0) === "/",
          `relative pathnames are not supported in hash history.push(${JSON.stringify(
            to2
          )})`
        );
      }
      return getUrlBasedHistory(
        createHashLocation,
        createHashHref,
        validateHashLocation,
        options
      );
    }
    function invariant(value, message2) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message2);
      }
    }
    function warning(cond, message2) {
      if (!cond) {
        if (typeof console !== "undefined") console.warn(message2);
        try {
          throw new Error(message2);
        } catch (e) {
        }
      }
    }
    function createKey() {
      return Math.random().toString(36).substring(2, 10);
    }
    function getHistoryState(location, index2) {
      return {
        usr: location.state,
        key: location.key,
        idx: index2
      };
    }
    function createLocation(current, to2, state = null, key) {
      let location = __spreadProps(__spreadValues({
        pathname: typeof current === "string" ? current : current.pathname,
        search: "",
        hash: ""
      }, typeof to2 === "string" ? parsePath(to2) : to2), {
        state,
        // TODO: This could be cleaned up.  push/replace should probably just take
        // full Locations now and avoid the need to run through this flow at all
        // But that's a pretty big refactor to the current test suite so going to
        // keep as is for the time being and just let any incoming keys take precedence
        key: to2 && to2.key || key || createKey()
      });
      return location;
    }
    function createPath({
      pathname = "/",
      search: search2 = "",
      hash = ""
    }) {
      if (search2 && search2 !== "?")
        pathname += search2.charAt(0) === "?" ? search2 : "?" + search2;
      if (hash && hash !== "#")
        pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
      return pathname;
    }
    function parsePath(path2) {
      let parsedPath = {};
      if (path2) {
        let hashIndex = path2.indexOf("#");
        if (hashIndex >= 0) {
          parsedPath.hash = path2.substring(hashIndex);
          path2 = path2.substring(0, hashIndex);
        }
        let searchIndex = path2.indexOf("?");
        if (searchIndex >= 0) {
          parsedPath.search = path2.substring(searchIndex);
          path2 = path2.substring(0, searchIndex);
        }
        if (path2) {
          parsedPath.pathname = path2;
        }
      }
      return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
      let { window: window2 = document.defaultView, v5Compat = false } = options;
      let globalHistory = window2.history;
      let action = "POP";
      let listener = null;
      let index2 = getIndex();
      if (index2 == null) {
        index2 = 0;
        globalHistory.replaceState(__spreadProps(__spreadValues({}, globalHistory.state), { idx: index2 }), "");
      }
      function getIndex() {
        let state = globalHistory.state || { idx: null };
        return state.idx;
      }
      function handlePop() {
        action = "POP";
        let nextIndex = getIndex();
        let delta = nextIndex == null ? null : nextIndex - index2;
        index2 = nextIndex;
        if (listener) {
          listener({ action, location: history2.location, delta });
        }
      }
      function push(to2, state) {
        action = "PUSH";
        let location = createLocation(history2.location, to2, state);
        if (validateLocation) validateLocation(location, to2);
        index2 = getIndex() + 1;
        let historyState = getHistoryState(location, index2);
        let url = history2.createHref(location);
        try {
          globalHistory.pushState(historyState, "", url);
        } catch (error2) {
          if (error2 instanceof DOMException && error2.name === "DataCloneError") {
            throw error2;
          }
          window2.location.assign(url);
        }
        if (v5Compat && listener) {
          listener({ action, location: history2.location, delta: 1 });
        }
      }
      function replace2(to2, state) {
        action = "REPLACE";
        let location = createLocation(history2.location, to2, state);
        if (validateLocation) validateLocation(location, to2);
        index2 = getIndex();
        let historyState = getHistoryState(location, index2);
        let url = history2.createHref(location);
        globalHistory.replaceState(historyState, "", url);
        if (v5Compat && listener) {
          listener({ action, location: history2.location, delta: 0 });
        }
      }
      function createURL(to2) {
        return createBrowserURLImpl(to2);
      }
      let history2 = {
        get action() {
          return action;
        },
        get location() {
          return getLocation(window2, globalHistory);
        },
        listen(fn) {
          if (listener) {
            throw new Error("A history only accepts one active listener");
          }
          window2.addEventListener(PopStateEventType, handlePop);
          listener = fn;
          return () => {
            window2.removeEventListener(PopStateEventType, handlePop);
            listener = null;
          };
        },
        createHref(to2) {
          return createHref2(window2, to2);
        },
        createURL,
        encodeLocation(to2) {
          let url = createURL(to2);
          return {
            pathname: url.pathname,
            search: url.search,
            hash: url.hash
          };
        },
        push,
        replace: replace2,
        go(n) {
          return globalHistory.go(n);
        }
      };
      return history2;
    }
    function createBrowserURLImpl(to2, isAbsolute = false) {
      let base2 = "http://localhost";
      if (typeof window !== "undefined") {
        base2 = window.location.origin !== "null" ? window.location.origin : window.location.href;
      }
      invariant(base2, "No window.location.(origin|href) available to create URL");
      let href = typeof to2 === "string" ? to2 : createPath(to2);
      href = href.replace(/ $/, "%20");
      if (!isAbsolute && href.startsWith("//")) {
        href = base2 + href;
      }
      return new URL(href, base2);
    }
    function matchRoutes(routes, locationArg, basename = "/") {
      return matchRoutesImpl(routes, locationArg, basename, false);
    }
    function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
      let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      let pathname = stripBasename(location.pathname || "/", basename);
      if (pathname == null) {
        return null;
      }
      let branches = flattenRoutes(routes);
      rankRouteBranches(branches);
      let matches = null;
      for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
        let decoded = decodePath(pathname);
        matches = matchRouteBranch(
          branches[i2],
          decoded,
          allowPartial
        );
      }
      return matches;
    }
    function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "", _hasParentOptionalSegments = false) {
      let flattenRoute = (route, index2, hasParentOptionalSegments = _hasParentOptionalSegments, relativePath) => {
        let meta2 = {
          relativePath: relativePath === void 0 ? route.path || "" : relativePath,
          caseSensitive: route.caseSensitive === true,
          childrenIndex: index2,
          route
        };
        if (meta2.relativePath.startsWith("/")) {
          if (!meta2.relativePath.startsWith(parentPath) && hasParentOptionalSegments) {
            return;
          }
          invariant(
            meta2.relativePath.startsWith(parentPath),
            `Absolute route path "${meta2.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
          );
          meta2.relativePath = meta2.relativePath.slice(parentPath.length);
        }
        let path2 = joinPaths([parentPath, meta2.relativePath]);
        let routesMeta = parentsMeta.concat(meta2);
        if (route.children && route.children.length > 0) {
          invariant(
            // Our types know better, but runtime JS may not!
            // @ts-expect-error
            route.index !== true,
            `Index routes must not have child routes. Please remove all child routes from route path "${path2}".`
          );
          flattenRoutes(
            route.children,
            branches,
            routesMeta,
            path2,
            hasParentOptionalSegments
          );
        }
        if (route.path == null && !route.index) {
          return;
        }
        branches.push({
          path: path2,
          score: computeScore(path2, route.index),
          routesMeta
        });
      };
      routes.forEach((route, index2) => {
        var _a2;
        if (route.path === "" || !((_a2 = route.path) == null ? void 0 : _a2.includes("?"))) {
          flattenRoute(route, index2);
        } else {
          for (let exploded of explodeOptionalSegments(route.path)) {
            flattenRoute(route, index2, true, exploded);
          }
        }
      });
      return branches;
    }
    function explodeOptionalSegments(path2) {
      let segments = path2.split("/");
      if (segments.length === 0) return [];
      let [first, ...rest] = segments;
      let isOptional = first.endsWith("?");
      let required = first.replace(/\?$/, "");
      if (rest.length === 0) {
        return isOptional ? [required, ""] : [required];
      }
      let restExploded = explodeOptionalSegments(rest.join("/"));
      let result = [];
      result.push(
        ...restExploded.map(
          (subpath) => subpath === "" ? required : [required, subpath].join("/")
        )
      );
      if (isOptional) {
        result.push(...restExploded);
      }
      return result.map(
        (exploded) => path2.startsWith("/") && exploded === "" ? "/" : exploded
      );
    }
    function rankRouteBranches(branches) {
      branches.sort(
        (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(
          a.routesMeta.map((meta2) => meta2.childrenIndex),
          b.routesMeta.map((meta2) => meta2.childrenIndex)
        )
      );
    }
    var paramRe = /^:[\w-]+$/;
    var dynamicSegmentValue = 3;
    var indexRouteValue = 2;
    var emptySegmentValue = 1;
    var staticSegmentValue = 10;
    var splatPenalty = -2;
    var isSplat = (s) => s === "*";
    function computeScore(path2, index2) {
      let segments = path2.split("/");
      let initialScore = segments.length;
      if (segments.some(isSplat)) {
        initialScore += splatPenalty;
      }
      if (index2) {
        initialScore += indexRouteValue;
      }
      return segments.filter((s) => !isSplat(s)).reduce(
        (score2, segment) => score2 + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue),
        initialScore
      );
    }
    function compareIndexes(a, b) {
      let siblings = a.length === b.length && a.slice(0, -1).every((n, i2) => n === b[i2]);
      return siblings ? (
        // If two routes are siblings, we should try to match the earlier sibling
        // first. This allows people to have fine-grained control over the matching
        // behavior by simply putting routes with identical paths in the order they
        // want them tried.
        a[a.length - 1] - b[b.length - 1]
      ) : (
        // Otherwise, it doesn't really make sense to rank non-siblings by index,
        // so they sort equally.
        0
      );
    }
    function matchRouteBranch(branch, pathname, allowPartial = false) {
      let { routesMeta } = branch;
      let matchedParams = {};
      let matchedPathname = "/";
      let matches = [];
      for (let i2 = 0; i2 < routesMeta.length; ++i2) {
        let meta2 = routesMeta[i2];
        let end = i2 === routesMeta.length - 1;
        let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
        let match = matchPath(
          { path: meta2.relativePath, caseSensitive: meta2.caseSensitive, end },
          remainingPathname
        );
        let route = meta2.route;
        if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
          match = matchPath(
            {
              path: meta2.relativePath,
              caseSensitive: meta2.caseSensitive,
              end: false
            },
            remainingPathname
          );
        }
        if (!match) {
          return null;
        }
        Object.assign(matchedParams, match.params);
        matches.push({
          // TODO: Can this as be avoided?
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match.pathname]),
          pathnameBase: normalizePathname(
            joinPaths([matchedPathname, match.pathnameBase])
          ),
          route
        });
        if (match.pathnameBase !== "/") {
          matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
        }
      }
      return matches;
    }
    function matchPath(pattern, pathname) {
      if (typeof pattern === "string") {
        pattern = { path: pattern, caseSensitive: false, end: true };
      }
      let [matcher, compiledParams] = compilePath(
        pattern.path,
        pattern.caseSensitive,
        pattern.end
      );
      let match = pathname.match(matcher);
      if (!match) return null;
      let matchedPathname = match[0];
      let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
      let captureGroups = match.slice(1);
      let params = compiledParams.reduce(
        (memo2, { paramName, isOptional }, index2) => {
          if (paramName === "*") {
            let splatValue = captureGroups[index2] || "";
            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
          }
          const value = captureGroups[index2];
          if (isOptional && !value) {
            memo2[paramName] = void 0;
          } else {
            memo2[paramName] = (value || "").replace(/%2F/g, "/");
          }
          return memo2;
        },
        {}
      );
      return {
        params,
        pathname: matchedPathname,
        pathnameBase,
        pattern
      };
    }
    function compilePath(path2, caseSensitive = false, end = true) {
      warning(
        path2 === "*" || !path2.endsWith("*") || path2.endsWith("/*"),
        `Route path "${path2}" will be treated as if it were "${path2.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path2.replace(/\*$/, "/*")}".`
      );
      let params = [];
      let regexpSource = "^" + path2.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
        /\/:([\w-]+)(\?)?/g,
        (_, paramName, isOptional) => {
          params.push({ paramName, isOptional: isOptional != null });
          return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
        }
      ).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
      if (path2.endsWith("*")) {
        params.push({ paramName: "*" });
        regexpSource += path2 === "*" || path2 === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
      } else if (end) {
        regexpSource += "\\/*$";
      } else if (path2 !== "" && path2 !== "/") {
        regexpSource += "(?:(?=\\/|$))";
      } else ;
      let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
      return [matcher, params];
    }
    function decodePath(value) {
      try {
        return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
      } catch (error2) {
        warning(
          false,
          `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error2}).`
        );
        return value;
      }
    }
    function stripBasename(pathname, basename) {
      if (basename === "/") return pathname;
      if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
        return null;
      }
      let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
      let nextChar2 = pathname.charAt(startIndex);
      if (nextChar2 && nextChar2 !== "/") {
        return null;
      }
      return pathname.slice(startIndex) || "/";
    }
    var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    var isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX.test(url);
    function resolvePath(to2, fromPathname = "/") {
      let {
        pathname: toPathname,
        search: search2 = "",
        hash = ""
      } = typeof to2 === "string" ? parsePath(to2) : to2;
      let pathname;
      if (toPathname) {
        if (isAbsoluteUrl(toPathname)) {
          pathname = toPathname;
        } else {
          if (toPathname.includes("//")) {
            let oldPathname = toPathname;
            toPathname = toPathname.replace(/\/\/+/g, "/");
            warning(
              false,
              `Pathnames cannot have embedded double slashes - normalizing ${oldPathname} -> ${toPathname}`
            );
          }
          if (toPathname.startsWith("/")) {
            pathname = resolvePathname(toPathname.substring(1), "/");
          } else {
            pathname = resolvePathname(toPathname, fromPathname);
          }
        }
      } else {
        pathname = fromPathname;
      }
      return {
        pathname,
        search: normalizeSearch(search2),
        hash: normalizeHash(hash)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments = fromPathname.replace(/\/+$/, "").split("/");
      let relativeSegments = relativePath.split("/");
      relativeSegments.forEach((segment) => {
        if (segment === "..") {
          if (segments.length > 1) segments.pop();
        } else if (segment !== ".") {
          segments.push(segment);
        }
      });
      return segments.length > 1 ? segments.join("/") : "/";
    }
    function getInvalidPathError(char, field, dest, path2) {
      return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
        path2
      )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
    }
    function getPathContributingMatches(matches) {
      return matches.filter(
        (match, index2) => index2 === 0 || match.route.path && match.route.path.length > 0
      );
    }
    function getResolveToMatches(matches) {
      let pathMatches = getPathContributingMatches(matches);
      return pathMatches.map(
        (match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase
      );
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
      let to2;
      if (typeof toArg === "string") {
        to2 = parsePath(toArg);
      } else {
        to2 = __spreadValues({}, toArg);
        invariant(
          !to2.pathname || !to2.pathname.includes("?"),
          getInvalidPathError("?", "pathname", "search", to2)
        );
        invariant(
          !to2.pathname || !to2.pathname.includes("#"),
          getInvalidPathError("#", "pathname", "hash", to2)
        );
        invariant(
          !to2.search || !to2.search.includes("#"),
          getInvalidPathError("#", "search", "hash", to2)
        );
      }
      let isEmptyPath = toArg === "" || to2.pathname === "";
      let toPathname = isEmptyPath ? "/" : to2.pathname;
      let from2;
      if (toPathname == null) {
        from2 = locationPathname;
      } else {
        let routePathnameIndex = routePathnames.length - 1;
        if (!isPathRelative && toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          while (toSegments[0] === "..") {
            toSegments.shift();
            routePathnameIndex -= 1;
          }
          to2.pathname = toSegments.join("/");
        }
        from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path2 = resolvePath(to2, from2);
      let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
      let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
      if (!path2.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
        path2.pathname += "/";
      }
      return path2;
    }
    var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
    var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
    var normalizeSearch = (search2) => !search2 || search2 === "?" ? "" : search2.startsWith("?") ? search2 : "?" + search2;
    var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
    function isRouteErrorResponse(error2) {
      return error2 != null && typeof error2.status === "number" && typeof error2.statusText === "string" && typeof error2.internal === "boolean" && "data" in error2;
    }
    function getRoutePattern(matches) {
      return matches.map((m) => m.route.path).filter(Boolean).join("/").replace(/\/\/*/g, "/") || "/";
    }
    Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
    var validMutationMethodsArr = [
      "POST",
      "PUT",
      "PATCH",
      "DELETE"
    ];
    new Set(
      validMutationMethodsArr
    );
    var validRequestMethodsArr = [
      "GET",
      ...validMutationMethodsArr
    ];
    new Set(validRequestMethodsArr);
    var DataRouterContext = reactExports.createContext(null);
    DataRouterContext.displayName = "DataRouter";
    var DataRouterStateContext = reactExports.createContext(null);
    DataRouterStateContext.displayName = "DataRouterState";
    reactExports.createContext(false);
    var ViewTransitionContext = reactExports.createContext({
      isTransitioning: false
    });
    ViewTransitionContext.displayName = "ViewTransition";
    var FetchersContext = reactExports.createContext(
      /* @__PURE__ */ new Map()
    );
    FetchersContext.displayName = "Fetchers";
    var AwaitContext = reactExports.createContext(null);
    AwaitContext.displayName = "Await";
    var NavigationContext = reactExports.createContext(
      null
    );
    NavigationContext.displayName = "Navigation";
    var LocationContext = reactExports.createContext(
      null
    );
    LocationContext.displayName = "Location";
    var RouteContext = reactExports.createContext({
      outlet: null,
      matches: [],
      isDataRoute: false
    });
    RouteContext.displayName = "Route";
    var RouteErrorContext = reactExports.createContext(null);
    RouteErrorContext.displayName = "RouteError";
    function useHref(to2, { relative } = {}) {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useHref() may be used only in the context of a <Router> component.`
      );
      let { basename, navigator: navigator2 } = reactExports.useContext(NavigationContext);
      let { hash, pathname, search: search2 } = useResolvedPath(to2, { relative });
      let joinedPathname = pathname;
      if (basename !== "/") {
        joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
      }
      return navigator2.createHref({ pathname: joinedPathname, search: search2, hash });
    }
    function useInRouterContext() {
      return reactExports.useContext(LocationContext) != null;
    }
    function useLocation() {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useLocation() may be used only in the context of a <Router> component.`
      );
      return reactExports.useContext(LocationContext).location;
    }
    var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
    function useIsomorphicLayoutEffect(cb) {
      let isStatic = reactExports.useContext(NavigationContext).static;
      if (!isStatic) {
        reactExports.useLayoutEffect(cb);
      }
    }
    function useNavigate() {
      let { isDataRoute } = reactExports.useContext(RouteContext);
      return isDataRoute ? useNavigateStable() : useNavigateUnstable();
    }
    function useNavigateUnstable() {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useNavigate() may be used only in the context of a <Router> component.`
      );
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      let { basename, navigator: navigator2 } = reactExports.useContext(NavigationContext);
      let { matches } = reactExports.useContext(RouteContext);
      let { pathname: locationPathname } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(
        (to2, options = {}) => {
          warning(activeRef.current, navigateEffectWarning);
          if (!activeRef.current) return;
          if (typeof to2 === "number") {
            navigator2.go(to2);
            return;
          }
          let path2 = resolveTo(
            to2,
            JSON.parse(routePathnamesJson),
            locationPathname,
            options.relative === "path"
          );
          if (dataRouterContext == null && basename !== "/") {
            path2.pathname = path2.pathname === "/" ? basename : joinPaths([basename, path2.pathname]);
          }
          (!!options.replace ? navigator2.replace : navigator2.push)(
            path2,
            options.state,
            options
          );
        },
        [
          basename,
          navigator2,
          routePathnamesJson,
          locationPathname,
          dataRouterContext
        ]
      );
      return navigate;
    }
    var OutletContext = reactExports.createContext(null);
    function useOutlet(context) {
      let outlet = reactExports.useContext(RouteContext).outlet;
      return reactExports.useMemo(
        () => outlet && /* @__PURE__ */ reactExports.createElement(OutletContext.Provider, { value: context }, outlet),
        [outlet, context]
      );
    }
    function useResolvedPath(to2, { relative } = {}) {
      let { matches } = reactExports.useContext(RouteContext);
      let { pathname: locationPathname } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
      return reactExports.useMemo(
        () => resolveTo(
          to2,
          JSON.parse(routePathnamesJson),
          locationPathname,
          relative === "path"
        ),
        [to2, routePathnamesJson, locationPathname, relative]
      );
    }
    function useRoutes(routes, locationArg) {
      return useRoutesImpl(routes, locationArg);
    }
    function useRoutesImpl(routes, locationArg, dataRouterState, unstable_onError, future) {
      var _a2;
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useRoutes() may be used only in the context of a <Router> component.`
      );
      let { navigator: navigator2 } = reactExports.useContext(NavigationContext);
      let { matches: parentMatches } = reactExports.useContext(RouteContext);
      let routeMatch = parentMatches[parentMatches.length - 1];
      let parentParams = routeMatch ? routeMatch.params : {};
      let parentPathname = routeMatch ? routeMatch.pathname : "/";
      let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
      let parentRoute = routeMatch && routeMatch.route;
      {
        let parentPath = parentRoute && parentRoute.path || "";
        warningOnce(
          parentPathname,
          !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
          `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`
        );
      }
      let locationFromContext = useLocation();
      let location;
      if (locationArg) {
        let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
        invariant(
          parentPathnameBase === "/" || ((_a2 = parsedLocationArg.pathname) == null ? void 0 : _a2.startsWith(parentPathnameBase)),
          `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
        );
        location = parsedLocationArg;
      } else {
        location = locationFromContext;
      }
      let pathname = location.pathname || "/";
      let remainingPathname = pathname;
      if (parentPathnameBase !== "/") {
        let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
        let segments = pathname.replace(/^\//, "").split("/");
        remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
      }
      let matches = matchRoutes(routes, { pathname: remainingPathname });
      {
        warning(
          parentRoute || matches != null,
          `No routes matched location "${location.pathname}${location.search}${location.hash}" `
        );
        warning(
          matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,
          `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
        );
      }
      let renderedMatches = _renderMatches(
        matches && matches.map(
          (match) => Object.assign({}, match, {
            params: Object.assign({}, parentParams, match.params),
            pathname: joinPaths([
              parentPathnameBase,
              // Re-encode pathnames that were decoded inside matchRoutes.
              // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
              // `new URL()` internally and we need to prevent it from treating
              // them as separators
              navigator2.encodeLocation ? navigator2.encodeLocation(
                match.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")
              ).pathname : match.pathname
            ]),
            pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
              parentPathnameBase,
              // Re-encode pathnames that were decoded inside matchRoutes
              // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
              // `new URL()` internally and we need to prevent it from treating
              // them as separators
              navigator2.encodeLocation ? navigator2.encodeLocation(
                match.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")
              ).pathname : match.pathnameBase
            ])
          })
        ),
        parentMatches,
        dataRouterState,
        unstable_onError,
        future
      );
      if (locationArg && renderedMatches) {
        return /* @__PURE__ */ reactExports.createElement(
          LocationContext.Provider,
          {
            value: {
              location: __spreadValues({
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default"
              }, location),
              navigationType: "POP"
              /* Pop */
            }
          },
          renderedMatches
        );
      }
      return renderedMatches;
    }
    function DefaultErrorComponent() {
      let error2 = useRouteError();
      let message2 = isRouteErrorResponse(error2) ? `${error2.status} ${error2.statusText}` : error2 instanceof Error ? error2.message : JSON.stringify(error2);
      let stack = error2 instanceof Error ? error2.stack : null;
      let lightgrey = "rgba(200,200,200, 0.5)";
      let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
      let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
      let devInfo = null;
      {
        console.error(
          "Error handled by React Router default ErrorBoundary:",
          error2
        );
        devInfo = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("p", null, " Hey developer "), /* @__PURE__ */ reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ reactExports.createElement("code", { style: codeStyles }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ reactExports.createElement("code", { style: codeStyles }, "errorElement"), " prop on your route."));
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", { style: { fontStyle: "italic" } }, message2), stack ? /* @__PURE__ */ reactExports.createElement("pre", { style: preStyles }, stack) : null, devInfo);
    }
    var defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
    var RenderErrorBoundary = class extends reactExports.Component {
      constructor(props) {
        super(props);
        this.state = {
          location: props.location,
          revalidation: props.revalidation,
          error: props.error
        };
      }
      static getDerivedStateFromError(error2) {
        return { error: error2 };
      }
      static getDerivedStateFromProps(props, state) {
        if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
          return {
            error: props.error,
            location: props.location,
            revalidation: props.revalidation
          };
        }
        return {
          error: props.error !== void 0 ? props.error : state.error,
          location: state.location,
          revalidation: props.revalidation || state.revalidation
        };
      }
      componentDidCatch(error2, errorInfo) {
        if (this.props.onError) {
          this.props.onError(error2, errorInfo);
        } else {
          console.error(
            "React Router caught the following error during render",
            error2
          );
        }
      }
      render() {
        return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ reactExports.createElement(
          RouteErrorContext.Provider,
          {
            value: this.state.error,
            children: this.props.component
          }
        )) : this.props.children;
      }
    };
    function RenderedRoute({ routeContext, match, children }) {
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
      }
      return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, { value: routeContext }, children);
    }
    function _renderMatches(matches, parentMatches = [], dataRouterState = null, unstable_onError = null, future = null) {
      if (matches == null) {
        if (!dataRouterState) {
          return null;
        }
        if (dataRouterState.errors) {
          matches = dataRouterState.matches;
        } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
          matches = dataRouterState.matches;
        } else {
          return null;
        }
      }
      let renderedMatches = matches;
      let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
      if (errors != null) {
        let errorIndex = renderedMatches.findIndex(
          (m) => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== void 0
        );
        invariant(
          errorIndex >= 0,
          `Could not find a matching route for errors on route IDs: ${Object.keys(
            errors
          ).join(",")}`
        );
        renderedMatches = renderedMatches.slice(
          0,
          Math.min(renderedMatches.length, errorIndex + 1)
        );
      }
      let renderFallback = false;
      let fallbackIndex = -1;
      if (dataRouterState) {
        for (let i2 = 0; i2 < renderedMatches.length; i2++) {
          let match = renderedMatches[i2];
          if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
            fallbackIndex = i2;
          }
          if (match.route.id) {
            let { loaderData, errors: errors2 } = dataRouterState;
            let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);
            if (match.route.lazy || needsToRunLoader) {
              renderFallback = true;
              if (fallbackIndex >= 0) {
                renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
              } else {
                renderedMatches = [renderedMatches[0]];
              }
              break;
            }
          }
        }
      }
      let onError = dataRouterState && unstable_onError ? (error2, errorInfo) => {
        var _a2, _b, _c;
        unstable_onError(error2, {
          location: dataRouterState.location,
          params: (_c = (_b = (_a2 = dataRouterState.matches) == null ? void 0 : _a2[0]) == null ? void 0 : _b.params) != null ? _c : {},
          unstable_pattern: getRoutePattern(dataRouterState.matches),
          errorInfo
        });
      } : void 0;
      return renderedMatches.reduceRight(
        (outlet, match, index2) => {
          let error2;
          let shouldRenderHydrateFallback = false;
          let errorElement = null;
          let hydrateFallbackElement = null;
          if (dataRouterState) {
            error2 = errors && match.route.id ? errors[match.route.id] : void 0;
            errorElement = match.route.errorElement || defaultErrorElement;
            if (renderFallback) {
              if (fallbackIndex < 0 && index2 === 0) {
                warningOnce(
                  "route-fallback",
                  false,
                  "No `HydrateFallback` element provided to render during initial hydration"
                );
                shouldRenderHydrateFallback = true;
                hydrateFallbackElement = null;
              } else if (fallbackIndex === index2) {
                shouldRenderHydrateFallback = true;
                hydrateFallbackElement = match.route.hydrateFallbackElement || null;
              }
            }
          }
          let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
          let getChildren2 = () => {
            let children;
            if (error2) {
              children = errorElement;
            } else if (shouldRenderHydrateFallback) {
              children = hydrateFallbackElement;
            } else if (match.route.Component) {
              children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
            } else if (match.route.element) {
              children = match.route.element;
            } else {
              children = outlet;
            }
            return /* @__PURE__ */ reactExports.createElement(
              RenderedRoute,
              {
                match,
                routeContext: {
                  outlet,
                  matches: matches2,
                  isDataRoute: dataRouterState != null
                },
                children
              }
            );
          };
          return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(
            RenderErrorBoundary,
            {
              location: dataRouterState.location,
              revalidation: dataRouterState.revalidation,
              component: errorElement,
              error: error2,
              children: getChildren2(),
              routeContext: { outlet: null, matches: matches2, isDataRoute: true },
              onError
            }
          ) : getChildren2();
        },
        null
      );
    }
    function getDataRouterConsoleError(hookName) {
      return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
    }
    function useDataRouterContext(hookName) {
      let ctx = reactExports.useContext(DataRouterContext);
      invariant(ctx, getDataRouterConsoleError(hookName));
      return ctx;
    }
    function useDataRouterState(hookName) {
      let state = reactExports.useContext(DataRouterStateContext);
      invariant(state, getDataRouterConsoleError(hookName));
      return state;
    }
    function useRouteContext(hookName) {
      let route = reactExports.useContext(RouteContext);
      invariant(route, getDataRouterConsoleError(hookName));
      return route;
    }
    function useCurrentRouteId(hookName) {
      let route = useRouteContext(hookName);
      let thisRoute = route.matches[route.matches.length - 1];
      invariant(
        thisRoute.route.id,
        `${hookName} can only be used on routes that contain a unique "id"`
      );
      return thisRoute.route.id;
    }
    function useRouteId() {
      return useCurrentRouteId(
        "useRouteId"
        /* UseRouteId */
      );
    }
    function useRouteError() {
      var _a2;
      let error2 = reactExports.useContext(RouteErrorContext);
      let state = useDataRouterState(
        "useRouteError"
        /* UseRouteError */
      );
      let routeId = useCurrentRouteId(
        "useRouteError"
        /* UseRouteError */
      );
      if (error2 !== void 0) {
        return error2;
      }
      return (_a2 = state.errors) == null ? void 0 : _a2[routeId];
    }
    function useNavigateStable() {
      let { router } = useDataRouterContext(
        "useNavigate"
        /* UseNavigateStable */
      );
      let id2 = useCurrentRouteId(
        "useNavigate"
        /* UseNavigateStable */
      );
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(
        (_0, ..._1) => __async(null, [_0, ..._1], function* (to2, options = {}) {
          warning(activeRef.current, navigateEffectWarning);
          if (!activeRef.current) return;
          if (typeof to2 === "number") {
            yield router.navigate(to2);
          } else {
            yield router.navigate(to2, __spreadValues({ fromRouteId: id2 }, options));
          }
        }),
        [router, id2]
      );
      return navigate;
    }
    var alreadyWarned$1 = {};
    function warningOnce(key, cond, message2) {
      if (!cond && !alreadyWarned$1[key]) {
        alreadyWarned$1[key] = true;
        warning(false, message2);
      }
    }
    reactExports.memo(DataRoutes);
    function DataRoutes({
      routes,
      future,
      state,
      unstable_onError
    }) {
      return useRoutesImpl(routes, void 0, state, unstable_onError, future);
    }
    function Navigate({
      to: to2,
      replace: replace2,
      state,
      relative
    }) {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of
        // the router loaded. We can help them understand how to avoid that.
        `<Navigate> may be used only in the context of a <Router> component.`
      );
      let { static: isStatic } = reactExports.useContext(NavigationContext);
      warning(
        !isStatic,
        `<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.`
      );
      let { matches } = reactExports.useContext(RouteContext);
      let { pathname: locationPathname } = useLocation();
      let navigate = useNavigate();
      let path2 = resolveTo(
        to2,
        getResolveToMatches(matches),
        locationPathname,
        relative === "path"
      );
      let jsonPath = JSON.stringify(path2);
      reactExports.useEffect(() => {
        navigate(JSON.parse(jsonPath), { replace: replace2, state, relative });
      }, [navigate, jsonPath, relative, replace2, state]);
      return null;
    }
    function Outlet(props) {
      return useOutlet(props.context);
    }
    function Route(props) {
      invariant(
        false,
        `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`
      );
    }
    function Router({
      basename: basenameProp = "/",
      children = null,
      location: locationProp,
      navigationType = "POP",
      navigator: navigator2,
      static: staticProp = false,
      unstable_useTransitions
    }) {
      invariant(
        !useInRouterContext(),
        `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`
      );
      let basename = basenameProp.replace(/^\/*/, "/");
      let navigationContext = reactExports.useMemo(
        () => ({
          basename,
          navigator: navigator2,
          static: staticProp,
          unstable_useTransitions,
          future: {}
        }),
        [basename, navigator2, staticProp, unstable_useTransitions]
      );
      if (typeof locationProp === "string") {
        locationProp = parsePath(locationProp);
      }
      let {
        pathname = "/",
        search: search2 = "",
        hash = "",
        state = null,
        key = "default"
      } = locationProp;
      let locationContext = reactExports.useMemo(() => {
        let trailingPathname = stripBasename(pathname, basename);
        if (trailingPathname == null) {
          return null;
        }
        return {
          location: {
            pathname: trailingPathname,
            search: search2,
            hash,
            state,
            key
          },
          navigationType
        };
      }, [basename, pathname, search2, hash, state, key, navigationType]);
      warning(
        locationContext != null,
        `<Router basename="${basename}"> is not able to match the URL "${pathname}${search2}${hash}" because it does not start with the basename, so the <Router> won't render anything.`
      );
      if (locationContext == null) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, { children, value: locationContext }));
    }
    function Routes({
      children,
      location
    }) {
      return useRoutes(createRoutesFromChildren(children), location);
    }
    function createRoutesFromChildren(children, parentPath = []) {
      let routes = [];
      reactExports.Children.forEach(children, (element, index2) => {
        if (!reactExports.isValidElement(element)) {
          return;
        }
        let treePath = [...parentPath, index2];
        if (element.type === reactExports.Fragment) {
          routes.push.apply(
            routes,
            createRoutesFromChildren(element.props.children, treePath)
          );
          return;
        }
        invariant(
          element.type === Route,
          `[${typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
        );
        invariant(
          !element.props.index || !element.props.children,
          "An index route cannot have child routes."
        );
        let route = {
          id: element.props.id || treePath.join("-"),
          caseSensitive: element.props.caseSensitive,
          element: element.props.element,
          Component: element.props.Component,
          index: element.props.index,
          path: element.props.path,
          middleware: element.props.middleware,
          loader: element.props.loader,
          action: element.props.action,
          hydrateFallbackElement: element.props.hydrateFallbackElement,
          HydrateFallback: element.props.HydrateFallback,
          errorElement: element.props.errorElement,
          ErrorBoundary: element.props.ErrorBoundary,
          hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,
          shouldRevalidate: element.props.shouldRevalidate,
          handle: element.props.handle,
          lazy: element.props.lazy
        };
        if (element.props.children) {
          route.children = createRoutesFromChildren(
            element.props.children,
            treePath
          );
        }
        routes.push(route);
      });
      return routes;
    }
    var defaultMethod = "get";
    var defaultEncType = "application/x-www-form-urlencoded";
    function isHtmlElement(object) {
      return typeof HTMLElement !== "undefined" && object instanceof HTMLElement;
    }
    function isButtonElement(object) {
      return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
    }
    function isFormElement(object) {
      return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
    }
    function isInputElement(object) {
      return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
    }
    function isModifiedEvent(event) {
      return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
    }
    function shouldProcessLinkClick(event, target) {
      return event.button === 0 && // Ignore everything but left clicks
      (!target || target === "_self") && // Let browser handle "target=_blank" etc.
      !isModifiedEvent(event);
    }
    var _formDataSupportsSubmitter = null;
    function isFormDataSubmitterSupported() {
      if (_formDataSupportsSubmitter === null) {
        try {
          new FormData(
            document.createElement("form"),
            // @ts-expect-error if FormData supports the submitter parameter, this will throw
            0
          );
          _formDataSupportsSubmitter = false;
        } catch (e) {
          _formDataSupportsSubmitter = true;
        }
      }
      return _formDataSupportsSubmitter;
    }
    var supportedFormEncTypes = /* @__PURE__ */ new Set([
      "application/x-www-form-urlencoded",
      "multipart/form-data",
      "text/plain"
    ]);
    function getFormEncType(encType) {
      if (encType != null && !supportedFormEncTypes.has(encType)) {
        warning(
          false,
          `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`
        );
        return null;
      }
      return encType;
    }
    function getFormSubmissionInfo(target, basename) {
      let method;
      let action;
      let encType;
      let formData;
      let body;
      if (isFormElement(target)) {
        let attr = target.getAttribute("action");
        action = attr ? stripBasename(attr, basename) : null;
        method = target.getAttribute("method") || defaultMethod;
        encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
        formData = new FormData(target);
      } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
        let form = target.form;
        if (form == null) {
          throw new Error(
            `Cannot submit a <button> or <input type="submit"> without a <form>`
          );
        }
        let attr = target.getAttribute("formaction") || form.getAttribute("action");
        action = attr ? stripBasename(attr, basename) : null;
        method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
        encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
        formData = new FormData(form, target);
        if (!isFormDataSubmitterSupported()) {
          let { name: name2, type, value } = target;
          if (type === "image") {
            let prefix = name2 ? `${name2}.` : "";
            formData.append(`${prefix}x`, "0");
            formData.append(`${prefix}y`, "0");
          } else if (name2) {
            formData.append(name2, value);
          }
        }
      } else if (isHtmlElement(target)) {
        throw new Error(
          `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
        );
      } else {
        method = defaultMethod;
        action = null;
        encType = defaultEncType;
        body = target;
      }
      if (formData && encType === "text/plain") {
        body = formData;
        formData = void 0;
      }
      return { action, method: method.toLowerCase(), encType, formData, body };
    }
    Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
    function invariant2(value, message2) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message2);
      }
    }
    function singleFetchUrl(reqUrl, basename, extension) {
      let url = typeof reqUrl === "string" ? new URL(
        reqUrl,
        // This can be called during the SSR flow via PrefetchPageLinksImpl so
        // don't assume window is available
        typeof window === "undefined" ? "server://singlefetch/" : window.location.origin
      ) : reqUrl;
      if (url.pathname === "/") {
        url.pathname = `_root.${extension}`;
      } else if (basename && stripBasename(url.pathname, basename) === "/") {
        url.pathname = `${basename.replace(/\/$/, "")}/_root.${extension}`;
      } else {
        url.pathname = `${url.pathname.replace(/\/$/, "")}.${extension}`;
      }
      return url;
    }
    function loadRouteModule(route, routeModulesCache) {
      return __async(this, null, function* () {
        if (route.id in routeModulesCache) {
          return routeModulesCache[route.id];
        }
        try {
          let routeModule = yield import(
            /* @vite-ignore */
            /* webpackIgnore: true */
            route.module
          );
          routeModulesCache[route.id] = routeModule;
          return routeModule;
        } catch (error2) {
          console.error(
            `Error loading route module \`${route.module}\`, reloading page...`
          );
          console.error(error2);
          if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error
          void 0) ;
          window.location.reload();
          return new Promise(() => {
          });
        }
      });
    }
    function isHtmlLinkDescriptor(object) {
      if (object == null) {
        return false;
      }
      if (object.href == null) {
        return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
      }
      return typeof object.rel === "string" && typeof object.href === "string";
    }
    function getKeyedPrefetchLinks(matches, manifest, routeModules) {
      return __async(this, null, function* () {
        let links = yield Promise.all(
          matches.map((match) => __async(null, null, function* () {
            let route = manifest.routes[match.route.id];
            if (route) {
              let mod = yield loadRouteModule(route, routeModules);
              return mod.links ? mod.links() : [];
            }
            return [];
          }))
        );
        return dedupeLinkDescriptors(
          links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map(
            (link) => link.rel === "stylesheet" ? __spreadProps(__spreadValues({}, link), { rel: "prefetch", as: "style" }) : __spreadProps(__spreadValues({}, link), { rel: "prefetch" })
          )
        );
      });
    }
    function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
      let isNew = (match, index2) => {
        if (!currentMatches[index2]) return true;
        return match.route.id !== currentMatches[index2].route.id;
      };
      let matchPathChanged = (match, index2) => {
        var _a2;
        return (
          // param change, /users/123 -> /users/456
          currentMatches[index2].pathname !== match.pathname || // splat param changed, which is not present in match.path
          // e.g. /files/images/avatar.jpg -> files/finances.xls
          ((_a2 = currentMatches[index2].route.path) == null ? void 0 : _a2.endsWith("*")) && currentMatches[index2].params["*"] !== match.params["*"]
        );
      };
      if (mode === "assets") {
        return nextMatches.filter(
          (match, index2) => isNew(match, index2) || matchPathChanged(match, index2)
        );
      }
      if (mode === "data") {
        return nextMatches.filter((match, index2) => {
          var _a2;
          let manifestRoute = manifest.routes[match.route.id];
          if (!manifestRoute || !manifestRoute.hasLoader) {
            return false;
          }
          if (isNew(match, index2) || matchPathChanged(match, index2)) {
            return true;
          }
          if (match.route.shouldRevalidate) {
            let routeChoice = match.route.shouldRevalidate({
              currentUrl: new URL(
                location.pathname + location.search + location.hash,
                window.origin
              ),
              currentParams: ((_a2 = currentMatches[0]) == null ? void 0 : _a2.params) || {},
              nextUrl: new URL(page, window.origin),
              nextParams: match.params,
              defaultShouldRevalidate: true
            });
            if (typeof routeChoice === "boolean") {
              return routeChoice;
            }
          }
          return true;
        });
      }
      return [];
    }
    function getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {
      return dedupeHrefs(
        matches.map((match) => {
          let route = manifest.routes[match.route.id];
          if (!route) return [];
          let hrefs = [route.module];
          if (route.clientActionModule) {
            hrefs = hrefs.concat(route.clientActionModule);
          }
          if (route.clientLoaderModule) {
            hrefs = hrefs.concat(route.clientLoaderModule);
          }
          if (includeHydrateFallback && route.hydrateFallbackModule) {
            hrefs = hrefs.concat(route.hydrateFallbackModule);
          }
          if (route.imports) {
            hrefs = hrefs.concat(route.imports);
          }
          return hrefs;
        }).flat(1)
      );
    }
    function dedupeHrefs(hrefs) {
      return [...new Set(hrefs)];
    }
    function sortKeys(obj) {
      let sorted = {};
      let keys2 = Object.keys(obj).sort();
      for (let key of keys2) {
        sorted[key] = obj[key];
      }
      return sorted;
    }
    function dedupeLinkDescriptors(descriptors2, preloads) {
      let set2 = /* @__PURE__ */ new Set();
      new Set(preloads);
      return descriptors2.reduce((deduped, descriptor) => {
        let key = JSON.stringify(sortKeys(descriptor));
        if (!set2.has(key)) {
          set2.add(key);
          deduped.push({ key, link: descriptor });
        }
        return deduped;
      }, []);
    }
    function useDataRouterContext2() {
      let context = reactExports.useContext(DataRouterContext);
      invariant2(
        context,
        "You must render this element inside a <DataRouterContext.Provider> element"
      );
      return context;
    }
    function useDataRouterStateContext() {
      let context = reactExports.useContext(DataRouterStateContext);
      invariant2(
        context,
        "You must render this element inside a <DataRouterStateContext.Provider> element"
      );
      return context;
    }
    var FrameworkContext = reactExports.createContext(void 0);
    FrameworkContext.displayName = "FrameworkContext";
    function useFrameworkContext() {
      let context = reactExports.useContext(FrameworkContext);
      invariant2(
        context,
        "You must render this element inside a <HydratedRouter> element"
      );
      return context;
    }
    function usePrefetchBehavior(prefetch, theirElementProps) {
      let frameworkContext = reactExports.useContext(FrameworkContext);
      let [maybePrefetch, setMaybePrefetch] = reactExports.useState(false);
      let [shouldPrefetch, setShouldPrefetch] = reactExports.useState(false);
      let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
      let ref = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (prefetch === "render") {
          setShouldPrefetch(true);
        }
        if (prefetch === "viewport") {
          let callback2 = (entries) => {
            entries.forEach((entry) => {
              setShouldPrefetch(entry.isIntersecting);
            });
          };
          let observer = new IntersectionObserver(callback2, { threshold: 0.5 });
          if (ref.current) observer.observe(ref.current);
          return () => {
            observer.disconnect();
          };
        }
      }, [prefetch]);
      reactExports.useEffect(() => {
        if (maybePrefetch) {
          let id2 = setTimeout(() => {
            setShouldPrefetch(true);
          }, 100);
          return () => {
            clearTimeout(id2);
          };
        }
      }, [maybePrefetch]);
      let setIntent = () => {
        setMaybePrefetch(true);
      };
      let cancelIntent = () => {
        setMaybePrefetch(false);
        setShouldPrefetch(false);
      };
      if (!frameworkContext) {
        return [false, ref, {}];
      }
      if (prefetch !== "intent") {
        return [shouldPrefetch, ref, {}];
      }
      return [
        shouldPrefetch,
        ref,
        {
          onFocus: composeEventHandlers(onFocus, setIntent),
          onBlur: composeEventHandlers(onBlur, cancelIntent),
          onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
          onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
          onTouchStart: composeEventHandlers(onTouchStart, setIntent)
        }
      ];
    }
    function composeEventHandlers(theirHandler, ourHandler) {
      return (event) => {
        theirHandler && theirHandler(event);
        if (!event.defaultPrevented) {
          ourHandler(event);
        }
      };
    }
    function PrefetchPageLinks(_a2) {
      var _b = _a2, { page } = _b, linkProps = __objRest(_b, ["page"]);
      let { router } = useDataRouterContext2();
      let matches = reactExports.useMemo(
        () => matchRoutes(router.routes, page, router.basename),
        [router.routes, page, router.basename]
      );
      if (!matches) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(PrefetchPageLinksImpl, __spreadValues({ page, matches }, linkProps));
    }
    function useKeyedPrefetchLinks(matches) {
      let { manifest, routeModules } = useFrameworkContext();
      let [keyedPrefetchLinks, setKeyedPrefetchLinks] = reactExports.useState([]);
      reactExports.useEffect(() => {
        let interrupted = false;
        void getKeyedPrefetchLinks(matches, manifest, routeModules).then(
          (links) => {
            if (!interrupted) {
              setKeyedPrefetchLinks(links);
            }
          }
        );
        return () => {
          interrupted = true;
        };
      }, [matches, manifest, routeModules]);
      return keyedPrefetchLinks;
    }
    function PrefetchPageLinksImpl(_c) {
      var _d = _c, {
        page,
        matches: nextMatches
      } = _d, linkProps = __objRest(_d, [
        "page",
        "matches"
      ]);
      let location = useLocation();
      let { manifest, routeModules } = useFrameworkContext();
      let { basename } = useDataRouterContext2();
      let { loaderData, matches } = useDataRouterStateContext();
      let newMatchesForData = reactExports.useMemo(
        () => getNewMatchesForLinks(
          page,
          nextMatches,
          matches,
          manifest,
          location,
          "data"
        ),
        [page, nextMatches, matches, manifest, location]
      );
      let newMatchesForAssets = reactExports.useMemo(
        () => getNewMatchesForLinks(
          page,
          nextMatches,
          matches,
          manifest,
          location,
          "assets"
        ),
        [page, nextMatches, matches, manifest, location]
      );
      let dataHrefs = reactExports.useMemo(() => {
        if (page === location.pathname + location.search + location.hash) {
          return [];
        }
        let routesParams = /* @__PURE__ */ new Set();
        let foundOptOutRoute = false;
        nextMatches.forEach((m) => {
          var _a2;
          let manifestRoute = manifest.routes[m.route.id];
          if (!manifestRoute || !manifestRoute.hasLoader) {
            return;
          }
          if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && ((_a2 = routeModules[m.route.id]) == null ? void 0 : _a2.shouldRevalidate)) {
            foundOptOutRoute = true;
          } else if (manifestRoute.hasClientLoader) {
            foundOptOutRoute = true;
          } else {
            routesParams.add(m.route.id);
          }
        });
        if (routesParams.size === 0) {
          return [];
        }
        let url = singleFetchUrl(page, basename, "data");
        if (foundOptOutRoute && routesParams.size > 0) {
          url.searchParams.set(
            "_routes",
            nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")
          );
        }
        return [url.pathname + url.search];
      }, [
        basename,
        loaderData,
        location,
        manifest,
        newMatchesForData,
        nextMatches,
        page,
        routeModules
      ]);
      let moduleHrefs = reactExports.useMemo(
        () => getModuleLinkHrefs(newMatchesForAssets, manifest),
        [newMatchesForAssets, manifest]
      );
      let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ reactExports.createElement("link", __spreadValues({ key: href, rel: "prefetch", as: "fetch", href }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ reactExports.createElement("link", __spreadValues({ key: href, rel: "modulepreload", href }, linkProps))), keyedPrefetchLinks.map(({ key, link }) => (
        // these don't spread `linkProps` because they are full link descriptors
        // already with their own props
        /* @__PURE__ */ reactExports.createElement("link", __spreadValues({ key, nonce: linkProps.nonce }, link))
      )));
    }
    function mergeRefs(...refs) {
      return (value) => {
        refs.forEach((ref) => {
          if (typeof ref === "function") {
            ref(value);
          } else if (ref != null) {
            ref.current = value;
          }
        });
      };
    }
    var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    try {
      if (isBrowser) {
        window.__reactRouterVersion = // @ts-expect-error
        "7.10.1";
      }
    } catch (e) {
    }
    function HashRouter({
      basename,
      children,
      unstable_useTransitions,
      window: window2
    }) {
      let historyRef = reactExports.useRef();
      if (historyRef.current == null) {
        historyRef.current = createHashHistory({ window: window2, v5Compat: true });
      }
      let history2 = historyRef.current;
      let [state, setStateImpl] = reactExports.useState({
        action: history2.action,
        location: history2.location
      });
      let setState = reactExports.useCallback(
        (newState) => {
          if (unstable_useTransitions === false) {
            setStateImpl(newState);
          } else {
            reactExports.startTransition(() => setStateImpl(newState));
          }
        },
        [unstable_useTransitions]
      );
      reactExports.useLayoutEffect(() => history2.listen(setState), [history2, setState]);
      return /* @__PURE__ */ reactExports.createElement(
        Router,
        {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history2,
          unstable_useTransitions: unstable_useTransitions === true
        }
      );
    }
    var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    var Link = reactExports.forwardRef(
      function LinkWithRef(_e, forwardedRef) {
        var _f = _e, {
          onClick,
          discover = "render",
          prefetch = "none",
          relative,
          reloadDocument,
          replace: replace2,
          state,
          target,
          to: to2,
          preventScrollReset,
          viewTransition
        } = _f, rest = __objRest(_f, [
          "onClick",
          "discover",
          "prefetch",
          "relative",
          "reloadDocument",
          "replace",
          "state",
          "target",
          "to",
          "preventScrollReset",
          "viewTransition"
        ]);
        let { basename, unstable_useTransitions } = reactExports.useContext(NavigationContext);
        let isAbsolute = typeof to2 === "string" && ABSOLUTE_URL_REGEX2.test(to2);
        let absoluteHref;
        let isExternal = false;
        if (typeof to2 === "string" && isAbsolute) {
          absoluteHref = to2;
          if (isBrowser) {
            try {
              let currentUrl = new URL(window.location.href);
              let targetUrl = to2.startsWith("//") ? new URL(currentUrl.protocol + to2) : new URL(to2);
              let path2 = stripBasename(targetUrl.pathname, basename);
              if (targetUrl.origin === currentUrl.origin && path2 != null) {
                to2 = path2 + targetUrl.search + targetUrl.hash;
              } else {
                isExternal = true;
              }
            } catch (e) {
              warning(
                false,
                `<Link to="${to2}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
              );
            }
          }
        }
        let href = useHref(to2, { relative });
        let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
          prefetch,
          rest
        );
        let internalOnClick = useLinkClickHandler(to2, {
          replace: replace2,
          state,
          target,
          preventScrollReset,
          relative,
          viewTransition,
          unstable_useTransitions
        });
        function handleClick(event) {
          if (onClick) onClick(event);
          if (!event.defaultPrevented) {
            internalOnClick(event);
          }
        }
        let link = (
          // eslint-disable-next-line jsx-a11y/anchor-has-content
          /* @__PURE__ */ reactExports.createElement(
            "a",
            __spreadProps(__spreadValues(__spreadValues({}, rest), prefetchHandlers), {
              href: absoluteHref || href,
              onClick: isExternal || reloadDocument ? onClick : handleClick,
              ref: mergeRefs(forwardedRef, prefetchRef),
              target,
              "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
            })
          )
        );
        return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, link, /* @__PURE__ */ reactExports.createElement(PrefetchPageLinks, { page: href })) : link;
      }
    );
    Link.displayName = "Link";
    var NavLink = reactExports.forwardRef(
      function NavLinkWithRef(_g, ref) {
        var _h = _g, {
          "aria-current": ariaCurrentProp = "page",
          caseSensitive = false,
          className: classNameProp = "",
          end = false,
          style: styleProp,
          to: to2,
          viewTransition,
          children
        } = _h, rest = __objRest(_h, [
          "aria-current",
          "caseSensitive",
          "className",
          "end",
          "style",
          "to",
          "viewTransition",
          "children"
        ]);
        let path2 = useResolvedPath(to2, { relative: rest.relative });
        let location = useLocation();
        let routerState = reactExports.useContext(DataRouterStateContext);
        let { navigator: navigator2, basename } = reactExports.useContext(NavigationContext);
        let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useViewTransitionState(path2) && viewTransition === true;
        let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path2).pathname : path2.pathname;
        let locationPathname = location.pathname;
        let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
        if (!caseSensitive) {
          locationPathname = locationPathname.toLowerCase();
          nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
          toPathname = toPathname.toLowerCase();
        }
        if (nextLocationPathname && basename) {
          nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
        }
        const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
        let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
        let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
        let renderProps = {
          isActive,
          isPending,
          isTransitioning
        };
        let ariaCurrent = isActive ? ariaCurrentProp : void 0;
        let className;
        if (typeof classNameProp === "function") {
          className = classNameProp(renderProps);
        } else {
          className = [
            classNameProp,
            isActive ? "active" : null,
            isPending ? "pending" : null,
            isTransitioning ? "transitioning" : null
          ].filter(Boolean).join(" ");
        }
        let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
        return /* @__PURE__ */ reactExports.createElement(
          Link,
          __spreadProps(__spreadValues({}, rest), {
            "aria-current": ariaCurrent,
            className,
            ref,
            style,
            to: to2,
            viewTransition
          }),
          typeof children === "function" ? children(renderProps) : children
        );
      }
    );
    NavLink.displayName = "NavLink";
    var Form = reactExports.forwardRef(
      (_i, forwardedRef) => {
        var _j = _i, {
          discover = "render",
          fetcherKey,
          navigate,
          reloadDocument,
          replace: replace2,
          state,
          method = defaultMethod,
          action,
          onSubmit,
          relative,
          preventScrollReset,
          viewTransition
        } = _j, props = __objRest(_j, [
          "discover",
          "fetcherKey",
          "navigate",
          "reloadDocument",
          "replace",
          "state",
          "method",
          "action",
          "onSubmit",
          "relative",
          "preventScrollReset",
          "viewTransition"
        ]);
        let { unstable_useTransitions } = reactExports.useContext(NavigationContext);
        let submit = useSubmit();
        let formAction = useFormAction(action, { relative });
        let formMethod = method.toLowerCase() === "get" ? "get" : "post";
        let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
        let submitHandler = (event) => {
          onSubmit && onSubmit(event);
          if (event.defaultPrevented) return;
          event.preventDefault();
          let submitter = event.nativeEvent.submitter;
          let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
          let doSubmit = () => submit(submitter || event.currentTarget, {
            fetcherKey,
            method: submitMethod,
            navigate,
            replace: replace2,
            state,
            relative,
            preventScrollReset,
            viewTransition
          });
          if (unstable_useTransitions && navigate !== false) {
            reactExports.startTransition(() => doSubmit());
          } else {
            doSubmit();
          }
        };
        return /* @__PURE__ */ reactExports.createElement(
          "form",
          __spreadProps(__spreadValues({
            ref: forwardedRef,
            method: formMethod,
            action: formAction,
            onSubmit: reloadDocument ? onSubmit : submitHandler
          }, props), {
            "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
          })
        );
      }
    );
    Form.displayName = "Form";
    function getDataRouterConsoleError2(hookName) {
      return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
    }
    function useDataRouterContext3(hookName) {
      let ctx = reactExports.useContext(DataRouterContext);
      invariant(ctx, getDataRouterConsoleError2(hookName));
      return ctx;
    }
    function useLinkClickHandler(to2, {
      target,
      replace: replaceProp,
      state,
      preventScrollReset,
      relative,
      viewTransition,
      unstable_useTransitions
    } = {}) {
      let navigate = useNavigate();
      let location = useLocation();
      let path2 = useResolvedPath(to2, { relative });
      return reactExports.useCallback(
        (event) => {
          if (shouldProcessLinkClick(event, target)) {
            event.preventDefault();
            let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path2);
            let doNavigate = () => navigate(to2, {
              replace: replace2,
              state,
              preventScrollReset,
              relative,
              viewTransition
            });
            if (unstable_useTransitions) {
              reactExports.startTransition(() => doNavigate());
            } else {
              doNavigate();
            }
          }
        },
        [
          location,
          navigate,
          path2,
          replaceProp,
          state,
          target,
          to2,
          preventScrollReset,
          relative,
          viewTransition,
          unstable_useTransitions
        ]
      );
    }
    var fetcherId = 0;
    var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
    function useSubmit() {
      let { router } = useDataRouterContext3(
        "useSubmit"
        /* UseSubmit */
      );
      let { basename } = reactExports.useContext(NavigationContext);
      let currentRouteId = useRouteId();
      let routerFetch = router.fetch;
      let routerNavigate = router.navigate;
      return reactExports.useCallback(
        (_0, ..._1) => __async(null, [_0, ..._1], function* (target, options = {}) {
          let { action, method, encType, formData, body } = getFormSubmissionInfo(
            target,
            basename
          );
          if (options.navigate === false) {
            let key = options.fetcherKey || getUniqueFetcherId();
            yield routerFetch(key, currentRouteId, options.action || action, {
              preventScrollReset: options.preventScrollReset,
              formData,
              body,
              formMethod: options.method || method,
              formEncType: options.encType || encType,
              flushSync: options.flushSync
            });
          } else {
            yield routerNavigate(options.action || action, {
              preventScrollReset: options.preventScrollReset,
              formData,
              body,
              formMethod: options.method || method,
              formEncType: options.encType || encType,
              replace: options.replace,
              state: options.state,
              fromRouteId: currentRouteId,
              flushSync: options.flushSync,
              viewTransition: options.viewTransition
            });
          }
        }),
        [routerFetch, routerNavigate, basename, currentRouteId]
      );
    }
    function useFormAction(action, { relative } = {}) {
      let { basename } = reactExports.useContext(NavigationContext);
      let routeContext = reactExports.useContext(RouteContext);
      invariant(routeContext, "useFormAction must be used inside a RouteContext");
      let [match] = routeContext.matches.slice(-1);
      let path2 = __spreadValues({}, useResolvedPath(action ? action : ".", { relative }));
      let location = useLocation();
      if (action == null) {
        path2.search = location.search;
        let params = new URLSearchParams(path2.search);
        let indexValues = params.getAll("index");
        let hasNakedIndexParam = indexValues.some((v) => v === "");
        if (hasNakedIndexParam) {
          params.delete("index");
          indexValues.filter((v) => v).forEach((v) => params.append("index", v));
          let qs = params.toString();
          path2.search = qs ? `?${qs}` : "";
        }
      }
      if ((!action || action === ".") && match.route.index) {
        path2.search = path2.search ? path2.search.replace(/^\?/, "?index&") : "?index";
      }
      if (basename !== "/") {
        path2.pathname = path2.pathname === "/" ? basename : joinPaths([basename, path2.pathname]);
      }
      return createPath(path2);
    }
    function useViewTransitionState(to2, { relative } = {}) {
      let vtContext = reactExports.useContext(ViewTransitionContext);
      invariant(
        vtContext != null,
        "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
      );
      let { basename } = useDataRouterContext3(
        "useViewTransitionState"
        /* useViewTransitionState */
      );
      let path2 = useResolvedPath(to2, { relative });
      if (!vtContext.isTransitioning) {
        return false;
      }
      let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
      let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
      return matchPath(path2.pathname, nextPath) != null || matchPath(path2.pathname, currentPath) != null;
    }
    const isString$2 = (obj) => typeof obj === "string";
    const defer = () => {
      let res;
      let rej;
      const promise = new Promise((resolve2, reject) => {
        res = resolve2;
        rej = reject;
      });
      promise.resolve = res;
      promise.reject = rej;
      return promise;
    };
    const makeString = (object) => {
      if (object == null) return "";
      return "" + object;
    };
    const copy = (a, s, t2) => {
      a.forEach((m) => {
        if (s[m]) t2[m] = s[m];
      });
    };
    const lastOfPathSeparatorRegExp = /###/g;
    const cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
    const canNotTraverseDeeper = (object) => !object || isString$2(object);
    const getLastOfPath = (object, path2, Empty) => {
      const stack = !isString$2(path2) ? path2 : path2.split(".");
      let stackIndex = 0;
      while (stackIndex < stack.length - 1) {
        if (canNotTraverseDeeper(object)) return {};
        const key = cleanKey(stack[stackIndex]);
        if (!object[key] && Empty) object[key] = new Empty();
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          object = object[key];
        } else {
          object = {};
        }
        ++stackIndex;
      }
      if (canNotTraverseDeeper(object)) return {};
      return {
        obj: object,
        k: cleanKey(stack[stackIndex])
      };
    };
    const setPath = (object, path2, newValue) => {
      const {
        obj,
        k
      } = getLastOfPath(object, path2, Object);
      if (obj !== void 0 || path2.length === 1) {
        obj[k] = newValue;
        return;
      }
      let e = path2[path2.length - 1];
      let p = path2.slice(0, path2.length - 1);
      let last = getLastOfPath(object, p, Object);
      while (last.obj === void 0 && p.length) {
        e = `${p[p.length - 1]}.${e}`;
        p = p.slice(0, p.length - 1);
        last = getLastOfPath(object, p, Object);
        if ((last == null ? void 0 : last.obj) && typeof last.obj[`${last.k}.${e}`] !== "undefined") {
          last.obj = void 0;
        }
      }
      last.obj[`${last.k}.${e}`] = newValue;
    };
    const pushPath = (object, path2, newValue, concat) => {
      const {
        obj,
        k
      } = getLastOfPath(object, path2, Object);
      obj[k] = obj[k] || [];
      obj[k].push(newValue);
    };
    const getPath = (object, path2) => {
      const {
        obj,
        k
      } = getLastOfPath(object, path2);
      if (!obj) return void 0;
      if (!Object.prototype.hasOwnProperty.call(obj, k)) return void 0;
      return obj[k];
    };
    const getPathWithDefaults = (data, defaultData, key) => {
      const value = getPath(data, key);
      if (value !== void 0) {
        return value;
      }
      return getPath(defaultData, key);
    };
    const deepExtend = (target, source2, overwrite) => {
      for (const prop in source2) {
        if (prop !== "__proto__" && prop !== "constructor") {
          if (prop in target) {
            if (isString$2(target[prop]) || target[prop] instanceof String || isString$2(source2[prop]) || source2[prop] instanceof String) {
              if (overwrite) target[prop] = source2[prop];
            } else {
              deepExtend(target[prop], source2[prop], overwrite);
            }
          } else {
            target[prop] = source2[prop];
          }
        }
      }
      return target;
    };
    const regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    var _entityMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "/": "&#x2F;"
    };
    const escape = (data) => {
      if (isString$2(data)) {
        return data.replace(/[&<>"'\/]/g, (s) => _entityMap[s]);
      }
      return data;
    };
    class RegExpCache {
      constructor(capacity) {
        this.capacity = capacity;
        this.regExpMap = /* @__PURE__ */ new Map();
        this.regExpQueue = [];
      }
      getRegExp(pattern) {
        const regExpFromCache = this.regExpMap.get(pattern);
        if (regExpFromCache !== void 0) {
          return regExpFromCache;
        }
        const regExpNew = new RegExp(pattern);
        if (this.regExpQueue.length === this.capacity) {
          this.regExpMap.delete(this.regExpQueue.shift());
        }
        this.regExpMap.set(pattern, regExpNew);
        this.regExpQueue.push(pattern);
        return regExpNew;
      }
    }
    const chars = [" ", ",", "?", "!", ";"];
    const looksLikeObjectPathRegExpCache = new RegExpCache(20);
    const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
      nsSeparator = nsSeparator || "";
      keySeparator = keySeparator || "";
      const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
      if (possibleChars.length === 0) return true;
      const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
      let matched = !r.test(key);
      if (!matched) {
        const ki = key.indexOf(keySeparator);
        if (ki > 0 && !r.test(key.substring(0, ki))) {
          matched = true;
        }
      }
      return matched;
    };
    const deepFind = (obj, path2, keySeparator = ".") => {
      if (!obj) return void 0;
      if (obj[path2]) {
        if (!Object.prototype.hasOwnProperty.call(obj, path2)) return void 0;
        return obj[path2];
      }
      const tokens = path2.split(keySeparator);
      let current = obj;
      for (let i2 = 0; i2 < tokens.length; ) {
        if (!current || typeof current !== "object") {
          return void 0;
        }
        let next;
        let nextPath = "";
        for (let j = i2; j < tokens.length; ++j) {
          if (j !== i2) {
            nextPath += keySeparator;
          }
          nextPath += tokens[j];
          next = current[nextPath];
          if (next !== void 0) {
            if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens.length - 1) {
              continue;
            }
            i2 += j - i2 + 1;
            break;
          }
        }
        current = next;
      }
      return current;
    };
    const getCleanedCode = (code2) => code2 == null ? void 0 : code2.replace("_", "-");
    const consoleLogger = {
      type: "logger",
      log(args) {
        this.output("log", args);
      },
      warn(args) {
        this.output("warn", args);
      },
      error(args) {
        this.output("error", args);
      },
      output(type, args) {
        var _a2, _b;
        (_b = (_a2 = console == null ? void 0 : console[type]) == null ? void 0 : _a2.apply) == null ? void 0 : _b.call(_a2, console, args);
      }
    };
    class Logger {
      constructor(concreteLogger, options = {}) {
        this.init(concreteLogger, options);
      }
      init(concreteLogger, options = {}) {
        this.prefix = options.prefix || "i18next:";
        this.logger = concreteLogger || consoleLogger;
        this.options = options;
        this.debug = options.debug;
      }
      log(...args) {
        return this.forward(args, "log", "", true);
      }
      warn(...args) {
        return this.forward(args, "warn", "", true);
      }
      error(...args) {
        return this.forward(args, "error", "");
      }
      deprecate(...args) {
        return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
      }
      forward(args, lvl, prefix, debugOnly) {
        if (debugOnly && !this.debug) return null;
        if (isString$2(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;
        return this.logger[lvl](args);
      }
      create(moduleName) {
        return new Logger(this.logger, __spreadValues(__spreadValues({}, {
          prefix: `${this.prefix}:${moduleName}:`
        }), this.options));
      }
      clone(options) {
        options = options || this.options;
        options.prefix = options.prefix || this.prefix;
        return new Logger(this.logger, options);
      }
    }
    var baseLogger = new Logger();
    class EventEmitter {
      constructor() {
        this.observers = {};
      }
      on(events, listener) {
        events.split(" ").forEach((event) => {
          if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
          const numListeners = this.observers[event].get(listener) || 0;
          this.observers[event].set(listener, numListeners + 1);
        });
        return this;
      }
      off(event, listener) {
        if (!this.observers[event]) return;
        if (!listener) {
          delete this.observers[event];
          return;
        }
        this.observers[event].delete(listener);
      }
      emit(event, ...args) {
        if (this.observers[event]) {
          const cloned = Array.from(this.observers[event].entries());
          cloned.forEach(([observer, numTimesAdded]) => {
            for (let i2 = 0; i2 < numTimesAdded; i2++) {
              observer(...args);
            }
          });
        }
        if (this.observers["*"]) {
          const cloned = Array.from(this.observers["*"].entries());
          cloned.forEach(([observer, numTimesAdded]) => {
            for (let i2 = 0; i2 < numTimesAdded; i2++) {
              observer.apply(observer, [event, ...args]);
            }
          });
        }
      }
    }
    class ResourceStore extends EventEmitter {
      constructor(data, options = {
        ns: ["translation"],
        defaultNS: "translation"
      }) {
        super();
        this.data = data || {};
        this.options = options;
        if (this.options.keySeparator === void 0) {
          this.options.keySeparator = ".";
        }
        if (this.options.ignoreJSONStructure === void 0) {
          this.options.ignoreJSONStructure = true;
        }
      }
      addNamespaces(ns) {
        if (this.options.ns.indexOf(ns) < 0) {
          this.options.ns.push(ns);
        }
      }
      removeNamespaces(ns) {
        const index2 = this.options.ns.indexOf(ns);
        if (index2 > -1) {
          this.options.ns.splice(index2, 1);
        }
      }
      getResource(lng, ns, key, options = {}) {
        var _a2, _b;
        const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
        const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
        let path2;
        if (lng.indexOf(".") > -1) {
          path2 = lng.split(".");
        } else {
          path2 = [lng, ns];
          if (key) {
            if (Array.isArray(key)) {
              path2.push(...key);
            } else if (isString$2(key) && keySeparator) {
              path2.push(...key.split(keySeparator));
            } else {
              path2.push(key);
            }
          }
        }
        const result = getPath(this.data, path2);
        if (!result && !ns && !key && lng.indexOf(".") > -1) {
          lng = path2[0];
          ns = path2[1];
          key = path2.slice(2).join(".");
        }
        if (result || !ignoreJSONStructure || !isString$2(key)) return result;
        return deepFind((_b = (_a2 = this.data) == null ? void 0 : _a2[lng]) == null ? void 0 : _b[ns], key, keySeparator);
      }
      addResource(lng, ns, key, value, options = {
        silent: false
      }) {
        const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
        let path2 = [lng, ns];
        if (key) path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
        if (lng.indexOf(".") > -1) {
          path2 = lng.split(".");
          value = ns;
          ns = path2[1];
        }
        this.addNamespaces(ns);
        setPath(this.data, path2, value);
        if (!options.silent) this.emit("added", lng, ns, key, value);
      }
      addResources(lng, ns, resources, options = {
        silent: false
      }) {
        for (const m in resources) {
          if (isString$2(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {
            silent: true
          });
        }
        if (!options.silent) this.emit("added", lng, ns, resources);
      }
      addResourceBundle(lng, ns, resources, deep, overwrite, options = {
        silent: false,
        skipCopy: false
      }) {
        let path2 = [lng, ns];
        if (lng.indexOf(".") > -1) {
          path2 = lng.split(".");
          deep = resources;
          resources = ns;
          ns = path2[1];
        }
        this.addNamespaces(ns);
        let pack = getPath(this.data, path2) || {};
        if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));
        if (deep) {
          deepExtend(pack, resources, overwrite);
        } else {
          pack = __spreadValues(__spreadValues({}, pack), resources);
        }
        setPath(this.data, path2, pack);
        if (!options.silent) this.emit("added", lng, ns, resources);
      }
      removeResourceBundle(lng, ns) {
        if (this.hasResourceBundle(lng, ns)) {
          delete this.data[lng][ns];
        }
        this.removeNamespaces(ns);
        this.emit("removed", lng, ns);
      }
      hasResourceBundle(lng, ns) {
        return this.getResource(lng, ns) !== void 0;
      }
      getResourceBundle(lng, ns) {
        if (!ns) ns = this.options.defaultNS;
        return this.getResource(lng, ns);
      }
      getDataByLanguage(lng) {
        return this.data[lng];
      }
      hasLanguageSomeTranslations(lng) {
        const data = this.getDataByLanguage(lng);
        const n = data && Object.keys(data) || [];
        return !!n.find((v) => data[v] && Object.keys(data[v]).length > 0);
      }
      toJSON() {
        return this.data;
      }
    }
    var postProcessor = {
      processors: {},
      addPostProcessor(module2) {
        this.processors[module2.name] = module2;
      },
      handle(processors, value, key, options, translator) {
        processors.forEach((processor) => {
          var _a2, _b;
          value = (_b = (_a2 = this.processors[processor]) == null ? void 0 : _a2.process(value, key, options, translator)) != null ? _b : value;
        });
        return value;
      }
    };
    const PATH_KEY = Symbol("i18next/PATH_KEY");
    function createProxy() {
      const state = [];
      const handler = /* @__PURE__ */ Object.create(null);
      let proxy;
      handler.get = (target, key) => {
        var _a2;
        (_a2 = proxy == null ? void 0 : proxy.revoke) == null ? void 0 : _a2.call(proxy);
        if (key === PATH_KEY) return state;
        state.push(key);
        proxy = Proxy.revocable(target, handler);
        return proxy.proxy;
      };
      return Proxy.revocable(/* @__PURE__ */ Object.create(null), handler).proxy;
    }
    function keysFromSelector(selector, opts) {
      var _a2;
      const {
        [PATH_KEY]: path2
      } = selector(createProxy());
      return path2.join((_a2 = opts == null ? void 0 : opts.keySeparator) != null ? _a2 : ".");
    }
    const checkedLoadedFor = {};
    const shouldHandleAsObject = (res) => !isString$2(res) && typeof res !== "boolean" && typeof res !== "number";
    class Translator extends EventEmitter {
      constructor(services, options = {}) {
        super();
        copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
        this.options = options;
        if (this.options.keySeparator === void 0) {
          this.options.keySeparator = ".";
        }
        this.logger = baseLogger.create("translator");
      }
      changeLanguage(lng) {
        if (lng) this.language = lng;
      }
      exists(key, o = {
        interpolation: {}
      }) {
        const opt = __spreadValues({}, o);
        if (key == null) return false;
        const resolved = this.resolve(key, opt);
        if ((resolved == null ? void 0 : resolved.res) === void 0) return false;
        const isObject2 = shouldHandleAsObject(resolved.res);
        if (opt.returnObjects === false && isObject2) {
          return false;
        }
        return true;
      }
      extractFromKey(key, opt) {
        let nsSeparator = opt.nsSeparator !== void 0 ? opt.nsSeparator : this.options.nsSeparator;
        if (nsSeparator === void 0) nsSeparator = ":";
        const keySeparator = opt.keySeparator !== void 0 ? opt.keySeparator : this.options.keySeparator;
        let namespaces = opt.ns || this.options.defaultNS || [];
        const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
        const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !opt.keySeparator && !this.options.userDefinedNsSeparator && !opt.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
        if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
          const m = key.match(this.interpolator.nestingRegexp);
          if (m && m.length > 0) {
            return {
              key,
              namespaces: isString$2(namespaces) ? [namespaces] : namespaces
            };
          }
          const parts = key.split(nsSeparator);
          if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
          key = parts.join(keySeparator);
        }
        return {
          key,
          namespaces: isString$2(namespaces) ? [namespaces] : namespaces
        };
      }
      translate(keys2, o, lastKey) {
        let opt = typeof o === "object" ? __spreadValues({}, o) : o;
        if (typeof opt !== "object" && this.options.overloadTranslationOptionHandler) {
          opt = this.options.overloadTranslationOptionHandler(arguments);
        }
        if (typeof opt === "object") opt = __spreadValues({}, opt);
        if (!opt) opt = {};
        if (keys2 == null) return "";
        if (typeof keys2 === "function") keys2 = keysFromSelector(keys2, __spreadValues(__spreadValues({}, this.options), opt));
        if (!Array.isArray(keys2)) keys2 = [String(keys2)];
        const returnDetails = opt.returnDetails !== void 0 ? opt.returnDetails : this.options.returnDetails;
        const keySeparator = opt.keySeparator !== void 0 ? opt.keySeparator : this.options.keySeparator;
        const {
          key,
          namespaces
        } = this.extractFromKey(keys2[keys2.length - 1], opt);
        const namespace = namespaces[namespaces.length - 1];
        let nsSeparator = opt.nsSeparator !== void 0 ? opt.nsSeparator : this.options.nsSeparator;
        if (nsSeparator === void 0) nsSeparator = ":";
        const lng = opt.lng || this.language;
        const appendNamespaceToCIMode = opt.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
        if ((lng == null ? void 0 : lng.toLowerCase()) === "cimode") {
          if (appendNamespaceToCIMode) {
            if (returnDetails) {
              return {
                res: `${namespace}${nsSeparator}${key}`,
                usedKey: key,
                exactUsedKey: key,
                usedLng: lng,
                usedNS: namespace,
                usedParams: this.getUsedParamsDetails(opt)
              };
            }
            return `${namespace}${nsSeparator}${key}`;
          }
          if (returnDetails) {
            return {
              res: key,
              usedKey: key,
              exactUsedKey: key,
              usedLng: lng,
              usedNS: namespace,
              usedParams: this.getUsedParamsDetails(opt)
            };
          }
          return key;
        }
        const resolved = this.resolve(keys2, opt);
        let res = resolved == null ? void 0 : resolved.res;
        const resUsedKey = (resolved == null ? void 0 : resolved.usedKey) || key;
        const resExactUsedKey = (resolved == null ? void 0 : resolved.exactUsedKey) || key;
        const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
        const joinArrays = opt.joinArrays !== void 0 ? opt.joinArrays : this.options.joinArrays;
        const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
        const needsPluralHandling = opt.count !== void 0 && !isString$2(opt.count);
        const hasDefaultValue = Translator.hasDefaultValue(opt);
        const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, opt) : "";
        const defaultValueSuffixOrdinalFallback = opt.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, {
          ordinal: false
        }) : "";
        const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
        const defaultValue = needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] || opt[`defaultValue${defaultValueSuffix}`] || opt[`defaultValue${defaultValueSuffixOrdinalFallback}`] || opt.defaultValue;
        let resForObjHndl = res;
        if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {
          resForObjHndl = defaultValue;
        }
        const handleAsObject = shouldHandleAsObject(resForObjHndl);
        const resType = Object.prototype.toString.apply(resForObjHndl);
        if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString$2(joinArrays) && Array.isArray(resForObjHndl))) {
          if (!opt.returnObjects && !this.options.returnObjects) {
            if (!this.options.returnedObjectHandler) {
              this.logger.warn("accessing an object - but returnObjects options is not enabled!");
            }
            const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, __spreadProps(__spreadValues({}, opt), {
              ns: namespaces
            })) : `key '${key} (${this.language})' returned an object instead of string.`;
            if (returnDetails) {
              resolved.res = r;
              resolved.usedParams = this.getUsedParamsDetails(opt);
              return resolved;
            }
            return r;
          }
          if (keySeparator) {
            const resTypeIsArray = Array.isArray(resForObjHndl);
            const copy2 = resTypeIsArray ? [] : {};
            const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
            for (const m in resForObjHndl) {
              if (Object.prototype.hasOwnProperty.call(resForObjHndl, m)) {
                const deepKey = `${newKeyToUse}${keySeparator}${m}`;
                if (hasDefaultValue && !res) {
                  copy2[m] = this.translate(deepKey, __spreadValues(__spreadProps(__spreadValues({}, opt), {
                    defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m] : void 0
                  }), {
                    joinArrays: false,
                    ns: namespaces
                  }));
                } else {
                  copy2[m] = this.translate(deepKey, __spreadValues(__spreadValues({}, opt), {
                    joinArrays: false,
                    ns: namespaces
                  }));
                }
                if (copy2[m] === deepKey) copy2[m] = resForObjHndl[m];
              }
            }
            res = copy2;
          }
        } else if (handleAsObjectInI18nFormat && isString$2(joinArrays) && Array.isArray(res)) {
          res = res.join(joinArrays);
          if (res) res = this.extendTranslation(res, keys2, opt, lastKey);
        } else {
          let usedDefault = false;
          let usedKey = false;
          if (!this.isValidLookup(res) && hasDefaultValue) {
            usedDefault = true;
            res = defaultValue;
          }
          if (!this.isValidLookup(res)) {
            usedKey = true;
            res = key;
          }
          const missingKeyNoValueFallbackToKey = opt.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
          const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
          const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
          if (usedKey || usedDefault || updateMissing) {
            this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
            if (keySeparator) {
              const fk = this.resolve(key, __spreadProps(__spreadValues({}, opt), {
                keySeparator: false
              }));
              if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
            }
            let lngs = [];
            const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, opt.lng || this.language);
            if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
              for (let i2 = 0; i2 < fallbackLngs.length; i2++) {
                lngs.push(fallbackLngs[i2]);
              }
            } else if (this.options.saveMissingTo === "all") {
              lngs = this.languageUtils.toResolveHierarchy(opt.lng || this.language);
            } else {
              lngs.push(opt.lng || this.language);
            }
            const send = (l, k, specificDefaultValue) => {
              var _a2;
              const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
              if (this.options.missingKeyHandler) {
                this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, opt);
              } else if ((_a2 = this.backendConnector) == null ? void 0 : _a2.saveMissing) {
                this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, opt);
              }
              this.emit("missingKey", l, namespace, k, res);
            };
            if (this.options.saveMissing) {
              if (this.options.saveMissingPlurals && needsPluralHandling) {
                lngs.forEach((language2) => {
                  const suffixes = this.pluralResolver.getSuffixes(language2, opt);
                  if (needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                    suffixes.push(`${this.options.pluralSeparator}zero`);
                  }
                  suffixes.forEach((suffix) => {
                    send([language2], key + suffix, opt[`defaultValue${suffix}`] || defaultValue);
                  });
                });
              } else {
                send(lngs, key, defaultValue);
              }
            }
          }
          res = this.extendTranslation(res, keys2, opt, resolved, lastKey);
          if (usedKey && res === key && this.options.appendNamespaceToMissingKey) {
            res = `${namespace}${nsSeparator}${key}`;
          }
          if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
            res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}${nsSeparator}${key}` : key, usedDefault ? res : void 0, opt);
          }
        }
        if (returnDetails) {
          resolved.res = res;
          resolved.usedParams = this.getUsedParamsDetails(opt);
          return resolved;
        }
        return res;
      }
      extendTranslation(res, key, opt, resolved, lastKey) {
        var _a2, _b;
        if ((_a2 = this.i18nFormat) == null ? void 0 : _a2.parse) {
          res = this.i18nFormat.parse(res, __spreadValues(__spreadValues({}, this.options.interpolation.defaultVariables), opt), opt.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
            resolved
          });
        } else if (!opt.skipInterpolation) {
          if (opt.interpolation) this.interpolator.init(__spreadValues(__spreadValues({}, opt), {
            interpolation: __spreadValues(__spreadValues({}, this.options.interpolation), opt.interpolation)
          }));
          const skipOnVariables = isString$2(res) && (((_b = opt == null ? void 0 : opt.interpolation) == null ? void 0 : _b.skipOnVariables) !== void 0 ? opt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
          let nestBef;
          if (skipOnVariables) {
            const nb = res.match(this.interpolator.nestingRegexp);
            nestBef = nb && nb.length;
          }
          let data = opt.replace && !isString$2(opt.replace) ? opt.replace : opt;
          if (this.options.interpolation.defaultVariables) data = __spreadValues(__spreadValues({}, this.options.interpolation.defaultVariables), data);
          res = this.interpolator.interpolate(res, data, opt.lng || this.language || resolved.usedLng, opt);
          if (skipOnVariables) {
            const na = res.match(this.interpolator.nestingRegexp);
            const nestAft = na && na.length;
            if (nestBef < nestAft) opt.nest = false;
          }
          if (!opt.lng && resolved && resolved.res) opt.lng = this.language || resolved.usedLng;
          if (opt.nest !== false) res = this.interpolator.nest(res, (...args) => {
            if ((lastKey == null ? void 0 : lastKey[0]) === args[0] && !opt.context) {
              this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
              return null;
            }
            return this.translate(...args, key);
          }, opt);
          if (opt.interpolation) this.interpolator.reset();
        }
        const postProcess = opt.postProcess || this.options.postProcess;
        const postProcessorNames = isString$2(postProcess) ? [postProcess] : postProcess;
        if (res != null && (postProcessorNames == null ? void 0 : postProcessorNames.length) && opt.applyPostProcessor !== false) {
          res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? __spreadValues({
            i18nResolved: __spreadProps(__spreadValues({}, resolved), {
              usedParams: this.getUsedParamsDetails(opt)
            })
          }, opt) : opt, this);
        }
        return res;
      }
      resolve(keys2, opt = {}) {
        let found;
        let usedKey;
        let exactUsedKey;
        let usedLng;
        let usedNS;
        if (isString$2(keys2)) keys2 = [keys2];
        keys2.forEach((k) => {
          if (this.isValidLookup(found)) return;
          const extracted = this.extractFromKey(k, opt);
          const key = extracted.key;
          usedKey = key;
          let namespaces = extracted.namespaces;
          if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
          const needsPluralHandling = opt.count !== void 0 && !isString$2(opt.count);
          const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
          const needsContextHandling = opt.context !== void 0 && (isString$2(opt.context) || typeof opt.context === "number") && opt.context !== "";
          const codes = opt.lngs ? opt.lngs : this.languageUtils.toResolveHierarchy(opt.lng || this.language, opt.fallbackLng);
          namespaces.forEach((ns) => {
            var _a2, _b;
            if (this.isValidLookup(found)) return;
            usedNS = ns;
            if (!checkedLoadedFor[`${codes[0]}-${ns}`] && ((_a2 = this.utils) == null ? void 0 : _a2.hasLoadedNamespace) && !((_b = this.utils) == null ? void 0 : _b.hasLoadedNamespace(usedNS))) {
              checkedLoadedFor[`${codes[0]}-${ns}`] = true;
              this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
            }
            codes.forEach((code2) => {
              var _a3;
              if (this.isValidLookup(found)) return;
              usedLng = code2;
              const finalKeys = [key];
              if ((_a3 = this.i18nFormat) == null ? void 0 : _a3.addLookupKeys) {
                this.i18nFormat.addLookupKeys(finalKeys, key, code2, ns, opt);
              } else {
                let pluralSuffix;
                if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code2, opt.count, opt);
                const zeroSuffix = `${this.options.pluralSeparator}zero`;
                const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                if (needsPluralHandling) {
                  if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                    finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                  }
                  finalKeys.push(key + pluralSuffix);
                  if (needsZeroSuffixLookup) {
                    finalKeys.push(key + zeroSuffix);
                  }
                }
                if (needsContextHandling) {
                  const contextKey = `${key}${this.options.contextSeparator || "_"}${opt.context}`;
                  finalKeys.push(contextKey);
                  if (needsPluralHandling) {
                    if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                      finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                    }
                    finalKeys.push(contextKey + pluralSuffix);
                    if (needsZeroSuffixLookup) {
                      finalKeys.push(contextKey + zeroSuffix);
                    }
                  }
                }
              }
              let possibleKey;
              while (possibleKey = finalKeys.pop()) {
                if (!this.isValidLookup(found)) {
                  exactUsedKey = possibleKey;
                  found = this.getResource(code2, ns, possibleKey, opt);
                }
              }
            });
          });
        });
        return {
          res: found,
          usedKey,
          exactUsedKey,
          usedLng,
          usedNS
        };
      }
      isValidLookup(res) {
        return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
      }
      getResource(code2, ns, key, options = {}) {
        var _a2;
        if ((_a2 = this.i18nFormat) == null ? void 0 : _a2.getResource) return this.i18nFormat.getResource(code2, ns, key, options);
        return this.resourceStore.getResource(code2, ns, key, options);
      }
      getUsedParamsDetails(options = {}) {
        const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
        const useOptionsReplaceForData = options.replace && !isString$2(options.replace);
        let data = useOptionsReplaceForData ? options.replace : options;
        if (useOptionsReplaceForData && typeof options.count !== "undefined") {
          data.count = options.count;
        }
        if (this.options.interpolation.defaultVariables) {
          data = __spreadValues(__spreadValues({}, this.options.interpolation.defaultVariables), data);
        }
        if (!useOptionsReplaceForData) {
          data = __spreadValues({}, data);
          for (const key of optionsKeys) {
            delete data[key];
          }
        }
        return data;
      }
      static hasDefaultValue(options) {
        const prefix = "defaultValue";
        for (const option in options) {
          if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
            return true;
          }
        }
        return false;
      }
    }
    class LanguageUtil {
      constructor(options) {
        this.options = options;
        this.supportedLngs = this.options.supportedLngs || false;
        this.logger = baseLogger.create("languageUtils");
      }
      getScriptPartFromCode(code2) {
        code2 = getCleanedCode(code2);
        if (!code2 || code2.indexOf("-") < 0) return null;
        const p = code2.split("-");
        if (p.length === 2) return null;
        p.pop();
        if (p[p.length - 1].toLowerCase() === "x") return null;
        return this.formatLanguageCode(p.join("-"));
      }
      getLanguagePartFromCode(code2) {
        code2 = getCleanedCode(code2);
        if (!code2 || code2.indexOf("-") < 0) return code2;
        const p = code2.split("-");
        return this.formatLanguageCode(p[0]);
      }
      formatLanguageCode(code2) {
        if (isString$2(code2) && code2.indexOf("-") > -1) {
          let formattedCode;
          try {
            formattedCode = Intl.getCanonicalLocales(code2)[0];
          } catch (e) {
          }
          if (formattedCode && this.options.lowerCaseLng) {
            formattedCode = formattedCode.toLowerCase();
          }
          if (formattedCode) return formattedCode;
          if (this.options.lowerCaseLng) {
            return code2.toLowerCase();
          }
          return code2;
        }
        return this.options.cleanCode || this.options.lowerCaseLng ? code2.toLowerCase() : code2;
      }
      isSupportedCode(code2) {
        if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
          code2 = this.getLanguagePartFromCode(code2);
        }
        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code2) > -1;
      }
      getBestMatchFromCodes(codes) {
        if (!codes) return null;
        let found;
        codes.forEach((code2) => {
          if (found) return;
          const cleanedLng = this.formatLanguageCode(code2);
          if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
        });
        if (!found && this.options.supportedLngs) {
          codes.forEach((code2) => {
            if (found) return;
            const lngScOnly = this.getScriptPartFromCode(code2);
            if (this.isSupportedCode(lngScOnly)) return found = lngScOnly;
            const lngOnly = this.getLanguagePartFromCode(code2);
            if (this.isSupportedCode(lngOnly)) return found = lngOnly;
            found = this.options.supportedLngs.find((supportedLng) => {
              if (supportedLng === lngOnly) return supportedLng;
              if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
              if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
              if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
            });
          });
        }
        if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
        return found;
      }
      getFallbackCodes(fallbacks, code2) {
        if (!fallbacks) return [];
        if (typeof fallbacks === "function") fallbacks = fallbacks(code2);
        if (isString$2(fallbacks)) fallbacks = [fallbacks];
        if (Array.isArray(fallbacks)) return fallbacks;
        if (!code2) return fallbacks.default || [];
        let found = fallbacks[code2];
        if (!found) found = fallbacks[this.getScriptPartFromCode(code2)];
        if (!found) found = fallbacks[this.formatLanguageCode(code2)];
        if (!found) found = fallbacks[this.getLanguagePartFromCode(code2)];
        if (!found) found = fallbacks.default;
        return found || [];
      }
      toResolveHierarchy(code2, fallbackCode) {
        const fallbackCodes = this.getFallbackCodes((fallbackCode === false ? [] : fallbackCode) || this.options.fallbackLng || [], code2);
        const codes = [];
        const addCode = (c) => {
          if (!c) return;
          if (this.isSupportedCode(c)) {
            codes.push(c);
          } else {
            this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
          }
        };
        if (isString$2(code2) && (code2.indexOf("-") > -1 || code2.indexOf("_") > -1)) {
          if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code2));
          if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code2));
          if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code2));
        } else if (isString$2(code2)) {
          addCode(this.formatLanguageCode(code2));
        }
        fallbackCodes.forEach((fc) => {
          if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
        });
        return codes;
      }
    }
    const suffixesOrder = {
      zero: 0,
      one: 1,
      two: 2,
      few: 3,
      many: 4,
      other: 5
    };
    const dummyRule = {
      select: (count) => count === 1 ? "one" : "other",
      resolvedOptions: () => ({
        pluralCategories: ["one", "other"]
      })
    };
    class PluralResolver {
      constructor(languageUtils, options = {}) {
        this.languageUtils = languageUtils;
        this.options = options;
        this.logger = baseLogger.create("pluralResolver");
        this.pluralRulesCache = {};
      }
      addRule(lng, obj) {
        this.rules[lng] = obj;
      }
      clearCache() {
        this.pluralRulesCache = {};
      }
      getRule(code2, options = {}) {
        const cleanedCode = getCleanedCode(code2 === "dev" ? "en" : code2);
        const type = options.ordinal ? "ordinal" : "cardinal";
        const cacheKey = JSON.stringify({
          cleanedCode,
          type
        });
        if (cacheKey in this.pluralRulesCache) {
          return this.pluralRulesCache[cacheKey];
        }
        let rule;
        try {
          rule = new Intl.PluralRules(cleanedCode, {
            type
          });
        } catch (err) {
          if (!Intl) {
            this.logger.error("No Intl support, please use an Intl polyfill!");
            return dummyRule;
          }
          if (!code2.match(/-|_/)) return dummyRule;
          const lngPart = this.languageUtils.getLanguagePartFromCode(code2);
          rule = this.getRule(lngPart, options);
        }
        this.pluralRulesCache[cacheKey] = rule;
        return rule;
      }
      needsPlural(code2, options = {}) {
        let rule = this.getRule(code2, options);
        if (!rule) rule = this.getRule("dev", options);
        return (rule == null ? void 0 : rule.resolvedOptions().pluralCategories.length) > 1;
      }
      getPluralFormsOfKey(code2, key, options = {}) {
        return this.getSuffixes(code2, options).map((suffix) => `${key}${suffix}`);
      }
      getSuffixes(code2, options = {}) {
        let rule = this.getRule(code2, options);
        if (!rule) rule = this.getRule("dev", options);
        if (!rule) return [];
        return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
      }
      getSuffix(code2, count, options = {}) {
        const rule = this.getRule(code2, options);
        if (rule) {
          return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
        }
        this.logger.warn(`no plural rule found for: ${code2}`);
        return this.getSuffix("dev", count, options);
      }
    }
    const deepFindWithDefaults = (data, defaultData, key, keySeparator = ".", ignoreJSONStructure = true) => {
      let path2 = getPathWithDefaults(data, defaultData, key);
      if (!path2 && ignoreJSONStructure && isString$2(key)) {
        path2 = deepFind(data, key, keySeparator);
        if (path2 === void 0) path2 = deepFind(defaultData, key, keySeparator);
      }
      return path2;
    };
    const regexSafe = (val) => val.replace(/\$/g, "$$$$");
    class Interpolator {
      constructor(options = {}) {
        var _a2;
        this.logger = baseLogger.create("interpolator");
        this.options = options;
        this.format = ((_a2 = options == null ? void 0 : options.interpolation) == null ? void 0 : _a2.format) || ((value) => value);
        this.init(options);
      }
      init(options = {}) {
        if (!options.interpolation) options.interpolation = {
          escapeValue: true
        };
        const {
          escape: escape$1,
          escapeValue,
          useRawValueToEscape,
          prefix,
          prefixEscaped,
          suffix,
          suffixEscaped,
          formatSeparator,
          unescapeSuffix,
          unescapePrefix,
          nestingPrefix,
          nestingPrefixEscaped,
          nestingSuffix,
          nestingSuffixEscaped,
          nestingOptionsSeparator,
          maxReplaces,
          alwaysFormat
        } = options.interpolation;
        this.escape = escape$1 !== void 0 ? escape$1 : escape;
        this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
        this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
        this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
        this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
        this.formatSeparator = formatSeparator || ",";
        this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
        this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
        this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
        this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
        this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
        this.maxReplaces = maxReplaces || 1e3;
        this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
        this.resetRegExp();
      }
      reset() {
        if (this.options) this.init(this.options);
      }
      resetRegExp() {
        const getOrResetRegExp = (existingRegExp, pattern) => {
          if ((existingRegExp == null ? void 0 : existingRegExp.source) === pattern) {
            existingRegExp.lastIndex = 0;
            return existingRegExp;
          }
          return new RegExp(pattern, "g");
        };
        this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
        this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
        this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}((?:[^()"']+|"[^"]*"|'[^']*'|\\((?:[^()]|"[^"]*"|'[^']*')*\\))*?)${this.nestingSuffix}`);
      }
      interpolate(str, data, lng, options) {
        var _a2;
        let match;
        let value;
        let replaces;
        const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
        const handleFormat = (key) => {
          if (key.indexOf(this.formatSeparator) < 0) {
            const path2 = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
            return this.alwaysFormat ? this.format(path2, void 0, lng, __spreadProps(__spreadValues(__spreadValues({}, options), data), {
              interpolationkey: key
            })) : path2;
          }
          const p = key.split(this.formatSeparator);
          const k = p.shift().trim();
          const f = p.join(this.formatSeparator).trim();
          return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, __spreadProps(__spreadValues(__spreadValues({}, options), data), {
            interpolationkey: k
          }));
        };
        this.resetRegExp();
        const missingInterpolationHandler = (options == null ? void 0 : options.missingInterpolationHandler) || this.options.missingInterpolationHandler;
        const skipOnVariables = ((_a2 = options == null ? void 0 : options.interpolation) == null ? void 0 : _a2.skipOnVariables) !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
        const todos = [{
          regex: this.regexpUnescape,
          safeValue: (val) => regexSafe(val)
        }, {
          regex: this.regexp,
          safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
        }];
        todos.forEach((todo) => {
          replaces = 0;
          while (match = todo.regex.exec(str)) {
            const matchedVar = match[1].trim();
            value = handleFormat(matchedVar);
            if (value === void 0) {
              if (typeof missingInterpolationHandler === "function") {
                const temp = missingInterpolationHandler(str, match, options);
                value = isString$2(temp) ? temp : "";
              } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
                value = "";
              } else if (skipOnVariables) {
                value = match[0];
                continue;
              } else {
                this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
                value = "";
              }
            } else if (!isString$2(value) && !this.useRawValueToEscape) {
              value = makeString(value);
            }
            const safeValue = todo.safeValue(value);
            str = str.replace(match[0], safeValue);
            if (skipOnVariables) {
              todo.regex.lastIndex += value.length;
              todo.regex.lastIndex -= match[0].length;
            } else {
              todo.regex.lastIndex = 0;
            }
            replaces++;
            if (replaces >= this.maxReplaces) {
              break;
            }
          }
        });
        return str;
      }
      nest(str, fc, options = {}) {
        let match;
        let value;
        let clonedOptions;
        const handleHasOptions = (key, inheritedOptions) => {
          var _a2;
          const sep = this.nestingOptionsSeparator;
          if (key.indexOf(sep) < 0) return key;
          const c = key.split(new RegExp(`${sep}[ ]*{`));
          let optionsString = `{${c[1]}`;
          key = c[0];
          optionsString = this.interpolate(optionsString, clonedOptions);
          const matchedSingleQuotes = optionsString.match(/'/g);
          const matchedDoubleQuotes = optionsString.match(/"/g);
          if (((_a2 = matchedSingleQuotes == null ? void 0 : matchedSingleQuotes.length) != null ? _a2 : 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
            optionsString = optionsString.replace(/'/g, '"');
          }
          try {
            clonedOptions = JSON.parse(optionsString);
            if (inheritedOptions) clonedOptions = __spreadValues(__spreadValues({}, inheritedOptions), clonedOptions);
          } catch (e) {
            this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
            return `${key}${sep}${optionsString}`;
          }
          if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
          return key;
        };
        while (match = this.nestingRegexp.exec(str)) {
          let formatters2 = [];
          clonedOptions = __spreadValues({}, options);
          clonedOptions = clonedOptions.replace && !isString$2(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
          clonedOptions.applyPostProcessor = false;
          delete clonedOptions.defaultValue;
          const keyEndIndex = /{.*}/.test(match[1]) ? match[1].lastIndexOf("}") + 1 : match[1].indexOf(this.formatSeparator);
          if (keyEndIndex !== -1) {
            formatters2 = match[1].slice(keyEndIndex).split(this.formatSeparator).map((elem) => elem.trim()).filter(Boolean);
            match[1] = match[1].slice(0, keyEndIndex);
          }
          value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
          if (value && match[0] === str && !isString$2(value)) return value;
          if (!isString$2(value)) value = makeString(value);
          if (!value) {
            this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
            value = "";
          }
          if (formatters2.length) {
            value = formatters2.reduce((v, f) => this.format(v, f, options.lng, __spreadProps(__spreadValues({}, options), {
              interpolationkey: match[1].trim()
            })), value.trim());
          }
          str = str.replace(match[0], value);
          this.regexp.lastIndex = 0;
        }
        return str;
      }
    }
    const parseFormatStr = (formatStr) => {
      let formatName = formatStr.toLowerCase().trim();
      const formatOptions = {};
      if (formatStr.indexOf("(") > -1) {
        const p = formatStr.split("(");
        formatName = p[0].toLowerCase().trim();
        const optStr = p[1].substring(0, p[1].length - 1);
        if (formatName === "currency" && optStr.indexOf(":") < 0) {
          if (!formatOptions.currency) formatOptions.currency = optStr.trim();
        } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
          if (!formatOptions.range) formatOptions.range = optStr.trim();
        } else {
          const opts = optStr.split(";");
          opts.forEach((opt) => {
            if (opt) {
              const [key, ...rest] = opt.split(":");
              const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
              const trimmedKey = key.trim();
              if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
              if (val === "false") formatOptions[trimmedKey] = false;
              if (val === "true") formatOptions[trimmedKey] = true;
              if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
            }
          });
        }
      }
      return {
        formatName,
        formatOptions
      };
    };
    const createCachedFormatter = (fn) => {
      const cache = {};
      return (v, l, o) => {
        let optForCache = o;
        if (o && o.interpolationkey && o.formatParams && o.formatParams[o.interpolationkey] && o[o.interpolationkey]) {
          optForCache = __spreadProps(__spreadValues({}, optForCache), {
            [o.interpolationkey]: void 0
          });
        }
        const key = l + JSON.stringify(optForCache);
        let frm = cache[key];
        if (!frm) {
          frm = fn(getCleanedCode(l), o);
          cache[key] = frm;
        }
        return frm(v);
      };
    };
    const createNonCachedFormatter = (fn) => (v, l, o) => fn(getCleanedCode(l), o)(v);
    class Formatter {
      constructor(options = {}) {
        this.logger = baseLogger.create("formatter");
        this.options = options;
        this.init(options);
      }
      init(services, options = {
        interpolation: {}
      }) {
        this.formatSeparator = options.interpolation.formatSeparator || ",";
        const cf = options.cacheInBuiltFormats ? createCachedFormatter : createNonCachedFormatter;
        this.formats = {
          number: cf((lng, opt) => {
            const formatter = new Intl.NumberFormat(lng, __spreadValues({}, opt));
            return (val) => formatter.format(val);
          }),
          currency: cf((lng, opt) => {
            const formatter = new Intl.NumberFormat(lng, __spreadProps(__spreadValues({}, opt), {
              style: "currency"
            }));
            return (val) => formatter.format(val);
          }),
          datetime: cf((lng, opt) => {
            const formatter = new Intl.DateTimeFormat(lng, __spreadValues({}, opt));
            return (val) => formatter.format(val);
          }),
          relativetime: cf((lng, opt) => {
            const formatter = new Intl.RelativeTimeFormat(lng, __spreadValues({}, opt));
            return (val) => formatter.format(val, opt.range || "day");
          }),
          list: cf((lng, opt) => {
            const formatter = new Intl.ListFormat(lng, __spreadValues({}, opt));
            return (val) => formatter.format(val);
          })
        };
      }
      add(name2, fc) {
        this.formats[name2.toLowerCase().trim()] = fc;
      }
      addCached(name2, fc) {
        this.formats[name2.toLowerCase().trim()] = createCachedFormatter(fc);
      }
      format(value, format, lng, options = {}) {
        const formats = format.split(this.formatSeparator);
        if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f) => f.indexOf(")") > -1)) {
          const lastIndex = formats.findIndex((f) => f.indexOf(")") > -1);
          formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
        }
        const result = formats.reduce((mem, f) => {
          var _a2;
          const {
            formatName,
            formatOptions
          } = parseFormatStr(f);
          if (this.formats[formatName]) {
            let formatted = mem;
            try {
              const valOptions = ((_a2 = options == null ? void 0 : options.formatParams) == null ? void 0 : _a2[options.interpolationkey]) || {};
              const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
              formatted = this.formats[formatName](mem, l, __spreadValues(__spreadValues(__spreadValues({}, formatOptions), options), valOptions));
            } catch (error2) {
              this.logger.warn(error2);
            }
            return formatted;
          } else {
            this.logger.warn(`there was no format function for ${formatName}`);
          }
          return mem;
        }, value);
        return result;
      }
    }
    const removePending = (q, name2) => {
      if (q.pending[name2] !== void 0) {
        delete q.pending[name2];
        q.pendingCount--;
      }
    };
    class Connector extends EventEmitter {
      constructor(backend, store, services, options = {}) {
        var _a2, _b;
        super();
        this.backend = backend;
        this.store = store;
        this.services = services;
        this.languageUtils = services.languageUtils;
        this.options = options;
        this.logger = baseLogger.create("backendConnector");
        this.waitingReads = [];
        this.maxParallelReads = options.maxParallelReads || 10;
        this.readingCalls = 0;
        this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
        this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
        this.state = {};
        this.queue = [];
        (_b = (_a2 = this.backend) == null ? void 0 : _a2.init) == null ? void 0 : _b.call(_a2, services, options.backend, options);
      }
      queueLoad(languages, namespaces, options, callback2) {
        const toLoad = {};
        const pending = {};
        const toLoadLanguages = {};
        const toLoadNamespaces = {};
        languages.forEach((lng) => {
          let hasAllNamespaces = true;
          namespaces.forEach((ns) => {
            const name2 = `${lng}|${ns}`;
            if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
              this.state[name2] = 2;
            } else if (this.state[name2] < 0) ;
            else if (this.state[name2] === 1) {
              if (pending[name2] === void 0) pending[name2] = true;
            } else {
              this.state[name2] = 1;
              hasAllNamespaces = false;
              if (pending[name2] === void 0) pending[name2] = true;
              if (toLoad[name2] === void 0) toLoad[name2] = true;
              if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
            }
          });
          if (!hasAllNamespaces) toLoadLanguages[lng] = true;
        });
        if (Object.keys(toLoad).length || Object.keys(pending).length) {
          this.queue.push({
            pending,
            pendingCount: Object.keys(pending).length,
            loaded: {},
            errors: [],
            callback: callback2
          });
        }
        return {
          toLoad: Object.keys(toLoad),
          pending: Object.keys(pending),
          toLoadLanguages: Object.keys(toLoadLanguages),
          toLoadNamespaces: Object.keys(toLoadNamespaces)
        };
      }
      loaded(name2, err, data) {
        const s = name2.split("|");
        const lng = s[0];
        const ns = s[1];
        if (err) this.emit("failedLoading", lng, ns, err);
        if (!err && data) {
          this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
            skipCopy: true
          });
        }
        this.state[name2] = err ? -1 : 2;
        if (err && data) this.state[name2] = 0;
        const loaded = {};
        this.queue.forEach((q) => {
          pushPath(q.loaded, [lng], ns);
          removePending(q, name2);
          if (err) q.errors.push(err);
          if (q.pendingCount === 0 && !q.done) {
            Object.keys(q.loaded).forEach((l) => {
              if (!loaded[l]) loaded[l] = {};
              const loadedKeys = q.loaded[l];
              if (loadedKeys.length) {
                loadedKeys.forEach((n) => {
                  if (loaded[l][n] === void 0) loaded[l][n] = true;
                });
              }
            });
            q.done = true;
            if (q.errors.length) {
              q.callback(q.errors);
            } else {
              q.callback();
            }
          }
        });
        this.emit("loaded", loaded);
        this.queue = this.queue.filter((q) => !q.done);
      }
      read(lng, ns, fcName, tried = 0, wait = this.retryTimeout, callback2) {
        if (!lng.length) return callback2(null, {});
        if (this.readingCalls >= this.maxParallelReads) {
          this.waitingReads.push({
            lng,
            ns,
            fcName,
            tried,
            wait,
            callback: callback2
          });
          return;
        }
        this.readingCalls++;
        const resolver = (err, data) => {
          this.readingCalls--;
          if (this.waitingReads.length > 0) {
            const next = this.waitingReads.shift();
            this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
          }
          if (err && data && tried < this.maxRetries) {
            setTimeout(() => {
              this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback2);
            }, wait);
            return;
          }
          callback2(err, data);
        };
        const fc = this.backend[fcName].bind(this.backend);
        if (fc.length === 2) {
          try {
            const r = fc(lng, ns);
            if (r && typeof r.then === "function") {
              r.then((data) => resolver(null, data)).catch(resolver);
            } else {
              resolver(null, r);
            }
          } catch (err) {
            resolver(err);
          }
          return;
        }
        return fc(lng, ns, resolver);
      }
      prepareLoading(languages, namespaces, options = {}, callback2) {
        if (!this.backend) {
          this.logger.warn("No backend was added via i18next.use. Will not load resources.");
          return callback2 && callback2();
        }
        if (isString$2(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
        if (isString$2(namespaces)) namespaces = [namespaces];
        const toLoad = this.queueLoad(languages, namespaces, options, callback2);
        if (!toLoad.toLoad.length) {
          if (!toLoad.pending.length) callback2();
          return null;
        }
        toLoad.toLoad.forEach((name2) => {
          this.loadOne(name2);
        });
      }
      load(languages, namespaces, callback2) {
        this.prepareLoading(languages, namespaces, {}, callback2);
      }
      reload(languages, namespaces, callback2) {
        this.prepareLoading(languages, namespaces, {
          reload: true
        }, callback2);
      }
      loadOne(name2, prefix = "") {
        const s = name2.split("|");
        const lng = s[0];
        const ns = s[1];
        this.read(lng, ns, "read", void 0, void 0, (err, data) => {
          if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
          if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
          this.loaded(name2, err, data);
        });
      }
      saveMissing(languages, namespace, key, fallbackValue, isUpdate, options = {}, clb = () => {
      }) {
        var _a2, _b, _c, _d, _e;
        if (((_b = (_a2 = this.services) == null ? void 0 : _a2.utils) == null ? void 0 : _b.hasLoadedNamespace) && !((_d = (_c = this.services) == null ? void 0 : _c.utils) == null ? void 0 : _d.hasLoadedNamespace(namespace))) {
          this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          return;
        }
        if (key === void 0 || key === null || key === "") return;
        if ((_e = this.backend) == null ? void 0 : _e.create) {
          const opts = __spreadProps(__spreadValues({}, options), {
            isUpdate
          });
          const fc = this.backend.create.bind(this.backend);
          if (fc.length < 6) {
            try {
              let r;
              if (fc.length === 5) {
                r = fc(languages, namespace, key, fallbackValue, opts);
              } else {
                r = fc(languages, namespace, key, fallbackValue);
              }
              if (r && typeof r.then === "function") {
                r.then((data) => clb(null, data)).catch(clb);
              } else {
                clb(null, r);
              }
            } catch (err) {
              clb(err);
            }
          } else {
            fc(languages, namespace, key, fallbackValue, clb, opts);
          }
        }
        if (!languages || !languages[0]) return;
        this.store.addResource(languages[0], namespace, key, fallbackValue);
      }
    }
    const get = () => ({
      debug: false,
      initAsync: true,
      ns: ["translation"],
      defaultNS: ["translation"],
      fallbackLng: ["dev"],
      fallbackNS: false,
      supportedLngs: false,
      nonExplicitSupportedLngs: false,
      load: "all",
      preload: false,
      simplifyPluralSuffix: true,
      keySeparator: ".",
      nsSeparator: ":",
      pluralSeparator: "_",
      contextSeparator: "_",
      partialBundledLanguages: false,
      saveMissing: false,
      updateMissing: false,
      saveMissingTo: "fallback",
      saveMissingPlurals: true,
      missingKeyHandler: false,
      missingInterpolationHandler: false,
      postProcess: false,
      postProcessPassResolved: false,
      returnNull: false,
      returnEmptyString: true,
      returnObjects: false,
      joinArrays: false,
      returnedObjectHandler: false,
      parseMissingKeyHandler: false,
      appendNamespaceToMissingKey: false,
      appendNamespaceToCIMode: false,
      overloadTranslationOptionHandler: (args) => {
        let ret = {};
        if (typeof args[1] === "object") ret = args[1];
        if (isString$2(args[1])) ret.defaultValue = args[1];
        if (isString$2(args[2])) ret.tDescription = args[2];
        if (typeof args[2] === "object" || typeof args[3] === "object") {
          const options = args[3] || args[2];
          Object.keys(options).forEach((key) => {
            ret[key] = options[key];
          });
        }
        return ret;
      },
      interpolation: {
        escapeValue: true,
        format: (value) => value,
        prefix: "{{",
        suffix: "}}",
        formatSeparator: ",",
        unescapePrefix: "-",
        nestingPrefix: "$t(",
        nestingSuffix: ")",
        nestingOptionsSeparator: ",",
        maxReplaces: 1e3,
        skipOnVariables: true
      },
      cacheInBuiltFormats: true
    });
    const transformOptions = (options) => {
      var _a2, _b;
      if (isString$2(options.ns)) options.ns = [options.ns];
      if (isString$2(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
      if (isString$2(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
      if (((_b = (_a2 = options.supportedLngs) == null ? void 0 : _a2.indexOf) == null ? void 0 : _b.call(_a2, "cimode")) < 0) {
        options.supportedLngs = options.supportedLngs.concat(["cimode"]);
      }
      if (typeof options.initImmediate === "boolean") options.initAsync = options.initImmediate;
      return options;
    };
    const noop$2 = () => {
    };
    const bindMemberFunctions = (inst) => {
      const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
      mems.forEach((mem) => {
        if (typeof inst[mem] === "function") {
          inst[mem] = inst[mem].bind(inst);
        }
      });
    };
    class I18n extends EventEmitter {
      constructor(options = {}, callback2) {
        super();
        this.options = transformOptions(options);
        this.services = {};
        this.logger = baseLogger;
        this.modules = {
          external: []
        };
        bindMemberFunctions(this);
        if (callback2 && !this.isInitialized && !options.isClone) {
          if (!this.options.initAsync) {
            this.init(options, callback2);
            return this;
          }
          setTimeout(() => {
            this.init(options, callback2);
          }, 0);
        }
      }
      init(options = {}, callback2) {
        this.isInitializing = true;
        if (typeof options === "function") {
          callback2 = options;
          options = {};
        }
        if (options.defaultNS == null && options.ns) {
          if (isString$2(options.ns)) {
            options.defaultNS = options.ns;
          } else if (options.ns.indexOf("translation") < 0) {
            options.defaultNS = options.ns[0];
          }
        }
        const defOpts = get();
        this.options = __spreadValues(__spreadValues(__spreadValues({}, defOpts), this.options), transformOptions(options));
        this.options.interpolation = __spreadValues(__spreadValues({}, defOpts.interpolation), this.options.interpolation);
        if (options.keySeparator !== void 0) {
          this.options.userDefinedKeySeparator = options.keySeparator;
        }
        if (options.nsSeparator !== void 0) {
          this.options.userDefinedNsSeparator = options.nsSeparator;
        }
        const createClassOnDemand = (ClassOrObject) => {
          if (!ClassOrObject) return null;
          if (typeof ClassOrObject === "function") return new ClassOrObject();
          return ClassOrObject;
        };
        if (!this.options.isClone) {
          if (this.modules.logger) {
            baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
          } else {
            baseLogger.init(null, this.options);
          }
          let formatter;
          if (this.modules.formatter) {
            formatter = this.modules.formatter;
          } else {
            formatter = Formatter;
          }
          const lu = new LanguageUtil(this.options);
          this.store = new ResourceStore(this.options.resources, this.options);
          const s = this.services;
          s.logger = baseLogger;
          s.resourceStore = this.store;
          s.languageUtils = lu;
          s.pluralResolver = new PluralResolver(lu, {
            prepend: this.options.pluralSeparator,
            simplifyPluralSuffix: this.options.simplifyPluralSuffix
          });
          const usingLegacyFormatFunction = this.options.interpolation.format && this.options.interpolation.format !== defOpts.interpolation.format;
          if (usingLegacyFormatFunction) {
            this.logger.deprecate(`init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting`);
          }
          if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
            s.formatter = createClassOnDemand(formatter);
            if (s.formatter.init) s.formatter.init(s, this.options);
            this.options.interpolation.format = s.formatter.format.bind(s.formatter);
          }
          s.interpolator = new Interpolator(this.options);
          s.utils = {
            hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
          };
          s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
          s.backendConnector.on("*", (event, ...args) => {
            this.emit(event, ...args);
          });
          if (this.modules.languageDetector) {
            s.languageDetector = createClassOnDemand(this.modules.languageDetector);
            if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
          }
          if (this.modules.i18nFormat) {
            s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
            if (s.i18nFormat.init) s.i18nFormat.init(this);
          }
          this.translator = new Translator(this.services, this.options);
          this.translator.on("*", (event, ...args) => {
            this.emit(event, ...args);
          });
          this.modules.external.forEach((m) => {
            if (m.init) m.init(this);
          });
        }
        this.format = this.options.interpolation.format;
        if (!callback2) callback2 = noop$2;
        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
          const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
        }
        if (!this.services.languageDetector && !this.options.lng) {
          this.logger.warn("init: no languageDetector is used and no lng is defined");
        }
        const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
        storeApi.forEach((fcName) => {
          this[fcName] = (...args) => this.store[fcName](...args);
        });
        const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
        storeApiChained.forEach((fcName) => {
          this[fcName] = (...args) => {
            this.store[fcName](...args);
            return this;
          };
        });
        const deferred = defer();
        const load = () => {
          const finish = (err, t2) => {
            this.isInitializing = false;
            if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
            this.isInitialized = true;
            if (!this.options.isClone) this.logger.log("initialized", this.options);
            this.emit("initialized", this.options);
            deferred.resolve(t2);
            callback2(err, t2);
          };
          if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));
          this.changeLanguage(this.options.lng, finish);
        };
        if (this.options.resources || !this.options.initAsync) {
          load();
        } else {
          setTimeout(load, 0);
        }
        return deferred;
      }
      loadResources(language2, callback2 = noop$2) {
        var _a2, _b;
        let usedCallback = callback2;
        const usedLng = isString$2(language2) ? language2 : this.language;
        if (typeof language2 === "function") usedCallback = language2;
        if (!this.options.resources || this.options.partialBundledLanguages) {
          if ((usedLng == null ? void 0 : usedLng.toLowerCase()) === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
          const toLoad = [];
          const append = (lng) => {
            if (!lng) return;
            if (lng === "cimode") return;
            const lngs = this.services.languageUtils.toResolveHierarchy(lng);
            lngs.forEach((l) => {
              if (l === "cimode") return;
              if (toLoad.indexOf(l) < 0) toLoad.push(l);
            });
          };
          if (!usedLng) {
            const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            fallbacks.forEach((l) => append(l));
          } else {
            append(usedLng);
          }
          (_b = (_a2 = this.options.preload) == null ? void 0 : _a2.forEach) == null ? void 0 : _b.call(_a2, (l) => append(l));
          this.services.backendConnector.load(toLoad, this.options.ns, (e) => {
            if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
            usedCallback(e);
          });
        } else {
          usedCallback(null);
        }
      }
      reloadResources(lngs, ns, callback2) {
        const deferred = defer();
        if (typeof lngs === "function") {
          callback2 = lngs;
          lngs = void 0;
        }
        if (typeof ns === "function") {
          callback2 = ns;
          ns = void 0;
        }
        if (!lngs) lngs = this.languages;
        if (!ns) ns = this.options.ns;
        if (!callback2) callback2 = noop$2;
        this.services.backendConnector.reload(lngs, ns, (err) => {
          deferred.resolve();
          callback2(err);
        });
        return deferred;
      }
      use(module2) {
        if (!module2) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
        if (!module2.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
        if (module2.type === "backend") {
          this.modules.backend = module2;
        }
        if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
          this.modules.logger = module2;
        }
        if (module2.type === "languageDetector") {
          this.modules.languageDetector = module2;
        }
        if (module2.type === "i18nFormat") {
          this.modules.i18nFormat = module2;
        }
        if (module2.type === "postProcessor") {
          postProcessor.addPostProcessor(module2);
        }
        if (module2.type === "formatter") {
          this.modules.formatter = module2;
        }
        if (module2.type === "3rdParty") {
          this.modules.external.push(module2);
        }
        return this;
      }
      setResolvedLanguage(l) {
        if (!l || !this.languages) return;
        if (["cimode", "dev"].indexOf(l) > -1) return;
        for (let li = 0; li < this.languages.length; li++) {
          const lngInLngs = this.languages[li];
          if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
          if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
            this.resolvedLanguage = lngInLngs;
            break;
          }
        }
        if (!this.resolvedLanguage && this.languages.indexOf(l) < 0 && this.store.hasLanguageSomeTranslations(l)) {
          this.resolvedLanguage = l;
          this.languages.unshift(l);
        }
      }
      changeLanguage(lng, callback2) {
        this.isLanguageChangingTo = lng;
        const deferred = defer();
        this.emit("languageChanging", lng);
        const setLngProps = (l) => {
          this.language = l;
          this.languages = this.services.languageUtils.toResolveHierarchy(l);
          this.resolvedLanguage = void 0;
          this.setResolvedLanguage(l);
        };
        const done = (err, l) => {
          if (l) {
            if (this.isLanguageChangingTo === lng) {
              setLngProps(l);
              this.translator.changeLanguage(l);
              this.isLanguageChangingTo = void 0;
              this.emit("languageChanged", l);
              this.logger.log("languageChanged", l);
            }
          } else {
            this.isLanguageChangingTo = void 0;
          }
          deferred.resolve((...args) => this.t(...args));
          if (callback2) callback2(err, (...args) => this.t(...args));
        };
        const setLng = (lngs) => {
          var _a2, _b;
          if (!lng && !lngs && this.services.languageDetector) lngs = [];
          const fl = isString$2(lngs) ? lngs : lngs && lngs[0];
          const l = this.store.hasLanguageSomeTranslations(fl) ? fl : this.services.languageUtils.getBestMatchFromCodes(isString$2(lngs) ? [lngs] : lngs);
          if (l) {
            if (!this.language) {
              setLngProps(l);
            }
            if (!this.translator.language) this.translator.changeLanguage(l);
            (_b = (_a2 = this.services.languageDetector) == null ? void 0 : _a2.cacheUserLanguage) == null ? void 0 : _b.call(_a2, l);
          }
          this.loadResources(l, (err) => {
            done(err, l);
          });
        };
        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
          setLng(this.services.languageDetector.detect());
        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
          if (this.services.languageDetector.detect.length === 0) {
            this.services.languageDetector.detect().then(setLng);
          } else {
            this.services.languageDetector.detect(setLng);
          }
        } else {
          setLng(lng);
        }
        return deferred;
      }
      getFixedT(lng, ns, keyPrefix) {
        const fixedT = (key, opts, ...rest) => {
          let o;
          if (typeof opts !== "object") {
            o = this.options.overloadTranslationOptionHandler([key, opts].concat(rest));
          } else {
            o = __spreadValues({}, opts);
          }
          o.lng = o.lng || fixedT.lng;
          o.lngs = o.lngs || fixedT.lngs;
          o.ns = o.ns || fixedT.ns;
          if (o.keyPrefix !== "") o.keyPrefix = o.keyPrefix || keyPrefix || fixedT.keyPrefix;
          const keySeparator = this.options.keySeparator || ".";
          let resultKey;
          if (o.keyPrefix && Array.isArray(key)) {
            resultKey = key.map((k) => {
              if (typeof k === "function") k = keysFromSelector(k, __spreadValues(__spreadValues({}, this.options), opts));
              return `${o.keyPrefix}${keySeparator}${k}`;
            });
          } else {
            if (typeof key === "function") key = keysFromSelector(key, __spreadValues(__spreadValues({}, this.options), opts));
            resultKey = o.keyPrefix ? `${o.keyPrefix}${keySeparator}${key}` : key;
          }
          return this.t(resultKey, o);
        };
        if (isString$2(lng)) {
          fixedT.lng = lng;
        } else {
          fixedT.lngs = lng;
        }
        fixedT.ns = ns;
        fixedT.keyPrefix = keyPrefix;
        return fixedT;
      }
      t(...args) {
        var _a2;
        return (_a2 = this.translator) == null ? void 0 : _a2.translate(...args);
      }
      exists(...args) {
        var _a2;
        return (_a2 = this.translator) == null ? void 0 : _a2.exists(...args);
      }
      setDefaultNamespace(ns) {
        this.options.defaultNS = ns;
      }
      hasLoadedNamespace(ns, options = {}) {
        if (!this.isInitialized) {
          this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
          return false;
        }
        if (!this.languages || !this.languages.length) {
          this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
          return false;
        }
        const lng = options.lng || this.resolvedLanguage || this.languages[0];
        const fallbackLng = this.options ? this.options.fallbackLng : false;
        const lastLng = this.languages[this.languages.length - 1];
        if (lng.toLowerCase() === "cimode") return true;
        const loadNotPending = (l, n) => {
          const loadState = this.services.backendConnector.state[`${l}|${n}`];
          return loadState === -1 || loadState === 0 || loadState === 2;
        };
        if (options.precheck) {
          const preResult = options.precheck(this, loadNotPending);
          if (preResult !== void 0) return preResult;
        }
        if (this.hasResourceBundle(lng, ns)) return true;
        if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
        return false;
      }
      loadNamespaces(ns, callback2) {
        const deferred = defer();
        if (!this.options.ns) {
          if (callback2) callback2();
          return Promise.resolve();
        }
        if (isString$2(ns)) ns = [ns];
        ns.forEach((n) => {
          if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);
        });
        this.loadResources((err) => {
          deferred.resolve();
          if (callback2) callback2(err);
        });
        return deferred;
      }
      loadLanguages(lngs, callback2) {
        const deferred = defer();
        if (isString$2(lngs)) lngs = [lngs];
        const preloaded = this.options.preload || [];
        const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
        if (!newLngs.length) {
          if (callback2) callback2();
          return Promise.resolve();
        }
        this.options.preload = preloaded.concat(newLngs);
        this.loadResources((err) => {
          deferred.resolve();
          if (callback2) callback2(err);
        });
        return deferred;
      }
      dir(lng) {
        var _a2, _b;
        if (!lng) lng = this.resolvedLanguage || (((_a2 = this.languages) == null ? void 0 : _a2.length) > 0 ? this.languages[0] : this.language);
        if (!lng) return "rtl";
        try {
          const l = new Intl.Locale(lng);
          if (l && l.getTextInfo) {
            const ti = l.getTextInfo();
            if (ti && ti.direction) return ti.direction;
          }
        } catch (e) {
        }
        const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
        const languageUtils = ((_b = this.services) == null ? void 0 : _b.languageUtils) || new LanguageUtil(get());
        if (lng.toLowerCase().indexOf("-latn") > 1) return "ltr";
        return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
      }
      static createInstance(options = {}, callback2) {
        const instance2 = new I18n(options, callback2);
        instance2.createInstance = I18n.createInstance;
        return instance2;
      }
      cloneInstance(options = {}, callback2 = noop$2) {
        const forkResourceStore = options.forkResourceStore;
        if (forkResourceStore) delete options.forkResourceStore;
        const mergedOptions = __spreadValues(__spreadValues(__spreadValues({}, this.options), options), {
          isClone: true
        });
        const clone2 = new I18n(mergedOptions);
        if (options.debug !== void 0 || options.prefix !== void 0) {
          clone2.logger = clone2.logger.clone(options);
        }
        const membersToCopy = ["store", "services", "language"];
        membersToCopy.forEach((m) => {
          clone2[m] = this[m];
        });
        clone2.services = __spreadValues({}, this.services);
        clone2.services.utils = {
          hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
        };
        if (forkResourceStore) {
          const clonedData = Object.keys(this.store.data).reduce((prev, l) => {
            prev[l] = __spreadValues({}, this.store.data[l]);
            prev[l] = Object.keys(prev[l]).reduce((acc, n) => {
              acc[n] = __spreadValues({}, prev[l][n]);
              return acc;
            }, prev[l]);
            return prev;
          }, {});
          clone2.store = new ResourceStore(clonedData, mergedOptions);
          clone2.services.resourceStore = clone2.store;
        }
        if (options.interpolation) clone2.services.interpolator = new Interpolator(mergedOptions);
        clone2.translator = new Translator(clone2.services, mergedOptions);
        clone2.translator.on("*", (event, ...args) => {
          clone2.emit(event, ...args);
        });
        clone2.init(mergedOptions, callback2);
        clone2.translator.options = mergedOptions;
        clone2.translator.backendConnector.services.utils = {
          hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
        };
        return clone2;
      }
      toJSON() {
        return {
          options: this.options,
          store: this.store,
          language: this.language,
          languages: this.languages,
          resolvedLanguage: this.resolvedLanguage
        };
      }
    }
    const instance = I18n.createInstance();
    instance.createInstance;
    instance.dir;
    instance.init;
    instance.loadResources;
    instance.reloadResources;
    instance.use;
    instance.changeLanguage;
    instance.getFixedT;
    instance.t;
    instance.exists;
    instance.setDefaultNamespace;
    instance.hasLoadedNamespace;
    instance.loadNamespaces;
    instance.loadLanguages;
    const warn = (i18n, code2, msg, rest) => {
      var _a2, _b, _c, _d;
      const args = [msg, __spreadValues({
        code: code2
      }, rest || {})];
      if ((_b = (_a2 = i18n == null ? void 0 : i18n.services) == null ? void 0 : _a2.logger) == null ? void 0 : _b.forward) {
        return i18n.services.logger.forward(args, "warn", "react-i18next::", true);
      }
      if (isString$1(args[0])) args[0] = `react-i18next:: ${args[0]}`;
      if ((_d = (_c = i18n == null ? void 0 : i18n.services) == null ? void 0 : _c.logger) == null ? void 0 : _d.warn) {
        i18n.services.logger.warn(...args);
      } else if (console == null ? void 0 : console.warn) {
        console.warn(...args);
      }
    };
    const alreadyWarned = {};
    const warnOnce = (i18n, code2, msg, rest) => {
      if (isString$1(msg) && alreadyWarned[msg]) return;
      if (isString$1(msg)) alreadyWarned[msg] = /* @__PURE__ */ new Date();
      warn(i18n, code2, msg, rest);
    };
    const loadedClb = (i18n, cb) => () => {
      if (i18n.isInitialized) {
        cb();
      } else {
        const initialized = () => {
          setTimeout(() => {
            i18n.off("initialized", initialized);
          }, 0);
          cb();
        };
        i18n.on("initialized", initialized);
      }
    };
    const loadNamespaces = (i18n, ns, cb) => {
      i18n.loadNamespaces(ns, loadedClb(i18n, cb));
    };
    const loadLanguages = (i18n, lng, ns, cb) => {
      if (isString$1(ns)) ns = [ns];
      if (i18n.options.preload && i18n.options.preload.indexOf(lng) > -1) return loadNamespaces(i18n, ns, cb);
      ns.forEach((n) => {
        if (i18n.options.ns.indexOf(n) < 0) i18n.options.ns.push(n);
      });
      i18n.loadLanguages(lng, loadedClb(i18n, cb));
    };
    const hasLoadedNamespace = (ns, i18n, options = {}) => {
      if (!i18n.languages || !i18n.languages.length) {
        warnOnce(i18n, "NO_LANGUAGES", "i18n.languages were undefined or empty", {
          languages: i18n.languages
        });
        return true;
      }
      return i18n.hasLoadedNamespace(ns, {
        lng: options.lng,
        precheck: (i18nInstance2, loadNotPending) => {
          if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns)) return false;
        }
      });
    };
    const isString$1 = (obj) => typeof obj === "string";
    const isObject$2 = (obj) => typeof obj === "object" && obj !== null;
    const matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
    const htmlEntities = {
      "&amp;": "&",
      "&#38;": "&",
      "&lt;": "<",
      "&#60;": "<",
      "&gt;": ">",
      "&#62;": ">",
      "&apos;": "'",
      "&#39;": "'",
      "&quot;": '"',
      "&#34;": '"',
      "&nbsp;": " ",
      "&#160;": " ",
      "&copy;": "",
      "&#169;": "",
      "&reg;": "",
      "&#174;": "",
      "&hellip;": "",
      "&#8230;": "",
      "&#x2F;": "/",
      "&#47;": "/"
    };
    const unescapeHtmlEntity = (m) => htmlEntities[m];
    const unescape$1 = (text) => text.replace(matchHtmlEntity, unescapeHtmlEntity);
    let defaultOptions = {
      bindI18n: "languageChanged",
      bindI18nStore: "",
      transEmptyNodeValue: "",
      transSupportBasicHtmlNodes: true,
      transWrapTextNodes: "",
      transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
      useSuspense: true,
      unescape: unescape$1
    };
    const setDefaults = (options = {}) => {
      defaultOptions = __spreadValues(__spreadValues({}, defaultOptions), options);
    };
    const getDefaults = () => defaultOptions;
    let i18nInstance;
    const setI18n = (instance2) => {
      i18nInstance = instance2;
    };
    const getI18n = () => i18nInstance;
    const initReactI18next = {
      type: "3rdParty",
      init(instance2) {
        setDefaults(instance2.options.react);
        setI18n(instance2);
      }
    };
    const I18nContext = reactExports.createContext();
    class ReportNamespaces {
      constructor() {
        this.usedNamespaces = {};
      }
      addUsedNamespaces(namespaces) {
        namespaces.forEach((ns) => {
          if (!this.usedNamespaces[ns]) this.usedNamespaces[ns] = true;
        });
      }
      getUsedNamespaces() {
        return Object.keys(this.usedNamespaces);
      }
    }
    var shim = { exports: {} };
    var useSyncExternalStoreShim_production = {};
    var hasRequiredUseSyncExternalStoreShim_production;
    function requireUseSyncExternalStoreShim_production() {
      if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
      hasRequiredUseSyncExternalStoreShim_production = 1;
      var React2 = requireReact();
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is, useState = React2.useState, useEffect = React2.useEffect, useLayoutEffect = React2.useLayoutEffect, useDebugValue = React2.useDebugValue;
      function useSyncExternalStore$2(subscribe, getSnapshot) {
        var value = getSnapshot(), _useState = useState({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
        useLayoutEffect(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe, value, getSnapshot]
        );
        useEffect(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe]
        );
        useDebugValue(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error2) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
      }
      var shim2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      useSyncExternalStoreShim_production.useSyncExternalStore = void 0 !== React2.useSyncExternalStore ? React2.useSyncExternalStore : shim2;
      return useSyncExternalStoreShim_production;
    }
    var hasRequiredShim;
    function requireShim() {
      if (hasRequiredShim) return shim.exports;
      hasRequiredShim = 1;
      {
        shim.exports = requireUseSyncExternalStoreShim_production();
      }
      return shim.exports;
    }
    var shimExports = requireShim();
    const notReadyT = (k, optsOrDefaultValue) => {
      if (isString$1(optsOrDefaultValue)) return optsOrDefaultValue;
      if (isObject$2(optsOrDefaultValue) && isString$1(optsOrDefaultValue.defaultValue)) return optsOrDefaultValue.defaultValue;
      return Array.isArray(k) ? k[k.length - 1] : k;
    };
    const notReadySnapshot = {
      t: notReadyT,
      ready: false
    };
    const dummySubscribe = () => () => {
    };
    const useTranslation = (ns, props = {}) => {
      var _a2, _b, _c;
      const {
        i18n: i18nFromProps
      } = props;
      const {
        i18n: i18nFromContext,
        defaultNS: defaultNSFromContext
      } = reactExports.useContext(I18nContext) || {};
      const i18n = i18nFromProps || i18nFromContext || getI18n();
      if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new ReportNamespaces();
      if (!i18n) {
        warnOnce(i18n, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next");
      }
      const i18nOptions = reactExports.useMemo(() => {
        var _a3;
        return __spreadValues(__spreadValues(__spreadValues({}, getDefaults()), (_a3 = i18n == null ? void 0 : i18n.options) == null ? void 0 : _a3.react), props);
      }, [i18n, props]);
      const {
        useSuspense,
        keyPrefix
      } = i18nOptions;
      const nsOrContext = defaultNSFromContext || ((_a2 = i18n == null ? void 0 : i18n.options) == null ? void 0 : _a2.defaultNS);
      const unstableNamespaces = isString$1(nsOrContext) ? [nsOrContext] : nsOrContext || ["translation"];
      const namespaces = reactExports.useMemo(() => unstableNamespaces, unstableNamespaces);
      (_c = (_b = i18n == null ? void 0 : i18n.reportNamespaces) == null ? void 0 : _b.addUsedNamespaces) == null ? void 0 : _c.call(_b, namespaces);
      const revisionRef = reactExports.useRef(0);
      const subscribe = reactExports.useCallback((callback2) => {
        if (!i18n) return dummySubscribe;
        const {
          bindI18n,
          bindI18nStore
        } = i18nOptions;
        const wrappedCallback = () => {
          revisionRef.current += 1;
          callback2();
        };
        if (bindI18n) i18n.on(bindI18n, wrappedCallback);
        if (bindI18nStore) i18n.store.on(bindI18nStore, wrappedCallback);
        return () => {
          if (bindI18n) bindI18n.split(" ").forEach((e) => i18n.off(e, wrappedCallback));
          if (bindI18nStore) bindI18nStore.split(" ").forEach((e) => i18n.store.off(e, wrappedCallback));
        };
      }, [i18n, i18nOptions]);
      const snapshotRef = reactExports.useRef();
      const getSnapshot = reactExports.useCallback(() => {
        if (!i18n) {
          return notReadySnapshot;
        }
        const calculatedReady = !!(i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n) => hasLoadedNamespace(n, i18n, i18nOptions));
        const currentLng = props.lng || i18n.language;
        const currentRevision = revisionRef.current;
        const lastSnapshot = snapshotRef.current;
        if (lastSnapshot && lastSnapshot.ready === calculatedReady && lastSnapshot.lng === currentLng && lastSnapshot.keyPrefix === keyPrefix && lastSnapshot.revision === currentRevision) {
          return lastSnapshot;
        }
        const calculatedT = i18n.getFixedT(currentLng, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
        const newSnapshot = {
          t: calculatedT,
          ready: calculatedReady,
          lng: currentLng,
          keyPrefix,
          revision: currentRevision
        };
        snapshotRef.current = newSnapshot;
        return newSnapshot;
      }, [i18n, namespaces, keyPrefix, i18nOptions, props.lng]);
      const [loadCount, setLoadCount] = reactExports.useState(0);
      const {
        t: t2,
        ready
      } = shimExports.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
      reactExports.useEffect(() => {
        if (i18n && !ready && !useSuspense) {
          const onLoaded = () => setLoadCount((c) => c + 1);
          if (props.lng) {
            loadLanguages(i18n, props.lng, namespaces, onLoaded);
          } else {
            loadNamespaces(i18n, namespaces, onLoaded);
          }
        }
      }, [i18n, props.lng, namespaces, ready, useSuspense, loadCount]);
      const finalI18n = i18n || {};
      const wrapperRef = reactExports.useRef(null);
      const wrapperLangRef = reactExports.useRef();
      const createI18nWrapper = (original) => {
        const descriptors2 = Object.getOwnPropertyDescriptors(original);
        if (descriptors2.__original) delete descriptors2.__original;
        const wrapper = Object.create(Object.getPrototypeOf(original), descriptors2);
        if (!Object.prototype.hasOwnProperty.call(wrapper, "__original")) {
          try {
            Object.defineProperty(wrapper, "__original", {
              value: original,
              writable: false,
              enumerable: false,
              configurable: false
            });
          } catch (_) {
          }
        }
        return wrapper;
      };
      const ret = reactExports.useMemo(() => {
        const original = finalI18n;
        const lang = original == null ? void 0 : original.language;
        let i18nWrapper = original;
        if (original) {
          if (wrapperRef.current && wrapperRef.current.__original === original) {
            if (wrapperLangRef.current !== lang) {
              i18nWrapper = createI18nWrapper(original);
              wrapperRef.current = i18nWrapper;
              wrapperLangRef.current = lang;
            } else {
              i18nWrapper = wrapperRef.current;
            }
          } else {
            i18nWrapper = createI18nWrapper(original);
            wrapperRef.current = i18nWrapper;
            wrapperLangRef.current = lang;
          }
        }
        const arr = [t2, i18nWrapper, ready];
        arr.t = t2;
        arr.i18n = i18nWrapper;
        arr.ready = ready;
        return arr;
      }, [t2, finalI18n, ready, finalI18n.resolvedLanguage, finalI18n.language, finalI18n.languages]);
      if (i18n && useSuspense && !ready) {
        throw new Promise((resolve2) => {
          const onLoaded = () => resolve2();
          if (props.lng) {
            loadLanguages(i18n, props.lng, namespaces, onLoaded);
          } else {
            loadNamespaces(i18n, namespaces, onLoaded);
          }
        });
      }
      return ret;
    };
    function Button(_k) {
      var _l = _k, {
        children,
        variant = "primary",
        size = "md",
        fullWidth = false,
        loading = false,
        className = "",
        disabled
      } = _l, rest = __objRest(_l, [
        "children",
        "variant",
        "size",
        "fullWidth",
        "loading",
        "className",
        "disabled"
      ]);
      const classes = [
        "btn",
        `btn-${variant}`,
        size === "sm" ? "btn-sm" : "",
        fullWidth ? "btn-full" : "",
        className
      ].filter(Boolean).join(" ");
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("button", __spreadProps(__spreadValues({ className: classes, disabled: disabled || loading }, rest), { children: [
        loading && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "loading-spinner", "aria-hidden": "true" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children })
      ] }));
    }
    function Input(_m) {
      var _n = _m, { label, hint: hint2, error: error2, rightElement, className = "" } = _n, rest = __objRest(_n, ["label", "hint", "error", "rightElement", "className"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
        label && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: label }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("input", __spreadValues({ className: `input ${className}`.trim() }, rest)),
          rightElement && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { position: "absolute", right: 8, top: "50%", transform: "translateY(-50%)" }, children: rightElement })
        ] }),
        hint2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: hint2 }),
        error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-box", children: error2 })
      ] });
    }
    const baseSvgProps = {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round",
      "aria-hidden": "true",
      focusable: "false"
    };
    function IconSlidersHorizontal(_o) {
      var _p = _o, { size = 20 } = _p, props = __objRest(_p, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "21", x2: "14", y1: "4", y2: "4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "10", x2: "3", y1: "4", y2: "4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "21", x2: "12", y1: "12", y2: "12" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "8", x2: "3", y1: "12", y2: "12" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "21", x2: "16", y1: "20", y2: "20" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", x2: "3", y1: "20", y2: "20" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14", x2: "14", y1: "2", y2: "6" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "8", x2: "8", y1: "10", y2: "14" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "16", x2: "16", y1: "18", y2: "22" })
      ] }));
    }
    function IconKey(_q) {
      var _r = _q, { size = 20 } = _r, props = __objRest(_r, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m15.5 7.5 2.3 2.3a1 1 0 0 0 1.4 0l2.1-2.1a1 1 0 0 0 0-1.4L19 4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m21 2-9.6 9.6" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "7.5", cy: "15.5", r: "5.5" })
      ] }));
    }
    function IconBot(_s) {
      var _t = _s, { size = 20 } = _t, props = __objRest(_t, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 8V4H8" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "16", height: "12", x: "4", y: "8", rx: "2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2 14h2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20 14h2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15 13v2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 13v2" })
      ] }));
    }
    function IconFileText(_u) {
      var _v = _u, { size = 20 } = _v, props = __objRest(_v, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10 9H8" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M16 13H8" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M16 17H8" })
      ] }));
    }
    function IconShield(_w) {
      var _x = _w, { size = 20 } = _x, props = __objRest(_x, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z" }) }));
    }
    function IconChartLine(_y) {
      var _z = _y, { size = 20 } = _z, props = __objRest(_z, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m19 9-5 5-4-4-3 3" })
      ] }));
    }
    function IconSettings(_A) {
      var _B = _A, { size = 20 } = _B, props = __objRest(_B, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
      ] }));
    }
    function IconScrollText(_C) {
      var _D = _C, { size = 20 } = _D, props = __objRest(_D, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15 12h-5" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15 8h-5" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 17V5a2 2 0 0 0-2-2H4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8 21h12a2 2 0 0 0 2-2v-1a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v1a2 2 0 1 1-4 0V5a2 2 0 1 0-4 0v2a1 1 0 0 0 1 1h3" })
      ] }));
    }
    function IconInfo(_E) {
      var _F = _E, { size = 20 } = _F, props = __objRest(_F, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 16v-4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 8h.01" })
      ] }));
    }
    function IconRefreshCw(_G) {
      var _H = _G, { size = 20 } = _H, props = __objRest(_H, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 3v5h-5" })
      ] }));
    }
    function IconDownload(_I) {
      var _J = _I, { size = 20 } = _J, props = __objRest(_J, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 15V3" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m7 10 5 5 5-5" })
      ] }));
    }
    function IconTrash2(_K) {
      var _L = _K, { size = 20 } = _L, props = __objRest(_L, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3 6h18" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "10", x2: "10", y1: "11", y2: "17" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14", x2: "14", y1: "11", y2: "17" })
      ] }));
    }
    function IconChevronUp(_M) {
      var _N = _M, { size = 20 } = _N, props = __objRest(_N, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m18 15-6-6-6 6" }) }));
    }
    function IconChevronDown(_O) {
      var _P = _O, { size = 20 } = _P, props = __objRest(_P, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m6 9 6 6 6-6" }) }));
    }
    function IconSearch(_Q) {
      var _R = _Q, { size = 20 } = _R, props = __objRest(_R, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m21 21-4.34-4.34" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11", cy: "11", r: "8" })
      ] }));
    }
    function IconX(_S) {
      var _T = _S, { size = 20 } = _T, props = __objRest(_T, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18 6 6 18" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m6 6 12 12" })
      ] }));
    }
    function IconCheck(_U) {
      var _V = _U, { size = 20 } = _V, props = __objRest(_V, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20 6 9 17l-5-5" }) }));
    }
    function IconEye(_W) {
      var _X = _W, { size = 20 } = _X, props = __objRest(_X, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
      ] }));
    }
    function IconEyeOff(_Y) {
      var _Z = _Y, { size = 20 } = _Z, props = __objRest(_Z, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.084 14.158a3 3 0 0 1-4.242-4.242" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m2 2 20 20" })
      ] }));
    }
    function IconInbox(__) {
      var _$ = __, { size = 20 } = _$, props = __objRest(_$, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "22 12 16 12 14 15 10 15 8 12 2 12" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z" })
      ] }));
    }
    function IconSatellite(_aa) {
      var _ba = _aa, { size = 20 } = _ba, props = __objRest(_ba, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m13.5 6.5-3.148-3.148a1.205 1.205 0 0 0-1.704 0L6.352 5.648a1.205 1.205 0 0 0 0 1.704L9.5 10.5" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M16.5 7.5 19 5" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m17.5 10.5 3.148 3.148a1.205 1.205 0 0 1 0 1.704l-2.296 2.296a1.205 1.205 0 0 1-1.704 0L13.5 14.5" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 21a6 6 0 0 0-6-6" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.352 10.648a1.205 1.205 0 0 0 0 1.704l2.296 2.296a1.205 1.205 0 0 0 1.704 0l4.296-4.296a1.205 1.205 0 0 0 0-1.704l-2.296-2.296a1.205 1.205 0 0 0-1.704 0z" })
      ] }));
    }
    function IconDiamond(_ca) {
      var _da = _ca, { size = 20 } = _da, props = __objRest(_da, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2.7 10.3a2.41 2.41 0 0 0 0 3.41l7.59 7.59a2.41 2.41 0 0 0 3.41 0l7.59-7.59a2.41 2.41 0 0 0 0-3.41l-7.59-7.59a2.41 2.41 0 0 0-3.41 0Z" }) }));
    }
    function IconTimer(_ea) {
      var _fa = _ea, { size = 20 } = _fa, props = __objRest(_fa, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "10", x2: "14", y1: "2", y2: "2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", x2: "15", y1: "14", y2: "11" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "14", r: "8" })
      ] }));
    }
    function IconTrendingUp(_ga) {
      var _ha = _ga, { size = 20 } = _ha, props = __objRest(_ha, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M16 7h6v6" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m22 7-8.5 8.5-5-5L2 17" })
      ] }));
    }
    function IconDollarSign(_ia) {
      var _ja = _ia, { size = 20 } = _ja, props = __objRest(_ja, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", x2: "12", y1: "2", y2: "22" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6" })
      ] }));
    }
    function IconGithub(_ka) {
      var _la = _ka, { size = 20 } = _la, props = __objRest(_la, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18c-4.51 2-5-2-7-2" })
      ] }));
    }
    function IconExternalLink(_ma) {
      var _na = _ma, { size = 20 } = _na, props = __objRest(_na, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15 3h6v6" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10 14 21 3" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" })
      ] }));
    }
    function IconBookOpen(_oa) {
      var _pa = _oa, { size = 20 } = _pa, props = __objRest(_pa, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 7v14" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z" })
      ] }));
    }
    function IconCode(_qa) {
      var _ra = _qa, { size = 20 } = _ra, props = __objRest(_ra, ["size"]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseSvgProps), { width: size, height: size }), props), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "16 18 22 12 16 6" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "8 6 2 12 8 18" })
      ] }));
    }
    const createStoreImpl = (createState) => {
      let state;
      const listeners = /* @__PURE__ */ new Set();
      const setState = (partial, replace2) => {
        const nextState = typeof partial === "function" ? partial(state) : partial;
        if (!Object.is(nextState, state)) {
          const previousState = state;
          state = (replace2 != null ? replace2 : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
          listeners.forEach((listener) => listener(state, previousState));
        }
      };
      const getState = () => state;
      const getInitialState = () => initialState;
      const subscribe = (listener) => {
        listeners.add(listener);
        return () => listeners.delete(listener);
      };
      const api = { setState, getState, getInitialState, subscribe };
      const initialState = state = createState(setState, getState, api);
      return api;
    };
    const createStore = ((createState) => createState ? createStoreImpl(createState) : createStoreImpl);
    const identity = (arg) => arg;
    function useStore(api, selector = identity) {
      const slice = React.useSyncExternalStore(
        api.subscribe,
        React.useCallback(() => selector(api.getState()), [api, selector]),
        React.useCallback(() => selector(api.getInitialState()), [api, selector])
      );
      React.useDebugValue(slice);
      return slice;
    }
    const createImpl = (createState) => {
      const api = createStore(createState);
      const useBoundStore = (selector) => useStore(api, selector);
      Object.assign(useBoundStore, api);
      return useBoundStore;
    };
    const create = ((createState) => createState ? createImpl(createState) : createImpl);
    function generateId() {
      return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    const CACHE_EXPIRY_MS = 30 * 1e3;
    const DEFAULT_API_PORT = 8317;
    const MANAGEMENT_API_PREFIX = "/v0/management";
    const REQUEST_TIMEOUT_MS = 30 * 1e3;
    const VERSION_HEADER_KEYS = ["x-cpa-version", "x-server-version"];
    const BUILD_DATE_HEADER_KEYS = ["x-cpa-build-date", "x-server-build-date"];
    const STORAGE_KEY_AUTH = "cli-proxy-auth";
    const STORAGE_KEY_THEME = "cli-proxy-theme";
    const STORAGE_KEY_LANGUAGE = "cli-proxy-language";
    const NOTIFICATION_DURATION_MS = 3e3;
    const useNotificationStore = create((set2) => ({
      notifications: [],
      showNotification: (message2, type = "info", duration = NOTIFICATION_DURATION_MS) => {
        const id2 = generateId();
        const notification2 = {
          id: id2,
          message: message2,
          type,
          duration
        };
        set2((state) => ({
          notifications: [...state.notifications, notification2]
        }));
        if (duration > 0) {
          setTimeout(() => {
            set2((state) => ({
              notifications: state.notifications.filter((n) => n.id !== id2)
            }));
          }, duration);
        }
      },
      removeNotification: (id2) => {
        set2((state) => ({
          notifications: state.notifications.filter((n) => n.id !== id2)
        }));
      },
      clearAll: () => {
        set2({ notifications: [] });
      }
    }));
    function createJSONStorage(getStorage, options) {
      let storage;
      try {
        storage = getStorage();
      } catch (e) {
        return;
      }
      const persistStorage = {
        getItem: (name2) => {
          var _a2;
          const parse2 = (str2) => {
            if (str2 === null) {
              return null;
            }
            return JSON.parse(str2, void 0);
          };
          const str = (_a2 = storage.getItem(name2)) != null ? _a2 : null;
          if (str instanceof Promise) {
            return str.then(parse2);
          }
          return parse2(str);
        },
        setItem: (name2, newValue) => storage.setItem(name2, JSON.stringify(newValue, void 0)),
        removeItem: (name2) => storage.removeItem(name2)
      };
      return persistStorage;
    }
    const toThenable = (fn) => (input) => {
      try {
        const result = fn(input);
        if (result instanceof Promise) {
          return result;
        }
        return {
          then(onFulfilled) {
            return toThenable(onFulfilled)(result);
          },
          catch(_onRejected) {
            return this;
          }
        };
      } catch (e) {
        return {
          then(_onFulfilled) {
            return this;
          },
          catch(onRejected) {
            return toThenable(onRejected)(e);
          }
        };
      }
    };
    const persistImpl = (config2, baseOptions) => (set2, get2, api) => {
      let options = __spreadValues({
        storage: createJSONStorage(() => localStorage),
        partialize: (state) => state,
        version: 0,
        merge: (persistedState, currentState) => __spreadValues(__spreadValues({}, currentState), persistedState)
      }, baseOptions);
      let hasHydrated = false;
      const hydrationListeners = /* @__PURE__ */ new Set();
      const finishHydrationListeners = /* @__PURE__ */ new Set();
      let storage = options.storage;
      if (!storage) {
        return config2(
          (...args) => {
            console.warn(
              `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
            );
            set2(...args);
          },
          get2,
          api
        );
      }
      const setItem = () => {
        const state = options.partialize(__spreadValues({}, get2()));
        return storage.setItem(options.name, {
          state,
          version: options.version
        });
      };
      const savedSetState = api.setState;
      api.setState = (state, replace2) => {
        savedSetState(state, replace2);
        return setItem();
      };
      const configResult = config2(
        (...args) => {
          set2(...args);
          return setItem();
        },
        get2,
        api
      );
      api.getInitialState = () => configResult;
      let stateFromStorage;
      const hydrate = () => {
        var _a2, _b;
        if (!storage) return;
        hasHydrated = false;
        hydrationListeners.forEach((cb) => {
          var _a22;
          return cb((_a22 = get2()) != null ? _a22 : configResult);
        });
        const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a2 = get2()) != null ? _a2 : configResult)) || void 0;
        return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
          if (deserializedStorageValue) {
            if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
              if (options.migrate) {
                const migration = options.migrate(
                  deserializedStorageValue.state,
                  deserializedStorageValue.version
                );
                if (migration instanceof Promise) {
                  return migration.then((result) => [true, result]);
                }
                return [true, migration];
              }
              console.error(
                `State loaded from storage couldn't be migrated since no migrate function was provided`
              );
            } else {
              return [false, deserializedStorageValue.state];
            }
          }
          return [false, void 0];
        }).then((migrationResult) => {
          var _a22;
          const [migrated, migratedState] = migrationResult;
          stateFromStorage = options.merge(
            migratedState,
            (_a22 = get2()) != null ? _a22 : configResult
          );
          set2(stateFromStorage, true);
          if (migrated) {
            return setItem();
          }
        }).then(() => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
          stateFromStorage = get2();
          hasHydrated = true;
          finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
        }).catch((e) => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
        });
      };
      api.persist = {
        setOptions: (newOptions) => {
          options = __spreadValues(__spreadValues({}, options), newOptions);
          if (newOptions.storage) {
            storage = newOptions.storage;
          }
        },
        clearStorage: () => {
          storage == null ? void 0 : storage.removeItem(options.name);
        },
        getOptions: () => options,
        rehydrate: () => hydrate(),
        hasHydrated: () => hasHydrated,
        onHydrate: (cb) => {
          hydrationListeners.add(cb);
          return () => {
            hydrationListeners.delete(cb);
          };
        },
        onFinishHydration: (cb) => {
          finishHydrationListeners.add(cb);
          return () => {
            finishHydrationListeners.delete(cb);
          };
        }
      };
      if (!options.skipHydration) {
        hydrate();
      }
      return stateFromStorage || configResult;
    };
    const persist = persistImpl;
    const useThemeStore = create()(
      persist(
        (set2, get2) => ({
          theme: "light",
          setTheme: (theme2) => {
            if (theme2 === "dark") {
              document.documentElement.setAttribute("data-theme", "dark");
            } else {
              document.documentElement.removeAttribute("data-theme");
            }
            set2({ theme: theme2 });
          },
          toggleTheme: () => {
            const { theme: theme2, setTheme } = get2();
            const newTheme = theme2 === "light" ? "dark" : "light";
            setTheme(newTheme);
          },
          initializeTheme: () => {
            const { theme: theme2, setTheme } = get2();
            if (!localStorage.getItem(STORAGE_KEY_THEME) && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches) {
              setTheme("dark");
              return;
            }
            setTheme(theme2);
            if (window.matchMedia) {
              window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", (e) => {
                if (!localStorage.getItem(STORAGE_KEY_THEME)) {
                  setTheme(e.matches ? "dark" : "light");
                }
              });
            }
          }
        }),
        {
          name: STORAGE_KEY_THEME
        }
      )
    );
    const common$1 = { "login": "", "logout": "", "cancel": "", "confirm": "", "save": "", "delete": "", "edit": "", "add": "", "update": "", "refresh": "", "close": "", "success": "", "error": "", "info": "", "warning": "", "loading": "...", "connecting": "...", "connected": "", "disconnected": "", "connecting_status": "", "connected_status": "", "disconnected_status": "", "yes": "", "no": "", "not_set": "", "optional": "", "required": "", "api_key": "", "base_url": "", "proxy_url": "", "alias": "", "failure": "", "unknown_error": "", "copy": "", "custom_headers_label": "", "custom_headers_hint": " HTTP ", "custom_headers_add": "", "custom_headers_key_placeholder": "Header  X-Custom-Header", "custom_headers_value_placeholder": "Header ", "model_name_placeholder": " claude-3-5-sonnet-20241022", "model_alias_placeholder": " ()" };
    const title$1 = { "main": "CLI Proxy API Management Center", "login": "CLI Proxy API Management Center", "abbr": "CPAMC" };
    const auto_login$1 = { "title": "...", "message": "" };
    const login$1 = { "subtitle": "", "connection_title": "", "connection_current": "", "connection_auto_hint": "", "custom_connection_label": ":", "custom_connection_placeholder": ": https://example.com:8317", "custom_connection_hint": "", "use_current_address": "", "management_key_label": ":", "management_key_placeholder": "", "connect_button": "", "submit_button": "", "submitting": "...", "error_title": "", "error_required": "", "error_invalid": "" };
    const header$2 = { "check_connection": "", "refresh_all": "", "logout": "" };
    const connection$1 = { "title": "", "server_address": ":", "management_key": ":", "status": ":" };
    const nav$2 = { "basic_settings": "", "api_keys": "API ", "ai_providers": "AI ", "auth_files": "", "oauth": "OAuth ", "usage_stats": "", "config_management": "", "logs": "", "system_info": "" };
    const basic_settings$1 = { "title": "", "debug_title": "", "debug_enable": "", "proxy_title": "", "proxy_url_label": " URL:", "proxy_url_placeholder": ": socks5://user:pass@127.0.0.1:1080/", "proxy_update": "", "proxy_clear": "", "retry_title": "", "retry_count_label": ":", "retry_update": "", "quota_title": "", "quota_switch_project": "", "quota_switch_preview": "", "usage_statistics_title": "", "usage_statistics_enable": "", "logging_title": "", "logging_to_file_enable": "", "request_log_enable": "", "ws_auth_title": "WebSocket ", "ws_auth_enable": " /ws/* " };
    const api_keys$1 = { "title": "API ", "proxy_auth_title": "", "add_button": "", "empty_title": "API", "empty_desc": "", "item_title": "API", "add_modal_title": "API", "add_modal_key_label": "API:", "add_modal_key_placeholder": "API", "edit_modal_title": "API", "edit_modal_key_label": "API:", "delete_confirm": "API" };
    const ai_providers$1 = { "title": "AI ", "gemini_title": "Gemini API ", "gemini_add_button": "", "gemini_empty_title": "Gemini", "gemini_empty_desc": "", "gemini_item_title": "Gemini", "gemini_add_modal_title": "Gemini API", "gemini_add_modal_key_label": "API", "gemini_add_modal_key_placeholder": " Gemini API ", "gemini_add_modal_key_hint": " Base URL", "gemini_keys_add_btn": "", "gemini_base_url_label": "Base URL ()", "gemini_base_url_placeholder": ": https://generativelanguage.googleapis.com", "gemini_edit_modal_title": "Gemini API", "gemini_edit_modal_key_label": "API:", "gemini_delete_confirm": "Gemini", "excluded_models_label": " ():", "excluded_models_placeholder": ": gemini-1.5-pro, gemini-1.5-flash", "excluded_models_hint": "", "excluded_models_count": " {{count}} ", "config_toggle_label": "", "config_disabled_badge": "", "codex_title": "Codex API ", "codex_add_button": "", "codex_empty_title": "Codex", "codex_empty_desc": "", "codex_item_title": "Codex", "codex_add_modal_title": "Codex API", "codex_add_modal_key_label": "API:", "codex_add_modal_key_placeholder": "Codex API", "codex_add_modal_url_label": "Base URL ():", "codex_add_modal_url_placeholder": ": https://api.example.com", "codex_add_modal_proxy_label": " URL ():", "codex_add_modal_proxy_placeholder": ": socks5://proxy.example.com:1080", "codex_edit_modal_title": "Codex API", "codex_edit_modal_key_label": "API:", "codex_edit_modal_url_label": "Base URL ():", "codex_edit_modal_proxy_label": " URL ():", "codex_delete_confirm": "Codex", "claude_title": "Claude API ", "claude_add_button": "", "claude_empty_title": "Claude", "claude_empty_desc": "", "claude_item_title": "Claude", "claude_add_modal_title": "Claude API", "claude_add_modal_key_label": "API:", "claude_add_modal_key_placeholder": "Claude API", "claude_add_modal_url_label": "Base URL ():", "claude_add_modal_url_placeholder": ": https://api.anthropic.com", "claude_add_modal_proxy_label": " URL ():", "claude_add_modal_proxy_placeholder": ": socks5://proxy.example.com:1080", "claude_edit_modal_title": "Claude API", "claude_edit_modal_key_label": "API:", "claude_edit_modal_url_label": "Base URL ():", "claude_edit_modal_proxy_label": " URL ():", "claude_delete_confirm": "Claude", "claude_models_label": " ():", "claude_models_hint": " name[, alias] ", "claude_models_add_btn": "", "claude_models_count": "", "ampcode_title": "Amp CLI  (ampcode)", "ampcode_modal_title": " Ampcode", "ampcode_upstream_url_label": "Upstream URL", "ampcode_upstream_url_placeholder": ": https://ampcode.com", "ampcode_upstream_url_hint": "/", "ampcode_upstream_api_key_label": "Upstream API Key (Amp)", "ampcode_upstream_api_key_placeholder": " sk-amp...", "ampcode_upstream_api_key_hint": "Amp", "ampcode_upstream_api_key_current": "Amp: {{key}}", "ampcode_clear_upstream_api_key": "", "ampcode_clear_upstream_api_key_confirm": " Ampcode  upstream API keyAmp", "ampcode_restrict_management_label": " Amp ", "ampcode_restrict_management_hint": "/api/auth/api/user/api/threads  Amp  127.0.0.1/::1 ", "ampcode_force_model_mappings_label": "", "ampcode_force_model_mappings_hint": " API Key ", "ampcode_model_mappings_label": " (from  to)", "ampcode_model_mappings_hint": " Amp ", "ampcode_model_mappings_add_btn": "", "ampcode_model_mappings_from_placeholder": "from ", "ampcode_model_mappings_to_placeholder": "to ", "ampcode_model_mappings_count": "", "ampcode_mappings_overwrite_confirm": "", "openai_title": "OpenAI ", "openai_add_button": "", "openai_empty_title": "OpenAI", "openai_empty_desc": "", "openai_add_modal_title": "OpenAI", "openai_add_modal_name_label": ":", "openai_add_modal_name_placeholder": ": openrouter", "openai_add_modal_url_label": "Base URL:", "openai_add_modal_url_placeholder": ": https://openrouter.ai/api/v1", "openai_add_modal_keys_label": "API", "openai_edit_modal_keys_label": "API", "openai_keys_hint": "", "openai_keys_add_btn": "", "openai_key_placeholder": " sk- ", "openai_proxy_placeholder": " URL ( socks5://...)", "openai_add_modal_models_label": " (name[, alias] ):", "openai_models_hint": "gpt-4o-mini  moonshotai/kimi-k2:free, kimi-k2", "openai_model_name_placeholder": " moonshotai/kimi-k2:free", "openai_model_alias_placeholder": " ()", "openai_models_add_btn": "", "openai_models_fetch_button": " /v1/models ", "openai_models_fetch_title": " /v1/models ", "openai_models_fetch_hint": " Base URL  /v1/models  API KeyBearer", "openai_models_fetch_url_label": "", "openai_models_fetch_refresh": "", "openai_models_fetch_loading": " /v1/models ...", "openai_models_fetch_empty": "", "openai_models_fetch_error": "", "openai_models_fetch_back": "", "openai_models_fetch_apply": "", "openai_models_search_label": "", "openai_models_search_placeholder": "", "openai_models_search_empty": "", "openai_models_fetch_invalid_url": " Base URL", "openai_models_fetch_added": " {{count}} ", "openai_edit_modal_title": "OpenAI", "openai_edit_modal_name_label": ":", "openai_edit_modal_url_label": "Base URL:", "openai_edit_modal_models_label": " (name[, alias] ):", "openai_delete_confirm": "OpenAI", "openai_keys_count": "", "openai_models_count": "", "openai_test_title": "", "openai_test_hint": " /v1/chat/completions ", "openai_test_model_placeholder": "", "openai_test_action": "", "openai_test_running": "...", "openai_test_timeout": "{{seconds}}", "openai_test_success": "", "openai_test_failed": "", "openai_test_select_placeholder": "", "openai_test_select_empty": "" };
    const auth_files$1 = { "title": "", "title_section": "", "description": " CLI Proxy  JSON  QwenGeminiVertex  AI ", "upload_button": "", "delete_all_button": "", "empty_title": "", "empty_desc": "", "search_empty_title": "", "search_empty_desc": "", "file_size": "", "file_modified": "", "download_button": "", "delete_button": "", "delete_confirm": "", "delete_all_confirm": "", "delete_filtered_confirm": " {{type}} ", "upload_error_json": "JSON", "upload_success": "", "download_success": "", "delete_success": "", "delete_all_success": "", "delete_filtered_success": " {{count}}  {{type}} ", "delete_filtered_partial": "{{type}}  {{success}}  {{failed}} ", "delete_filtered_none": " ({{type}}) ", "files_count": "", "pagination_prev": "", "pagination_next": "", "pagination_info": " {{current}} / {{total}}    {{count}} ", "search_label": "", "search_placeholder": "", "page_size_label": "", "page_size_unit": "/", "filter_all": "", "filter_qwen": "Qwen", "filter_gemini": "Gemini", "filter_gemini-cli": "GeminiCLI", "filter_aistudio": "AIStudio", "filter_claude": "Claude", "filter_codex": "Codex", "filter_antigravity": "Antigravity", "filter_iflow": "iFlow", "filter_vertex": "Vertex", "filter_empty": "", "filter_unknown": "", "type_qwen": "Qwen", "type_gemini": "Gemini", "type_gemini-cli": "GeminiCLI", "type_aistudio": "AIStudio", "type_claude": "Claude", "type_codex": "Codex", "type_antigravity": "Antigravity", "type_iflow": "iFlow", "type_vertex": "Vertex", "type_empty": "", "type_unknown": "", "type_virtual": "", "models_button": "", "models_title": "", "models_loading": "...", "models_empty": "", "models_empty_desc": "", "models_unsupported": "", "models_unsupported_desc": " CLI Proxy API ", "models_excluded_badge": "", "models_excluded_hint": " OAuth " };
    const vertex_import$1 = { "title": "Vertex AI ", "description": " Google  JSON CLI vertex-import  auth-dir/vertex-<project>.json", "location_label": " ()", "location_placeholder": "us-central1", "location_hint": " us-central1", "file_label": " JSON", "file_hint": " Google Cloud service account key JSON ", "file_placeholder": "", "choose_file": "", "import_button": " Vertex ", "file_required": " .json ", "success": "Vertex ", "result_title": "", "result_project": " ID", "result_email": "", "result_location": "", "result_file": "" };
    const oauth_excluded$1 = { "title": "OAuth ", "description": " * ", "add": "", "add_title": "", "edit_title": " {{provider}} ", "refresh": "", "refreshing": "...", "provider_label": "", "provider_auto": "", "provider_placeholder": " gemini-cli / openai", "provider_hint": "", "models_label": "", "models_placeholder": "gpt-4.1-mini\n*-preview", "models_hint": " * ", "save": "/", "saving": "...", "save_success": "", "save_failed": "", "delete": "", "delete_confirm": " {{provider}} ", "delete_success": "", "delete_failed": "", "deleting": "...", "no_models": "", "model_count": " {{count}} ", "list_empty_all": "", "list_empty_filtered": "", "disconnected": "", "load_failed": "", "provider_required": "", "scope_all": "", "scope_provider": "{{provider}}", "upgrade_required": " CPA  CPA ", "upgrade_required_title": " CPA ", "upgrade_required_desc": " CPACLI Proxy API" };
    const auth_login$1 = { "codex_oauth_title": "Codex OAuth", "codex_oauth_button": " Codex ", "codex_oauth_hint": " OAuth  Codex ", "codex_oauth_url_label": ":", "codex_open_link": "", "codex_copy_link": "", "codex_oauth_status_waiting": "...", "codex_oauth_status_success": "", "codex_oauth_status_error": ":", "codex_oauth_start_error": " Codex OAuth :", "codex_oauth_polling_error": ":", "anthropic_oauth_title": "Anthropic OAuth", "anthropic_oauth_button": " Anthropic ", "anthropic_oauth_hint": " OAuth  Anthropic (Claude) ", "anthropic_oauth_url_label": ":", "anthropic_open_link": "", "anthropic_copy_link": "", "anthropic_oauth_status_waiting": "...", "anthropic_oauth_status_success": "", "anthropic_oauth_status_error": ":", "anthropic_oauth_start_error": " Anthropic OAuth :", "anthropic_oauth_polling_error": ":", "antigravity_oauth_title": "Antigravity OAuth", "antigravity_oauth_button": " Antigravity ", "antigravity_oauth_hint": " OAuth  AntigravityGoogle ", "antigravity_oauth_url_label": ":", "antigravity_open_link": "", "antigravity_copy_link": "", "antigravity_oauth_status_waiting": "...", "antigravity_oauth_status_success": "", "antigravity_oauth_status_error": ":", "antigravity_oauth_start_error": " Antigravity OAuth :", "antigravity_oauth_polling_error": ":", "gemini_cli_oauth_title": "Gemini CLI OAuth", "gemini_cli_oauth_button": " Gemini CLI ", "gemini_cli_oauth_hint": " OAuth  Google Gemini CLI ", "gemini_cli_project_id_label": "Google Cloud  ID:", "gemini_cli_project_id_placeholder": " Google Cloud  ID", "gemini_cli_project_id_hint": " ID Gemini CLI OAuth ", "gemini_cli_project_id_required": " Google Cloud  ID", "gemini_cli_oauth_url_label": ":", "gemini_cli_open_link": "", "gemini_cli_copy_link": "", "gemini_cli_oauth_status_waiting": "...", "gemini_cli_oauth_status_success": "", "gemini_cli_oauth_status_error": ":", "gemini_cli_oauth_start_error": " Gemini CLI OAuth :", "gemini_cli_oauth_polling_error": ":", "qwen_oauth_title": "Qwen OAuth", "qwen_oauth_button": " Qwen ", "qwen_oauth_hint": " Qwen ", "qwen_oauth_url_label": ":", "qwen_open_link": "", "qwen_copy_link": "", "qwen_oauth_status_waiting": "...", "qwen_oauth_status_success": "", "qwen_oauth_status_error": ":", "qwen_oauth_start_error": " Qwen OAuth :", "qwen_oauth_polling_error": ":", "oauth_callback_label": " URL", "oauth_callback_placeholder": "http://localhost:1455/auth/callback?code=...&state=...", "oauth_callback_hint": " http://localhost:...  URL ", "oauth_callback_button": " URL", "oauth_callback_required": " URL", "oauth_callback_success": " URL ", "oauth_callback_error": " URL :", "oauth_callback_upgrade_hint": "CLI Proxy API", "oauth_callback_status_success": " URL ...", "oauth_callback_status_error": " URL :", "missing_state": "", "iflow_oauth_title": "iFlow OAuth", "iflow_oauth_button": " iFlow ", "iflow_oauth_hint": " OAuth  iFlow ", "iflow_oauth_url_label": ":", "iflow_open_link": "", "iflow_copy_link": "", "iflow_oauth_status_waiting": "...", "iflow_oauth_status_success": "", "iflow_oauth_status_error": ":", "iflow_oauth_start_error": " iFlow OAuth :", "iflow_oauth_polling_error": ":", "iflow_cookie_title": "iFlow Cookie ", "iflow_cookie_label": "Cookie :", "iflow_cookie_placeholder": " Cookie sessionid=...;", "iflow_cookie_hint": " Cookie ", "iflow_cookie_key_hint": " Key", "iflow_cookie_button": " Cookie ", "iflow_cookie_status_success": "Cookie ", "iflow_cookie_status_error": "Cookie :", "iflow_cookie_status_duplicate": ":", "iflow_cookie_start_error": " Cookie :", "iflow_cookie_config_duplicate": "", "iflow_cookie_required": " Cookie ", "iflow_cookie_result_title": "Cookie ", "iflow_cookie_result_email": "", "iflow_cookie_result_expired": "", "iflow_cookie_result_path": "", "iflow_cookie_result_type": "", "remote_access_disabled": " (localhost) ", "kiro_title": "Kiro ", "kiro_button": "", "kiro_hint": " AWS SSO  Kiro (AWS CodeWhisperer) ", "kiro_path_hint": "", "kiro_file_path_label": "OAuth :", "kiro_file_path_placeholder": ": ~/.aws/sso/cache/kiro-auth-token.json", "kiro_file_path_hint": " ~/.aws/sso/cache/ ", "kiro_upload_button": "", "kiro_upload_success": "", "kiro_upload_error": ":", "kiro_status_success": "Kiro ", "kiro_status_error": "Kiro :", "kiro_status_duplicate": ":", "kiro_start_error": " Kiro :", "kiro_config_duplicate": "", "kiro_result_title": "Kiro ", "kiro_result_region": "", "kiro_result_path": "", "kiro_result_type": "" };
    const usage_stats$1 = { "title": "", "total_requests": "", "success_requests": "", "failed_requests": "", "total_tokens": "Token", "cached_tokens": " Tokens", "reasoning_tokens": " Tokens", "rpm_30m": "RPM", "tpm_30m": "TPM", "rate_30m": "30", "model_name": "", "model_price_settings": "", "saved_prices": "", "requests_trend": "", "tokens_trend": "Token ", "api_details": "API ", "by_hour": "", "by_day": "", "refresh": "", "chart_line_label_1": " 1", "chart_line_label_2": " 2", "chart_line_label_3": " 3", "chart_line_label_4": " 4", "chart_line_label_5": " 5", "chart_line_label_6": " 6", "chart_line_label_7": " 7", "chart_line_label_8": " 8", "chart_line_label_9": " 9", "chart_line_hidden": "", "chart_line_actions_label": "", "chart_line_add": "", "chart_line_all": "", "chart_line_delete": "", "chart_line_hint": " 9 ", "no_data": "", "loading_error": "", "api_endpoint": "API", "requests_count": "", "tokens_count": "Token", "models": "", "success_rate": "", "total_cost": "", "total_cost_hint": "", "model_price_title": "", "model_price_reset": "", "model_price_model_label": "", "model_price_select_placeholder": "", "model_price_select_hint": "", "model_price_prompt": "", "model_price_completion": "", "model_price_cache": "", "model_price_save": "", "model_price_empty": "", "model_price_model": "", "model_price_saved": "", "model_price_model_required": "", "cost_trend": "", "cost_axis_label": " ($)", "cost_need_price": "", "cost_need_usage": "", "cost_no_data": "" };
    const stats$1 = { "success": "", "failure": "" };
    const logs$1 = { "title": "", "refresh_button": "", "clear_button": "", "download_button": "", "error_log_button": "", "error_logs_modal_title": "", "error_logs_description": "", "error_logs_empty": "", "error_logs_load_error": "", "error_logs_size": "", "error_logs_modified": "", "error_logs_download": "", "error_log_download_success": "", "empty_title": "", "empty_desc": '""', "log_content": "", "loading": "...", "load_error": "", "clear_confirm": "", "clear_success": "", "download_success": "", "auto_refresh": "", "auto_refresh_enabled": "", "auto_refresh_disabled": "", "load_more_hint": "", "hidden_lines": " {{count}} ", "hide_management_logs": " {{prefix}} ", "search_placeholder": "", "search_empty_title": "", "search_empty_desc": "", "double_click_copy_hint": "", "copy_success": "", "copy_failed": "", "lines": "", "removed": "", "upgrade_required_title": " CLI Proxy API", "upgrade_required_desc": " CLI Proxy API " };
    const config_management$1 = { "title": "", "editor_title": "", "reload": "", "save": "", "description": " config.yaml ", "status_idle": "", "status_loading": "...", "status_loaded": "", "status_dirty": "", "status_disconnected": "", "status_load_failed": "", "status_saving": "...", "status_saved": "", "status_save_failed": "", "save_success": "", "error_yaml_not_supported": " YAML  /config.yaml ", "editor_placeholder": "key: value", "search_placeholder": "...", "search_button": "", "search_no_results": "", "search_prev": "", "search_next": "" };
    const system_info$1 = { "title": "", "connection_status_title": "", "api_status_label": "API :", "config_status_label": ":", "last_update_label": ":", "cache_data": "", "real_time_data": "", "not_loaded": "", "seconds_ago": "", "models_title": "", "models_desc": " /v1/models  API Key ", "models_loading": "...", "models_empty": " /v1/models ", "models_error": "", "models_count": " {{count}} ", "version_check_title": "", "version_check_desc": " /latest-version ", "version_current_label": "", "version_latest_label": "", "version_check_button": "", "version_check_idle": "", "version_checking": "...", "version_update_available": "{{version}}", "version_is_latest": "", "version_check_error": "", "version_current_missing": "", "version_unknown": "", "quick_links_title": "", "quick_links_desc": "", "link_main_repo": "", "link_main_repo_desc": "CLI Proxy API ", "link_webui_repo": "WebUI ", "link_webui_repo_desc": "", "link_docs": "", "link_docs_desc": "" };
    const notification$1 = { "debug_updated": "", "proxy_updated": "", "proxy_cleared": "", "retry_updated": "", "quota_switch_project_updated": "", "quota_switch_preview_updated": "", "usage_statistics_updated": "", "logging_to_file_updated": "", "request_log_updated": "", "ws_auth_updated": "WebSocket ", "api_key_added": "API", "api_key_updated": "API", "api_key_deleted": "API", "gemini_key_added": "Gemini", "gemini_key_updated": "Gemini", "gemini_key_deleted": "Gemini", "gemini_multi_input_required": "Gemini", "gemini_multi_failed": "Gemini", "gemini_multi_summary": "Gemini {{success}} {{skipped}} {{failed}}", "codex_config_added": "Codex", "codex_config_updated": "Codex", "codex_config_deleted": "Codex", "codex_base_url_required": "Codex Base URL", "claude_config_added": "Claude", "claude_config_updated": "Claude", "claude_config_deleted": "Claude", "config_enabled": "", "config_disabled": "", "field_required": "", "openai_provider_required": "Base URL", "openai_provider_added": "OpenAI", "openai_provider_updated": "OpenAI", "openai_provider_deleted": "OpenAI", "ampcode_updated": "Ampcode ", "ampcode_upstream_api_key_cleared": "Ampcode upstream API key ", "openai_model_name_required": "", "openai_test_url_required": " Base URL ", "openai_test_key_required": " API ", "openai_test_model_required": "", "data_refreshed": "", "connection_required": "", "refresh_failed": "", "update_failed": "", "add_failed": "", "delete_failed": "", "upload_failed": "", "download_failed": "", "login_failed": "", "please_enter": "", "please_fill": "", "provider_name_url": "Base URL", "api_key": "API", "gemini_api_key": "Gemini API", "codex_api_key": "Codex API", "claude_api_key": "Claude API", "link_copied": "" };
    const language$2 = { "switch": "", "chinese": "", "english": "English" };
    const theme$2 = { "switch": "", "light": "", "dark": "", "switch_to_light": "", "switch_to_dark": "", "auto": "" };
    const sidebar$1 = { "toggle_expand": "", "toggle_collapse": "" };
    const footer$1 = { "api_version": "CLI Proxy API ", "build_date": "", "version": "", "author": "" };
    const zhCN = {
      common: common$1,
      title: title$1,
      auto_login: auto_login$1,
      login: login$1,
      header: header$2,
      connection: connection$1,
      nav: nav$2,
      basic_settings: basic_settings$1,
      api_keys: api_keys$1,
      ai_providers: ai_providers$1,
      auth_files: auth_files$1,
      vertex_import: vertex_import$1,
      oauth_excluded: oauth_excluded$1,
      auth_login: auth_login$1,
      usage_stats: usage_stats$1,
      stats: stats$1,
      logs: logs$1,
      config_management: config_management$1,
      system_info: system_info$1,
      notification: notification$1,
      language: language$2,
      theme: theme$2,
      sidebar: sidebar$1,
      footer: footer$1
    };
    const common = { "login": "Login", "logout": "Logout", "cancel": "Cancel", "confirm": "Confirm", "save": "Save", "delete": "Delete", "edit": "Edit", "add": "Add", "update": "Update", "refresh": "Refresh", "close": "Close", "success": "Success", "error": "Error", "info": "Info", "warning": "Warning", "loading": "Loading...", "connecting": "Connecting...", "connected": "Connected", "disconnected": "Disconnected", "connecting_status": "Connecting", "connected_status": "Connected", "disconnected_status": "Disconnected", "yes": "Yes", "no": "No", "not_set": "Not set", "optional": "Optional", "required": "Required", "api_key": "Key", "base_url": "Address", "proxy_url": "Proxy", "alias": "Alias", "failure": "Failure", "unknown_error": "Unknown error", "copy": "Copy", "custom_headers_label": "Custom Headers", "custom_headers_hint": "Optional HTTP headers to send with the request. Leave blank to remove.", "custom_headers_add": "Add Header", "custom_headers_key_placeholder": "Header name, e.g. X-Custom-Header", "custom_headers_value_placeholder": "Header value", "model_name_placeholder": "Model name, e.g. claude-3-5-sonnet-20241022", "model_alias_placeholder": "Model alias (optional)" };
    const title = { "main": "CLI Proxy API Management Center", "login": "CLI Proxy API Management Center", "abbr": "CPAMC" };
    const auto_login = { "title": "Auto Login in Progress...", "message": "Attempting to connect to server using locally saved connection information" };
    const login = { "subtitle": "Please enter connection information to access the management interface", "connection_title": "Connection Address", "connection_current": "Current URL", "connection_auto_hint": "The system will automatically use the current URL for connection", "custom_connection_label": "Custom Connection URL:", "custom_connection_placeholder": "Eg: https://example.com:8317", "custom_connection_hint": "By default the current URL is used. Override it here if needed.", "use_current_address": "Use Current URL", "management_key_label": "Management Key:", "management_key_placeholder": "Enter the management key", "connect_button": "Connect", "submit_button": "Login", "submitting": "Connecting...", "error_title": "Login Failed", "error_required": "Please fill in complete connection information", "error_invalid": "Connection failed, please check address and key" };
    const header$1 = { "check_connection": "Check Connection", "refresh_all": "Refresh All", "logout": "Logout" };
    const connection = { "title": "Connection Information", "server_address": "Server Address:", "management_key": "Management Key:", "status": "Connection Status:" };
    const nav$1 = { "basic_settings": "Basic Settings", "api_keys": "API Keys", "ai_providers": "AI Providers", "auth_files": "Auth Files", "oauth": "OAuth Login", "usage_stats": "Usage Statistics", "config_management": "Config Management", "logs": "Logs Viewer", "system_info": "Management Center Info" };
    const basic_settings = { "title": "Basic Settings", "debug_title": "Debug Mode", "debug_enable": "Enable Debug Mode", "proxy_title": "Proxy Settings", "proxy_url_label": "Proxy URL:", "proxy_url_placeholder": "e.g.: socks5://user:pass@127.0.0.1:1080/", "proxy_update": "Update", "proxy_clear": "Clear", "retry_title": "Request Retry", "retry_count_label": "Retry Count:", "retry_update": "Update", "quota_title": "Quota Exceeded Behavior", "quota_switch_project": "Auto Switch Project", "quota_switch_preview": "Switch to Preview Model", "usage_statistics_title": "Usage Statistics", "usage_statistics_enable": "Enable usage statistics", "logging_title": "Logging", "logging_to_file_enable": "Enable logging to file", "request_log_enable": "Enable request logging", "ws_auth_title": "WebSocket Authentication", "ws_auth_enable": "Require auth for /ws/*" };
    const api_keys = { "title": "API Keys Management", "proxy_auth_title": "Proxy Service Authentication Keys", "add_button": "Add Key", "empty_title": "No API Keys", "empty_desc": "Click the button above to add the first key", "item_title": "API Key", "add_modal_title": "Add API Key", "add_modal_key_label": "API Key:", "add_modal_key_placeholder": "Please enter API key", "edit_modal_title": "Edit API Key", "edit_modal_key_label": "API Key:", "delete_confirm": "Are you sure you want to delete this API key?" };
    const ai_providers = { "title": "AI Providers Configuration", "gemini_title": "Gemini API Keys", "gemini_add_button": "Add Key", "gemini_empty_title": "No Gemini Keys", "gemini_empty_desc": "Click the button above to add the first key", "gemini_item_title": "Gemini Key", "gemini_add_modal_title": "Add Gemini API Key", "gemini_add_modal_key_label": "API Keys:", "gemini_add_modal_key_placeholder": "Enter Gemini API key", "gemini_add_modal_key_hint": "Add keys one by one and optionally specify a Base URL.", "gemini_keys_add_btn": "Add Key", "gemini_base_url_label": "Base URL (Optional):", "gemini_base_url_placeholder": "e.g.: https://generativelanguage.googleapis.com", "gemini_edit_modal_title": "Edit Gemini API Key", "gemini_edit_modal_key_label": "API Key:", "gemini_delete_confirm": "Are you sure you want to delete this Gemini key?", "excluded_models_label": "Excluded models (optional):", "excluded_models_placeholder": "Comma or newline separated, e.g. gemini-1.5-pro, gemini-1.5-flash", "excluded_models_hint": "Leave empty to allow all models; values are trimmed and deduplicated automatically.", "excluded_models_count": "Excluding {{count}} models", "config_toggle_label": "Enabled", "config_disabled_badge": "Disabled", "codex_title": "Codex API Configuration", "codex_add_button": "Add Configuration", "codex_empty_title": "No Codex Configuration", "codex_empty_desc": "Click the button above to add the first configuration", "codex_item_title": "Codex Configuration", "codex_add_modal_title": "Add Codex API Configuration", "codex_add_modal_key_label": "API Key:", "codex_add_modal_key_placeholder": "Please enter Codex API key", "codex_add_modal_url_label": "Base URL (Required):", "codex_add_modal_url_placeholder": "e.g.: https://api.example.com", "codex_add_modal_proxy_label": "Proxy URL (Optional):", "codex_add_modal_proxy_placeholder": "e.g.: socks5://proxy.example.com:1080", "codex_edit_modal_title": "Edit Codex API Configuration", "codex_edit_modal_key_label": "API Key:", "codex_edit_modal_url_label": "Base URL (Required):", "codex_edit_modal_proxy_label": "Proxy URL (Optional):", "codex_delete_confirm": "Are you sure you want to delete this Codex configuration?", "claude_title": "Claude API Configuration", "claude_add_button": "Add Configuration", "claude_empty_title": "No Claude Configuration", "claude_empty_desc": "Click the button above to add the first configuration", "claude_item_title": "Claude Configuration", "claude_add_modal_title": "Add Claude API Configuration", "claude_add_modal_key_label": "API Key:", "claude_add_modal_key_placeholder": "Please enter Claude API key", "claude_add_modal_url_label": "Base URL (Optional):", "claude_add_modal_url_placeholder": "e.g.: https://api.anthropic.com", "claude_add_modal_proxy_label": "Proxy URL (Optional):", "claude_add_modal_proxy_placeholder": "e.g.: socks5://proxy.example.com:1080", "claude_edit_modal_title": "Edit Claude API Configuration", "claude_edit_modal_key_label": "API Key:", "claude_edit_modal_url_label": "Base URL (Optional):", "claude_edit_modal_proxy_label": "Proxy URL (Optional):", "claude_delete_confirm": "Are you sure you want to delete this Claude configuration?", "claude_models_label": "Custom Models (Optional):", "claude_models_hint": "Leave empty to allow all models, or add name[, alias] entries to limit/alias them.", "claude_models_add_btn": "Add Model", "claude_models_count": "Models Count", "ampcode_title": "Amp CLI Integration (ampcode)", "ampcode_modal_title": "Configure Ampcode", "ampcode_upstream_url_label": "Upstream URL", "ampcode_upstream_url_placeholder": "e.g. https://ampcode.com", "ampcode_upstream_url_hint": "Optional. Leave empty to use the default/auto-discovered control plane URL.", "ampcode_upstream_api_key_label": "Upstream API Key (Amp Official)", "ampcode_upstream_api_key_placeholder": "Enter sk-amp... (leave empty to keep current)", "ampcode_upstream_api_key_hint": "Optional. Leaving it empty will not change the current Amp official key. Use the button below to clear it.", "ampcode_upstream_api_key_current": "Current Amp official key: {{key}}", "ampcode_clear_upstream_api_key": "Clear official key", "ampcode_clear_upstream_api_key_confirm": "Are you sure you want to clear the Ampcode upstream API key (Amp official)?", "ampcode_restrict_management_label": "Restrict Amp management routes to localhost", "ampcode_restrict_management_hint": "When enabled, Amp management routes (/api/auth, /api/user, /api/threads, etc.) only accept 127.0.0.1/::1 (recommended).", "ampcode_force_model_mappings_label": "Force model mappings", "ampcode_force_model_mappings_hint": "When enabled, mappings override local API-key availability checks.", "ampcode_model_mappings_label": "Model mappings (from  to)", "ampcode_model_mappings_hint": "Rewrites model names in Amp requests. Leave empty to disable mappings.", "ampcode_model_mappings_add_btn": "Add mapping", "ampcode_model_mappings_from_placeholder": "from model (source)", "ampcode_model_mappings_to_placeholder": "to model (target)", "ampcode_model_mappings_count": "Mappings Count", "ampcode_mappings_overwrite_confirm": "Existing mappings could not be loaded. Continuing may overwrite or clear them. Continue?", "openai_title": "OpenAI Compatible Providers", "openai_add_button": "Add Provider", "openai_empty_title": "No OpenAI Compatible Providers", "openai_empty_desc": "Click the button above to add the first provider", "openai_add_modal_title": "Add OpenAI Compatible Provider", "openai_add_modal_name_label": "Provider Name:", "openai_add_modal_name_placeholder": "e.g.: openrouter", "openai_add_modal_url_label": "Base URL:", "openai_add_modal_url_placeholder": "e.g.: https://openrouter.ai/api/v1", "openai_add_modal_keys_label": "API Keys", "openai_edit_modal_keys_label": "API Keys", "openai_keys_hint": "Add each key separately with an optional proxy URL to keep things organized.", "openai_keys_add_btn": "Add Key", "openai_key_placeholder": "sk-... key", "openai_proxy_placeholder": "Optional proxy URL (e.g. socks5://...)", "openai_add_modal_models_label": "Model List (name[, alias] one per line):", "openai_models_hint": "Example: gpt-4o-mini or moonshotai/kimi-k2:free, kimi-k2", "openai_model_name_placeholder": "Model name, e.g. moonshotai/kimi-k2:free", "openai_model_alias_placeholder": "Model alias (optional)", "openai_models_add_btn": "Add Model", "openai_models_fetch_button": "Fetch via /v1/models", "openai_models_fetch_title": "Pick Models from /v1/models", "openai_models_fetch_hint": "Call the /v1/models endpoint using the Base URL above, sending the first API key as Bearer plus custom headers.", "openai_models_fetch_url_label": "Request URL", "openai_models_fetch_refresh": "Refresh", "openai_models_fetch_loading": "Fetching models from /v1/models...", "openai_models_fetch_empty": "No models returned. Please check the endpoint or auth.", "openai_models_fetch_error": "Failed to fetch models", "openai_models_fetch_back": "Back to edit", "openai_models_fetch_apply": "Add selected models", "openai_models_search_label": "Search models", "openai_models_search_placeholder": "Filter by name, alias, or description", "openai_models_search_empty": "No models match your search. Try a different keyword.", "openai_models_fetch_invalid_url": "Please enter a valid Base URL first", "openai_models_fetch_added": "{{count}} new models added", "openai_edit_modal_title": "Edit OpenAI Compatible Provider", "openai_edit_modal_name_label": "Provider Name:", "openai_edit_modal_url_label": "Base URL:", "openai_edit_modal_models_label": "Model List (name[, alias] one per line):", "openai_delete_confirm": "Are you sure you want to delete this OpenAI provider?", "openai_keys_count": "Keys Count", "openai_models_count": "Models Count", "openai_test_title": "Connection Test", "openai_test_hint": "Send a /v1/chat/completions request with the current settings to verify availability.", "openai_test_model_placeholder": "Model to test", "openai_test_action": "Run Test", "openai_test_running": "Sending test request...", "openai_test_timeout": "Test request timed out after {{seconds}} seconds.", "openai_test_success": "Test succeeded. The model responded.", "openai_test_failed": "Test failed", "openai_test_select_placeholder": "Choose from current models", "openai_test_select_empty": "No models configured. Add models first" };
    const auth_files = { "title": "Auth Files Management", "title_section": "Auth Files", "description": "Manage all CLI Proxy JSON auth files here (e.g. Qwen, Gemini, Vertex). Uploading a credential immediately enables the corresponding AI integration.", "upload_button": "Upload File", "delete_all_button": "Delete All", "empty_title": "No Auth Files", "empty_desc": "Click the button above to upload the first file", "search_empty_title": "No matching files", "search_empty_desc": "Try changing the filters or clearing the search box.", "file_size": "Size", "file_modified": "Modified", "download_button": "Download", "delete_button": "Delete", "delete_confirm": "Are you sure you want to delete file", "delete_all_confirm": "Are you sure you want to delete all auth files? This operation cannot be undone!", "delete_filtered_confirm": "Are you sure you want to delete all {{type}} auth files? This operation cannot be undone!", "upload_error_json": "Only JSON files are allowed", "upload_success": "File uploaded successfully", "download_success": "File downloaded successfully", "delete_success": "File deleted successfully", "delete_all_success": "Successfully deleted", "delete_filtered_success": "Deleted {{count}} {{type}} auth files successfully", "delete_filtered_partial": "{{type}} auth files deletion finished: {{success}} succeeded, {{failed}} failed", "delete_filtered_none": "No deletable auth files under the current filter ({{type}})", "files_count": "files", "pagination_prev": "Previous", "pagination_next": "Next", "pagination_info": "Page {{current}} / {{total}}  {{count}} files", "search_label": "Search configs", "search_placeholder": "Filter by name, type, or provider", "page_size_label": "Per page", "page_size_unit": "items", "filter_all": "All", "filter_qwen": "Qwen", "filter_gemini": "Gemini", "filter_gemini-cli": "GeminiCLI", "filter_aistudio": "AIStudio", "filter_claude": "Claude", "filter_codex": "Codex", "filter_antigravity": "Antigravity", "filter_iflow": "iFlow", "filter_vertex": "Vertex", "filter_empty": "Empty", "filter_unknown": "Other", "type_qwen": "Qwen", "type_gemini": "Gemini", "type_gemini-cli": "GeminiCLI", "type_aistudio": "AIStudio", "type_claude": "Claude", "type_codex": "Codex", "type_antigravity": "Antigravity", "type_iflow": "iFlow", "type_vertex": "Vertex", "type_empty": "Empty", "type_unknown": "Other", "type_virtual": "Virtual auth file", "models_button": "Models", "models_title": "Supported models", "models_loading": "Loading model list...", "models_empty": "No available models for this credential", "models_empty_desc": "This credential may not be loaded by the server yet, or no models are bound to it.", "models_unsupported": "This feature is not supported in the current version", "models_unsupported_desc": "Please update CLI Proxy API to the latest version and try again", "models_excluded_badge": "Excluded", "models_excluded_hint": "This model is excluded by OAuth" };
    const vertex_import = { "title": "Vertex AI Credential Import", "description": "Upload a Google service account JSON to store it as auth-dir/vertex-<project>.json using the same rules as the CLI vertex-import helper.", "location_label": "Region (optional)", "location_placeholder": "us-central1", "location_hint": "Leave empty to use the default region us-central1.", "file_label": "Service account key JSON", "file_hint": "Only Google Cloud service account key JSON files are accepted.", "file_placeholder": "No file selected", "choose_file": "Choose File", "import_button": "Import Vertex Credential", "file_required": "Select a .json credential file first", "success": "Vertex credential imported successfully", "result_title": "Credential saved", "result_project": "Project ID", "result_email": "Service account", "result_location": "Region", "result_file": "Persisted file" };
    const oauth_excluded = { "title": "OAuth Excluded Models", "description": "Per-provider exclusions are shown as cards; click edit to adjust. Wildcards * are supported and the scope follows the auth file filter.", "add": "Add Exclusion", "add_title": "Add provider exclusion", "edit_title": "Edit exclusions for {{provider}}", "refresh": "Refresh", "refreshing": "Refreshing...", "provider_label": "Provider", "provider_auto": "Follow current filter", "provider_placeholder": "e.g. gemini-cli", "provider_hint": "Defaults to the current filter; pick an existing provider or type a new name.", "models_label": "Models to exclude", "models_placeholder": "gpt-4.1-mini\n*-preview", "models_hint": "Separate by commas or new lines; saving an empty list removes that provider. * wildcards are supported.", "save": "Save/Update", "saving": "Saving...", "save_success": "Excluded models updated", "save_failed": "Failed to update excluded models", "delete": "Delete Provider", "delete_confirm": "Delete the exclusion list for {{provider}}?", "delete_success": "Exclusion list removed", "delete_failed": "Failed to delete exclusion list", "deleting": "Deleting...", "no_models": "No excluded models", "model_count": "{{count}} models excluded", "list_empty_all": "No exclusions yetuse Add Exclusion to create one.", "list_empty_filtered": "No exclusions in this scope; click Add Exclusion to add.", "disconnected": "Connect to the server to view exclusions", "load_failed": "Failed to load exclusion list", "provider_required": "Please enter a provider first", "scope_all": "Scope: All providers", "scope_provider": "Scope: {{provider}}", "upgrade_required": "This feature requires a newer CLI Proxy API (CPA) version. Please upgrade.", "upgrade_required_title": "Please upgrade CLI Proxy API", "upgrade_required_desc": "The current server does not support the OAuth excluded models API. Please upgrade to the latest CLI Proxy API (CPA) version." };
    const auth_login = { "codex_oauth_title": "Codex OAuth", "codex_oauth_button": "Start Codex Login", "codex_oauth_hint": "Login to Codex service through OAuth flow, automatically obtain and save authentication files.", "codex_oauth_url_label": "Authorization URL:", "codex_open_link": "Open Link", "codex_copy_link": "Copy Link", "codex_oauth_status_waiting": "Waiting for authentication...", "codex_oauth_status_success": "Authentication successful!", "codex_oauth_status_error": "Authentication failed:", "codex_oauth_start_error": "Failed to start Codex OAuth:", "codex_oauth_polling_error": "Failed to check authentication status:", "anthropic_oauth_title": "Anthropic OAuth", "anthropic_oauth_button": "Start Anthropic Login", "anthropic_oauth_hint": "Login to Anthropic (Claude) service through OAuth flow, automatically obtain and save authentication files.", "anthropic_oauth_url_label": "Authorization URL:", "anthropic_open_link": "Open Link", "anthropic_copy_link": "Copy Link", "anthropic_oauth_status_waiting": "Waiting for authentication...", "anthropic_oauth_status_success": "Authentication successful!", "anthropic_oauth_status_error": "Authentication failed:", "anthropic_oauth_start_error": "Failed to start Anthropic OAuth:", "anthropic_oauth_polling_error": "Failed to check authentication status:", "antigravity_oauth_title": "Antigravity OAuth", "antigravity_oauth_button": "Start Antigravity Login", "antigravity_oauth_hint": "Login to Antigravity service (Google account) through OAuth flow, automatically obtain and save authentication files.", "antigravity_oauth_url_label": "Authorization URL:", "antigravity_open_link": "Open Link", "antigravity_copy_link": "Copy Link", "antigravity_oauth_status_waiting": "Waiting for authentication...", "antigravity_oauth_status_success": "Authentication successful!", "antigravity_oauth_status_error": "Authentication failed:", "antigravity_oauth_start_error": "Failed to start Antigravity OAuth:", "antigravity_oauth_polling_error": "Failed to check authentication status:", "gemini_cli_oauth_title": "Gemini CLI OAuth", "gemini_cli_oauth_button": "Start Gemini CLI Login", "gemini_cli_oauth_hint": "Login to Google Gemini CLI service through OAuth flow, automatically obtain and save authentication files.", "gemini_cli_project_id_label": "Google Cloud Project ID:", "gemini_cli_project_id_placeholder": "Enter Google Cloud Project ID", "gemini_cli_project_id_hint": "Project ID is required for Gemini CLI OAuth.", "gemini_cli_project_id_required": "Please enter a Google Cloud project ID.", "gemini_cli_oauth_url_label": "Authorization URL:", "gemini_cli_open_link": "Open Link", "gemini_cli_copy_link": "Copy Link", "gemini_cli_oauth_status_waiting": "Waiting for authentication...", "gemini_cli_oauth_status_success": "Authentication successful!", "gemini_cli_oauth_status_error": "Authentication failed:", "gemini_cli_oauth_start_error": "Failed to start Gemini CLI OAuth:", "gemini_cli_oauth_polling_error": "Failed to check authentication status:", "qwen_oauth_title": "Qwen OAuth", "qwen_oauth_button": "Start Qwen Login", "qwen_oauth_hint": "Login to Qwen service through device authorization flow, automatically obtain and save authentication files.", "qwen_oauth_url_label": "Authorization URL:", "qwen_open_link": "Open Link", "qwen_copy_link": "Copy Link", "qwen_oauth_status_waiting": "Waiting for authentication...", "qwen_oauth_status_success": "Authentication successful!", "qwen_oauth_status_error": "Authentication failed:", "qwen_oauth_start_error": "Failed to start Qwen OAuth:", "qwen_oauth_polling_error": "Failed to check authentication status:", "oauth_callback_label": "Callback URL", "oauth_callback_placeholder": "http://localhost:1455/auth/callback?code=...&state=...", "oauth_callback_hint": "Remote browser mode: after the provider redirects to http://localhost:..., copy the full URL and submit it here.", "oauth_callback_button": "Submit Callback URL", "oauth_callback_required": "Please paste the full redirect URL first.", "oauth_callback_success": "Callback URL submitted. Continue waiting for authentication.", "oauth_callback_error": "Failed to submit callback URL:", "oauth_callback_upgrade_hint": "Please update CLI Proxy API or check the connection.", "oauth_callback_status_success": "Callback URL submitted, waiting for authentication...", "oauth_callback_status_error": "Callback URL submission failed:", "missing_state": "Unable to retrieve authentication state parameter", "iflow_oauth_title": "iFlow OAuth", "iflow_oauth_button": "Start iFlow Login", "iflow_oauth_hint": "Login to iFlow service through OAuth flow, automatically obtain and save authentication files.", "iflow_oauth_url_label": "Authorization URL:", "iflow_open_link": "Open Link", "iflow_copy_link": "Copy Link", "iflow_oauth_status_waiting": "Waiting for authentication...", "iflow_oauth_status_success": "Authentication successful!", "iflow_oauth_status_error": "Authentication failed:", "iflow_oauth_start_error": "Failed to start iFlow OAuth:", "iflow_oauth_polling_error": "Failed to check authentication status:", "iflow_cookie_title": "iFlow Cookie Login", "iflow_cookie_label": "Cookie Value:", "iflow_cookie_placeholder": "Paste browser cookie, e.g. sessionid=...;", "iflow_cookie_hint": "Submit an existing cookie to finish login without opening the authorization link; the credential file will be saved automatically.", "iflow_cookie_key_hint": "Note: Create a key on the platform first.", "iflow_cookie_button": "Submit Cookie Login", "iflow_cookie_status_success": "Cookie login succeeded and credentials are saved.", "iflow_cookie_status_error": "Cookie login failed:", "iflow_cookie_status_duplicate": "Duplicate config:", "iflow_cookie_start_error": "Failed to submit cookie login:", "iflow_cookie_config_duplicate": "A config file already exists (duplicate). Remove the existing file and try again if you want to re-save it.", "iflow_cookie_required": "Please provide the Cookie value first.", "iflow_cookie_result_title": "Cookie Login Result", "iflow_cookie_result_email": "Account", "iflow_cookie_result_expired": "Expires At", "iflow_cookie_result_path": "Saved Path", "iflow_cookie_result_type": "Type", "remote_access_disabled": "This login method is not available for remote access. Please access from localhost.", "kiro_title": "Kiro Credential Login", "kiro_button": "Load Credentials", "kiro_hint": "Load Kiro (AWS CodeWhisperer) credentials from AWS SSO cache.", "kiro_path_hint": "Supports specifying a file path or directory path.", "kiro_file_path_label": "OAuth Credential File Path:", "kiro_file_path_placeholder": "e.g., ~/.aws/sso/cache/kiro-auth-token.json", "kiro_file_path_hint": "Leave empty to auto-scan ~/.aws/sso/cache/ directory", "kiro_upload_button": "Upload", "kiro_upload_success": "File uploaded successfully", "kiro_upload_error": "File upload failed:", "kiro_status_success": "Kiro credentials loaded and saved successfully.", "kiro_status_error": "Failed to load Kiro credentials:", "kiro_status_duplicate": "Duplicate config:", "kiro_start_error": "Failed to load Kiro credentials:", "kiro_config_duplicate": "A config file already exists (duplicate). Remove the existing file and try again if you want to re-save it.", "kiro_result_title": "Kiro Credential Load Result", "kiro_result_region": "Region", "kiro_result_path": "Saved Path", "kiro_result_type": "Type" };
    const usage_stats = { "title": "Usage Statistics", "total_requests": "Total Requests", "success_requests": "Success Requests", "failed_requests": "Failed Requests", "total_tokens": "Total Tokens", "cached_tokens": "Cached Tokens", "reasoning_tokens": "Reasoning Tokens", "rpm_30m": "RPM", "tpm_30m": "TPM", "rate_30m": "Rate (last 30 min)", "model_name": "Model Name", "model_price_settings": "Model Pricing Settings", "saved_prices": "Saved Prices", "requests_trend": "Request Trends", "tokens_trend": "Token Usage Trends", "api_details": "API Details", "by_hour": "By Hour", "by_day": "By Day", "refresh": "Refresh", "chart_line_label_1": "Line 1", "chart_line_label_2": "Line 2", "chart_line_label_3": "Line 3", "chart_line_label_4": "Line 4", "chart_line_label_5": "Line 5", "chart_line_label_6": "Line 6", "chart_line_label_7": "Line 7", "chart_line_label_8": "Line 8", "chart_line_label_9": "Line 9", "chart_line_hidden": "Hide", "chart_line_actions_label": "Lines to display", "chart_line_add": "Add line", "chart_line_all": "All", "chart_line_delete": "Delete line", "chart_line_hint": "Show up to 9 model lines at once", "no_data": "No Data Available", "loading_error": "Loading Failed", "api_endpoint": "API Endpoint", "requests_count": "Request Count", "tokens_count": "Token Count", "models": "Model Statistics", "success_rate": "Success Rate", "total_cost": "Total Cost", "total_cost_hint": "Based on configured model pricing", "model_price_title": "Model Pricing", "model_price_reset": "Clear Prices", "model_price_model_label": "Model", "model_price_select_placeholder": "Choose a model", "model_price_select_hint": "Models come from usage details", "model_price_prompt": "Prompt price", "model_price_completion": "Completion price", "model_price_cache": "Cache price", "model_price_save": "Save Price", "model_price_empty": "No model prices set", "model_price_model": "Model", "model_price_saved": "Model price saved", "model_price_model_required": "Please choose a model to set pricing", "cost_trend": "Cost Overview", "cost_axis_label": "Cost ($)", "cost_need_price": "Set a model price to view cost stats", "cost_need_usage": "No usage data available to calculate cost", "cost_no_data": "No cost data yet" };
    const stats = { "success": "Success", "failure": "Failure" };
    const logs = { "title": "Logs Viewer", "refresh_button": "Refresh Logs", "clear_button": "Clear Logs", "download_button": "Download Logs", "error_log_button": "Select Error Log", "error_logs_modal_title": "Error Request Logs", "error_logs_description": "Pick an error request log file to download (only generated when request logging is off).", "error_logs_empty": "No error request log files found", "error_logs_load_error": "Failed to load error log list", "error_logs_size": "Size", "error_logs_modified": "Last modified", "error_logs_download": "Download", "error_log_download_success": "Error log downloaded successfully", "empty_title": "No Logs Available", "empty_desc": 'When "Enable logging to file" is enabled, logs will be displayed here', "log_content": "Log Content", "loading": "Loading logs...", "load_error": "Failed to load logs", "clear_confirm": "Are you sure you want to clear all logs? This action cannot be undone!", "clear_success": "Logs cleared successfully", "download_success": "Logs downloaded successfully", "auto_refresh": "Auto Refresh", "auto_refresh_enabled": "Auto refresh enabled", "auto_refresh_disabled": "Auto refresh disabled", "load_more_hint": "Scroll up to load more", "hidden_lines": "Hidden: {{count}} lines", "hide_management_logs": "Hide {{prefix}} logs", "search_placeholder": "Search logs by content or keyword", "search_empty_title": "No matching logs found", "search_empty_desc": "Try a different keyword or clear the filters.", "double_click_copy_hint": "Double-click to copy raw log line", "copy_success": "Log copied to clipboard", "copy_failed": "Copy failed", "lines": "lines", "removed": "Filtered", "upgrade_required_title": "Please Upgrade CLI Proxy API", "upgrade_required_desc": "The current server version does not support the logs viewing feature. Please upgrade to the latest version of CLI Proxy API to use this feature." };
    const config_management = { "title": "Config Management", "editor_title": "Configuration File", "reload": "Reload", "save": "Save", "description": "View and edit the server-side config.yaml file. Validate the syntax before saving.", "status_idle": "Waiting for action", "status_loading": "Loading configuration...", "status_loaded": "Configuration loaded", "status_dirty": "Unsaved changes", "status_disconnected": "Connect to the server to load the configuration", "status_load_failed": "Load failed", "status_saving": "Saving configuration...", "status_saved": "Configuration saved", "status_save_failed": "Save failed", "save_success": "Configuration saved successfully", "error_yaml_not_supported": "Server did not return YAML. Verify the /config.yaml endpoint is available.", "editor_placeholder": "key: value", "search_placeholder": "Search config...", "search_button": "Search", "search_no_results": "No results", "search_prev": "Previous", "search_next": "Next" };
    const system_info = { "title": "Management Center Info", "connection_status_title": "Connection Status", "api_status_label": "API Status:", "config_status_label": "Config Status:", "last_update_label": "Last Update:", "cache_data": "Cache Data", "real_time_data": "Real-time Data", "not_loaded": "Not Loaded", "seconds_ago": "seconds ago", "models_title": "Available Models", "models_desc": "Shows the /v1/models response and uses saved API keys for auth automatically.", "models_loading": "Loading available models...", "models_empty": "No models returned by /v1/models", "models_error": "Failed to load model list", "models_count": "{{count}} available models", "version_check_title": "Update Check", "version_check_desc": "Call the /latest-version endpoint to compare with the server version and see if an update is available.", "version_current_label": "Current version", "version_latest_label": "Latest version", "version_check_button": "Check for updates", "version_check_idle": "Click to check for updates", "version_checking": "Checking for the latest version...", "version_update_available": "An update is available: {{version}}", "version_is_latest": "You are on the latest version", "version_check_error": "Update check failed", "version_current_missing": "Server version is unavailable; cannot compare", "version_unknown": "Unknown", "quick_links_title": "Quick Links", "quick_links_desc": "Access project repositories and documentation for help and updates.", "link_main_repo": "Main Repository", "link_main_repo_desc": "CLI Proxy API core program source code", "link_webui_repo": "WebUI Repository", "link_webui_repo_desc": "Management Center frontend source code", "link_docs": "Documentation", "link_docs_desc": "Usage tutorials and configuration guides" };
    const notification = { "debug_updated": "Debug settings updated", "proxy_updated": "Proxy settings updated", "proxy_cleared": "Proxy settings cleared", "retry_updated": "Retry settings updated", "quota_switch_project_updated": "Project switch settings updated", "quota_switch_preview_updated": "Preview model switch settings updated", "usage_statistics_updated": "Usage statistics settings updated", "logging_to_file_updated": "Logging settings updated", "request_log_updated": "Request logging setting updated", "ws_auth_updated": "WebSocket authentication setting updated", "api_key_added": "API key added successfully", "api_key_updated": "API key updated successfully", "api_key_deleted": "API key deleted successfully", "gemini_key_added": "Gemini key added successfully", "gemini_key_updated": "Gemini key updated successfully", "gemini_key_deleted": "Gemini key deleted successfully", "gemini_multi_input_required": "Please enter at least one Gemini key", "gemini_multi_failed": "Gemini bulk add failed", "gemini_multi_summary": "Gemini bulk add finished: {{success}} added, {{skipped}} skipped, {{failed}} failed", "codex_config_added": "Codex configuration added successfully", "codex_config_updated": "Codex configuration updated successfully", "codex_config_deleted": "Codex configuration deleted successfully", "codex_base_url_required": "Please enter the Codex Base URL", "claude_config_added": "Claude configuration added successfully", "claude_config_updated": "Claude configuration updated successfully", "claude_config_deleted": "Claude configuration deleted successfully", "config_enabled": "Configuration enabled", "config_disabled": "Configuration disabled", "field_required": "Required fields cannot be empty", "openai_provider_required": "Please fill in provider name and Base URL", "openai_provider_added": "OpenAI provider added successfully", "openai_provider_updated": "OpenAI provider updated successfully", "openai_provider_deleted": "OpenAI provider deleted successfully", "ampcode_updated": "Ampcode configuration updated", "ampcode_upstream_api_key_cleared": "Ampcode upstream API key override cleared", "openai_model_name_required": "Model name is required", "openai_test_url_required": "Please provide a valid Base URL before testing", "openai_test_key_required": "Please add at least one API key before testing", "openai_test_model_required": "Please select a model to test", "data_refreshed": "Data refreshed successfully", "connection_required": "Please establish connection first", "refresh_failed": "Refresh failed", "update_failed": "Update failed", "add_failed": "Add failed", "delete_failed": "Delete failed", "upload_failed": "Upload failed", "download_failed": "Download failed", "login_failed": "Login failed", "please_enter": "Please enter", "please_fill": "Please fill", "provider_name_url": "provider name and Base URL", "api_key": "API key", "gemini_api_key": "Gemini API key", "codex_api_key": "Codex API key", "claude_api_key": "Claude API key", "link_copied": "Link copied to clipboard" };
    const language$1 = { "switch": "Language", "chinese": "", "english": "English" };
    const theme$1 = { "switch": "Theme", "light": "Light", "dark": "Dark", "switch_to_light": "Switch to light mode", "switch_to_dark": "Switch to dark mode", "auto": "Follow system" };
    const sidebar = { "toggle_expand": "Expand sidebar", "toggle_collapse": "Collapse sidebar" };
    const footer = { "api_version": "CLI Proxy API Version", "build_date": "Build Time", "version": "Management UI Version", "author": "Author" };
    const en = {
      common,
      title,
      auto_login,
      login,
      header: header$1,
      connection,
      nav: nav$1,
      basic_settings,
      api_keys,
      ai_providers,
      auth_files,
      vertex_import,
      oauth_excluded,
      auth_login,
      usage_stats,
      stats,
      logs,
      config_management,
      system_info,
      notification,
      language: language$1,
      theme: theme$1,
      sidebar,
      footer
    };
    instance.use(initReactI18next).init({
      resources: {
        "zh-CN": { translation: zhCN },
        en: { translation: en }
      },
      lng: localStorage.getItem(STORAGE_KEY_LANGUAGE) || "zh-CN",
      fallbackLng: "zh-CN",
      interpolation: {
        escapeValue: false
        // React 
      },
      react: {
        useSuspense: false
      }
    });
    const useLanguageStore = create()(
      persist(
        (set2, get2) => ({
          language: "zh-CN",
          setLanguage: (language2) => {
            instance.changeLanguage(language2);
            set2({ language: language2 });
          },
          toggleLanguage: () => {
            const { language: language2, setLanguage } = get2();
            const newLanguage = language2 === "zh-CN" ? "en" : "zh-CN";
            setLanguage(newLanguage);
          }
        }),
        {
          name: STORAGE_KEY_LANGUAGE
        }
      )
    );
    const ENC_PREFIX = "enc::v1::";
    const SECRET_SALT = "cli-proxy-api-webui::secure-storage";
    let cachedKeyBytes = null;
    function encodeText(text) {
      const encoder = new TextEncoder();
      return encoder.encode(text);
    }
    function decodeText(bytes) {
      const decoder = new TextDecoder();
      return decoder.decode(bytes);
    }
    function getKeyBytes() {
      if (cachedKeyBytes) return cachedKeyBytes;
      try {
        const host = window.location.host;
        const ua = navigator.userAgent;
        cachedKeyBytes = encodeText(`${SECRET_SALT}|${host}|${ua}`);
      } catch (error2) {
        console.warn("Encryption fallback to simple key:", error2);
        cachedKeyBytes = encodeText(SECRET_SALT);
      }
      return cachedKeyBytes;
    }
    function xorBytes(data, keyBytes) {
      const result = new Uint8Array(data.length);
      for (let i2 = 0; i2 < data.length; i2++) {
        result[i2] = data[i2] ^ keyBytes[i2 % keyBytes.length];
      }
      return result;
    }
    function toBase64(bytes) {
      let binary = "";
      for (let i2 = 0; i2 < bytes.length; i2++) {
        binary += String.fromCharCode(bytes[i2]);
      }
      return btoa(binary);
    }
    function fromBase64(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i2 = 0; i2 < binary.length; i2++) {
        bytes[i2] = binary.charCodeAt(i2);
      }
      return bytes;
    }
    function encryptData(value) {
      if (!value) return value;
      try {
        const keyBytes = getKeyBytes();
        const encrypted = xorBytes(encodeText(value), keyBytes);
        return `${ENC_PREFIX}${toBase64(encrypted)}`;
      } catch (error2) {
        console.warn("Encryption failed, fallback to plaintext:", error2);
        return value;
      }
    }
    function decryptData(payload) {
      if (!payload || !payload.startsWith(ENC_PREFIX)) {
        return payload;
      }
      try {
        const encodedBody = payload.slice(ENC_PREFIX.length);
        const encrypted = fromBase64(encodedBody);
        const decrypted = xorBytes(encrypted, getKeyBytes());
        return decodeText(decrypted);
      } catch (error2) {
        console.warn("Decryption failed, return as-is:", error2);
        return payload;
      }
    }
    class SecureStorageService {
      /**
       * 
       */
      setItem(key, value, options = {}) {
        const { encrypt = true } = options;
        if (value === null || value === void 0) {
          this.removeItem(key);
          return;
        }
        const stringValue = JSON.stringify(value);
        const storedValue = encrypt ? encryptData(stringValue) : stringValue;
        localStorage.setItem(key, storedValue);
      }
      /**
       * 
       */
      getItem(key, options = {}) {
        const { encrypt = true } = options;
        const raw = localStorage.getItem(key);
        if (raw === null) return null;
        try {
          const decrypted = encrypt ? decryptData(raw) : raw;
          return JSON.parse(decrypted);
        } catch (e) {
          try {
            if (encrypt && raw.startsWith("enc::v1::")) {
              const decrypted = decryptData(raw);
              return decrypted;
            }
            return raw;
          } catch (e2) {
            return null;
          }
        }
      }
      /**
       * 
       */
      removeItem(key) {
        localStorage.removeItem(key);
      }
      /**
       * 
       */
      clear() {
        localStorage.clear();
      }
      /**
       * 
       */
      migratePlaintextKeys(keys2) {
        keys2.forEach((key) => {
          const raw = localStorage.getItem(key);
          if (!raw) return;
          if (raw.startsWith("enc::v1::")) {
            return;
          }
          let parsed = raw;
          try {
            parsed = JSON.parse(raw);
          } catch (e) {
            parsed = raw;
          }
          try {
            this.setItem(key, parsed);
          } catch (error2) {
            console.warn(`Failed to migrate key "${key}":`, error2);
          }
        });
      }
      /**
       * 
       */
      hasItem(key) {
        return localStorage.getItem(key) !== null;
      }
    }
    const secureStorage = new SecureStorageService();
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    const { toString } = Object.prototype;
    const { getPrototypeOf } = Object;
    const { iterator, toStringTag } = Symbol;
    const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    const kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    const typeOfTest = (type) => (thing) => typeof thing === type;
    const { isArray: isArray$1 } = Array;
    const isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    const isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    const isString = typeOfTest("string");
    const isFunction$2 = typeOfTest("function");
    const isNumber$1 = typeOfTest("number");
    const isObject$1 = (thing) => thing !== null && typeof thing === "object";
    const isBoolean = (thing) => thing === true || thing === false;
    const isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
    };
    const isEmptyObject = (val) => {
      if (!isObject$1(val) || isBuffer(val)) {
        return false;
      }
      try {
        return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
      } catch (e) {
        return false;
      }
    };
    const isDate = kindOfTest("Date");
    const isFile = kindOfTest("File");
    const isBlob = kindOfTest("Blob");
    const isFileList = kindOfTest("FileList");
    const isStream = (val) => isObject$1(val) && isFunction$2(val.pipe);
    const isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$2(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction$2(thing.toString) && thing.toString() === "[object FormData]"));
    };
    const isURLSearchParams = kindOfTest("URLSearchParams");
    const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
    const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i2;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray$1(obj)) {
        for (i2 = 0, l = obj.length; i2 < l; i2++) {
          fn.call(null, obj[i2], i2, obj);
        }
      } else {
        if (isBuffer(obj)) {
          return;
        }
        const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys2.length;
        let key;
        for (i2 = 0; i2 < len; i2++) {
          key = keys2[i2];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      if (isBuffer(obj)) {
        return null;
      }
      key = key.toLowerCase();
      const keys2 = Object.keys(obj);
      let i2 = keys2.length;
      let _key;
      while (i2-- > 0) {
        _key = keys2[i2];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    const _global = (() => {
      if (typeof globalThis !== "undefined") return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    const isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge$1() {
      const { caseless, skipUndefined } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge$1(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge$1({}, val);
        } else if (isArray$1(val)) {
          result[targetKey] = val.slice();
        } else if (!skipUndefined || !isUndefined(val)) {
          result[targetKey] = val;
        }
      };
      for (let i2 = 0, l = arguments.length; i2 < l; i2++) {
        arguments[i2] && forEach(arguments[i2], assignValue);
      }
      return result;
    }
    const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction$2(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    const stripBOM = (content2) => {
      if (content2.charCodeAt(0) === 65279) {
        content2 = content2.slice(1);
      }
      return content2;
    };
    const inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i2;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null) return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i2 = props.length;
        while (i2-- > 0) {
          prop = props[i2];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    const endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    const toArray = (thing) => {
      if (!thing) return null;
      if (isArray$1(thing)) return thing;
      let i2 = thing.length;
      if (!isNumber$1(i2)) return null;
      const arr = new Array(i2);
      while (i2-- > 0) {
        arr[i2] = thing[i2];
      }
      return arr;
    };
    const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    const forEachEntry = (obj, fn) => {
      const generator = obj && obj[iterator];
      const _iterator = generator.call(obj);
      let result;
      while ((result = _iterator.next()) && !result.done) {
        const pair2 = result.value;
        fn.call(obj, pair2[0], pair2[1]);
      }
    };
    const matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    const isHTMLForm = kindOfTest("HTMLFormElement");
    const toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    const isRegExp = kindOfTest("RegExp");
    const reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name2) => {
        let ret;
        if ((ret = reducer(descriptor, name2, obj)) !== false) {
          reducedDescriptors[name2] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    const freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name2) => {
        if (isFunction$2(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
          return false;
        }
        const value = obj[name2];
        if (!isFunction$2(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name2 + "'");
          };
        }
      });
    };
    const toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray$1(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
      return obj;
    };
    const noop$1 = () => {
    };
    const toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction$2(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
    }
    const toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source2, i2) => {
        if (isObject$1(source2)) {
          if (stack.indexOf(source2) >= 0) {
            return;
          }
          if (isBuffer(source2)) {
            return source2;
          }
          if (!("toJSON" in source2)) {
            stack[i2] = source2;
            const target = isArray$1(source2) ? [] : {};
            forEach(source2, (value, key) => {
              const reducedValue = visit(value, i2 + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i2] = void 0;
            return target;
          }
        }
        return source2;
      };
      return visit(obj, 0);
    };
    const isAsyncFn = kindOfTest("AsyncFunction");
    const isThenable = (thing) => thing && (isObject$1(thing) || isFunction$2(thing)) && isFunction$2(thing.then) && isFunction$2(thing.catch);
    const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported ? ((token, callbacks) => {
        _global.addEventListener("message", ({ source: source2, data }) => {
          if (source2 === _global && data === token) {
            callbacks.length && callbacks.shift()();
          }
        }, false);
        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token, "*");
        };
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(
      typeof setImmediate === "function",
      isFunction$2(_global.postMessage)
    );
    const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
    const isIterable = (thing) => thing != null && isFunction$2(thing[iterator]);
    const utils$1 = {
      isArray: isArray$1,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber: isNumber$1,
      isBoolean,
      isObject: isObject$1,
      isPlainObject,
      isEmptyObject,
      isReadableStream,
      isRequest,
      isResponse,
      isHeaders,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction: isFunction$2,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge: merge$1,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop: noop$1,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap,
      isIterable
    };
    function AxiosError$1(message2, code2, config2, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message2;
      this.name = "AxiosError";
      code2 && (this.code = code2);
      config2 && (this.config = config2);
      request && (this.request = request);
      if (response) {
        this.response = response;
        this.status = response.status ? response.status : null;
      }
    }
    utils$1.inherits(AxiosError$1, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.status
        };
      }
    });
    const prototype$1 = AxiosError$1.prototype;
    const descriptors$1 = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code2) => {
      descriptors$1[code2] = { value: code2 };
    });
    Object.defineProperties(AxiosError$1, descriptors$1);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError$1.from = (error2, code2, config2, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error2, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      const msg = error2 && error2.message ? error2.message : "Error";
      const errCode = code2 == null && error2 ? error2.code : code2;
      AxiosError$1.call(axiosError, msg, errCode, config2, request, response);
      if (error2 && axiosError.cause == null) {
        Object.defineProperty(axiosError, "cause", { value: error2, configurable: true });
      }
      axiosError.name = error2 && error2.name || "Error";
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    const httpAdapter = null;
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path2, key, dots) {
      if (!path2) return key;
      return path2.concat(key).map(function each2(token, i2) {
        token = removeBrackets(token);
        return !dots && i2 ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData$1(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined2(option, source2) {
        return !utils$1.isUndefined(source2[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null) return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (utils$1.isBoolean(value)) {
          return value.toString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path2) {
        let arr = value;
        if (value && !path2 && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each2(el, index2) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path2, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path2) {
        if (utils$1.isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path2.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each2(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path2,
            exposedHelpers
          );
          if (result === true) {
            build(el, path2 ? path2.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData$1(params, this, options);
    }
    const prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name2, value) {
      this._pairs.push([name2, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each2(pair2) {
        return _encode(pair2[0]) + "=" + _encode(pair2[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      if (utils$1.isFunction(options)) {
        options = {
          serialize: options
        };
      }
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    class InterceptorManager {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {void}
       */
      eject(id2) {
        if (this.handlers[id2]) {
          this.handlers[id2] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    }
    const transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    const platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    const _navigator = typeof navigator === "object" && navigator || void 0;
    const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
    const hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    const origin = hasBrowserEnv && window.location.href || "http://localhost";
    const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      navigator: _navigator,
      origin
    }, Symbol.toStringTag, { value: "Module" }));
    const platform = __spreadValues(__spreadValues({}, utils), platform$1);
    function toURLEncodedForm(data, options) {
      return toFormData$1(data, new platform.classes.URLSearchParams(), __spreadValues({
        visitor: function(value, key, path2, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name2) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys2 = Object.keys(arr);
      let i2;
      const len = keys2.length;
      let key;
      for (i2 = 0; i2 < len; i2++) {
        key = keys2[i2];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path2, value, target, index2) {
        let name2 = path2[index2++];
        if (name2 === "__proto__") return true;
        const isNumericKey = Number.isFinite(+name2);
        const isLast = index2 >= path2.length;
        name2 = !name2 && utils$1.isArray(target) ? target.length : name2;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name2)) {
            target[name2] = [target[name2], value];
          } else {
            target[name2] = value;
          }
          return !isNumericKey;
        }
        if (!target[name2] || !utils$1.isObject(target[name2])) {
          target[name2] = [];
        }
        const result = buildPath(path2, value, target[name2], index2);
        if (result && utils$1.isArray(target[name2])) {
          target[name2] = arrayToObject(target[name2]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name2, value) => {
          buildPath(parsePropPath(name2), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser2, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser2 || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    const defaults$3 = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData$1(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults$3.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data, this.parseReviver);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status2) {
        return status2 >= 200 && status2 < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults$3.headers[method] = {};
    });
    const ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    const parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i2;
      rawHeaders && rawHeaders.split("\n").forEach(function parser2(line) {
        i2 = line.indexOf(":");
        key = line.substring(0, i2).trim().toLowerCase();
        val = line.substring(i2 + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    const $internals = Symbol("internals");
    function normalizeHeader(header2) {
      return header2 && String(header2).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header2, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header2);
      }
      if (isHeaderNameFilter) {
        value = header2;
      }
      if (!utils$1.isString(value)) return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header2) {
      return header2.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header2) {
      const accessorName = utils$1.toCamelCase(" " + header2);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header2, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    let AxiosHeaders$1 = class AxiosHeaders {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header2, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header2) || header2 instanceof this.constructor) {
          setHeaders(header2, valueOrRewrite);
        } else if (utils$1.isString(header2) && (header2 = header2.trim()) && !isValidHeaderName(header2)) {
          setHeaders(parseHeaders(header2), valueOrRewrite);
        } else if (utils$1.isObject(header2) && utils$1.isIterable(header2)) {
          let obj = {}, dest, key;
          for (const entry of header2) {
            if (!utils$1.isArray(entry)) {
              throw TypeError("Object iterator must return a key-value pair");
            }
            obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
          }
          setHeaders(obj, valueOrRewrite);
        } else {
          header2 != null && setHeader(valueOrRewrite, header2, rewrite);
        }
        return this;
      }
      get(header2, parser2) {
        header2 = normalizeHeader(header2);
        if (header2) {
          const key = utils$1.findKey(this, header2);
          if (key) {
            const value = this[key];
            if (!parser2) {
              return value;
            }
            if (parser2 === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser2)) {
              return parser2.call(this, value, key);
            }
            if (utils$1.isRegExp(parser2)) {
              return parser2.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header2, matcher) {
        header2 = normalizeHeader(header2);
        if (header2) {
          const key = utils$1.findKey(this, header2);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header2, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header2)) {
          header2.forEach(deleteHeader);
        } else {
          deleteHeader(header2);
        }
        return deleted;
      }
      clear(matcher) {
        const keys2 = Object.keys(this);
        let i2 = keys2.length;
        let deleted = false;
        while (i2--) {
          const key = keys2[i2];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header2) => {
          const key = utils$1.findKey(headers, header2);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header2];
            return;
          }
          const normalized = format ? formatHeader(header2) : String(header2).trim();
          if (normalized !== header2) {
            delete self2[header2];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header2) => {
          value != null && value !== false && (obj[header2] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header2, value]) => header2 + ": " + value).join("\n");
      }
      getSetCookie() {
        return this.get("set-cookie") || [];
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header2) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header2) ? header2.forEach(defineAccessor) : defineAccessor(header2);
        return this;
      }
    };
    AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders$1);
    function transformData(fns, response) {
      const config2 = this || defaults$3;
      const context = response || config2;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel$1(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError$1(message2, config2, request) {
      AxiosError$1.call(this, message2 == null ? "canceled" : message2, AxiosError$1.ERR_CANCELED, config2, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError$1, AxiosError$1, {
      __CANCEL__: true
    });
    function settle(resolve2, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve2(response);
      } else {
        reject(new AxiosError$1(
          "Request failed with status code " + response.status,
          [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i2 = tail;
        let bytesCount = 0;
        while (i2 !== head) {
          bytesCount += bytes[i2++];
          i2 = i2 % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function throttle(fn, freq) {
      let timestamp2 = 0;
      let threshold = 1e3 / freq;
      let lastArgs;
      let timer;
      const invoke = (args, now = Date.now()) => {
        timestamp2 = now;
        lastArgs = null;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        fn(...args);
      };
      const throttled2 = (...args) => {
        const now = Date.now();
        const passed = now - timestamp2;
        if (passed >= threshold) {
          invoke(args, now);
        } else {
          lastArgs = args;
          if (!timer) {
            timer = setTimeout(() => {
              timer = null;
              invoke(lastArgs);
            }, threshold - passed);
          }
        }
      };
      const flush = () => lastArgs && invoke(lastArgs);
      return [throttled2, flush];
    }
    const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return throttle((e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? "download" : "upload"]: true
        };
        listener(data);
      }, freq);
    };
    const progressEventDecorator = (total, throttled2) => {
      const lengthComputable = total != null;
      return [(loaded) => throttled2[0]({
        lengthComputable,
        total,
        loaded
      }), throttled2[1]];
    };
    const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
    const isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
      url = new URL(url, platform.origin);
      return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
    })(
      new URL(platform.origin),
      platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
    ) : () => true;
    const cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name2, value, expires, path2, domain, secure, sameSite) {
          if (typeof document === "undefined") return;
          const cookie = [`${name2}=${encodeURIComponent(value)}`];
          if (utils$1.isNumber(expires)) {
            cookie.push(`expires=${new Date(expires).toUTCString()}`);
          }
          if (utils$1.isString(path2)) {
            cookie.push(`path=${path2}`);
          }
          if (utils$1.isString(domain)) {
            cookie.push(`domain=${domain}`);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          if (utils$1.isString(sameSite)) {
            cookie.push(`SameSite=${sameSite}`);
          }
          document.cookie = cookie.join("; ");
        },
        read(name2) {
          if (typeof document === "undefined") return null;
          const match = document.cookie.match(new RegExp("(?:^|; )" + name2 + "=([^;]*)"));
          return match ? decodeURIComponent(match[1]) : null;
        },
        remove(name2) {
          this.write(name2, "", Date.now() - 864e5, "/");
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
      let isRelativeUrl = !isAbsoluteURL(requestedURL);
      if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? __spreadValues({}, thing) : thing;
    function mergeConfig$1(config1, config2) {
      config2 = config2 || {};
      const config3 = {};
      function getMergedValue(target, source2, prop, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source2)) {
          return utils$1.merge.call({ caseless }, target, source2);
        } else if (utils$1.isPlainObject(source2)) {
          return utils$1.merge({}, source2);
        } else if (utils$1.isArray(source2)) {
          return source2.slice();
        }
        return source2;
      }
      function mergeDeepProperties(a, b, prop, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, prop, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, prop, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
      };
      utils$1.forEach(Object.keys(__spreadValues(__spreadValues({}, config1), config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
      });
      return config3;
    }
    const resolveConfig = (config2) => {
      const newConfig = mergeConfig$1({}, config2);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders$1.from(headers);
      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config2.params, config2.paramsSerializer);
      if (auth) {
        headers.set(
          "Authorization",
          "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
        );
      }
      if (utils$1.isFormData(data)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(void 0);
        } else if (utils$1.isFunction(data.getHeaders)) {
          const formHeaders = data.getHeaders();
          const allowedHeaders = ["content-type", "content-length"];
          Object.entries(formHeaders).forEach(([key, val]) => {
            if (allowedHeaders.includes(key.toLowerCase())) {
              headers.set(key, val);
            }
          });
        }
      }
      if (platform.hasStandardBrowserEnv) {
        withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
    const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    const xhrAdapter = isXHRAdapterSupported && function(config2) {
      return new Promise(function dispatchXhrRequest(resolve2, reject) {
        const _config = resolveConfig(config2);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
          flushUpload && flushUpload();
          flushDownload && flushDownload();
          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
          _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config2,
            request
          };
          settle(function _resolve2(value) {
            resolve2(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config2, request));
          request = null;
        };
        request.onerror = function handleError(event) {
          const msg = event && event.message ? event.message : "Network Error";
          const err = new AxiosError$1(msg, AxiosError$1.ERR_NETWORK, config2, request);
          err.event = event || null;
          reject(err);
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = _config.transitional || transitionalDefaults;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError$1(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
            config2,
            request
          ));
          request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
          request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
          request.upload.addEventListener("progress", uploadThrottled);
          request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError$1(null, config2, request) : cancel);
            request.abort();
            request = null;
          };
          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(_config.url);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config2));
          return;
        }
        request.send(requestData || null);
      });
    };
    const composeSignals = (signals, timeout) => {
      const { length } = signals = signals ? signals.filter(Boolean) : [];
      if (timeout || length) {
        let controller = new AbortController();
        let aborted;
        const onabort = function(reason) {
          if (!aborted) {
            aborted = true;
            unsubscribe();
            const err = reason instanceof Error ? reason : this.reason;
            controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
          }
        };
        let timer = timeout && setTimeout(() => {
          timer = null;
          onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
        }, timeout);
        const unsubscribe = () => {
          if (signals) {
            timer && clearTimeout(timer);
            timer = null;
            signals.forEach((signal2) => {
              signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
            });
            signals = null;
          }
        };
        signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
        const { signal } = controller;
        signal.unsubscribe = () => utils$1.asap(unsubscribe);
        return signal;
      }
    };
    const streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;
      if (len < chunkSize) {
        yield chunk;
        return;
      }
      let pos = 0;
      let end;
      while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
      }
    };
    const readBytes = function(iterable, chunkSize) {
      return __asyncGenerator(this, null, function* () {
        try {
          for (var iter = __forAwait(readStream(iterable)), more, temp, error2; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const chunk = temp.value;
            yield* __yieldStar(streamChunk(chunk, chunkSize));
          }
        } catch (temp) {
          error2 = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error2)
              throw error2[0];
          }
        }
      });
    };
    const readStream = function(stream) {
      return __asyncGenerator(this, null, function* () {
        if (stream[Symbol.asyncIterator]) {
          yield* __yieldStar(stream);
          return;
        }
        const reader = stream.getReader();
        try {
          for (; ; ) {
            const { done, value } = yield new __await(reader.read());
            if (done) {
              break;
            }
            yield value;
          }
        } finally {
          yield new __await(reader.cancel());
        }
      });
    };
    const trackStream = (stream, chunkSize, onProgress, onFinish) => {
      const iterator2 = readBytes(stream, chunkSize);
      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };
      return new ReadableStream({
        pull(controller) {
          return __async(this, null, function* () {
            try {
              const { done: done2, value } = yield iterator2.next();
              if (done2) {
                _onFinish();
                controller.close();
                return;
              }
              let len = value.byteLength;
              if (onProgress) {
                let loadedBytes = bytes += len;
                onProgress(loadedBytes);
              }
              controller.enqueue(new Uint8Array(value));
            } catch (err) {
              _onFinish(err);
              throw err;
            }
          });
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator2.return();
        }
      }, {
        highWaterMark: 2
      });
    };
    const DEFAULT_CHUNK_SIZE = 64 * 1024;
    const { isFunction: isFunction$1 } = utils$1;
    const globalFetchAPI = (({ Request, Response }) => ({
      Request,
      Response
    }))(utils$1.global);
    const {
      ReadableStream: ReadableStream$1,
      TextEncoder: TextEncoder$1
    } = utils$1.global;
    const test = (fn, ...args) => {
      try {
        return !!fn(...args);
      } catch (e) {
        return false;
      }
    };
    const factory = (env) => {
      env = utils$1.merge.call({
        skipUndefined: true
      }, globalFetchAPI, env);
      const { fetch: envFetch, Request, Response } = env;
      const isFetchSupported = envFetch ? isFunction$1(envFetch) : typeof fetch === "function";
      const isRequestSupported = isFunction$1(Request);
      const isResponseSupported = isFunction$1(Response);
      if (!isFetchSupported) {
        return false;
      }
      const isReadableStreamSupported = isFetchSupported && isFunction$1(ReadableStream$1);
      const encodeText2 = isFetchSupported && (typeof TextEncoder$1 === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder$1()) : (str) => __async(null, null, function* () {
        return new Uint8Array(yield new Request(str).arrayBuffer());
      }));
      const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
        let duplexAccessed = false;
        const hasContentType = new Request(platform.origin, {
          body: new ReadableStream$1(),
          method: "POST",
          get duplex() {
            duplexAccessed = true;
            return "half";
          }
        }).headers.has("Content-Type");
        return duplexAccessed && !hasContentType;
      });
      const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
      const resolvers = {
        stream: supportsResponseStream && ((res) => res.body)
      };
      isFetchSupported && (() => {
        ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
          !resolvers[type] && (resolvers[type] = (res, config2) => {
            let method = res && res[type];
            if (method) {
              return method.call(res);
            }
            throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config2);
          });
        });
      })();
      const getBodyLength = (body) => __async(null, null, function* () {
        if (body == null) {
          return 0;
        }
        if (utils$1.isBlob(body)) {
          return body.size;
        }
        if (utils$1.isSpecCompliantForm(body)) {
          const _request = new Request(platform.origin, {
            method: "POST",
            body
          });
          return (yield _request.arrayBuffer()).byteLength;
        }
        if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
          return body.byteLength;
        }
        if (utils$1.isURLSearchParams(body)) {
          body = body + "";
        }
        if (utils$1.isString(body)) {
          return (yield encodeText2(body)).byteLength;
        }
      });
      const resolveBodyLength = (headers, body) => __async(null, null, function* () {
        const length = utils$1.toFiniteNumber(headers.getContentLength());
        return length == null ? getBodyLength(body) : length;
      });
      return (config2) => __async(null, null, function* () {
        let {
          url,
          method,
          data,
          signal,
          cancelToken,
          timeout,
          onDownloadProgress,
          onUploadProgress,
          responseType,
          headers,
          withCredentials = "same-origin",
          fetchOptions
        } = resolveConfig(config2);
        let _fetch = envFetch || fetch;
        responseType = responseType ? (responseType + "").toLowerCase() : "text";
        let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
        let request = null;
        const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
          composedSignal.unsubscribe();
        });
        let requestContentLength;
        try {
          if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = yield resolveBodyLength(headers, data)) !== 0) {
            let _request = new Request(url, {
              method: "POST",
              body: data,
              duplex: "half"
            });
            let contentTypeHeader;
            if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
              headers.setContentType(contentTypeHeader);
            }
            if (_request.body) {
              const [onProgress, flush] = progressEventDecorator(
                requestContentLength,
                progressEventReducer(asyncDecorator(onUploadProgress))
              );
              data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
            }
          }
          if (!utils$1.isString(withCredentials)) {
            withCredentials = withCredentials ? "include" : "omit";
          }
          const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
          const resolvedOptions = __spreadProps(__spreadValues({}, fetchOptions), {
            signal: composedSignal,
            method: method.toUpperCase(),
            headers: headers.normalize().toJSON(),
            body: data,
            duplex: "half",
            credentials: isCredentialsSupported ? withCredentials : void 0
          });
          request = isRequestSupported && new Request(url, resolvedOptions);
          let response = yield isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions);
          const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
          if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
            const options = {};
            ["status", "statusText", "headers"].forEach((prop) => {
              options[prop] = response[prop];
            });
            const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
            const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
              responseContentLength,
              progressEventReducer(asyncDecorator(onDownloadProgress), true)
            ) || [];
            response = new Response(
              trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
                flush && flush();
                unsubscribe && unsubscribe();
              }),
              options
            );
          }
          responseType = responseType || "text";
          let responseData = yield resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config2);
          !isStreamResponse && unsubscribe && unsubscribe();
          return yield new Promise((resolve2, reject) => {
            settle(resolve2, reject, {
              data: responseData,
              headers: AxiosHeaders$1.from(response.headers),
              status: response.status,
              statusText: response.statusText,
              config: config2,
              request
            });
          });
        } catch (err) {
          unsubscribe && unsubscribe();
          if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
            throw Object.assign(
              new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config2, request),
              {
                cause: err.cause || err
              }
            );
          }
          throw AxiosError$1.from(err, err && err.code, config2, request);
        }
      });
    };
    const seedCache = /* @__PURE__ */ new Map();
    const getFetch = (config2) => {
      let env = config2 && config2.env || {};
      const { fetch: fetch2, Request, Response } = env;
      const seeds = [
        Request,
        Response,
        fetch2
      ];
      let len = seeds.length, i2 = len, seed, target, map2 = seedCache;
      while (i2--) {
        seed = seeds[i2];
        target = map2.get(seed);
        target === void 0 && map2.set(seed, target = i2 ? /* @__PURE__ */ new Map() : factory(env));
        map2 = target;
      }
      return target;
    };
    getFetch();
    const knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter,
      fetch: {
        get: getFetch
      }
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    const renderReason = (reason) => `- ${reason}`;
    const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    function getAdapter$1(adapters2, config2) {
      adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
      const { length } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i2 = 0; i2 < length; i2++) {
        nameOrAdapter = adapters2[i2];
        let id2;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError$1(`Unknown adapter '${id2}'`);
          }
        }
        if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config2)))) {
          break;
        }
        rejectedReasons[id2 || "#" + i2] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError$1(
          `There is no suitable adapter to dispatch the request ` + s,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    }
    const adapters$1 = {
      /**
       * Resolve an adapter from a list of adapter names or functions.
       * @type {Function}
       */
      getAdapter: getAdapter$1,
      /**
       * Exposes all known adapters
       * @type {Object<string, Function|Object>}
       */
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config2) {
      if (config2.cancelToken) {
        config2.cancelToken.throwIfRequested();
      }
      if (config2.signal && config2.signal.aborted) {
        throw new CanceledError$1(null, config2);
      }
    }
    function dispatchRequest(config2) {
      throwIfCancellationRequested(config2);
      config2.headers = AxiosHeaders$1.from(config2.headers);
      config2.data = transformData.call(
        config2,
        config2.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
        config2.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters$1.getAdapter(config2.adapter || defaults$3.adapter, config2);
      return adapter(config2).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config2);
        response.data = transformData.call(
          config2,
          config2.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel$1(reason)) {
          throwIfCancellationRequested(config2);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config2,
              config2.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    const VERSION$1 = "1.13.2";
    const validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
      };
    });
    const deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version2, message2) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError$1(
            formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
            AxiosError$1.ERR_DEPRECATED
          );
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    validators$1.spelling = function spelling(correctSpelling) {
      return (value, opt) => {
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      const keys2 = Object.keys(options);
      let i2 = keys2.length;
      while (i2-- > 0) {
        const opt = keys2[i2];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
        }
      }
    }
    const validator = {
      assertOptions,
      validators: validators$1
    };
    const validators = validator.validators;
    let Axios$1 = class Axios {
      constructor(instanceConfig) {
        this.defaults = instanceConfig || {};
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      request(configOrUrl, config2) {
        return __async(this, null, function* () {
          try {
            return yield this._request(configOrUrl, config2);
          } catch (err) {
            if (err instanceof Error) {
              let dummy = {};
              Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
              const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
              try {
                if (!err.stack) {
                  err.stack = stack;
                } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                  err.stack += "\n" + stack;
                }
              } catch (e) {
              }
            }
            throw err;
          }
        });
      }
      _request(configOrUrl, config2) {
        if (typeof configOrUrl === "string") {
          config2 = config2 || {};
          config2.url = configOrUrl;
        } else {
          config2 = configOrUrl || {};
        }
        config2 = mergeConfig$1(this.defaults, config2);
        const { transitional, paramsSerializer, headers } = config2;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config2.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        if (config2.allowAbsoluteUrls !== void 0) ;
        else if (this.defaults.allowAbsoluteUrls !== void 0) {
          config2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
        } else {
          config2.allowAbsoluteUrls = true;
        }
        validator.assertOptions(config2, {
          baseUrl: validators.spelling("baseURL"),
          withXsrfToken: validators.spelling("withXSRFToken")
        }, true);
        config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config2.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i2 = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift(...requestInterceptorChain);
          chain.push(...responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config2);
          while (i2 < len) {
            promise = promise.then(chain[i2++], chain[i2++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config2;
        while (i2 < len) {
          const onFulfilled = requestInterceptorChain[i2++];
          const onRejected = requestInterceptorChain[i2++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error2) {
            onRejected.call(this, error2);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error2) {
          return Promise.reject(error2);
        }
        i2 = 0;
        len = responseInterceptorChain.length;
        while (i2 < len) {
          promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
        }
        return promise;
      }
      getUri(config2) {
        config2 = mergeConfig$1(this.defaults, config2);
        const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
        return buildURL(fullPath, config2.params, config2.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios$1.prototype[method] = function(url, config2) {
        return this.request(mergeConfig$1(config2 || {}, {
          method,
          url,
          data: (config2 || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config2) {
          return this.request(mergeConfig$1(config2 || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios$1.prototype[method] = generateHTTPMethod();
      Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    let CancelToken$1 = class CancelToken2 {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve2) {
          resolvePromise = resolve2;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners) return;
          let i2 = token._listeners.length;
          while (i2-- > 0) {
            token._listeners[i2](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve2;
          const promise = new Promise((resolve2) => {
            token.subscribe(resolve2);
            _resolve2 = resolve2;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve2);
          };
          return promise;
        };
        executor(function cancel(message2, config2, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError$1(message2, config2, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index2 = this._listeners.indexOf(listener);
        if (index2 !== -1) {
          this._listeners.splice(index2, 1);
        }
      }
      toAbortSignal() {
        const controller = new AbortController();
        const abort = (err) => {
          controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = () => this.unsubscribe(abort);
        return controller.signal;
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new CancelToken2(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    function spread$1(callback2) {
      return function wrap(arr) {
        return callback2.apply(null, arr);
      };
    }
    function isAxiosError$1(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    const HttpStatusCode$1 = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511,
      WebServerIsDown: 521,
      ConnectionTimedOut: 522,
      OriginIsUnreachable: 523,
      TimeoutOccurred: 524,
      SslHandshakeFailed: 525,
      InvalidSslCertificate: 526
    };
    Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
      HttpStatusCode$1[value] = key;
    });
    function createInstance(defaultConfig2) {
      const context = new Axios$1(defaultConfig2);
      const instance2 = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance2, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance2, context, null, { allOwnKeys: true });
      instance2.create = function create2(instanceConfig) {
        return createInstance(mergeConfig$1(defaultConfig2, instanceConfig));
      };
      return instance2;
    }
    const axios = createInstance(defaults$3);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError$1;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel$1;
    axios.VERSION = VERSION$1;
    axios.toFormData = toFormData$1;
    axios.AxiosError = AxiosError$1;
    axios.Cancel = axios.CanceledError;
    axios.all = function all2(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread$1;
    axios.isAxiosError = isAxiosError$1;
    axios.mergeConfig = mergeConfig$1;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters$1.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    const {
      Axios,
      AxiosError,
      CanceledError,
      isCancel,
      CancelToken,
      VERSION,
      all,
      Cancel,
      isAxiosError,
      spread,
      toFormData,
      AxiosHeaders,
      HttpStatusCode,
      formToJSON,
      getAdapter,
      mergeConfig
    } = axios;
    class ApiClient {
      constructor() {
        __publicField(this, "instance");
        __publicField(this, "apiBase", "");
        __publicField(this, "managementKey", "");
        this.instance = axios.create({
          timeout: REQUEST_TIMEOUT_MS,
          headers: {
            "Content-Type": "application/json"
          }
        });
        this.setupInterceptors();
      }
      /**
       *  API 
       */
      setConfig(config2) {
        this.apiBase = this.normalizeApiBase(config2.apiBase);
        this.managementKey = config2.managementKey;
        if (config2.timeout) {
          this.instance.defaults.timeout = config2.timeout;
        } else {
          this.instance.defaults.timeout = REQUEST_TIMEOUT_MS;
        }
      }
      /**
       *  API Base URL
       */
      normalizeApiBase(base2) {
        let normalized = base2.trim();
        normalized = normalized.replace(/\/?v0\/management\/?$/i, "");
        normalized = normalized.replace(/\/+$/, "");
        if (!/^https?:\/\//i.test(normalized)) {
          normalized = `http://${normalized}`;
        }
        return `${normalized}${MANAGEMENT_API_PREFIX}`;
      }
      readHeader(headers, keys2) {
        const normalized = Object.fromEntries(
          Object.entries(headers || {}).map(([key, value]) => [key.toLowerCase(), value])
        );
        for (const key of keys2) {
          const match = normalized[key.toLowerCase()];
          if (match) return match;
        }
        return null;
      }
      /**
       * /
       */
      setupInterceptors() {
        this.instance.interceptors.request.use(
          (config2) => {
            config2.baseURL = this.apiBase;
            if (this.managementKey) {
              config2.headers.Authorization = `Bearer ${this.managementKey}`;
            }
            return config2;
          },
          (error2) => Promise.reject(this.handleError(error2))
        );
        this.instance.interceptors.response.use(
          (response) => {
            const headers = response.headers;
            const version2 = this.readHeader(headers, VERSION_HEADER_KEYS);
            const buildDate = this.readHeader(headers, BUILD_DATE_HEADER_KEYS);
            if (version2 || buildDate) {
              window.dispatchEvent(
                new CustomEvent("server-version-update", {
                  detail: { version: version2 || null, buildDate: buildDate || null }
                })
              );
            }
            return response;
          },
          (error2) => Promise.reject(this.handleError(error2))
        );
      }
      /**
       * 
       */
      handleError(error2) {
        var _a2, _b, _c;
        if (axios.isAxiosError(error2)) {
          const responseData = (_a2 = error2.response) == null ? void 0 : _a2.data;
          const message2 = (responseData == null ? void 0 : responseData.error) || (responseData == null ? void 0 : responseData.message) || error2.message || "Request failed";
          const apiError = new Error(message2);
          apiError.name = "ApiError";
          apiError.status = (_b = error2.response) == null ? void 0 : _b.status;
          apiError.code = error2.code;
          apiError.details = responseData;
          apiError.data = responseData;
          if (((_c = error2.response) == null ? void 0 : _c.status) === 401) {
            window.dispatchEvent(new Event("unauthorized"));
          }
          return apiError;
        }
        const fallback = new Error((error2 == null ? void 0 : error2.message) || "Unknown error occurred");
        fallback.name = "ApiError";
        return fallback;
      }
      /**
       * GET 
       */
      get(url, config2) {
        return __async(this, null, function* () {
          const response = yield this.instance.get(url, config2);
          return response.data;
        });
      }
      /**
       * POST 
       */
      post(url, data, config2) {
        return __async(this, null, function* () {
          const response = yield this.instance.post(url, data, config2);
          return response.data;
        });
      }
      /**
       * PUT 
       */
      put(url, data, config2) {
        return __async(this, null, function* () {
          const response = yield this.instance.put(url, data, config2);
          return response.data;
        });
      }
      /**
       * PATCH 
       */
      patch(url, data, config2) {
        return __async(this, null, function* () {
          const response = yield this.instance.patch(url, data, config2);
          return response.data;
        });
      }
      /**
       * DELETE 
       */
      delete(url, config2) {
        return __async(this, null, function* () {
          const response = yield this.instance.delete(url, config2);
          return response.data;
        });
      }
      /**
       * 
       */
      getRaw(url, config2) {
        return __async(this, null, function* () {
          return this.instance.get(url, config2);
        });
      }
      /**
       *  FormData
       */
      postForm(url, formData, config2) {
        return __async(this, null, function* () {
          const response = yield this.instance.post(url, formData, __spreadProps(__spreadValues({}, config2), {
            headers: __spreadProps(__spreadValues({}, (config2 == null ? void 0 : config2.headers) || {}), {
              "Content-Type": "multipart/form-data"
            })
          }));
          return response.data;
        });
      }
      /**
       *  axios.request 
       */
      requestRaw(config2) {
        return __async(this, null, function* () {
          return this.instance.request(config2);
        });
      }
    }
    const apiClient = new ApiClient();
    function buildHeaderObject(input) {
      if (!input) return {};
      if (Array.isArray(input)) {
        return input.reduce((acc, item) => {
          var _a2, _b;
          const key = (_a2 = item == null ? void 0 : item.key) == null ? void 0 : _a2.trim();
          const value = (_b = item == null ? void 0 : item.value) == null ? void 0 : _b.trim();
          if (key && value !== void 0 && value !== null && value !== "") {
            acc[key] = value;
          }
          return acc;
        }, {});
      }
      return Object.entries(input).reduce((acc, [rawKey, rawValue]) => {
        const key = rawKey == null ? void 0 : rawKey.trim();
        const value = typeof rawValue === "string" ? rawValue.trim() : rawValue;
        if (key && value !== void 0 && value !== null && value !== "") {
          acc[key] = String(value);
        }
        return acc;
      }, {});
    }
    function headersToEntries(headers) {
      if (!headers || typeof headers !== "object") return [];
      return Object.entries(headers).filter(([, value]) => value !== void 0 && value !== null && value !== "").map(([key, value]) => ({ key, value: String(value) }));
    }
    const normalizeBoolean = (value) => {
      if (value === void 0 || value === null) return void 0;
      if (typeof value === "boolean") return value;
      if (typeof value === "number") return value !== 0;
      if (typeof value === "string") {
        const trimmed = value.trim().toLowerCase();
        if (["true", "1", "yes", "y", "on"].includes(trimmed)) return true;
        if (["false", "0", "no", "n", "off"].includes(trimmed)) return false;
      }
      return Boolean(value);
    };
    const normalizeModelAliases = (models) => {
      if (!Array.isArray(models)) return [];
      return models.map((item) => {
        var _a2, _b;
        if (!item) return null;
        const name2 = item.name || item.id || item.model;
        if (!name2) return null;
        const alias = item.alias || item.display_name || item.displayName;
        const priority = (_a2 = item.priority) != null ? _a2 : item["priority"];
        const testModel = (_b = item["test-model"]) != null ? _b : item.testModel;
        const entry = { name: String(name2) };
        if (alias && alias !== name2) {
          entry.alias = String(alias);
        }
        if (priority !== void 0) {
          entry.priority = Number(priority);
        }
        if (testModel) {
          entry.testModel = String(testModel);
        }
        return entry;
      }).filter(Boolean);
    };
    const normalizeHeaders = (headers) => {
      if (!headers || typeof headers !== "object") return void 0;
      const normalized = buildHeaderObject(headers);
      return Object.keys(normalized).length ? normalized : void 0;
    };
    const normalizeExcludedModels = (input) => {
      const rawList = Array.isArray(input) ? input : typeof input === "string" ? input.split(/[\n,]/) : [];
      const seen = /* @__PURE__ */ new Set();
      const normalized = [];
      rawList.forEach((item) => {
        const trimmed = String(item != null ? item : "").trim();
        if (!trimmed) return;
        const key = trimmed.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);
        normalized.push(trimmed);
      });
      return normalized;
    };
    const normalizeApiKeyEntry = (entry) => {
      var _a2, _b, _c, _d;
      if (!entry) return null;
      const apiKey = (_c = (_b = (_a2 = entry["api-key"]) != null ? _a2 : entry.apiKey) != null ? _b : entry.key) != null ? _c : typeof entry === "string" ? entry : "";
      const trimmed = String(apiKey || "").trim();
      if (!trimmed) return null;
      const proxyUrl = (_d = entry["proxy-url"]) != null ? _d : entry.proxyUrl;
      const headers = normalizeHeaders(entry.headers);
      return {
        apiKey: trimmed,
        proxyUrl: proxyUrl ? String(proxyUrl) : void 0,
        headers
      };
    };
    const normalizeProviderKeyConfig = (item) => {
      var _a2, _b, _c, _d, _e, _f, _g;
      if (!item) return null;
      const apiKey = (_b = (_a2 = item["api-key"]) != null ? _a2 : item.apiKey) != null ? _b : typeof item === "string" ? item : "";
      const trimmed = String(apiKey || "").trim();
      if (!trimmed) return null;
      const config2 = { apiKey: trimmed };
      const baseUrl = (_c = item["base-url"]) != null ? _c : item.baseUrl;
      const proxyUrl = (_d = item["proxy-url"]) != null ? _d : item.proxyUrl;
      if (baseUrl) config2.baseUrl = String(baseUrl);
      if (proxyUrl) config2.proxyUrl = String(proxyUrl);
      const headers = normalizeHeaders(item.headers);
      if (headers) config2.headers = headers;
      const models = normalizeModelAliases(item.models);
      if (models.length) config2.models = models;
      const excludedModels2 = normalizeExcludedModels(
        (_g = (_f = (_e = item["excluded-models"]) != null ? _e : item.excludedModels) != null ? _f : item["excluded_models"]) != null ? _g : item.excluded_models
      );
      if (excludedModels2.length) config2.excludedModels = excludedModels2;
      return config2;
    };
    const normalizeGeminiKeyConfig = (item) => {
      var _a2, _b, _c, _d;
      if (!item) return null;
      let apiKey = (_a2 = item["api-key"]) != null ? _a2 : item.apiKey;
      if (!apiKey && typeof item === "string") {
        apiKey = item;
      }
      const trimmed = String(apiKey || "").trim();
      if (!trimmed) return null;
      const config2 = { apiKey: trimmed };
      const baseUrl = (_c = (_b = item["base-url"]) != null ? _b : item.baseUrl) != null ? _c : item["base_url"];
      if (baseUrl) config2.baseUrl = String(baseUrl);
      const headers = normalizeHeaders(item.headers);
      if (headers) config2.headers = headers;
      const excludedModels2 = normalizeExcludedModels((_d = item["excluded-models"]) != null ? _d : item.excludedModels);
      if (excludedModels2.length) config2.excludedModels = excludedModels2;
      return config2;
    };
    const normalizeOpenAIProvider = (provider) => {
      var _a2, _b, _c;
      if (!provider || typeof provider !== "object") return null;
      const name2 = provider.name || provider.id;
      const baseUrl = (_a2 = provider["base-url"]) != null ? _a2 : provider.baseUrl;
      if (!name2 || !baseUrl) return null;
      let apiKeyEntries = [];
      if (Array.isArray(provider["api-key-entries"])) {
        apiKeyEntries = provider["api-key-entries"].map((entry) => normalizeApiKeyEntry(entry)).filter(Boolean);
      } else if (Array.isArray(provider["api-keys"])) {
        apiKeyEntries = provider["api-keys"].map((key) => normalizeApiKeyEntry({ "api-key": key })).filter(Boolean);
      }
      const headers = normalizeHeaders(provider.headers);
      const models = normalizeModelAliases(provider.models);
      const priority = (_b = provider.priority) != null ? _b : provider["priority"];
      const testModel = (_c = provider["test-model"]) != null ? _c : provider.testModel;
      const result = {
        name: String(name2),
        baseUrl: String(baseUrl),
        apiKeyEntries
      };
      if (headers) result.headers = headers;
      if (models.length) result.models = models;
      if (priority !== void 0) result.priority = Number(priority);
      if (testModel) result.testModel = String(testModel);
      return result;
    };
    const normalizeOauthExcluded = (payload) => {
      var _a2, _b;
      if (!payload || typeof payload !== "object") return void 0;
      const source2 = (_b = (_a2 = payload["oauth-excluded-models"]) != null ? _a2 : payload.items) != null ? _b : payload;
      if (!source2 || typeof source2 !== "object") return void 0;
      const map2 = {};
      Object.entries(source2).forEach(([provider, models]) => {
        const key = String(provider || "").trim();
        if (!key) return;
        const normalized = normalizeExcludedModels(models);
        map2[key.toLowerCase()] = normalized;
      });
      return map2;
    };
    const normalizeAmpcodeModelMappings = (input) => {
      if (!Array.isArray(input)) return [];
      const seen = /* @__PURE__ */ new Set();
      const mappings = [];
      input.forEach((entry) => {
        var _a2, _b, _c, _d;
        if (!entry || typeof entry !== "object") return;
        const from2 = String((_b = (_a2 = entry.from) != null ? _a2 : entry["from"]) != null ? _b : "").trim();
        const to2 = String((_d = (_c = entry.to) != null ? _c : entry["to"]) != null ? _d : "").trim();
        if (!from2 || !to2) return;
        const key = from2.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);
        mappings.push({ from: from2, to: to2 });
      });
      return mappings;
    };
    const normalizeAmpcodeConfig = (payload) => {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      const source2 = (_a2 = payload == null ? void 0 : payload.ampcode) != null ? _a2 : payload;
      if (!source2 || typeof source2 !== "object") return void 0;
      const config2 = {};
      const upstreamUrl = (_c = (_b = source2["upstream-url"]) != null ? _b : source2.upstreamUrl) != null ? _c : source2["upstream_url"];
      if (upstreamUrl) config2.upstreamUrl = String(upstreamUrl);
      const upstreamApiKey = (_e = (_d = source2["upstream-api-key"]) != null ? _d : source2.upstreamApiKey) != null ? _e : source2["upstream_api_key"];
      if (upstreamApiKey) config2.upstreamApiKey = String(upstreamApiKey);
      const restrictManagementToLocalhost = normalizeBoolean(
        (_g = (_f = source2["restrict-management-to-localhost"]) != null ? _f : source2.restrictManagementToLocalhost) != null ? _g : source2["restrict_management_to_localhost"]
      );
      if (restrictManagementToLocalhost !== void 0) {
        config2.restrictManagementToLocalhost = restrictManagementToLocalhost;
      }
      const forceModelMappings = normalizeBoolean(
        (_i = (_h = source2["force-model-mappings"]) != null ? _h : source2.forceModelMappings) != null ? _i : source2["force_model_mappings"]
      );
      if (forceModelMappings !== void 0) {
        config2.forceModelMappings = forceModelMappings;
      }
      const modelMappings = normalizeAmpcodeModelMappings(
        (_k = (_j = source2["model-mappings"]) != null ? _j : source2.modelMappings) != null ? _k : source2["model_mappings"]
      );
      if (modelMappings.length) {
        config2.modelMappings = modelMappings;
      }
      return config2;
    };
    const normalizeConfigResponse = (raw) => {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
      const config2 = { raw: raw || {} };
      if (!raw || typeof raw !== "object") {
        return config2;
      }
      config2.debug = raw.debug;
      config2.proxyUrl = (_a2 = raw["proxy-url"]) != null ? _a2 : raw.proxyUrl;
      config2.requestRetry = (_b = raw["request-retry"]) != null ? _b : raw.requestRetry;
      const quota = (_c = raw["quota-exceeded"]) != null ? _c : raw.quotaExceeded;
      if (quota && typeof quota === "object") {
        config2.quotaExceeded = {
          switchProject: (_d = quota["switch-project"]) != null ? _d : quota.switchProject,
          switchPreviewModel: (_e = quota["switch-preview-model"]) != null ? _e : quota.switchPreviewModel
        };
      }
      config2.usageStatisticsEnabled = (_f = raw["usage-statistics-enabled"]) != null ? _f : raw.usageStatisticsEnabled;
      config2.requestLog = (_g = raw["request-log"]) != null ? _g : raw.requestLog;
      config2.loggingToFile = (_h = raw["logging-to-file"]) != null ? _h : raw.loggingToFile;
      config2.wsAuth = (_i = raw["ws-auth"]) != null ? _i : raw.wsAuth;
      config2.apiKeys = Array.isArray(raw["api-keys"]) ? raw["api-keys"].slice() : raw.apiKeys;
      const geminiList = (_k = (_j = raw["gemini-api-key"]) != null ? _j : raw.geminiApiKey) != null ? _k : raw.geminiApiKeys;
      if (Array.isArray(geminiList)) {
        config2.geminiApiKeys = geminiList.map((item) => normalizeGeminiKeyConfig(item)).filter(Boolean);
      }
      const codexList = (_m = (_l = raw["codex-api-key"]) != null ? _l : raw.codexApiKey) != null ? _m : raw.codexApiKeys;
      if (Array.isArray(codexList)) {
        config2.codexApiKeys = codexList.map((item) => normalizeProviderKeyConfig(item)).filter(Boolean);
      }
      const claudeList = (_o = (_n = raw["claude-api-key"]) != null ? _n : raw.claudeApiKey) != null ? _o : raw.claudeApiKeys;
      if (Array.isArray(claudeList)) {
        config2.claudeApiKeys = claudeList.map((item) => normalizeProviderKeyConfig(item)).filter(Boolean);
      }
      const openaiList = (_q = (_p = raw["openai-compatibility"]) != null ? _p : raw.openaiCompatibility) != null ? _q : raw.openAICompatibility;
      if (Array.isArray(openaiList)) {
        config2.openaiCompatibility = openaiList.map((item) => normalizeOpenAIProvider(item)).filter(Boolean);
      }
      const ampcode = normalizeAmpcodeConfig(raw.ampcode);
      if (ampcode) {
        config2.ampcode = ampcode;
      }
      const oauthExcluded = normalizeOauthExcluded((_r = raw["oauth-excluded-models"]) != null ? _r : raw.oauthExcludedModels);
      if (oauthExcluded) {
        config2.oauthExcludedModels = oauthExcluded;
      }
      return config2;
    };
    const configApi = {
      /**
       * 
       */
      getConfig() {
        return __async(this, null, function* () {
          const raw = yield apiClient.get("/config");
          return normalizeConfigResponse(raw);
        });
      },
      /**
       * 
       */
      getRawConfig: () => apiClient.get("/config"),
      /**
       *  Debug 
       */
      updateDebug: (enabled) => apiClient.put("/debug", { value: enabled }),
      /**
       *  URL
       */
      updateProxyUrl: (proxyUrl) => apiClient.put("/proxy-url", { value: proxyUrl }),
      /**
       *  URL
       */
      clearProxyUrl: () => apiClient.delete("/proxy-url"),
      /**
       * 
       */
      updateRequestRetry: (retryCount) => apiClient.put("/request-retry", { value: retryCount }),
      /**
       * 
       */
      updateSwitchProject: (enabled) => apiClient.put("/quota-exceeded/switch-project", { value: enabled }),
      /**
       * 
       */
      updateSwitchPreviewModel: (enabled) => apiClient.put("/quota-exceeded/switch-preview-model", { value: enabled }),
      /**
       * 
       */
      updateUsageStatistics: (enabled) => apiClient.put("/usage-statistics-enabled", { value: enabled }),
      /**
       * 
       */
      updateRequestLog: (enabled) => apiClient.put("/request-log", { value: enabled }),
      /**
       * 
       */
      updateLoggingToFile: (enabled) => apiClient.put("/logging-to-file", { value: enabled }),
      /**
       * WebSocket 
       */
      updateWsAuth: (enabled) => apiClient.put("/ws-auth", { value: enabled })
    };
    let configRequestToken = 0;
    let inFlightConfigRequest = null;
    const SECTION_KEYS = [
      "debug",
      "proxy-url",
      "request-retry",
      "quota-exceeded",
      "usage-statistics-enabled",
      "request-log",
      "logging-to-file",
      "ws-auth",
      "api-keys",
      "ampcode",
      "gemini-api-key",
      "codex-api-key",
      "claude-api-key",
      "openai-compatibility",
      "oauth-excluded-models"
    ];
    const extractSectionValue = (config2, section) => {
      var _a2;
      if (!config2) return void 0;
      switch (section) {
        case "debug":
          return config2.debug;
        case "proxy-url":
          return config2.proxyUrl;
        case "request-retry":
          return config2.requestRetry;
        case "quota-exceeded":
          return config2.quotaExceeded;
        case "usage-statistics-enabled":
          return config2.usageStatisticsEnabled;
        case "request-log":
          return config2.requestLog;
        case "logging-to-file":
          return config2.loggingToFile;
        case "ws-auth":
          return config2.wsAuth;
        case "api-keys":
          return config2.apiKeys;
        case "ampcode":
          return config2.ampcode;
        case "gemini-api-key":
          return config2.geminiApiKeys;
        case "codex-api-key":
          return config2.codexApiKeys;
        case "claude-api-key":
          return config2.claudeApiKeys;
        case "openai-compatibility":
          return config2.openaiCompatibility;
        case "oauth-excluded-models":
          return config2.oauthExcludedModels;
        default:
          if (!section) return void 0;
          return (_a2 = config2.raw) == null ? void 0 : _a2[section];
      }
    };
    const useConfigStore = create((set2, get2) => ({
      config: null,
      cache: /* @__PURE__ */ new Map(),
      loading: false,
      error: null,
      fetchConfig: (section, forceRefresh = false) => __async(null, null, function* () {
        const { cache, isCacheValid } = get2();
        const cacheKey = section || "__full__";
        if (!forceRefresh && isCacheValid(section)) {
          const cached = cache.get(cacheKey);
          if (cached) {
            return cached.data;
          }
        }
        if (!forceRefresh && section && isCacheValid()) {
          const fullCached = cache.get("__full__");
          if (fullCached == null ? void 0 : fullCached.data) {
            return extractSectionValue(fullCached.data, section);
          }
        }
        if (inFlightConfigRequest) {
          const data = yield inFlightConfigRequest.promise;
          return section ? extractSectionValue(data, section) : data;
        }
        set2({ loading: true, error: null });
        const requestId = configRequestToken += 1;
        try {
          const requestPromise = configApi.getConfig();
          inFlightConfigRequest = { id: requestId, promise: requestPromise };
          const data = yield requestPromise;
          const now = Date.now();
          if (requestId !== configRequestToken) {
            return section ? extractSectionValue(data, section) : data;
          }
          const newCache = new Map(cache);
          newCache.set("__full__", { data, timestamp: now });
          SECTION_KEYS.forEach((key) => {
            const value = extractSectionValue(data, key);
            if (value !== void 0) {
              newCache.set(key, { data: value, timestamp: now });
            }
          });
          set2({
            config: data,
            cache: newCache,
            loading: false
          });
          return section ? extractSectionValue(data, section) : data;
        } catch (error2) {
          if (requestId === configRequestToken) {
            set2({
              error: error2.message || "Failed to fetch config",
              loading: false
            });
          }
          throw error2;
        } finally {
          if ((inFlightConfigRequest == null ? void 0 : inFlightConfigRequest.id) === requestId) {
            inFlightConfigRequest = null;
          }
        }
      }),
      updateConfigValue: (section, value) => {
        set2((state) => {
          var _a2;
          const raw = __spreadValues({}, ((_a2 = state.config) == null ? void 0 : _a2.raw) || {});
          raw[section] = value;
          const nextConfig = __spreadProps(__spreadValues({}, state.config || {}), { raw });
          switch (section) {
            case "debug":
              nextConfig.debug = value;
              break;
            case "proxy-url":
              nextConfig.proxyUrl = value;
              break;
            case "request-retry":
              nextConfig.requestRetry = value;
              break;
            case "quota-exceeded":
              nextConfig.quotaExceeded = value;
              break;
            case "usage-statistics-enabled":
              nextConfig.usageStatisticsEnabled = value;
              break;
            case "request-log":
              nextConfig.requestLog = value;
              break;
            case "logging-to-file":
              nextConfig.loggingToFile = value;
              break;
            case "ws-auth":
              nextConfig.wsAuth = value;
              break;
            case "api-keys":
              nextConfig.apiKeys = value;
              break;
            case "ampcode":
              nextConfig.ampcode = value;
              break;
            case "gemini-api-key":
              nextConfig.geminiApiKeys = value;
              break;
            case "codex-api-key":
              nextConfig.codexApiKeys = value;
              break;
            case "claude-api-key":
              nextConfig.claudeApiKeys = value;
              break;
            case "openai-compatibility":
              nextConfig.openaiCompatibility = value;
              break;
            case "oauth-excluded-models":
              nextConfig.oauthExcludedModels = value;
              break;
          }
          return { config: nextConfig };
        });
        get2().clearCache(section);
      },
      clearCache: (section) => {
        const { cache } = get2();
        const newCache = new Map(cache);
        if (section) {
          newCache.delete(section);
          newCache.delete("__full__");
          set2({ cache: newCache });
          return;
        } else {
          newCache.clear();
        }
        configRequestToken += 1;
        inFlightConfigRequest = null;
        set2({ config: null, cache: newCache, loading: false, error: null });
      },
      isCacheValid: (section) => {
        const { cache } = get2();
        const cacheKey = section || "__full__";
        const cached = cache.get(cacheKey);
        if (!cached) return false;
        return Date.now() - cached.timestamp < CACHE_EXPIRY_MS;
      }
    }));
    const normalizeApiBase = (input) => {
      let base2 = (input || "").trim();
      if (!base2) return "";
      base2 = base2.replace(/\/?v0\/management\/?$/i, "");
      base2 = base2.replace(/\/+$/i, "");
      if (!/^https?:\/\//i.test(base2)) {
        base2 = `http://${base2}`;
      }
      return base2;
    };
    const detectApiBaseFromLocation = () => {
      try {
        const { protocol, hostname, port } = window.location;
        const normalizedPort = port ? `:${port}` : "";
        return normalizeApiBase(`${protocol}//${hostname}${normalizedPort}`);
      } catch (error2) {
        console.warn("Failed to detect api base from location, fallback to default", error2);
        return normalizeApiBase(`http://localhost:${DEFAULT_API_PORT}`);
      }
    };
    let restoreSessionPromise = null;
    const useAuthStore = create()(
      persist(
        (set2, get2) => ({
          // 
          isAuthenticated: false,
          apiBase: "",
          managementKey: "",
          serverVersion: null,
          serverBuildDate: null,
          connectionStatus: "disconnected",
          connectionError: null,
          // 
          restoreSession: () => {
            if (restoreSessionPromise) return restoreSessionPromise;
            restoreSessionPromise = (() => __async(null, null, function* () {
              secureStorage.migratePlaintextKeys(["apiBase", "apiUrl", "managementKey"]);
              const wasLoggedIn = localStorage.getItem("isLoggedIn") === "true";
              const legacyBase = secureStorage.getItem("apiBase") || secureStorage.getItem("apiUrl", { encrypt: true });
              const legacyKey = secureStorage.getItem("managementKey");
              const { apiBase, managementKey } = get2();
              const resolvedBase = normalizeApiBase(apiBase || legacyBase || detectApiBaseFromLocation());
              const resolvedKey = managementKey || legacyKey || "";
              set2({ apiBase: resolvedBase, managementKey: resolvedKey });
              apiClient.setConfig({ apiBase: resolvedBase, managementKey: resolvedKey });
              if (wasLoggedIn && resolvedBase && resolvedKey) {
                try {
                  yield get2().login({ apiBase: resolvedBase, managementKey: resolvedKey });
                  return true;
                } catch (error2) {
                  console.warn("Auto login failed:", error2);
                  return false;
                }
              }
              return false;
            }))();
            return restoreSessionPromise;
          },
          // 
          login: (credentials) => __async(null, null, function* () {
            const apiBase = normalizeApiBase(credentials.apiBase);
            const managementKey = credentials.managementKey.trim();
            try {
              set2({ connectionStatus: "connecting" });
              apiClient.setConfig({
                apiBase,
                managementKey
              });
              yield useConfigStore.getState().fetchConfig(void 0, true);
              set2({
                isAuthenticated: true,
                apiBase,
                managementKey,
                connectionStatus: "connected",
                connectionError: null
              });
              localStorage.setItem("isLoggedIn", "true");
            } catch (error2) {
              set2({
                connectionStatus: "error",
                connectionError: error2.message || "Connection failed"
              });
              throw error2;
            }
          }),
          // 
          logout: () => {
            restoreSessionPromise = null;
            useConfigStore.getState().clearCache();
            set2({
              isAuthenticated: false,
              apiBase: "",
              managementKey: "",
              serverVersion: null,
              serverBuildDate: null,
              connectionStatus: "disconnected",
              connectionError: null
            });
            localStorage.removeItem("isLoggedIn");
          },
          // 
          checkAuth: () => __async(null, null, function* () {
            const { managementKey, apiBase } = get2();
            if (!managementKey || !apiBase) {
              return false;
            }
            try {
              apiClient.setConfig({ apiBase, managementKey });
              yield useConfigStore.getState().fetchConfig();
              set2({
                isAuthenticated: true,
                connectionStatus: "connected"
              });
              return true;
            } catch (error2) {
              set2({
                isAuthenticated: false,
                connectionStatus: "error"
              });
              return false;
            }
          }),
          // 
          updateServerVersion: (version2, buildDate) => {
            set2({ serverVersion: version2 || null, serverBuildDate: buildDate || null });
          },
          // 
          updateConnectionStatus: (status2, error2 = null) => {
            set2({
              connectionStatus: status2,
              connectionError: error2
            });
          }
        }),
        {
          name: STORAGE_KEY_AUTH,
          storage: createJSONStorage(() => ({
            getItem: (name2) => {
              const data = secureStorage.getItem(name2);
              return data ? JSON.stringify(data) : null;
            },
            setItem: (name2, value) => {
              secureStorage.setItem(name2, JSON.parse(value));
            },
            removeItem: (name2) => {
              secureStorage.removeItem(name2);
            }
          })),
          partialize: (state) => ({
            apiBase: state.apiBase,
            managementKey: state.managementKey,
            serverVersion: state.serverVersion,
            serverBuildDate: state.serverBuildDate
          })
        }
      )
    );
    if (typeof window !== "undefined") {
      window.addEventListener("unauthorized", () => {
        useAuthStore.getState().logout();
      });
      window.addEventListener(
        "server-version-update",
        ((e) => {
          const detail = e.detail || {};
          useAuthStore.getState().updateServerVersion(detail.version || null, detail.buildDate || null);
        })
      );
    }
    const MODEL_CATEGORIES = [
      { id: "gpt", label: "GPT", patterns: [/gpt/i, /\bo\d\b/i, /\bo\d+\.?/i, /\bchatgpt/i] },
      { id: "claude", label: "Claude", patterns: [/claude/i] },
      { id: "gemini", label: "Gemini", patterns: [/gemini/i, /\bgai\b/i] },
      { id: "kimi", label: "Kimi", patterns: [/kimi/i] },
      { id: "qwen", label: "Qwen", patterns: [/qwen/i] },
      { id: "glm", label: "GLM", patterns: [/glm/i, /chatglm/i] },
      { id: "grok", label: "Grok", patterns: [/grok/i] },
      { id: "deepseek", label: "DeepSeek", patterns: [/deepseek/i] }
    ];
    const matchCategory = (text) => {
      for (const category of MODEL_CATEGORIES) {
        if (category.patterns.some((pattern) => pattern.test(text))) {
          return category.id;
        }
      }
      return null;
    };
    function normalizeModelList(payload, { dedupe = false } = {}) {
      const toModel = (entry) => {
        if (typeof entry === "string") {
          return { name: entry };
        }
        if (!entry || typeof entry !== "object") {
          return null;
        }
        const name2 = entry.id || entry.name || entry.model || entry.value;
        if (!name2) return null;
        const alias = entry.alias || entry.display_name || entry.displayName;
        const description2 = entry.description || entry.note || entry.comment;
        const model = { name: String(name2) };
        if (alias && alias !== name2) {
          model.alias = String(alias);
        }
        if (description2) {
          model.description = String(description2);
        }
        return model;
      };
      let models = [];
      if (Array.isArray(payload)) {
        models = payload.map(toModel);
      } else if (payload && typeof payload === "object") {
        if (Array.isArray(payload.data)) {
          models = payload.data.map(toModel);
        } else if (Array.isArray(payload.models)) {
          models = payload.models.map(toModel);
        }
      }
      const normalized = models.filter(Boolean);
      if (!dedupe) {
        return normalized;
      }
      const seen = /* @__PURE__ */ new Set();
      return normalized.filter((model) => {
        const key = ((model == null ? void 0 : model.name) || "").toLowerCase();
        if (!key || seen.has(key)) {
          return false;
        }
        seen.add(key);
        return true;
      });
    }
    function classifyModels(models = [], { otherLabel = "Other" } = {}) {
      const groups = MODEL_CATEGORIES.map((category) => ({
        id: category.id,
        label: category.label,
        items: []
      }));
      const otherGroup = { id: "other", label: otherLabel, items: [] };
      models.forEach((model) => {
        const name2 = ((model == null ? void 0 : model.name) || "").toString();
        const alias = ((model == null ? void 0 : model.alias) || "").toString();
        const haystack = `${name2} ${alias}`.toLowerCase();
        const matchedId = matchCategory(haystack);
        const target = matchedId ? groups.find((group) => group.id === matchedId) : null;
        if (target) {
          target.items.push(model);
        } else {
          otherGroup.items.push(model);
        }
      });
      const populatedGroups = groups.filter((group) => group.items.length > 0);
      if (otherGroup.items.length) {
        populatedGroups.push(otherGroup);
      }
      return populatedGroups;
    }
    const normalizeBaseUrl = (baseUrl) => {
      let normalized = String(baseUrl || "").trim();
      if (!normalized) return "";
      normalized = normalized.replace(/\/?v0\/management\/?$/i, "");
      normalized = normalized.replace(/\/+$/g, "");
      if (!/^https?:\/\//i.test(normalized)) {
        normalized = `http://${normalized}`;
      }
      return normalized;
    };
    const buildModelsEndpoint = (baseUrl) => {
      const normalized = normalizeBaseUrl(baseUrl);
      if (!normalized) return "";
      return normalized.endsWith("/v1") ? `${normalized}/models` : `${normalized}/v1/models`;
    };
    const modelsApi = {
      fetchModels(_0, _1) {
        return __async(this, arguments, function* (baseUrl, apiKey, headers = {}) {
          var _a2, _b, _c, _d;
          const endpoint = buildModelsEndpoint(baseUrl);
          if (!endpoint) {
            throw new Error("Invalid base url");
          }
          const resolvedHeaders = __spreadValues({}, headers);
          if (apiKey) {
            resolvedHeaders.Authorization = `Bearer ${apiKey}`;
          }
          const response = yield axios.get(endpoint, {
            headers: Object.keys(resolvedHeaders).length ? resolvedHeaders : void 0
          });
          const payload = (_d = (_c = (_a2 = response.data) == null ? void 0 : _a2.data) != null ? _c : (_b = response.data) == null ? void 0 : _b.models) != null ? _d : response.data;
          return normalizeModelList(payload, { dedupe: true });
        });
      }
    };
    const useModelsStore = create((set2, get2) => ({
      models: [],
      loading: false,
      error: null,
      cache: null,
      fetchModels: (apiBase, apiKey, forceRefresh = false) => __async(null, null, function* () {
        const { cache, isCacheValid } = get2();
        if (!forceRefresh && isCacheValid(apiBase) && cache) {
          set2({ models: cache.data, error: null });
          return cache.data;
        }
        set2({ loading: true, error: null });
        try {
          const list = yield modelsApi.fetchModels(apiBase, apiKey);
          const now = Date.now();
          set2({
            models: list,
            loading: false,
            cache: { data: list, timestamp: now, apiBase }
          });
          return list;
        } catch (error2) {
          const message2 = (error2 == null ? void 0 : error2.message) || "Failed to fetch models";
          set2({
            error: message2,
            loading: false,
            models: []
          });
          throw error2;
        }
      }),
      clearCache: () => {
        set2({ cache: null, models: [] });
      },
      isCacheValid: (apiBase) => {
        const { cache } = get2();
        if (!cache) return false;
        if (cache.apiBase !== apiBase) return false;
        return Date.now() - cache.timestamp < CACHE_EXPIRY_MS;
      }
    }));
    function LoginPage() {
      const { t: t2 } = useTranslation();
      const navigate = useNavigate();
      const location = useLocation();
      const { showNotification } = useNotificationStore();
      const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
      const login2 = useAuthStore((state) => state.login);
      const restoreSession = useAuthStore((state) => state.restoreSession);
      const storedBase = useAuthStore((state) => state.apiBase);
      const storedKey = useAuthStore((state) => state.managementKey);
      const [apiBase, setApiBase] = reactExports.useState("");
      const [managementKey, setManagementKey] = reactExports.useState("");
      const [showCustomBase, setShowCustomBase] = reactExports.useState(false);
      const [showKey, setShowKey] = reactExports.useState(false);
      const [loading, setLoading] = reactExports.useState(false);
      const [autoLoading, setAutoLoading] = reactExports.useState(true);
      const [error2, setError] = reactExports.useState("");
      const detectedBase = reactExports.useMemo(() => detectApiBaseFromLocation(), []);
      reactExports.useEffect(() => {
        const init = () => __async(null, null, function* () {
          try {
            const autoLoggedIn = yield restoreSession();
            if (!autoLoggedIn) {
              setApiBase(storedBase || detectedBase);
              setManagementKey(storedKey || "");
            }
          } finally {
            setAutoLoading(false);
          }
        });
        init();
      }, [detectedBase, restoreSession, storedBase, storedKey]);
      reactExports.useEffect(() => {
        var _a2, _b;
        if (isAuthenticated) {
          const redirect = ((_b = (_a2 = location.state) == null ? void 0 : _a2.from) == null ? void 0 : _b.pathname) || "/";
          navigate(redirect, { replace: true });
        }
      }, [isAuthenticated, navigate, location.state]);
      const handleUseCurrent = () => {
        setApiBase(detectedBase);
      };
      const handleSubmit = () => __async(null, null, function* () {
        if (!managementKey.trim()) {
          setError(t2("login.error_required"));
          return;
        }
        const baseToUse = apiBase ? normalizeApiBase(apiBase) : detectedBase;
        setLoading(true);
        setError("");
        try {
          yield login2({ apiBase: baseToUse, managementKey: managementKey.trim() });
          showNotification(t2("common.connected_status"), "success");
          navigate("/", { replace: true });
        } catch (err) {
          const message2 = (err == null ? void 0 : err.message) || t2("login.error_invalid");
          setError(message2);
          showNotification(`${t2("notification.login_failed")}: ${message2}`, "error");
        } finally {
          setLoading(false);
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "login-page", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "login-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "login-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "title", children: t2("title.login") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "subtitle", children: t2("login.subtitle") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "connection-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "label", children: t2("login.connection_current") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "value", children: apiBase || detectedBase }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("login.connection_auto_hint") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "toggle-advanced", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              id: "custom-connection-toggle",
              type: "checkbox",
              checked: showCustomBase,
              onChange: (e) => setShowCustomBase(e.target.checked)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "custom-connection-toggle", children: t2("login.custom_connection_label") })
        ] }),
        showCustomBase && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            label: t2("login.custom_connection_label"),
            placeholder: t2("login.custom_connection_placeholder"),
            value: apiBase,
            onChange: (e) => setApiBase(e.target.value),
            hint: t2("login.custom_connection_hint")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            label: t2("login.management_key_label"),
            placeholder: t2("login.management_key_placeholder"),
            type: showKey ? "text" : "password",
            value: managementKey,
            onChange: (e) => setManagementKey(e.target.value),
            rightElement: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: "btn btn-ghost btn-sm",
                onClick: () => setShowKey((prev) => !prev),
                "aria-label": showKey ? t2("login.hide_key", { defaultValue: "" }) : t2("login.show_key", { defaultValue: "" }),
                title: showKey ? t2("login.hide_key", { defaultValue: "" }) : t2("login.show_key", { defaultValue: "" }),
                children: showKey ? /* @__PURE__ */ jsxRuntimeExports.jsx(IconEyeOff, { size: 16 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(IconEye, { size: 16 })
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 12, alignItems: "center" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: handleUseCurrent, children: t2("login.use_current_address") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { fullWidth: true, onClick: handleSubmit, loading, children: loading ? t2("login.submitting") : t2("login.submit_button") })
        ] }),
        error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-box", children: error2 }),
        autoLoading && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "connection-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "label", children: t2("auto_login.title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "value", children: t2("auto_login.message") })
        ] })
      ] }) });
    }
    function Card({ title: title2, extra, children }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
        (title2 || extra) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "title", children: title2 }),
          extra
        ] }),
        children
      ] });
    }
    function ToggleSwitch({ checked, onChange, label, disabled = false }) {
      const handleChange = (event) => {
        onChange(event.target.checked);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "switch", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "checkbox", checked, onChange: handleChange, disabled }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "track", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "thumb" }) }),
        label && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: label })
      ] });
    }
    const configFileApi = {
      fetchConfigYaml() {
        return __async(this, null, function* () {
          const response = yield apiClient.getRaw("/config.yaml", {
            responseType: "text",
            headers: { Accept: "application/yaml, text/yaml, text/plain" }
          });
          const data = response.data;
          if (typeof data === "string") return data;
          if (data === void 0 || data === null) return "";
          return String(data);
        });
      },
      saveConfigYaml(content2) {
        return __async(this, null, function* () {
          yield apiClient.put("/config.yaml", content2, {
            headers: {
              "Content-Type": "application/yaml",
              Accept: "application/json, text/plain, */*"
            }
          });
        });
      }
    };
    const apiKeysApi = {
      list() {
        return __async(this, null, function* () {
          var _a2;
          const data = yield apiClient.get("/api-keys");
          const keys2 = data && ((_a2 = data["api-keys"]) != null ? _a2 : data.apiKeys);
          return Array.isArray(keys2) ? keys2 : [];
        });
      },
      replace: (keys2) => apiClient.put("/api-keys", keys2),
      update: (index2, value) => apiClient.patch("/api-keys", { index: index2, value }),
      delete: (index2) => apiClient.delete(`/api-keys?index=${index2}`)
    };
    const ampcodeApi = {
      getAmpcode() {
        return __async(this, null, function* () {
          var _a2;
          const data = yield apiClient.get("/ampcode");
          return (_a2 = normalizeAmpcodeConfig(data)) != null ? _a2 : {};
        });
      },
      updateUpstreamUrl: (url) => apiClient.put("/ampcode/upstream-url", { value: url }),
      clearUpstreamUrl: () => apiClient.delete("/ampcode/upstream-url"),
      updateUpstreamApiKey: (apiKey) => apiClient.put("/ampcode/upstream-api-key", { value: apiKey }),
      clearUpstreamApiKey: () => apiClient.delete("/ampcode/upstream-api-key"),
      updateRestrictManagementToLocalhost: (enabled) => apiClient.put("/ampcode/restrict-management-to-localhost", { value: enabled }),
      getModelMappings() {
        return __async(this, null, function* () {
          var _a2, _b, _c;
          const data = yield apiClient.get("/ampcode/model-mappings");
          const list = (_c = (_b = (_a2 = data == null ? void 0 : data["model-mappings"]) != null ? _a2 : data == null ? void 0 : data.modelMappings) != null ? _b : data == null ? void 0 : data.items) != null ? _c : data;
          return normalizeAmpcodeModelMappings(list);
        });
      },
      saveModelMappings: (mappings) => apiClient.put("/ampcode/model-mappings", { value: mappings }),
      patchModelMappings: (mappings) => apiClient.patch("/ampcode/model-mappings", { value: mappings }),
      clearModelMappings: () => apiClient.delete("/ampcode/model-mappings"),
      deleteModelMappings: (fromList) => apiClient.delete("/ampcode/model-mappings", { data: { value: fromList } }),
      updateForceModelMappings: (enabled) => apiClient.put("/ampcode/force-model-mappings", { value: enabled })
    };
    const serializeHeaders = (headers) => headers && Object.keys(headers).length ? headers : void 0;
    const serializeModelAliases = (models) => Array.isArray(models) ? models.map((model) => {
      if (!(model == null ? void 0 : model.name)) return null;
      const payload = { name: model.name };
      if (model.alias && model.alias !== model.name) {
        payload.alias = model.alias;
      }
      if (model.priority !== void 0) {
        payload.priority = model.priority;
      }
      if (model.testModel) {
        payload["test-model"] = model.testModel;
      }
      return payload;
    }).filter(Boolean) : void 0;
    const serializeApiKeyEntry = (entry) => {
      const payload = { "api-key": entry.apiKey };
      if (entry.proxyUrl) payload["proxy-url"] = entry.proxyUrl;
      const headers = serializeHeaders(entry.headers);
      if (headers) payload.headers = headers;
      return payload;
    };
    const serializeProviderKey = (config2) => {
      const payload = { "api-key": config2.apiKey };
      if (config2.baseUrl) payload["base-url"] = config2.baseUrl;
      if (config2.proxyUrl) payload["proxy-url"] = config2.proxyUrl;
      const headers = serializeHeaders(config2.headers);
      if (headers) payload.headers = headers;
      const models = serializeModelAliases(config2.models);
      if (models && models.length) payload.models = models;
      if (config2.excludedModels && config2.excludedModels.length) {
        payload["excluded-models"] = config2.excludedModels;
      }
      return payload;
    };
    const serializeGeminiKey = (config2) => {
      const payload = { "api-key": config2.apiKey };
      if (config2.baseUrl) payload["base-url"] = config2.baseUrl;
      const headers = serializeHeaders(config2.headers);
      if (headers) payload.headers = headers;
      if (config2.excludedModels && config2.excludedModels.length) {
        payload["excluded-models"] = config2.excludedModels;
      }
      return payload;
    };
    const serializeOpenAIProvider = (provider) => {
      const payload = {
        name: provider.name,
        "base-url": provider.baseUrl,
        "api-key-entries": Array.isArray(provider.apiKeyEntries) ? provider.apiKeyEntries.map((entry) => serializeApiKeyEntry(entry)) : []
      };
      const headers = serializeHeaders(provider.headers);
      if (headers) payload.headers = headers;
      const models = serializeModelAliases(provider.models);
      if (models && models.length) payload.models = models;
      if (provider.priority !== void 0) payload.priority = provider.priority;
      if (provider.testModel) payload["test-model"] = provider.testModel;
      return payload;
    };
    const providersApi = {
      getGeminiKeys() {
        return __async(this, null, function* () {
          var _a2, _b;
          const data = yield apiClient.get("/gemini-api-key");
          const list = data && ((_b = (_a2 = data["gemini-api-key"]) != null ? _a2 : data.items) != null ? _b : data);
          if (!Array.isArray(list)) return [];
          return list.map((item) => normalizeGeminiKeyConfig(item)).filter(Boolean);
        });
      },
      saveGeminiKeys: (configs) => apiClient.put("/gemini-api-key", configs.map((item) => serializeGeminiKey(item))),
      updateGeminiKey: (index2, value) => apiClient.patch("/gemini-api-key", { index: index2, value: serializeGeminiKey(value) }),
      deleteGeminiKey: (apiKey) => apiClient.delete(`/gemini-api-key?api-key=${encodeURIComponent(apiKey)}`),
      getCodexConfigs() {
        return __async(this, null, function* () {
          var _a2, _b;
          const data = yield apiClient.get("/codex-api-key");
          const list = data && ((_b = (_a2 = data["codex-api-key"]) != null ? _a2 : data.items) != null ? _b : data);
          if (!Array.isArray(list)) return [];
          return list.map((item) => normalizeProviderKeyConfig(item)).filter(Boolean);
        });
      },
      saveCodexConfigs: (configs) => apiClient.put("/codex-api-key", configs.map((item) => serializeProviderKey(item))),
      updateCodexConfig: (index2, value) => apiClient.patch("/codex-api-key", { index: index2, value: serializeProviderKey(value) }),
      deleteCodexConfig: (apiKey) => apiClient.delete(`/codex-api-key?api-key=${encodeURIComponent(apiKey)}`),
      getClaudeConfigs() {
        return __async(this, null, function* () {
          var _a2, _b;
          const data = yield apiClient.get("/claude-api-key");
          const list = data && ((_b = (_a2 = data["claude-api-key"]) != null ? _a2 : data.items) != null ? _b : data);
          if (!Array.isArray(list)) return [];
          return list.map((item) => normalizeProviderKeyConfig(item)).filter(Boolean);
        });
      },
      saveClaudeConfigs: (configs) => apiClient.put("/claude-api-key", configs.map((item) => serializeProviderKey(item))),
      updateClaudeConfig: (index2, value) => apiClient.patch("/claude-api-key", { index: index2, value: serializeProviderKey(value) }),
      deleteClaudeConfig: (apiKey) => apiClient.delete(`/claude-api-key?api-key=${encodeURIComponent(apiKey)}`),
      getOpenAIProviders() {
        return __async(this, null, function* () {
          var _a2, _b;
          const data = yield apiClient.get("/openai-compatibility");
          const list = data && ((_b = (_a2 = data["openai-compatibility"]) != null ? _a2 : data.items) != null ? _b : data);
          if (!Array.isArray(list)) return [];
          return list.map((item) => normalizeOpenAIProvider(item)).filter(Boolean);
        });
      },
      saveOpenAIProviders: (providers) => apiClient.put("/openai-compatibility", providers.map((item) => serializeOpenAIProvider(item))),
      updateOpenAIProvider: (index2, value) => apiClient.patch("/openai-compatibility", { index: index2, value: serializeOpenAIProvider(value) }),
      deleteOpenAIProvider: (name2) => apiClient.delete(`/openai-compatibility?name=${encodeURIComponent(name2)}`)
    };
    const authFilesApi = {
      list: () => apiClient.get("/auth-files"),
      upload: (file) => {
        const formData = new FormData();
        formData.append("file", file, file.name);
        return apiClient.postForm("/auth-files", formData);
      },
      deleteFile: (name2) => apiClient.delete(`/auth-files?name=${encodeURIComponent(name2)}`),
      deleteAll: () => apiClient.delete("/auth-files", { params: { all: true } }),
      // 
      updatePriority: (name2, priority) => apiClient.patch(`/auth-files?name=${encodeURIComponent(name2)}`, { priority }),
      // OAuth 
      getOauthExcludedModels() {
        return __async(this, null, function* () {
          var _a2, _b;
          const data = yield apiClient.get("/oauth-excluded-models");
          const payload = data && ((_b = (_a2 = data["oauth-excluded-models"]) != null ? _a2 : data.items) != null ? _b : data);
          return payload && typeof payload === "object" ? payload : {};
        });
      },
      saveOauthExcludedModels: (provider, models) => apiClient.patch("/oauth-excluded-models", { provider, models }),
      deleteOauthExcludedEntry: (provider) => apiClient.delete(`/oauth-excluded-models?provider=${encodeURIComponent(provider)}`),
      // 
      getModelsForAuthFile(name2) {
        return __async(this, null, function* () {
          const data = yield apiClient.get(`/auth-files/models?name=${encodeURIComponent(name2)}`);
          return data && Array.isArray(data["models"]) ? data["models"] : [];
        });
      },
      //  Antigravity 
      getAntigravityQuotas() {
        return __async(this, null, function* () {
          const data = yield apiClient.get("/antigravity-quotas");
          return (data == null ? void 0 : data.quotas) || {};
        });
      },
      //  Kiro 
      getKiroUsageLimits(authId) {
        return __async(this, null, function* () {
          try {
            const data = yield apiClient.get("/kiro-usage-limits", { params: { auth_id: authId } });
            return (data == null ? void 0 : data.usage) || null;
          } catch (e) {
            return null;
          }
        });
      }
    };
    const WEBUI_SUPPORTED = ["codex", "anthropic", "antigravity", "gemini-cli", "iflow"];
    const CALLBACK_PROVIDER_MAP = {
      "gemini-cli": "gemini"
    };
    const oauthApi = {
      startAuth: (provider, options) => {
        const params = {};
        if (WEBUI_SUPPORTED.includes(provider)) {
          params.is_webui = true;
        }
        if (provider === "gemini-cli" && (options == null ? void 0 : options.projectId)) {
          params.project_id = options.projectId;
        }
        return apiClient.get(`/${provider}-auth-url`, {
          params: Object.keys(params).length ? params : void 0
        });
      },
      getAuthStatus: (state) => apiClient.get(`/get-auth-status`, {
        params: { state }
      }),
      submitCallback: (provider, redirectUrl) => {
        var _a2;
        const callbackProvider = (_a2 = CALLBACK_PROVIDER_MAP[provider]) != null ? _a2 : provider;
        return apiClient.post("/oauth-callback", {
          provider: callbackProvider,
          redirect_url: redirectUrl
        });
      },
      /** iFlow cookie  */
      iflowCookieAuth: (cookie) => apiClient.post("/iflow-auth-url", { cookie }),
      /** Kiro  */
      kiroCredentialAuth: (credPath) => apiClient.post("/kiro-auth-url", { cred_path: credPath }),
      /** Kiro  */
      kiroUploadCredential: (file) => __async(null, null, function* () {
        const formData = new FormData();
        formData.append("file", file);
        formData.append("provider", "kiro");
        return apiClient.postForm("/upload-oauth-credentials", formData);
      }),
      /** Kiro  */
      kiroGetUsageLimits: (authId) => apiClient.get("/kiro-usage-limits", { params: { auth_id: authId } })
    };
    function maskApiKey(key, visibleChars = 4) {
      if (!key || key.length <= visibleChars * 2) {
        return key;
      }
      const start = key.slice(0, visibleChars);
      const end = key.slice(-visibleChars);
      const maskedLength = Math.min(key.length - visibleChars * 2, 20);
      const masked = "*".repeat(maskedLength);
      return `${start}${masked}${end}`;
    }
    function formatFileSize(bytes) {
      if (bytes === 0) return "0 B";
      const units = ["B", "KB", "MB", "GB"];
      const k = 1024;
      const i2 = Math.floor(Math.log(bytes) / Math.log(k));
      return `${(bytes / Math.pow(k, i2)).toFixed(2)} ${units[i2]}`;
    }
    function formatUnixTimestamp(value, locale) {
      if (value === null || value === void 0 || value === "") return "";
      const asNumber = typeof value === "number" ? value : Number(value);
      const date = (() => {
        if (!Number.isFinite(asNumber) || Number.isNaN(asNumber)) {
          return new Date(String(value));
        }
        const abs = Math.abs(asNumber);
        if (abs < 1e11) return new Date(asNumber * 1e3);
        if (abs < 1e14) return new Date(asNumber);
        if (abs < 1e17) return new Date(Math.round(asNumber / 1e3));
        return new Date(Math.round(asNumber / 1e6));
      })();
      if (Number.isNaN(date.getTime())) return "";
      return locale ? date.toLocaleString(locale) : date.toLocaleString();
    }
    const TOKENS_PER_PRICE_UNIT = 1e6;
    const MODEL_PRICE_STORAGE_KEY = "cli-proxy-model-prices-v2";
    const normalizeAuthIndex = (value) => {
      if (typeof value === "number" && Number.isFinite(value)) {
        return value.toString();
      }
      if (typeof value === "string") {
        const trimmed = value.trim();
        return trimmed ? trimmed : null;
      }
      return null;
    };
    function maskUsageSensitiveValue(value, masker = maskApiKey) {
      if (value === null || value === void 0) {
        return "";
      }
      const raw = typeof value === "string" ? value : String(value);
      if (!raw) {
        return "";
      }
      let masked = raw;
      const queryRegex = /([?&])(api[-_]?key|key|token|access_token|authorization)=([^&#\s]+)/gi;
      masked = masked.replace(queryRegex, (_full, prefix, keyName2, valuePart) => `${prefix}${keyName2}=${masker(valuePart)}`);
      const headerRegex = /(api[-_]?key|key|token|access[-_]?token|authorization)\s*([:=])\s*([A-Za-z0-9._-]+)/gi;
      masked = masked.replace(headerRegex, (_full, keyName2, separator, valuePart) => `${keyName2}${separator}${masker(valuePart)}`);
      const keyLikeRegex = /(sk-[A-Za-z0-9]{6,}|AI[a-zA-Z0-9_-]{6,}|AIza[0-9A-Za-z-_]{8,}|hf_[A-Za-z0-9]{6,}|pk_[A-Za-z0-9]{6,}|rk_[A-Za-z0-9]{6,})/g;
      masked = masked.replace(keyLikeRegex, (match) => masker(match));
      if (masked === raw) {
        const trimmed = raw.trim();
        if (trimmed && !/\s/.test(trimmed)) {
          const looksLikeKey = /^sk-/i.test(trimmed) || /^AI/i.test(trimmed) || /^AIza/i.test(trimmed) || /^hf_/i.test(trimmed) || /^pk_/i.test(trimmed) || /^rk_/i.test(trimmed) || !/[\\/]/.test(trimmed) && (/\d/.test(trimmed) || trimmed.length >= 10) || trimmed.length >= 24;
          if (looksLikeKey) {
            return masker(trimmed);
          }
        }
      }
      return masked;
    }
    function formatTokensInMillions(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) {
        return "0.00M";
      }
      return `${(num / 1e6).toFixed(2)}M`;
    }
    function formatPerMinuteValue(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) {
        return "0.00";
      }
      const abs = Math.abs(num);
      if (abs >= 1e3) {
        return Math.round(num).toLocaleString();
      }
      if (abs >= 100) {
        return num.toFixed(0);
      }
      if (abs >= 10) {
        return num.toFixed(1);
      }
      return num.toFixed(2);
    }
    function formatUsd(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) {
        return "$0.00";
      }
      const fixed = num.toFixed(2);
      const parts = Number(fixed).toLocaleString(void 0, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      });
      return `$${parts}`;
    }
    function collectUsageDetails(usageData) {
      if (!usageData) {
        return [];
      }
      const apis = usageData.apis || {};
      const details = [];
      Object.values(apis).forEach((apiEntry) => {
        const models = (apiEntry == null ? void 0 : apiEntry.models) || {};
        Object.entries(models).forEach(([modelName2, modelEntry]) => {
          const modelDetails = Array.isArray(modelEntry.details) ? modelEntry.details : [];
          modelDetails.forEach((detail) => {
            if (detail && detail.timestamp) {
              details.push(__spreadProps(__spreadValues({}, detail), {
                __modelName: modelName2
              }));
            }
          });
        });
      });
      return details;
    }
    function extractTotalTokens(detail) {
      const tokens = (detail == null ? void 0 : detail.tokens) || {};
      if (typeof tokens.total_tokens === "number") {
        return tokens.total_tokens;
      }
      const inputTokens = typeof tokens.input_tokens === "number" ? tokens.input_tokens : 0;
      const outputTokens = typeof tokens.output_tokens === "number" ? tokens.output_tokens : 0;
      const reasoningTokens = typeof tokens.reasoning_tokens === "number" ? tokens.reasoning_tokens : 0;
      const cachedTokens = Math.max(
        typeof tokens.cached_tokens === "number" ? Math.max(tokens.cached_tokens, 0) : 0,
        typeof tokens.cache_tokens === "number" ? Math.max(tokens.cache_tokens, 0) : 0
      );
      return inputTokens + outputTokens + reasoningTokens + cachedTokens;
    }
    function calculateTokenBreakdown(usageData) {
      const details = collectUsageDetails(usageData);
      if (!details.length) {
        return { cachedTokens: 0, reasoningTokens: 0 };
      }
      let cachedTokens = 0;
      let reasoningTokens = 0;
      details.forEach((detail) => {
        const tokens = (detail == null ? void 0 : detail.tokens) || {};
        cachedTokens += Math.max(
          typeof tokens.cached_tokens === "number" ? Math.max(tokens.cached_tokens, 0) : 0,
          typeof tokens.cache_tokens === "number" ? Math.max(tokens.cache_tokens, 0) : 0
        );
        if (typeof tokens.reasoning_tokens === "number") {
          reasoningTokens += tokens.reasoning_tokens;
        }
      });
      return { cachedTokens, reasoningTokens };
    }
    function calculateRecentPerMinuteRates(windowMinutes = 30, usageData) {
      const details = collectUsageDetails(usageData);
      const effectiveWindow = Number.isFinite(windowMinutes) && windowMinutes > 0 ? windowMinutes : 30;
      if (!details.length) {
        return { rpm: 0, tpm: 0, windowMinutes: effectiveWindow, requestCount: 0, tokenCount: 0 };
      }
      const now = Date.now();
      const windowStart = now - effectiveWindow * 60 * 1e3;
      let requestCount = 0;
      let tokenCount = 0;
      details.forEach((detail) => {
        const timestamp2 = Date.parse(detail.timestamp);
        if (Number.isNaN(timestamp2) || timestamp2 < windowStart) {
          return;
        }
        requestCount += 1;
        tokenCount += extractTotalTokens(detail);
      });
      const denominator = effectiveWindow > 0 ? effectiveWindow : 1;
      return {
        rpm: requestCount / denominator,
        tpm: tokenCount / denominator,
        windowMinutes: effectiveWindow,
        requestCount,
        tokenCount
      };
    }
    function getModelNamesFromUsage(usageData) {
      if (!usageData) {
        return [];
      }
      const apis = usageData.apis || {};
      const names2 = /* @__PURE__ */ new Set();
      Object.values(apis).forEach((apiEntry) => {
        const models = (apiEntry == null ? void 0 : apiEntry.models) || {};
        Object.keys(models).forEach((modelName2) => {
          if (modelName2) {
            names2.add(modelName2);
          }
        });
      });
      return Array.from(names2).sort((a, b) => a.localeCompare(b));
    }
    function calculateCost(detail, modelPrices) {
      const modelName2 = detail.__modelName || "";
      const price = modelPrices[modelName2];
      if (!price) {
        return 0;
      }
      const tokens = (detail == null ? void 0 : detail.tokens) || {};
      const rawInputTokens = Number(tokens.input_tokens);
      const rawCompletionTokens = Number(tokens.output_tokens);
      const rawCachedTokensPrimary = Number(tokens.cached_tokens);
      const rawCachedTokensAlternate = Number(tokens.cache_tokens);
      const inputTokens = Number.isFinite(rawInputTokens) ? Math.max(rawInputTokens, 0) : 0;
      const completionTokens = Number.isFinite(rawCompletionTokens) ? Math.max(rawCompletionTokens, 0) : 0;
      const cachedTokens = Math.max(
        Number.isFinite(rawCachedTokensPrimary) ? Math.max(rawCachedTokensPrimary, 0) : 0,
        Number.isFinite(rawCachedTokensAlternate) ? Math.max(rawCachedTokensAlternate, 0) : 0
      );
      const promptTokens = Math.max(inputTokens - cachedTokens, 0);
      const promptCost = promptTokens / TOKENS_PER_PRICE_UNIT * (Number(price.prompt) || 0);
      const cachedCost = cachedTokens / TOKENS_PER_PRICE_UNIT * (Number(price.cache) || 0);
      const completionCost = completionTokens / TOKENS_PER_PRICE_UNIT * (Number(price.completion) || 0);
      const total = promptCost + cachedCost + completionCost;
      return Number.isFinite(total) && total > 0 ? total : 0;
    }
    function calculateTotalCost(usageData, modelPrices) {
      const details = collectUsageDetails(usageData);
      if (!details.length || !Object.keys(modelPrices).length) {
        return 0;
      }
      return details.reduce((sum, detail) => sum + calculateCost(detail, modelPrices), 0);
    }
    function loadModelPrices() {
      try {
        if (typeof localStorage === "undefined") {
          return {};
        }
        const raw = localStorage.getItem(MODEL_PRICE_STORAGE_KEY);
        if (!raw) {
          return {};
        }
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") {
          return {};
        }
        const normalized = {};
        Object.entries(parsed).forEach(([model, price]) => {
          if (!model) return;
          const promptRaw = Number(price == null ? void 0 : price.prompt);
          const completionRaw = Number(price == null ? void 0 : price.completion);
          const cacheRaw = Number(price == null ? void 0 : price.cache);
          if (!Number.isFinite(promptRaw) && !Number.isFinite(completionRaw) && !Number.isFinite(cacheRaw)) {
            return;
          }
          const prompt = Number.isFinite(promptRaw) && promptRaw >= 0 ? promptRaw : 0;
          const completion = Number.isFinite(completionRaw) && completionRaw >= 0 ? completionRaw : 0;
          const cache = Number.isFinite(cacheRaw) && cacheRaw >= 0 ? cacheRaw : Number.isFinite(promptRaw) && promptRaw >= 0 ? promptRaw : prompt;
          normalized[model] = {
            prompt,
            completion,
            cache
          };
        });
        return normalized;
      } catch (e) {
        return {};
      }
    }
    function saveModelPrices(prices) {
      try {
        if (typeof localStorage === "undefined") {
          return;
        }
        localStorage.setItem(MODEL_PRICE_STORAGE_KEY, JSON.stringify(prices));
      } catch (e) {
        console.warn("");
      }
    }
    function getApiStats(usageData, modelPrices) {
      if (!(usageData == null ? void 0 : usageData.apis)) {
        return [];
      }
      const apis = usageData.apis;
      const result = [];
      Object.entries(apis).forEach(([endpoint, apiData]) => {
        const models = {};
        let totalCost = 0;
        const modelsData = (apiData == null ? void 0 : apiData.models) || {};
        Object.entries(modelsData).forEach(([modelName2, modelData]) => {
          models[modelName2] = {
            requests: modelData.total_requests || 0,
            tokens: modelData.total_tokens || 0
          };
          const price = modelPrices[modelName2];
          if (price) {
            const details = Array.isArray(modelData.details) ? modelData.details : [];
            details.forEach((detail) => {
              totalCost += calculateCost(__spreadProps(__spreadValues({}, detail), { __modelName: modelName2 }), modelPrices);
            });
          }
        });
        result.push({
          endpoint: maskUsageSensitiveValue(endpoint) || endpoint,
          totalRequests: apiData.total_requests || 0,
          totalTokens: apiData.total_tokens || 0,
          totalCost,
          models
        });
      });
      return result;
    }
    function getModelStats(usageData, modelPrices) {
      if (!(usageData == null ? void 0 : usageData.apis)) {
        return [];
      }
      const modelMap = /* @__PURE__ */ new Map();
      Object.values(usageData.apis).forEach((apiData) => {
        const models = (apiData == null ? void 0 : apiData.models) || {};
        Object.entries(models).forEach(([modelName2, modelData]) => {
          const existing = modelMap.get(modelName2) || { requests: 0, tokens: 0, cost: 0 };
          existing.requests += modelData.total_requests || 0;
          existing.tokens += modelData.total_tokens || 0;
          const price = modelPrices[modelName2];
          if (price) {
            const details = Array.isArray(modelData.details) ? modelData.details : [];
            details.forEach((detail) => {
              existing.cost += calculateCost(__spreadProps(__spreadValues({}, detail), { __modelName: modelName2 }), modelPrices);
            });
          }
          modelMap.set(modelName2, existing);
        });
      });
      return Array.from(modelMap.entries()).map(([model, stats2]) => __spreadValues({ model }, stats2)).sort((a, b) => b.requests - a.requests);
    }
    function formatHourLabel(date) {
      if (!(date instanceof Date)) {
        return "";
      }
      const month = (date.getMonth() + 1).toString().padStart(2, "0");
      const day = date.getDate().toString().padStart(2, "0");
      const hour = date.getHours().toString().padStart(2, "0");
      return `${month}-${day} ${hour}:00`;
    }
    function formatDayLabel(date) {
      if (!(date instanceof Date)) {
        return "";
      }
      const year = date.getFullYear();
      const month = (date.getMonth() + 1).toString().padStart(2, "0");
      const day = date.getDate().toString().padStart(2, "0");
      return `${year}-${month}-${day}`;
    }
    function buildHourlySeriesByModel(usageData, metric = "requests") {
      const hourMs = 60 * 60 * 1e3;
      const now = /* @__PURE__ */ new Date();
      const currentHour = new Date(now);
      currentHour.setMinutes(0, 0, 0);
      const earliestBucket = new Date(currentHour);
      earliestBucket.setHours(earliestBucket.getHours() - 23);
      const earliestTime = earliestBucket.getTime();
      const labels = [];
      for (let i2 = 0; i2 < 24; i2++) {
        const bucketStart = earliestTime + i2 * hourMs;
        labels.push(formatHourLabel(new Date(bucketStart)));
      }
      const details = collectUsageDetails(usageData);
      const dataByModel = /* @__PURE__ */ new Map();
      let hasData = false;
      if (!details.length) {
        return { labels, dataByModel, hasData };
      }
      details.forEach((detail) => {
        const timestamp2 = Date.parse(detail.timestamp);
        if (Number.isNaN(timestamp2)) {
          return;
        }
        const normalized = new Date(timestamp2);
        normalized.setMinutes(0, 0, 0);
        const bucketStart = normalized.getTime();
        const lastBucketTime = earliestTime + (labels.length - 1) * hourMs;
        if (bucketStart < earliestTime || bucketStart > lastBucketTime) {
          return;
        }
        const bucketIndex = Math.floor((bucketStart - earliestTime) / hourMs);
        if (bucketIndex < 0 || bucketIndex >= labels.length) {
          return;
        }
        const modelName2 = detail.__modelName || "Unknown";
        if (!dataByModel.has(modelName2)) {
          dataByModel.set(modelName2, new Array(labels.length).fill(0));
        }
        const bucketValues = dataByModel.get(modelName2);
        if (metric === "tokens") {
          bucketValues[bucketIndex] += extractTotalTokens(detail);
        } else {
          bucketValues[bucketIndex] += 1;
        }
        hasData = true;
      });
      return { labels, dataByModel, hasData };
    }
    function buildDailySeriesByModel(usageData, metric = "requests") {
      const details = collectUsageDetails(usageData);
      const valuesByModel = /* @__PURE__ */ new Map();
      const labelsSet = /* @__PURE__ */ new Set();
      let hasData = false;
      if (!details.length) {
        return { labels: [], dataByModel: /* @__PURE__ */ new Map(), hasData };
      }
      details.forEach((detail) => {
        const timestamp2 = Date.parse(detail.timestamp);
        if (Number.isNaN(timestamp2)) {
          return;
        }
        const dayLabel = formatDayLabel(new Date(timestamp2));
        if (!dayLabel) {
          return;
        }
        const modelName2 = detail.__modelName || "Unknown";
        if (!valuesByModel.has(modelName2)) {
          valuesByModel.set(modelName2, /* @__PURE__ */ new Map());
        }
        const modelDayMap = valuesByModel.get(modelName2);
        const increment = metric === "tokens" ? extractTotalTokens(detail) : 1;
        modelDayMap.set(dayLabel, (modelDayMap.get(dayLabel) || 0) + increment);
        labelsSet.add(dayLabel);
        hasData = true;
      });
      const labels = Array.from(labelsSet).sort();
      const dataByModel = /* @__PURE__ */ new Map();
      valuesByModel.forEach((dayMap, modelName2) => {
        const series = labels.map((label) => dayMap.get(label) || 0);
        dataByModel.set(modelName2, series);
      });
      return { labels, dataByModel, hasData };
    }
    const CHART_COLORS = [
      { borderColor: "#3b82f6", backgroundColor: "rgba(59, 130, 246, 0.15)" },
      { borderColor: "#22c55e", backgroundColor: "rgba(34, 197, 94, 0.15)" },
      { borderColor: "#f59e0b", backgroundColor: "rgba(245, 158, 11, 0.15)" },
      { borderColor: "#ef4444", backgroundColor: "rgba(239, 68, 68, 0.15)" },
      { borderColor: "#8b5cf6", backgroundColor: "rgba(139, 92, 246, 0.15)" },
      { borderColor: "#06b6d4", backgroundColor: "rgba(6, 182, 212, 0.15)" },
      { borderColor: "#ec4899", backgroundColor: "rgba(236, 72, 153, 0.15)" },
      { borderColor: "#84cc16", backgroundColor: "rgba(132, 204, 22, 0.15)" },
      { borderColor: "#f97316", backgroundColor: "rgba(249, 115, 22, 0.15)" }
    ];
    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
    const hexToRgb = (hex2) => {
      const normalized = hex2.trim().replace("#", "");
      if (normalized.length !== 6) {
        return null;
      }
      const r = Number.parseInt(normalized.slice(0, 2), 16);
      const g = Number.parseInt(normalized.slice(2, 4), 16);
      const b = Number.parseInt(normalized.slice(4, 6), 16);
      if (![r, g, b].every((channel) => Number.isFinite(channel))) {
        return null;
      }
      return { r, g, b };
    };
    const withAlpha = (hex2, alpha2) => {
      const rgb = hexToRgb(hex2);
      if (!rgb) {
        return hex2;
      }
      const clamped = clamp(alpha2, 0, 1);
      return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${clamped})`;
    };
    const buildAreaGradient = (context, baseHex, fallback) => {
      const chart = context.chart;
      const ctx = chart.ctx;
      const area = chart.chartArea;
      if (!area) {
        return fallback;
      }
      const gradient = ctx.createLinearGradient(0, area.top, 0, area.bottom);
      gradient.addColorStop(0, withAlpha(baseHex, 0.28));
      gradient.addColorStop(0.6, withAlpha(baseHex, 0.12));
      gradient.addColorStop(1, withAlpha(baseHex, 0.02));
      return gradient;
    };
    function buildChartData(usageData, period = "day", metric = "requests", selectedModels = []) {
      const baseSeries = period === "hour" ? buildHourlySeriesByModel(usageData, metric) : buildDailySeriesByModel(usageData, metric);
      const { labels, dataByModel } = baseSeries;
      const getAllSeries = () => {
        const summed = new Array(labels.length).fill(0);
        dataByModel.forEach((values) => {
          values.forEach((value, idx) => {
            summed[idx] = (summed[idx] || 0) + value;
          });
        });
        return summed;
      };
      const modelsToShow = selectedModels.length > 0 ? selectedModels : ["all"];
      const datasets = modelsToShow.map((model, index2) => {
        const isAll = model === "all";
        const data = isAll ? getAllSeries() : dataByModel.get(model) || new Array(labels.length).fill(0);
        const colorIndex = index2 % CHART_COLORS.length;
        const style = CHART_COLORS[colorIndex];
        const shouldFill = modelsToShow.length === 1 || isAll && modelsToShow.length > 1;
        return {
          label: isAll ? "All Models" : model,
          data,
          borderColor: style.borderColor,
          backgroundColor: shouldFill ? (ctx) => buildAreaGradient(ctx, style.borderColor, style.backgroundColor) : style.backgroundColor,
          fill: shouldFill,
          tension: 0.35
        };
      });
      return { labels, datasets };
    }
    function computeKeyStats(usageData, masker = maskApiKey) {
      if (!usageData) {
        return { bySource: {}, byAuthIndex: {} };
      }
      const sourceStats = {};
      const authIndexStats = {};
      const ensureBucket = (bucket, key) => {
        if (!bucket[key]) {
          bucket[key] = { success: 0, failure: 0 };
        }
        return bucket[key];
      };
      const apis = usageData.apis || {};
      Object.values(apis).forEach((apiEntry) => {
        const models = (apiEntry == null ? void 0 : apiEntry.models) || {};
        Object.values(models).forEach((modelEntry) => {
          const details = (modelEntry == null ? void 0 : modelEntry.details) || [];
          details.forEach((detail) => {
            const source2 = maskUsageSensitiveValue(detail == null ? void 0 : detail.source, masker);
            const authIndexKey = normalizeAuthIndex(detail == null ? void 0 : detail.auth_index);
            const isFailed = (detail == null ? void 0 : detail.failed) === true;
            if (source2) {
              const bucket = ensureBucket(sourceStats, source2);
              if (isFailed) {
                bucket.failure += 1;
              } else {
                bucket.success += 1;
              }
            }
            if (authIndexKey) {
              const bucket = ensureBucket(authIndexStats, authIndexKey);
              if (isFailed) {
                bucket.failure += 1;
              } else {
                bucket.success += 1;
              }
            }
          });
        });
      });
      return {
        bySource: sourceStats,
        byAuthIndex: authIndexStats
      };
    }
    const USAGE_TIMEOUT_MS = 60 * 1e3;
    const usageApi = {
      /**
       * 
       */
      getUsage: () => apiClient.get("/usage", { timeout: USAGE_TIMEOUT_MS }),
      /**
       * / usage 
       */
      getKeyStats(usageData) {
        return __async(this, null, function* () {
          var _a2;
          let payload = usageData;
          if (!payload) {
            const response = yield apiClient.get("/usage", { timeout: USAGE_TIMEOUT_MS });
            payload = (_a2 = response == null ? void 0 : response.usage) != null ? _a2 : response;
          }
          return computeKeyStats(payload);
        });
      }
    };
    const logsApi = {
      fetchLogs: (params = {}) => apiClient.get("/logs", { params }),
      clearLogs: () => apiClient.delete("/logs"),
      fetchErrorLogs: () => apiClient.get("/request-error-logs"),
      downloadErrorLog: (filename) => apiClient.getRaw(`/request-error-logs/${encodeURIComponent(filename)}`, {
        responseType: "blob"
      })
    };
    const versionApi = {
      checkLatest: () => apiClient.get("/latest-version")
    };
    const container$8 = "Settings-module__container___UY8S9";
    const pageTitle$8 = "Settings-module__pageTitle___ADRp3";
    const grid = "Settings-module__grid___WziyQ";
    const retryRow = "Settings-module__retryRow___fKNn1";
    const retryInput = "Settings-module__retryInput___-fsAl";
    const retryButton = "Settings-module__retryButton___hpjto";
    const styles$8 = {
      container: container$8,
      pageTitle: pageTitle$8,
      grid,
      retryRow,
      retryInput,
      retryButton
    };
    function SettingsPage() {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
      const { t: t2 } = useTranslation();
      const { showNotification } = useNotificationStore();
      const connectionStatus = useAuthStore((state) => state.connectionStatus);
      const config2 = useConfigStore((state) => state.config);
      const fetchConfig = useConfigStore((state) => state.fetchConfig);
      const updateConfigValue = useConfigStore((state) => state.updateConfigValue);
      const clearCache = useConfigStore((state) => state.clearCache);
      const [loading, setLoading] = reactExports.useState(true);
      const [proxyValue, setProxyValue] = reactExports.useState("");
      const [retryValue, setRetryValue] = reactExports.useState(0);
      const [pending, setPending] = reactExports.useState({});
      const [error2, setError] = reactExports.useState("");
      const disableControls = connectionStatus !== "connected";
      reactExports.useEffect(() => {
        const load = () => __async(null, null, function* () {
          var _a3;
          setLoading(true);
          setError("");
          try {
            const data = yield fetchConfig();
            setProxyValue((_a3 = data == null ? void 0 : data.proxyUrl) != null ? _a3 : "");
            setRetryValue(typeof (data == null ? void 0 : data.requestRetry) === "number" ? data.requestRetry : 0);
          } catch (err) {
            setError((err == null ? void 0 : err.message) || t2("notification.refresh_failed"));
          } finally {
            setLoading(false);
          }
        });
        load();
      }, [fetchConfig, t2]);
      reactExports.useEffect(() => {
        var _a3;
        if (config2) {
          setProxyValue((_a3 = config2.proxyUrl) != null ? _a3 : "");
          if (typeof config2.requestRetry === "number") {
            setRetryValue(config2.requestRetry);
          }
        }
      }, [config2 == null ? void 0 : config2.proxyUrl, config2 == null ? void 0 : config2.requestRetry]);
      const setPendingFlag = (key, value) => {
        setPending((prev) => __spreadProps(__spreadValues({}, prev), { [key]: value }));
      };
      const toggleSetting = (section, rawKey, value, updater, successMessage) => __async(null, null, function* () {
        const previous = (() => {
          var _a3, _b2, _c2, _d2, _e2;
          switch (rawKey) {
            case "debug":
              return (_a3 = config2 == null ? void 0 : config2.debug) != null ? _a3 : false;
            case "usage-statistics-enabled":
              return (_b2 = config2 == null ? void 0 : config2.usageStatisticsEnabled) != null ? _b2 : false;
            case "request-log":
              return (_c2 = config2 == null ? void 0 : config2.requestLog) != null ? _c2 : false;
            case "logging-to-file":
              return (_d2 = config2 == null ? void 0 : config2.loggingToFile) != null ? _d2 : false;
            case "ws-auth":
              return (_e2 = config2 == null ? void 0 : config2.wsAuth) != null ? _e2 : false;
            default:
              return false;
          }
        })();
        setPendingFlag(section, true);
        updateConfigValue(rawKey, value);
        try {
          yield updater(value);
          clearCache(rawKey);
          showNotification(successMessage, "success");
        } catch (err) {
          updateConfigValue(rawKey, previous);
          showNotification(`${t2("notification.update_failed")}: ${(err == null ? void 0 : err.message) || ""}`, "error");
        } finally {
          setPendingFlag(section, false);
        }
      });
      const handleProxyUpdate = () => __async(null, null, function* () {
        var _a3;
        const previous = (_a3 = config2 == null ? void 0 : config2.proxyUrl) != null ? _a3 : "";
        setPendingFlag("proxy", true);
        updateConfigValue("proxy-url", proxyValue);
        try {
          yield configApi.updateProxyUrl(proxyValue.trim());
          clearCache("proxy-url");
          showNotification(t2("notification.proxy_updated"), "success");
        } catch (err) {
          setProxyValue(previous);
          updateConfigValue("proxy-url", previous);
          showNotification(`${t2("notification.update_failed")}: ${(err == null ? void 0 : err.message) || ""}`, "error");
        } finally {
          setPendingFlag("proxy", false);
        }
      });
      const handleProxyClear = () => __async(null, null, function* () {
        var _a3;
        const previous = (_a3 = config2 == null ? void 0 : config2.proxyUrl) != null ? _a3 : "";
        setPendingFlag("proxy", true);
        updateConfigValue("proxy-url", "");
        try {
          yield configApi.clearProxyUrl();
          clearCache("proxy-url");
          setProxyValue("");
          showNotification(t2("notification.proxy_cleared"), "success");
        } catch (err) {
          setProxyValue(previous);
          updateConfigValue("proxy-url", previous);
          showNotification(`${t2("notification.update_failed")}: ${(err == null ? void 0 : err.message) || ""}`, "error");
        } finally {
          setPendingFlag("proxy", false);
        }
      });
      const handleRetryUpdate = () => __async(null, null, function* () {
        var _a3;
        const previous = (_a3 = config2 == null ? void 0 : config2.requestRetry) != null ? _a3 : 0;
        const parsed = Number(retryValue);
        if (!Number.isFinite(parsed) || parsed < 0) {
          showNotification(t2("login.error_invalid"), "error");
          setRetryValue(previous);
          return;
        }
        setPendingFlag("retry", true);
        updateConfigValue("request-retry", parsed);
        try {
          yield configApi.updateRequestRetry(parsed);
          clearCache("request-retry");
          showNotification(t2("notification.retry_updated"), "success");
        } catch (err) {
          setRetryValue(previous);
          updateConfigValue("request-retry", previous);
          showNotification(`${t2("notification.update_failed")}: ${(err == null ? void 0 : err.message) || ""}`, "error");
        } finally {
          setPendingFlag("retry", false);
        }
      });
      const quotaSwitchProject = (_b = (_a2 = config2 == null ? void 0 : config2.quotaExceeded) == null ? void 0 : _a2.switchProject) != null ? _b : false;
      const quotaSwitchPreview = (_d = (_c = config2 == null ? void 0 : config2.quotaExceeded) == null ? void 0 : _c.switchPreviewModel) != null ? _d : false;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$8.container, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$8.pageTitle, children: t2("basic_settings.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$8.grid, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
            error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-box", children: error2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: 16 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ToggleSwitch,
                {
                  label: t2("basic_settings.debug_enable"),
                  checked: (_e = config2 == null ? void 0 : config2.debug) != null ? _e : false,
                  disabled: disableControls || pending.debug || loading,
                  onChange: (value) => toggleSetting("debug", "debug", value, configApi.updateDebug, t2("notification.debug_updated"))
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ToggleSwitch,
                {
                  label: t2("basic_settings.usage_statistics_enable"),
                  checked: (_f = config2 == null ? void 0 : config2.usageStatisticsEnabled) != null ? _f : false,
                  disabled: disableControls || pending.usage || loading,
                  onChange: (value) => toggleSetting(
                    "usage",
                    "usage-statistics-enabled",
                    value,
                    configApi.updateUsageStatistics,
                    t2("notification.usage_statistics_updated")
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ToggleSwitch,
                {
                  label: t2("basic_settings.request_log_enable"),
                  checked: (_g = config2 == null ? void 0 : config2.requestLog) != null ? _g : false,
                  disabled: disableControls || pending.requestLog || loading,
                  onChange: (value) => toggleSetting(
                    "requestLog",
                    "request-log",
                    value,
                    configApi.updateRequestLog,
                    t2("notification.request_log_updated")
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ToggleSwitch,
                {
                  label: t2("basic_settings.logging_to_file_enable"),
                  checked: (_h = config2 == null ? void 0 : config2.loggingToFile) != null ? _h : false,
                  disabled: disableControls || pending.loggingToFile || loading,
                  onChange: (value) => toggleSetting(
                    "loggingToFile",
                    "logging-to-file",
                    value,
                    configApi.updateLoggingToFile,
                    t2("notification.logging_to_file_updated")
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ToggleSwitch,
                {
                  label: t2("basic_settings.ws_auth_enable"),
                  checked: (_i = config2 == null ? void 0 : config2.wsAuth) != null ? _i : false,
                  disabled: disableControls || pending.wsAuth || loading,
                  onChange: (value) => toggleSetting(
                    "wsAuth",
                    "ws-auth",
                    value,
                    configApi.updateWsAuth,
                    t2("notification.ws_auth_updated")
                  )
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { title: t2("basic_settings.proxy_title"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                label: t2("basic_settings.proxy_url_label"),
                placeholder: t2("basic_settings.proxy_url_placeholder"),
                value: proxyValue,
                onChange: (e) => setProxyValue(e.target.value),
                disabled: disableControls || loading
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 12 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: handleProxyClear, disabled: disableControls || pending.proxy || loading, children: t2("basic_settings.proxy_clear") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleProxyUpdate, loading: pending.proxy, disabled: disableControls || loading, children: t2("basic_settings.proxy_update") })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { title: t2("basic_settings.retry_title"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$8.retryRow, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                label: t2("basic_settings.retry_count_label"),
                type: "number",
                inputMode: "numeric",
                min: 0,
                step: 1,
                value: retryValue,
                onChange: (e) => setRetryValue(Number(e.target.value)),
                disabled: disableControls || loading,
                className: styles$8.retryInput
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                className: styles$8.retryButton,
                onClick: handleRetryUpdate,
                loading: pending.retry,
                disabled: disableControls || loading,
                children: t2("basic_settings.retry_update")
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { title: t2("basic_settings.quota_title"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: 16 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ToggleSwitch,
              {
                label: t2("basic_settings.quota_switch_project"),
                checked: quotaSwitchProject,
                disabled: disableControls || pending.switchProject || loading,
                onChange: (value) => (() => __async(null, null, function* () {
                  var _a3, _b2;
                  const previous = (_b2 = (_a3 = config2 == null ? void 0 : config2.quotaExceeded) == null ? void 0 : _a3.switchProject) != null ? _b2 : false;
                  const nextQuota = __spreadProps(__spreadValues({}, (config2 == null ? void 0 : config2.quotaExceeded) || {}), { switchProject: value });
                  setPendingFlag("switchProject", true);
                  updateConfigValue("quota-exceeded", nextQuota);
                  try {
                    yield configApi.updateSwitchProject(value);
                    clearCache("quota-exceeded");
                    showNotification(t2("notification.quota_switch_project_updated"), "success");
                  } catch (err) {
                    updateConfigValue("quota-exceeded", __spreadProps(__spreadValues({}, (config2 == null ? void 0 : config2.quotaExceeded) || {}), { switchProject: previous }));
                    showNotification(`${t2("notification.update_failed")}: ${(err == null ? void 0 : err.message) || ""}`, "error");
                  } finally {
                    setPendingFlag("switchProject", false);
                  }
                }))()
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ToggleSwitch,
              {
                label: t2("basic_settings.quota_switch_preview"),
                checked: quotaSwitchPreview,
                disabled: disableControls || pending.switchPreview || loading,
                onChange: (value) => (() => __async(null, null, function* () {
                  var _a3, _b2;
                  const previous = (_b2 = (_a3 = config2 == null ? void 0 : config2.quotaExceeded) == null ? void 0 : _a3.switchPreviewModel) != null ? _b2 : false;
                  const nextQuota = __spreadProps(__spreadValues({}, (config2 == null ? void 0 : config2.quotaExceeded) || {}), { switchPreviewModel: value });
                  setPendingFlag("switchPreview", true);
                  updateConfigValue("quota-exceeded", nextQuota);
                  try {
                    yield configApi.updateSwitchPreviewModel(value);
                    clearCache("quota-exceeded");
                    showNotification(t2("notification.quota_switch_preview_updated"), "success");
                  } catch (err) {
                    updateConfigValue("quota-exceeded", __spreadProps(__spreadValues({}, (config2 == null ? void 0 : config2.quotaExceeded) || {}), { switchPreviewModel: previous }));
                    showNotification(`${t2("notification.update_failed")}: ${(err == null ? void 0 : err.message) || ""}`, "error");
                  } finally {
                    setPendingFlag("switchPreview", false);
                  }
                }))()
              }
            )
          ] }) })
        ] })
      ] });
    }
    function Modal({ open, title: title2, onClose, footer: footer2, width = 520, children }) {
      if (!open) return null;
      const handleMaskClick = (event) => {
        if (event.target === event.currentTarget) {
          onClose();
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: handleMaskClick, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal", style: { width }, role: "dialog", "aria-modal": "true", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-title", children: title2 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, "aria-label": "Close", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconX, { size: 18 }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-body", children }),
        footer2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-footer", children: footer2 })
      ] }) });
    }
    function EmptyState({ title: title2, description: description2, action }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-state", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "empty-icon", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconInbox, { size: 20 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "empty-title", children: title2 }),
            description2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "empty-desc", children: description2 })
          ] })
        ] }),
        action && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "empty-action", children: action })
      ] });
    }
    function LoadingSpinner({ size = 20 }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "loading-spinner",
          style: { width: size, height: size, borderWidth: size / 7 },
          role: "status",
          "aria-live": "polite"
        }
      );
    }
    const container$7 = "ApiKeysPage-module__container___tdy0z";
    const pageTitle$7 = "ApiKeysPage-module__pageTitle___nLQ41";
    const styles$7 = {
      container: container$7,
      pageTitle: pageTitle$7
    };
    function ApiKeysPage() {
      const { t: t2 } = useTranslation();
      const { showNotification } = useNotificationStore();
      const connectionStatus = useAuthStore((state) => state.connectionStatus);
      const config2 = useConfigStore((state) => state.config);
      const fetchConfig = useConfigStore((state) => state.fetchConfig);
      const updateConfigValue = useConfigStore((state) => state.updateConfigValue);
      const clearCache = useConfigStore((state) => state.clearCache);
      const [apiKeys, setApiKeys] = reactExports.useState([]);
      const [loading, setLoading] = reactExports.useState(true);
      const [error2, setError] = reactExports.useState("");
      const [modalOpen, setModalOpen] = reactExports.useState(false);
      const [editingIndex, setEditingIndex] = reactExports.useState(null);
      const [inputValue, setInputValue] = reactExports.useState("");
      const [saving, setSaving] = reactExports.useState(false);
      const [deletingIndex, setDeletingIndex] = reactExports.useState(null);
      const disableControls = reactExports.useMemo(() => connectionStatus !== "connected", [connectionStatus]);
      const loadApiKeys = reactExports.useCallback(
        (force = false) => __async(null, null, function* () {
          setLoading(true);
          setError("");
          try {
            const result = yield fetchConfig("api-keys", force);
            const list = Array.isArray(result) ? result : [];
            setApiKeys(list);
          } catch (err) {
            setError((err == null ? void 0 : err.message) || t2("notification.refresh_failed"));
          } finally {
            setLoading(false);
          }
        }),
        [fetchConfig, t2]
      );
      reactExports.useEffect(() => {
        loadApiKeys();
      }, [loadApiKeys]);
      reactExports.useEffect(() => {
        if (Array.isArray(config2 == null ? void 0 : config2.apiKeys)) {
          setApiKeys(config2.apiKeys);
        }
      }, [config2 == null ? void 0 : config2.apiKeys]);
      const openAddModal = () => {
        setEditingIndex(null);
        setInputValue("");
        setModalOpen(true);
      };
      const openEditModal = (index2) => {
        var _a2;
        setEditingIndex(index2);
        setInputValue((_a2 = apiKeys[index2]) != null ? _a2 : "");
        setModalOpen(true);
      };
      const closeModal = () => {
        setModalOpen(false);
        setInputValue("");
        setEditingIndex(null);
      };
      const handleSave = () => __async(null, null, function* () {
        const trimmed = inputValue.trim();
        if (!trimmed) {
          showNotification(`${t2("notification.please_enter")} ${t2("notification.api_key")}`, "error");
          return;
        }
        const isEdit = editingIndex !== null;
        const nextKeys = isEdit ? apiKeys.map((key, idx) => idx === editingIndex ? trimmed : key) : [...apiKeys, trimmed];
        setSaving(true);
        try {
          if (isEdit && editingIndex !== null) {
            yield apiKeysApi.update(editingIndex, trimmed);
            showNotification(t2("notification.api_key_updated"), "success");
          } else {
            yield apiKeysApi.replace(nextKeys);
            showNotification(t2("notification.api_key_added"), "success");
          }
          setApiKeys(nextKeys);
          updateConfigValue("api-keys", nextKeys);
          clearCache("api-keys");
          closeModal();
        } catch (err) {
          showNotification(`${t2("notification.update_failed")}: ${(err == null ? void 0 : err.message) || ""}`, "error");
        } finally {
          setSaving(false);
        }
      });
      const handleDelete = (index2) => __async(null, null, function* () {
        if (!window.confirm(t2("api_keys.delete_confirm"))) return;
        setDeletingIndex(index2);
        try {
          yield apiKeysApi.delete(index2);
          const nextKeys = apiKeys.filter((_, idx) => idx !== index2);
          setApiKeys(nextKeys);
          updateConfigValue("api-keys", nextKeys);
          clearCache("api-keys");
          showNotification(t2("notification.api_key_deleted"), "success");
        } catch (err) {
          showNotification(`${t2("notification.delete_failed")}: ${(err == null ? void 0 : err.message) || ""}`, "error");
        } finally {
          setDeletingIndex(null);
        }
      });
      const actionButtons = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", size: "sm", onClick: () => loadApiKeys(true), disabled: loading, children: t2("common.refresh") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "sm", onClick: openAddModal, disabled: disableControls, children: t2("api_keys.add_button") })
      ] });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7.container, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$7.pageTitle, children: t2("api_keys.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { title: t2("api_keys.proxy_auth_title"), extra: actionButtons, children: [
          error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-box", children: error2 }),
          loading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-center", style: { padding: "24px 0" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: 28 }) }) : apiKeys.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            EmptyState,
            {
              title: t2("api_keys.empty_title"),
              description: t2("api_keys.empty_desc"),
              action: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: openAddModal, disabled: disableControls, children: t2("api_keys.add_button") })
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-list", children: apiKeys.map((key, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-row", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-meta", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pill", children: [
                "#",
                index2 + 1
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-title", children: t2("api_keys.item_title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-subtitle", children: maskApiKey(String(key || "")) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-actions", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", size: "sm", onClick: () => openEditModal(index2), disabled: disableControls, children: t2("common.edit") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "danger",
                  size: "sm",
                  onClick: () => handleDelete(index2),
                  disabled: disableControls || deletingIndex === index2,
                  loading: deletingIndex === index2,
                  children: t2("common.delete")
                }
              )
            ] })
          ] }, index2)) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Modal,
            {
              open: modalOpen,
              onClose: closeModal,
              title: editingIndex !== null ? t2("api_keys.edit_modal_title") : t2("api_keys.add_modal_title"),
              footer: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: closeModal, disabled: saving, children: t2("common.cancel") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleSave, loading: saving, children: editingIndex !== null ? t2("common.update") : t2("common.add") })
              ] }),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  label: editingIndex !== null ? t2("api_keys.edit_modal_key_label") : t2("api_keys.add_modal_key_label"),
                  placeholder: editingIndex !== null ? t2("api_keys.edit_modal_key_label") : t2("api_keys.add_modal_key_placeholder"),
                  value: inputValue,
                  onChange: (e) => setInputValue(e.target.value),
                  disabled: saving
                }
              )
            }
          )
        ] })
      ] });
    }
    function HeaderInputList({
      entries,
      onChange,
      addLabel,
      disabled = false,
      keyPlaceholder = "X-Custom-Header",
      valuePlaceholder = "value"
    }) {
      const currentEntries = entries.length ? entries : [{ key: "", value: "" }];
      const updateEntry = (index2, field, value) => {
        const next = currentEntries.map((entry, idx) => idx === index2 ? __spreadProps(__spreadValues({}, entry), { [field]: value }) : entry);
        onChange(next);
      };
      const addEntry = () => {
        onChange([...currentEntries, { key: "", value: "" }]);
      };
      const removeEntry = (index2) => {
        const next = currentEntries.filter((_, idx) => idx !== index2);
        onChange(next.length ? next : [{ key: "", value: "" }]);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-input-list", children: [
        currentEntries.map((entry, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-input-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              className: "input",
              placeholder: keyPlaceholder,
              value: entry.key,
              onChange: (e) => updateEntry(index2, "key", e.target.value),
              disabled
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "header-separator", children: ":" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              className: "input",
              placeholder: valuePlaceholder,
              value: entry.value,
              onChange: (e) => updateEntry(index2, "value", e.target.value),
              disabled
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "ghost",
              size: "sm",
              onClick: () => removeEntry(index2),
              disabled: disabled || currentEntries.length <= 1,
              title: "Remove",
              "aria-label": "Remove",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconX, { size: 14 })
            }
          )
        ] }) }, index2)),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", size: "sm", onClick: addEntry, disabled, className: "align-start", children: addLabel })
      ] });
    }
    const modelsToEntries = (models) => {
      if (!Array.isArray(models) || models.length === 0) {
        return [{ name: "", alias: "" }];
      }
      return models.map((m) => ({
        name: m.name || "",
        alias: m.alias || ""
      }));
    };
    const entriesToModels = (entries) => {
      return entries.filter((entry) => entry.name.trim()).map((entry) => {
        const model = { name: entry.name.trim() };
        const alias = entry.alias.trim();
        if (alias && alias !== model.name) {
          model.alias = alias;
        }
        return model;
      });
    };
    function ModelInputList({
      entries,
      onChange,
      addLabel,
      disabled = false,
      namePlaceholder = "model-name",
      aliasPlaceholder = "alias (optional)"
    }) {
      const currentEntries = entries.length ? entries : [{ name: "", alias: "" }];
      const updateEntry = (index2, field, value) => {
        const next = currentEntries.map((entry, idx) => idx === index2 ? __spreadProps(__spreadValues({}, entry), { [field]: value }) : entry);
        onChange(next);
      };
      const addEntry = () => {
        onChange([...currentEntries, { name: "", alias: "" }]);
      };
      const removeEntry = (index2) => {
        const next = currentEntries.filter((_, idx) => idx !== index2);
        onChange(next.length ? next : [{ name: "", alias: "" }]);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-input-list", children: [
        currentEntries.map((entry, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-input-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              className: "input",
              placeholder: namePlaceholder,
              value: entry.name,
              onChange: (e) => updateEntry(index2, "name", e.target.value),
              disabled
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "header-separator", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              className: "input",
              placeholder: aliasPlaceholder,
              value: entry.alias,
              onChange: (e) => updateEntry(index2, "alias", e.target.value),
              disabled
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "ghost",
              size: "sm",
              onClick: () => removeEntry(index2),
              disabled: disabled || currentEntries.length <= 1,
              title: "Remove",
              "aria-label": "Remove",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconX, { size: 14 })
            }
          )
        ] }) }, index2)),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", size: "sm", onClick: addEntry, disabled, className: "align-start", children: addLabel })
      ] });
    }
    const container$6 = "AiProvidersPage-module__container___y-jfS";
    const pageTitle$6 = "AiProvidersPage-module__pageTitle___DoSv8";
    const content$5 = "AiProvidersPage-module__content___E2Czu";
    const cardStats$1 = "AiProvidersPage-module__cardStats___rELY1";
    const statPill$1 = "AiProvidersPage-module__statPill___d812A";
    const statSuccess$1 = "AiProvidersPage-module__statSuccess___5dRtj";
    const statFailure$1 = "AiProvidersPage-module__statFailure___krDjY";
    const fieldRow = "AiProvidersPage-module__fieldRow___XK6hX";
    const fieldLabel = "AiProvidersPage-module__fieldLabel___cLX9f";
    const fieldValue = "AiProvidersPage-module__fieldValue___VdFCH";
    const headerBadgeList = "AiProvidersPage-module__headerBadgeList___kwkIM";
    const headerBadge = "AiProvidersPage-module__headerBadge___eN0Fd";
    const modelTagList = "AiProvidersPage-module__modelTagList___shUnj";
    const modelCountLabel = "AiProvidersPage-module__modelCountLabel___uV8s-";
    const modelTag$1 = "AiProvidersPage-module__modelTag___k-VuJ";
    const modelName$2 = "AiProvidersPage-module__modelName___-6r4h";
    const modelAlias$1 = "AiProvidersPage-module__modelAlias___ljQjM";
    const excludedModelTag = "AiProvidersPage-module__excludedModelTag___emTfi";
    const excludedModelsSection = "AiProvidersPage-module__excludedModelsSection___XFykq";
    const excludedModelsLabel = "AiProvidersPage-module__excludedModelsLabel___Drdds";
    const apiKeyEntriesSection = "AiProvidersPage-module__apiKeyEntriesSection___60ydj";
    const apiKeyEntriesLabel = "AiProvidersPage-module__apiKeyEntriesLabel___c5W8h";
    const apiKeyEntryList = "AiProvidersPage-module__apiKeyEntryList___-xrgk";
    const apiKeyEntryCard = "AiProvidersPage-module__apiKeyEntryCard___Y5gRi";
    const apiKeyEntryIndex = "AiProvidersPage-module__apiKeyEntryIndex___h8oWW";
    const apiKeyEntryKey = "AiProvidersPage-module__apiKeyEntryKey___JgU0c";
    const apiKeyEntryProxy = "AiProvidersPage-module__apiKeyEntryProxy___gy9Vu";
    const apiKeyEntryStats = "AiProvidersPage-module__apiKeyEntryStats___Whq5E";
    const apiKeyEntryStat = "AiProvidersPage-module__apiKeyEntryStat___rwvkB";
    const apiKeyEntryStatSuccess = "AiProvidersPage-module__apiKeyEntryStatSuccess___GXIwG";
    const apiKeyEntryStatFailure = "AiProvidersPage-module__apiKeyEntryStatFailure___XV9wg";
    const modelDiscoveryList = "AiProvidersPage-module__modelDiscoveryList___HKeOb";
    const modelDiscoveryRow = "AiProvidersPage-module__modelDiscoveryRow___3J8pc";
    const modelDiscoveryRowSelected = "AiProvidersPage-module__modelDiscoveryRowSelected___VLfIp";
    const modelDiscoveryMeta = "AiProvidersPage-module__modelDiscoveryMeta___7D6Y5";
    const modelDiscoveryName = "AiProvidersPage-module__modelDiscoveryName___yf70V";
    const modelDiscoveryAlias = "AiProvidersPage-module__modelDiscoveryAlias___N2nU7";
    const modelDiscoveryDesc = "AiProvidersPage-module__modelDiscoveryDesc___nsrtd";
    const openaiTestButtonSuccess = "AiProvidersPage-module__openaiTestButtonSuccess___ZiymQ";
    const openaiTestSelect = "AiProvidersPage-module__openaiTestSelect___7-Upw";
    const openaiTestButton = "AiProvidersPage-module__openaiTestButton___IEmjD";
    const styles$6 = {
      container: container$6,
      pageTitle: pageTitle$6,
      content: content$5,
      cardStats: cardStats$1,
      statPill: statPill$1,
      statSuccess: statSuccess$1,
      statFailure: statFailure$1,
      fieldRow,
      fieldLabel,
      fieldValue,
      headerBadgeList,
      headerBadge,
      modelTagList,
      modelCountLabel,
      modelTag: modelTag$1,
      modelName: modelName$2,
      modelAlias: modelAlias$1,
      excludedModelTag,
      excludedModelsSection,
      excludedModelsLabel,
      apiKeyEntriesSection,
      apiKeyEntriesLabel,
      apiKeyEntryList,
      apiKeyEntryCard,
      apiKeyEntryIndex,
      apiKeyEntryKey,
      apiKeyEntryProxy,
      apiKeyEntryStats,
      apiKeyEntryStat,
      apiKeyEntryStatSuccess,
      apiKeyEntryStatFailure,
      modelDiscoveryList,
      modelDiscoveryRow,
      modelDiscoveryRowSelected,
      modelDiscoveryMeta,
      modelDiscoveryName,
      modelDiscoveryAlias,
      modelDiscoveryDesc,
      openaiTestButtonSuccess,
      openaiTestSelect,
      openaiTestButton
    };
    const DISABLE_ALL_MODELS_RULE = "*";
    const hasDisableAllModelsRule = (models) => Array.isArray(models) && models.some((model) => String(model != null ? model : "").trim() === DISABLE_ALL_MODELS_RULE);
    const stripDisableAllModelsRule = (models) => Array.isArray(models) ? models.filter((model) => String(model != null ? model : "").trim() !== DISABLE_ALL_MODELS_RULE) : [];
    const withDisableAllModelsRule = (models) => {
      const base2 = stripDisableAllModelsRule(models);
      return [...base2, DISABLE_ALL_MODELS_RULE];
    };
    const withoutDisableAllModelsRule = (models) => {
      const base2 = stripDisableAllModelsRule(models);
      return base2;
    };
    const parseExcludedModels = (text) => text.split(/[\n,]+/).map((item) => item.trim()).filter(Boolean);
    const excludedModelsToText = (models) => Array.isArray(models) ? models.join("\n") : "";
    const buildOpenAIModelsEndpoint = (baseUrl) => {
      const trimmed = String(baseUrl || "").trim().replace(/\/+$/g, "");
      if (!trimmed) return "";
      return trimmed.endsWith("/v1") ? `${trimmed}/models` : `${trimmed}/v1/models`;
    };
    const buildOpenAIChatCompletionsEndpoint = (baseUrl) => {
      const trimmed = String(baseUrl || "").trim().replace(/\/+$/g, "");
      if (!trimmed) return "";
      if (trimmed.endsWith("/chat/completions")) {
        return trimmed;
      }
      return trimmed.endsWith("/v1") ? `${trimmed}/chat/completions` : `${trimmed}/v1/chat/completions`;
    };
    const OPENAI_TEST_TIMEOUT_MS = 3e4;
    const getStatsBySource = (apiKey, keyStats, maskFn) => {
      var _a2;
      const bySource = (_a2 = keyStats.bySource) != null ? _a2 : {};
      const masked = maskFn(apiKey);
      return bySource[apiKey] || bySource[masked] || { success: 0, failure: 0 };
    };
    const getOpenAIProviderStats = (apiKeyEntries, keyStats, maskFn) => {
      var _a2;
      const bySource = (_a2 = keyStats.bySource) != null ? _a2 : {};
      let totalSuccess = 0;
      let totalFailure = 0;
      (apiKeyEntries || []).forEach((entry) => {
        const key = (entry == null ? void 0 : entry.apiKey) || "";
        if (!key) return;
        const masked = maskFn(key);
        const stats2 = bySource[key] || bySource[masked] || { success: 0, failure: 0 };
        totalSuccess += stats2.success;
        totalFailure += stats2.failure;
      });
      return { success: totalSuccess, failure: totalFailure };
    };
    const buildApiKeyEntry = (input) => {
      var _a2, _b, _c;
      return {
        apiKey: (_a2 = input == null ? void 0 : input.apiKey) != null ? _a2 : "",
        proxyUrl: (_b = input == null ? void 0 : input.proxyUrl) != null ? _b : "",
        headers: (_c = input == null ? void 0 : input.headers) != null ? _c : {}
      };
    };
    const ampcodeMappingsToEntries = (mappings) => {
      if (!Array.isArray(mappings) || mappings.length === 0) {
        return [{ name: "", alias: "" }];
      }
      return mappings.map((mapping) => {
        var _a2, _b;
        return {
          name: (_a2 = mapping.from) != null ? _a2 : "",
          alias: (_b = mapping.to) != null ? _b : ""
        };
      });
    };
    const entriesToAmpcodeMappings = (entries) => {
      const seen = /* @__PURE__ */ new Set();
      const mappings = [];
      entries.forEach((entry) => {
        const from2 = entry.name.trim();
        const to2 = entry.alias.trim();
        if (!from2 || !to2) return;
        const key = from2.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);
        mappings.push({ from: from2, to: to2 });
      });
      return mappings;
    };
    const buildAmpcodeFormState = (ampcode) => {
      var _a2, _b, _c;
      return {
        upstreamUrl: (_a2 = ampcode == null ? void 0 : ampcode.upstreamUrl) != null ? _a2 : "",
        upstreamApiKey: "",
        restrictManagementToLocalhost: (_b = ampcode == null ? void 0 : ampcode.restrictManagementToLocalhost) != null ? _b : true,
        forceModelMappings: (_c = ampcode == null ? void 0 : ampcode.forceModelMappings) != null ? _c : false,
        mappingEntries: ampcodeMappingsToEntries(ampcode == null ? void 0 : ampcode.modelMappings)
      };
    };
    function AiProvidersPage() {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
      const { t: t2 } = useTranslation();
      const { showNotification } = useNotificationStore();
      const connectionStatus = useAuthStore((state) => state.connectionStatus);
      const config2 = useConfigStore((state) => state.config);
      const fetchConfig = useConfigStore((state) => state.fetchConfig);
      const updateConfigValue = useConfigStore((state) => state.updateConfigValue);
      const clearCache = useConfigStore((state) => state.clearCache);
      const [loading, setLoading] = reactExports.useState(true);
      const [error2, setError] = reactExports.useState("");
      const [geminiKeys, setGeminiKeys] = reactExports.useState([]);
      const [codexConfigs, setCodexConfigs] = reactExports.useState([]);
      const [claudeConfigs, setClaudeConfigs] = reactExports.useState([]);
      const [openaiProviders, setOpenaiProviders] = reactExports.useState([]);
      const [keyStats, setKeyStats] = reactExports.useState({ bySource: {}, byAuthIndex: {} });
      const [modal, setModal] = reactExports.useState(null);
      const [geminiForm, setGeminiForm] = reactExports.useState({
        apiKey: "",
        baseUrl: "",
        headers: {},
        excludedModels: [],
        excludedText: ""
      });
      const [providerForm, setProviderForm] = reactExports.useState({
        apiKey: "",
        baseUrl: "",
        proxyUrl: "",
        headers: {},
        models: [],
        excludedModels: [],
        modelEntries: [{ name: "", alias: "" }],
        excludedText: ""
      });
      const [openaiForm, setOpenaiForm] = reactExports.useState({
        name: "",
        baseUrl: "",
        headers: [],
        apiKeyEntries: [buildApiKeyEntry()],
        modelEntries: [{ name: "", alias: "" }]
      });
      const [ampcodeForm, setAmpcodeForm] = reactExports.useState(
        () => buildAmpcodeFormState(null)
      );
      const [ampcodeModalLoading, setAmpcodeModalLoading] = reactExports.useState(false);
      const [ampcodeLoaded, setAmpcodeLoaded] = reactExports.useState(false);
      const [ampcodeMappingsDirty, setAmpcodeMappingsDirty] = reactExports.useState(false);
      const [ampcodeModalError, setAmpcodeModalError] = reactExports.useState("");
      const [ampcodeSaving, setAmpcodeSaving] = reactExports.useState(false);
      const [openaiDiscoveryOpen, setOpenaiDiscoveryOpen] = reactExports.useState(false);
      const [openaiDiscoveryEndpoint, setOpenaiDiscoveryEndpoint] = reactExports.useState("");
      const [openaiDiscoveryModels, setOpenaiDiscoveryModels] = reactExports.useState([]);
      const [openaiDiscoveryLoading, setOpenaiDiscoveryLoading] = reactExports.useState(false);
      const [openaiDiscoveryError, setOpenaiDiscoveryError] = reactExports.useState("");
      const [openaiDiscoverySearch, setOpenaiDiscoverySearch] = reactExports.useState("");
      const [openaiDiscoverySelected, setOpenaiDiscoverySelected] = reactExports.useState(/* @__PURE__ */ new Set());
      const [openaiTestModel, setOpenaiTestModel] = reactExports.useState("");
      const [openaiTestStatus, setOpenaiTestStatus] = reactExports.useState("idle");
      const [openaiTestMessage, setOpenaiTestMessage] = reactExports.useState("");
      const [saving, setSaving] = reactExports.useState(false);
      const [configSwitchingKey, setConfigSwitchingKey] = reactExports.useState(null);
      const disableControls = reactExports.useMemo(() => connectionStatus !== "connected", [connectionStatus]);
      const filteredOpenaiDiscoveryModels = reactExports.useMemo(() => {
        const filter = openaiDiscoverySearch.trim().toLowerCase();
        if (!filter) return openaiDiscoveryModels;
        return openaiDiscoveryModels.filter((model) => {
          const name2 = (model.name || "").toLowerCase();
          const alias = (model.alias || "").toLowerCase();
          const desc = (model.description || "").toLowerCase();
          return name2.includes(filter) || alias.includes(filter) || desc.includes(filter);
        });
      }, [openaiDiscoveryModels, openaiDiscoverySearch]);
      const openaiAvailableModels = reactExports.useMemo(
        () => openaiForm.modelEntries.map((entry) => entry.name.trim()).filter(Boolean),
        [openaiForm.modelEntries]
      );
      const loadKeyStats = reactExports.useCallback(() => __async(null, null, function* () {
        try {
          const stats2 = yield usageApi.getKeyStats();
          setKeyStats(stats2);
        } catch (e) {
        }
      }), []);
      const loadConfigs = () => __async(null, null, function* () {
        setLoading(true);
        setError("");
        try {
          const data = yield fetchConfig();
          setGeminiKeys((data == null ? void 0 : data.geminiApiKeys) || []);
          setCodexConfigs((data == null ? void 0 : data.codexApiKeys) || []);
          setClaudeConfigs((data == null ? void 0 : data.claudeApiKeys) || []);
          setOpenaiProviders((data == null ? void 0 : data.openaiCompatibility) || []);
          try {
            const ampcode = yield ampcodeApi.getAmpcode();
            updateConfigValue("ampcode", ampcode);
            clearCache("ampcode");
          } catch (e) {
          }
        } catch (err) {
          setError((err == null ? void 0 : err.message) || t2("notification.refresh_failed"));
        } finally {
          setLoading(false);
        }
      });
      reactExports.useEffect(() => {
        loadConfigs();
        loadKeyStats();
      }, [loadKeyStats]);
      reactExports.useEffect(() => {
        if (config2 == null ? void 0 : config2.geminiApiKeys) setGeminiKeys(config2.geminiApiKeys);
        if (config2 == null ? void 0 : config2.codexApiKeys) setCodexConfigs(config2.codexApiKeys);
        if (config2 == null ? void 0 : config2.claudeApiKeys) setClaudeConfigs(config2.claudeApiKeys);
        if (config2 == null ? void 0 : config2.openaiCompatibility) setOpenaiProviders(config2.openaiCompatibility);
      }, [
        config2 == null ? void 0 : config2.geminiApiKeys,
        config2 == null ? void 0 : config2.codexApiKeys,
        config2 == null ? void 0 : config2.claudeApiKeys,
        config2 == null ? void 0 : config2.openaiCompatibility
      ]);
      const closeModal = () => {
        setModal(null);
        setGeminiForm({
          apiKey: "",
          baseUrl: "",
          headers: {},
          excludedModels: [],
          excludedText: ""
        });
        setProviderForm({
          apiKey: "",
          baseUrl: "",
          proxyUrl: "",
          headers: {},
          models: [],
          excludedModels: [],
          modelEntries: [{ name: "", alias: "" }],
          excludedText: ""
        });
        setOpenaiForm({
          name: "",
          baseUrl: "",
          headers: [],
          apiKeyEntries: [buildApiKeyEntry()],
          modelEntries: [{ name: "", alias: "" }],
          testModel: void 0
        });
        setAmpcodeForm(buildAmpcodeFormState(null));
        setAmpcodeModalLoading(false);
        setAmpcodeLoaded(false);
        setAmpcodeMappingsDirty(false);
        setAmpcodeModalError("");
        setAmpcodeSaving(false);
        setOpenaiDiscoveryOpen(false);
        setOpenaiDiscoveryModels([]);
        setOpenaiDiscoverySelected(/* @__PURE__ */ new Set());
        setOpenaiDiscoverySearch("");
        setOpenaiDiscoveryError("");
        setOpenaiDiscoveryEndpoint("");
        setOpenaiTestModel("");
        setOpenaiTestStatus("idle");
        setOpenaiTestMessage("");
      };
      const openGeminiModal = (index2) => {
        if (index2 !== null) {
          const entry = geminiKeys[index2];
          setGeminiForm(__spreadProps(__spreadValues({}, entry), {
            excludedText: excludedModelsToText(entry == null ? void 0 : entry.excludedModels)
          }));
        }
        setModal({ type: "gemini", index: index2 });
      };
      const openProviderModal = (type, index2) => {
        const source2 = type === "codex" ? codexConfigs : claudeConfigs;
        if (index2 !== null) {
          const entry = source2[index2];
          setProviderForm(__spreadProps(__spreadValues({}, entry), {
            modelEntries: modelsToEntries(entry == null ? void 0 : entry.models),
            excludedText: excludedModelsToText(entry == null ? void 0 : entry.excludedModels)
          }));
        }
        setModal({ type, index: index2 });
      };
      const openAmpcodeModal = () => {
        var _a3;
        setAmpcodeModalLoading(true);
        setAmpcodeLoaded(false);
        setAmpcodeMappingsDirty(false);
        setAmpcodeModalError("");
        setAmpcodeForm(buildAmpcodeFormState((_a3 = config2 == null ? void 0 : config2.ampcode) != null ? _a3 : null));
        setModal({ type: "ampcode", index: null });
        void (() => __async(null, null, function* () {
          try {
            const ampcode = yield ampcodeApi.getAmpcode();
            setAmpcodeLoaded(true);
            updateConfigValue("ampcode", ampcode);
            clearCache("ampcode");
            setAmpcodeForm(buildAmpcodeFormState(ampcode));
          } catch (err) {
            setAmpcodeModalError((err == null ? void 0 : err.message) || t2("notification.refresh_failed"));
          } finally {
            setAmpcodeModalLoading(false);
          }
        }))();
      };
      const openOpenaiModal = (index2) => {
        var _a3;
        if (index2 !== null) {
          const entry = openaiProviders[index2];
          const modelEntries = modelsToEntries(entry.models);
          setOpenaiForm({
            name: entry.name,
            baseUrl: entry.baseUrl,
            headers: headersToEntries(entry.headers),
            testModel: entry.testModel,
            modelEntries,
            apiKeyEntries: ((_a3 = entry.apiKeyEntries) == null ? void 0 : _a3.length) ? entry.apiKeyEntries : [buildApiKeyEntry()]
          });
          const available = modelEntries.map((m) => m.name.trim()).filter(Boolean);
          const initialModel = entry.testModel && available.includes(entry.testModel) ? entry.testModel : available[0] || "";
          setOpenaiTestModel(initialModel);
        } else {
          setOpenaiTestModel("");
        }
        setOpenaiTestStatus("idle");
        setOpenaiTestMessage("");
        setModal({ type: "openai", index: index2 });
      };
      const closeOpenaiModelDiscovery = () => {
        setOpenaiDiscoveryOpen(false);
        setOpenaiDiscoveryModels([]);
        setOpenaiDiscoverySelected(/* @__PURE__ */ new Set());
        setOpenaiDiscoverySearch("");
        setOpenaiDiscoveryError("");
      };
      const fetchOpenaiModelDiscovery = (..._0) => __async(null, [..._0], function* ({
        allowFallback = true
      } = {}) {
        var _a3, _b2;
        const baseUrl = openaiForm.baseUrl.trim();
        if (!baseUrl) return;
        setOpenaiDiscoveryLoading(true);
        setOpenaiDiscoveryError("");
        try {
          const headers = buildHeaderObject(openaiForm.headers);
          const firstKey = (_b2 = (_a3 = openaiForm.apiKeyEntries.find((entry) => {
            var _a4;
            return (_a4 = entry.apiKey) == null ? void 0 : _a4.trim();
          })) == null ? void 0 : _a3.apiKey) == null ? void 0 : _b2.trim();
          const hasAuthHeader = Boolean(headers.Authorization || headers["authorization"]);
          const list = yield modelsApi.fetchModels(
            baseUrl,
            hasAuthHeader ? void 0 : firstKey,
            headers
          );
          setOpenaiDiscoveryModels(list);
        } catch (err) {
          if (allowFallback) {
            try {
              const list = yield modelsApi.fetchModels(baseUrl);
              setOpenaiDiscoveryModels(list);
              return;
            } catch (fallbackErr) {
              const message2 = (fallbackErr == null ? void 0 : fallbackErr.message) || (err == null ? void 0 : err.message) || "";
              setOpenaiDiscoveryModels([]);
              setOpenaiDiscoveryError(`${t2("ai_providers.openai_models_fetch_error")}: ${message2}`);
            }
          } else {
            setOpenaiDiscoveryModels([]);
            setOpenaiDiscoveryError(
              `${t2("ai_providers.openai_models_fetch_error")}: ${(err == null ? void 0 : err.message) || ""}`
            );
          }
        } finally {
          setOpenaiDiscoveryLoading(false);
        }
      });
      const openOpenaiModelDiscovery = () => {
        const baseUrl = openaiForm.baseUrl.trim();
        if (!baseUrl) {
          showNotification(t2("ai_providers.openai_models_fetch_invalid_url"), "error");
          return;
        }
        setOpenaiDiscoveryEndpoint(buildOpenAIModelsEndpoint(baseUrl));
        setOpenaiDiscoveryModels([]);
        setOpenaiDiscoverySearch("");
        setOpenaiDiscoverySelected(/* @__PURE__ */ new Set());
        setOpenaiDiscoveryError("");
        setOpenaiDiscoveryOpen(true);
        void fetchOpenaiModelDiscovery();
      };
      const toggleOpenaiModelSelection = (name2) => {
        setOpenaiDiscoverySelected((prev) => {
          const next = new Set(prev);
          if (next.has(name2)) {
            next.delete(name2);
          } else {
            next.add(name2);
          }
          return next;
        });
      };
      const applyOpenaiModelDiscoverySelection = () => {
        const selectedModels = openaiDiscoveryModels.filter(
          (model) => openaiDiscoverySelected.has(model.name)
        );
        if (!selectedModels.length) {
          closeOpenaiModelDiscovery();
          return;
        }
        const mergedMap = /* @__PURE__ */ new Map();
        openaiForm.modelEntries.forEach((entry) => {
          var _a3;
          const name2 = entry.name.trim();
          if (!name2) return;
          mergedMap.set(name2, { name: name2, alias: ((_a3 = entry.alias) == null ? void 0 : _a3.trim()) || "" });
        });
        let addedCount = 0;
        selectedModels.forEach((model) => {
          var _a3;
          const name2 = model.name.trim();
          if (!name2 || mergedMap.has(name2)) return;
          mergedMap.set(name2, { name: name2, alias: (_a3 = model.alias) != null ? _a3 : "" });
          addedCount += 1;
        });
        const mergedEntries = Array.from(mergedMap.values());
        setOpenaiForm((prev) => __spreadProps(__spreadValues({}, prev), {
          modelEntries: mergedEntries.length ? mergedEntries : [{ name: "", alias: "" }]
        }));
        closeOpenaiModelDiscovery();
        if (addedCount > 0) {
          showNotification(
            t2("ai_providers.openai_models_fetch_added", { count: addedCount }),
            "success"
          );
        }
      };
      reactExports.useEffect(() => {
        if ((modal == null ? void 0 : modal.type) !== "openai") return;
        if (openaiAvailableModels.length === 0) {
          if (openaiTestModel) {
            setOpenaiTestModel("");
            setOpenaiTestStatus("idle");
            setOpenaiTestMessage("");
          }
          return;
        }
        if (!openaiTestModel || !openaiAvailableModels.includes(openaiTestModel)) {
          setOpenaiTestModel(openaiAvailableModels[0]);
          setOpenaiTestStatus("idle");
          setOpenaiTestMessage("");
        }
      }, [modal == null ? void 0 : modal.type, openaiAvailableModels, openaiTestModel]);
      const testOpenaiProviderConnection = () => __async(null, null, function* () {
        var _a3;
        const baseUrl = openaiForm.baseUrl.trim();
        if (!baseUrl) {
          const message2 = t2("notification.openai_test_url_required");
          setOpenaiTestStatus("error");
          setOpenaiTestMessage(message2);
          showNotification(message2, "error");
          return;
        }
        const endpoint = buildOpenAIChatCompletionsEndpoint(baseUrl);
        if (!endpoint) {
          const message2 = t2("notification.openai_test_url_required");
          setOpenaiTestStatus("error");
          setOpenaiTestMessage(message2);
          showNotification(message2, "error");
          return;
        }
        const firstKeyEntry = openaiForm.apiKeyEntries.find((entry) => {
          var _a4;
          return (_a4 = entry.apiKey) == null ? void 0 : _a4.trim();
        });
        if (!firstKeyEntry) {
          const message2 = t2("notification.openai_test_key_required");
          setOpenaiTestStatus("error");
          setOpenaiTestMessage(message2);
          showNotification(message2, "error");
          return;
        }
        const modelName2 = openaiTestModel.trim() || openaiAvailableModels[0] || "";
        if (!modelName2) {
          const message2 = t2("notification.openai_test_model_required");
          setOpenaiTestStatus("error");
          setOpenaiTestMessage(message2);
          showNotification(message2, "error");
          return;
        }
        const customHeaders = buildHeaderObject(openaiForm.headers);
        const headers = __spreadValues({
          "Content-Type": "application/json"
        }, customHeaders);
        if (!headers.Authorization && !headers["authorization"]) {
          headers.Authorization = `Bearer ${firstKeyEntry.apiKey.trim()}`;
        }
        setOpenaiTestStatus("loading");
        setOpenaiTestMessage(t2("ai_providers.openai_test_running"));
        const controller = new AbortController();
        const timeoutId = window.setTimeout(() => controller.abort(), OPENAI_TEST_TIMEOUT_MS);
        try {
          const response = yield fetch(endpoint, {
            method: "POST",
            headers,
            signal: controller.signal,
            body: JSON.stringify({
              model: modelName2,
              messages: [{ role: "user", content: "Hi" }],
              stream: false,
              max_tokens: 5
            })
          });
          const rawText = yield response.text();
          if (!response.ok) {
            let errorMessage = `${response.status} ${response.statusText}`;
            try {
              const parsed = rawText ? JSON.parse(rawText) : null;
              errorMessage = ((_a3 = parsed == null ? void 0 : parsed.error) == null ? void 0 : _a3.message) || (parsed == null ? void 0 : parsed.message) || errorMessage;
            } catch (e) {
              if (rawText) {
                errorMessage = rawText;
              }
            }
            throw new Error(errorMessage);
          }
          setOpenaiTestStatus("success");
          setOpenaiTestMessage(t2("ai_providers.openai_test_success"));
        } catch (err) {
          setOpenaiTestStatus("error");
          if ((err == null ? void 0 : err.name) === "AbortError") {
            setOpenaiTestMessage(
              t2("ai_providers.openai_test_timeout", { seconds: OPENAI_TEST_TIMEOUT_MS / 1e3 })
            );
          } else {
            setOpenaiTestMessage(`${t2("ai_providers.openai_test_failed")}: ${(err == null ? void 0 : err.message) || ""}`);
          }
        } finally {
          window.clearTimeout(timeoutId);
        }
      });
      const clearAmpcodeUpstreamApiKey = () => __async(null, null, function* () {
        var _a3;
        if (!window.confirm(t2("ai_providers.ampcode_clear_upstream_api_key_confirm"))) return;
        setAmpcodeSaving(true);
        setAmpcodeModalError("");
        try {
          yield ampcodeApi.clearUpstreamApiKey();
          const previous = (_a3 = config2 == null ? void 0 : config2.ampcode) != null ? _a3 : {};
          const next = __spreadValues({}, previous);
          delete next.upstreamApiKey;
          updateConfigValue("ampcode", next);
          clearCache("ampcode");
          showNotification(t2("notification.ampcode_upstream_api_key_cleared"), "success");
        } catch (err) {
          const message2 = (err == null ? void 0 : err.message) || "";
          setAmpcodeModalError(message2);
          showNotification(`${t2("notification.update_failed")}: ${message2}`, "error");
        } finally {
          setAmpcodeSaving(false);
        }
      });
      const saveAmpcode = () => __async(null, null, function* () {
        var _a3;
        if (!ampcodeLoaded && ampcodeMappingsDirty) {
          const confirmed = window.confirm(t2("ai_providers.ampcode_mappings_overwrite_confirm"));
          if (!confirmed) return;
        }
        setAmpcodeSaving(true);
        setAmpcodeModalError("");
        try {
          const upstreamUrl = ampcodeForm.upstreamUrl.trim();
          const overrideKey = ampcodeForm.upstreamApiKey.trim();
          const modelMappings = entriesToAmpcodeMappings(ampcodeForm.mappingEntries);
          if (upstreamUrl) {
            yield ampcodeApi.updateUpstreamUrl(upstreamUrl);
          } else {
            yield ampcodeApi.clearUpstreamUrl();
          }
          yield ampcodeApi.updateRestrictManagementToLocalhost(
            ampcodeForm.restrictManagementToLocalhost
          );
          yield ampcodeApi.updateForceModelMappings(ampcodeForm.forceModelMappings);
          if (ampcodeLoaded || ampcodeMappingsDirty) {
            if (modelMappings.length) {
              yield ampcodeApi.saveModelMappings(modelMappings);
            } else {
              yield ampcodeApi.clearModelMappings();
            }
          }
          if (overrideKey) {
            yield ampcodeApi.updateUpstreamApiKey(overrideKey);
          }
          const previous = (_a3 = config2 == null ? void 0 : config2.ampcode) != null ? _a3 : {};
          const next = __spreadProps(__spreadValues({}, previous), {
            upstreamUrl: upstreamUrl || void 0,
            restrictManagementToLocalhost: ampcodeForm.restrictManagementToLocalhost,
            forceModelMappings: ampcodeForm.forceModelMappings
          });
          if (overrideKey) {
            next.upstreamApiKey = overrideKey;
          }
          if (ampcodeLoaded || ampcodeMappingsDirty) {
            if (modelMappings.length) {
              next.modelMappings = modelMappings;
            } else {
              delete next.modelMappings;
            }
          }
          updateConfigValue("ampcode", next);
          clearCache("ampcode");
          showNotification(t2("notification.ampcode_updated"), "success");
          closeModal();
        } catch (err) {
          const message2 = (err == null ? void 0 : err.message) || "";
          setAmpcodeModalError(message2);
          showNotification(`${t2("notification.update_failed")}: ${message2}`, "error");
        } finally {
          setAmpcodeSaving(false);
        }
      });
      const saveGemini = () => __async(null, null, function* () {
        var _a3;
        setSaving(true);
        try {
          const payload = {
            apiKey: geminiForm.apiKey.trim(),
            baseUrl: ((_a3 = geminiForm.baseUrl) == null ? void 0 : _a3.trim()) || void 0,
            headers: buildHeaderObject(headersToEntries(geminiForm.headers)),
            excludedModels: parseExcludedModels(geminiForm.excludedText)
          };
          const nextList = (modal == null ? void 0 : modal.type) === "gemini" && modal.index !== null ? geminiKeys.map((item, idx) => idx === modal.index ? payload : item) : [...geminiKeys, payload];
          yield providersApi.saveGeminiKeys(nextList);
          setGeminiKeys(nextList);
          updateConfigValue("gemini-api-key", nextList);
          clearCache("gemini-api-key");
          const message2 = (modal == null ? void 0 : modal.index) !== null ? t2("notification.gemini_key_updated") : t2("notification.gemini_key_added");
          showNotification(message2, "success");
          closeModal();
        } catch (err) {
          showNotification(`${t2("notification.update_failed")}: ${(err == null ? void 0 : err.message) || ""}`, "error");
        } finally {
          setSaving(false);
        }
      });
      const deleteGemini = (apiKey) => __async(null, null, function* () {
        if (!window.confirm(t2("ai_providers.gemini_delete_confirm"))) return;
        try {
          yield providersApi.deleteGeminiKey(apiKey);
          const next = geminiKeys.filter((item) => item.apiKey !== apiKey);
          setGeminiKeys(next);
          updateConfigValue("gemini-api-key", next);
          clearCache("gemini-api-key");
          showNotification(t2("notification.gemini_key_deleted"), "success");
        } catch (err) {
          showNotification(`${t2("notification.delete_failed")}: ${(err == null ? void 0 : err.message) || ""}`, "error");
        }
      });
      const setConfigEnabled = (provider, index2, enabled) => __async(null, null, function* () {
        if (provider === "gemini") {
          const current2 = geminiKeys[index2];
          if (!current2) return;
          const switchingKey2 = `${provider}:${current2.apiKey}`;
          setConfigSwitchingKey(switchingKey2);
          const previousList2 = geminiKeys;
          const nextExcluded2 = enabled ? withoutDisableAllModelsRule(current2.excludedModels) : withDisableAllModelsRule(current2.excludedModels);
          const nextItem2 = __spreadProps(__spreadValues({}, current2), { excludedModels: nextExcluded2 });
          const nextList2 = previousList2.map((item, idx) => idx === index2 ? nextItem2 : item);
          setGeminiKeys(nextList2);
          updateConfigValue("gemini-api-key", nextList2);
          clearCache("gemini-api-key");
          try {
            yield providersApi.saveGeminiKeys(nextList2);
            showNotification(
              enabled ? t2("notification.config_enabled") : t2("notification.config_disabled"),
              "success"
            );
          } catch (err) {
            setGeminiKeys(previousList2);
            updateConfigValue("gemini-api-key", previousList2);
            clearCache("gemini-api-key");
            showNotification(`${t2("notification.update_failed")}: ${(err == null ? void 0 : err.message) || ""}`, "error");
          } finally {
            setConfigSwitchingKey(null);
          }
          return;
        }
        const source2 = provider === "codex" ? codexConfigs : claudeConfigs;
        const current = source2[index2];
        if (!current) return;
        const switchingKey = `${provider}:${current.apiKey}`;
        setConfigSwitchingKey(switchingKey);
        const previousList = source2;
        const nextExcluded = enabled ? withoutDisableAllModelsRule(current.excludedModels) : withDisableAllModelsRule(current.excludedModels);
        const nextItem = __spreadProps(__spreadValues({}, current), { excludedModels: nextExcluded });
        const nextList = previousList.map((item, idx) => idx === index2 ? nextItem : item);
        if (provider === "codex") {
          setCodexConfigs(nextList);
          updateConfigValue("codex-api-key", nextList);
          clearCache("codex-api-key");
        } else {
          setClaudeConfigs(nextList);
          updateConfigValue("claude-api-key", nextList);
          clearCache("claude-api-key");
        }
        try {
          if (provider === "codex") {
            yield providersApi.saveCodexConfigs(nextList);
          } else {
            yield providersApi.saveClaudeConfigs(nextList);
          }
          showNotification(
            enabled ? t2("notification.config_enabled") : t2("notification.config_disabled"),
            "success"
          );
        } catch (err) {
          if (provider === "codex") {
            setCodexConfigs(previousList);
            updateConfigValue("codex-api-key", previousList);
            clearCache("codex-api-key");
          } else {
            setClaudeConfigs(previousList);
            updateConfigValue("claude-api-key", previousList);
            clearCache("claude-api-key");
          }
          showNotification(`${t2("notification.update_failed")}: ${(err == null ? void 0 : err.message) || ""}`, "error");
        } finally {
          setConfigSwitchingKey(null);
        }
      });
      const saveProvider = (type) => __async(null, null, function* () {
        var _a3, _b2;
        const baseUrl = ((_a3 = providerForm.baseUrl) != null ? _a3 : "").trim();
        if (!baseUrl) {
          showNotification(t2("codex_base_url_required"), "error");
          return;
        }
        setSaving(true);
        try {
          const source2 = type === "codex" ? codexConfigs : claudeConfigs;
          const payload = {
            apiKey: providerForm.apiKey.trim(),
            baseUrl,
            proxyUrl: ((_b2 = providerForm.proxyUrl) == null ? void 0 : _b2.trim()) || void 0,
            headers: buildHeaderObject(headersToEntries(providerForm.headers)),
            models: entriesToModels(providerForm.modelEntries),
            excludedModels: parseExcludedModels(providerForm.excludedText)
          };
          const nextList = (modal == null ? void 0 : modal.type) === type && modal.index !== null ? source2.map((item, idx) => idx === modal.index ? payload : item) : [...source2, payload];
          if (type === "codex") {
            yield providersApi.saveCodexConfigs(nextList);
            setCodexConfigs(nextList);
            updateConfigValue("codex-api-key", nextList);
            clearCache("codex-api-key");
            const message2 = (modal == null ? void 0 : modal.index) !== null ? t2("notification.codex_config_updated") : t2("notification.codex_config_added");
            showNotification(message2, "success");
          } else {
            yield providersApi.saveClaudeConfigs(nextList);
            setClaudeConfigs(nextList);
            updateConfigValue("claude-api-key", nextList);
            clearCache("claude-api-key");
            const message2 = (modal == null ? void 0 : modal.index) !== null ? t2("notification.claude_config_updated") : t2("notification.claude_config_added");
            showNotification(message2, "success");
          }
          closeModal();
        } catch (err) {
          showNotification(`${t2("notification.update_failed")}: ${(err == null ? void 0 : err.message) || ""}`, "error");
        } finally {
          setSaving(false);
        }
      });
      const deleteProviderEntry = (type, apiKey) => __async(null, null, function* () {
        if (!window.confirm(t2(`ai_providers.${type}_delete_confirm`))) return;
        try {
          if (type === "codex") {
            yield providersApi.deleteCodexConfig(apiKey);
            const next = codexConfigs.filter((item) => item.apiKey !== apiKey);
            setCodexConfigs(next);
            updateConfigValue("codex-api-key", next);
            clearCache("codex-api-key");
            showNotification(t2("notification.codex_config_deleted"), "success");
          } else {
            yield providersApi.deleteClaudeConfig(apiKey);
            const next = claudeConfigs.filter((item) => item.apiKey !== apiKey);
            setClaudeConfigs(next);
            updateConfigValue("claude-api-key", next);
            clearCache("claude-api-key");
            showNotification(t2("notification.claude_config_deleted"), "success");
          }
        } catch (err) {
          showNotification(`${t2("notification.delete_failed")}: ${(err == null ? void 0 : err.message) || ""}`, "error");
        }
      });
      const saveOpenai = () => __async(null, null, function* () {
        setSaving(true);
        try {
          const payload = {
            name: openaiForm.name.trim(),
            baseUrl: openaiForm.baseUrl.trim(),
            headers: buildHeaderObject(openaiForm.headers),
            apiKeyEntries: openaiForm.apiKeyEntries.map((entry) => {
              var _a3;
              return {
                apiKey: entry.apiKey.trim(),
                proxyUrl: ((_a3 = entry.proxyUrl) == null ? void 0 : _a3.trim()) || void 0,
                headers: entry.headers
              };
            })
          };
          if (openaiForm.testModel) payload.testModel = openaiForm.testModel.trim();
          const models = entriesToModels(openaiForm.modelEntries);
          if (models.length) payload.models = models;
          const nextList = (modal == null ? void 0 : modal.type) === "openai" && modal.index !== null ? openaiProviders.map((item, idx) => idx === modal.index ? payload : item) : [...openaiProviders, payload];
          yield providersApi.saveOpenAIProviders(nextList);
          setOpenaiProviders(nextList);
          updateConfigValue("openai-compatibility", nextList);
          clearCache("openai-compatibility");
          const message2 = (modal == null ? void 0 : modal.index) !== null ? t2("notification.openai_provider_updated") : t2("notification.openai_provider_added");
          showNotification(message2, "success");
          closeModal();
        } catch (err) {
          showNotification(`${t2("notification.update_failed")}: ${(err == null ? void 0 : err.message) || ""}`, "error");
        } finally {
          setSaving(false);
        }
      });
      const deleteOpenai = (name2) => __async(null, null, function* () {
        if (!window.confirm(t2("ai_providers.openai_delete_confirm"))) return;
        try {
          yield providersApi.deleteOpenAIProvider(name2);
          const next = openaiProviders.filter((item) => item.name !== name2);
          setOpenaiProviders(next);
          updateConfigValue("openai-compatibility", next);
          clearCache("openai-compatibility");
          showNotification(t2("notification.openai_provider_deleted"), "success");
        } catch (err) {
          showNotification(`${t2("notification.delete_failed")}: ${(err == null ? void 0 : err.message) || ""}`, "error");
        }
      });
      const renderKeyEntries = (entries) => {
        const list = entries.length ? entries : [buildApiKeyEntry()];
        const updateEntry = (idx, field, value) => {
          const next = list.map((entry, i2) => i2 === idx ? __spreadProps(__spreadValues({}, entry), { [field]: value }) : entry);
          setOpenaiForm((prev) => __spreadProps(__spreadValues({}, prev), { apiKeyEntries: next }));
        };
        const removeEntry = (idx) => {
          const next = list.filter((_, i2) => i2 !== idx);
          setOpenaiForm((prev) => __spreadProps(__spreadValues({}, prev), {
            apiKeyEntries: next.length ? next : [buildApiKeyEntry()]
          }));
        };
        const addEntry = () => {
          setOpenaiForm((prev) => __spreadProps(__spreadValues({}, prev), { apiKeyEntries: [...list, buildApiKeyEntry()] }));
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stack", children: [
          list.map((entry, index2) => {
            var _a3;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-row", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-meta", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    label: `${t2("common.api_key")} #${index2 + 1}`,
                    value: entry.apiKey,
                    onChange: (e) => updateEntry(index2, "apiKey", e.target.value)
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    label: t2("common.proxy_url"),
                    value: (_a3 = entry.proxyUrl) != null ? _a3 : "",
                    onChange: (e) => updateEntry(index2, "proxyUrl", e.target.value)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-actions", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "ghost",
                  size: "sm",
                  onClick: () => removeEntry(index2),
                  disabled: list.length <= 1 || saving,
                  children: t2("common.delete")
                }
              ) })
            ] }, index2);
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", size: "sm", onClick: addEntry, disabled: saving, children: t2("ai_providers.openai_keys_add_btn") })
        ] });
      };
      const renderList = (items, keyField, renderContent, onEdit, onDelete, addLabel, deleteLabel, options) => {
        if (loading) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("common.loading") });
        }
        if (!items.length) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            EmptyState,
            {
              title: t2("common.info"),
              description: t2("ai_providers.gemini_empty_desc"),
              action: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => onEdit(-1), disabled: disableControls, children: addLabel })
            }
          );
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-list", children: items.map((item, index2) => {
          const rowDisabled = (options == null ? void 0 : options.getRowDisabled) ? options.getRowDisabled(item, index2) : false;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "item-row",
              style: rowDisabled ? { opacity: 0.6 } : void 0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-meta", children: renderContent(item, index2) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-actions", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      variant: "secondary",
                      size: "sm",
                      onClick: () => onEdit(index2),
                      disabled: disableControls || saving || Boolean(configSwitchingKey),
                      children: t2("common.edit")
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      variant: "danger",
                      size: "sm",
                      onClick: () => onDelete(item),
                      disabled: disableControls || saving || Boolean(configSwitchingKey),
                      children: t2("common.delete")
                    }
                  ),
                  (options == null ? void 0 : options.renderExtraActions) ? options.renderExtraActions(item, index2) : null
                ] })
              ]
            },
            keyField(item)
          );
        }) });
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.container, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$6.pageTitle, children: t2("ai_providers.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.content, children: [
          error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-box", children: error2 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Card,
            {
              title: t2("ai_providers.gemini_title"),
              extra: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  size: "sm",
                  onClick: () => openGeminiModal(null),
                  disabled: disableControls || saving || Boolean(configSwitchingKey),
                  children: t2("ai_providers.gemini_add_button")
                }
              ),
              children: renderList(
                geminiKeys,
                (item) => item.apiKey,
                (item, index2) => {
                  var _a3;
                  const stats2 = getStatsBySource(item.apiKey, keyStats, maskApiKey);
                  const headerEntries = Object.entries(item.headers || {});
                  const configDisabled = hasDisableAllModelsRule(item.excludedModels);
                  const excludedModels2 = (_a3 = item.excludedModels) != null ? _a3 : [];
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-title", children: [
                      t2("ai_providers.gemini_item_title"),
                      " #",
                      index2 + 1
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.fieldRow, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.fieldLabel, children: [
                        t2("common.api_key"),
                        ":"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldValue, children: maskApiKey(item.apiKey) })
                    ] }),
                    item.baseUrl && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.fieldRow, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.fieldLabel, children: [
                        t2("common.base_url"),
                        ":"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldValue, children: item.baseUrl })
                    ] }),
                    headerEntries.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.headerBadgeList, children: headerEntries.map(([key, value]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.headerBadge, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
                        key,
                        ":"
                      ] }),
                      " ",
                      value
                    ] }, key)) }),
                    configDisabled && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-badge warning", style: { marginTop: 8, marginBottom: 0 }, children: t2("ai_providers.config_disabled_badge") }),
                    excludedModels2.length ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.excludedModelsSection, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.excludedModelsLabel, children: t2("ai_providers.excluded_models_count", { count: excludedModels2.length }) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.modelTagList, children: excludedModels2.map((model) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          className: `${styles$6.modelTag} ${styles$6.excludedModelTag}`,
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.modelName, children: model })
                        },
                        model
                      )) })
                    ] }) : null,
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.cardStats, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$6.statPill} ${styles$6.statSuccess}`, children: [
                        t2("stats.success"),
                        ": ",
                        stats2.success
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$6.statPill} ${styles$6.statFailure}`, children: [
                        t2("stats.failure"),
                        ": ",
                        stats2.failure
                      ] })
                    ] })
                  ] });
                },
                (index2) => openGeminiModal(index2),
                (item) => deleteGemini(item.apiKey),
                t2("ai_providers.gemini_add_button"),
                void 0,
                {
                  getRowDisabled: (item) => hasDisableAllModelsRule(item.excludedModels),
                  renderExtraActions: (item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ToggleSwitch,
                    {
                      label: t2("ai_providers.config_toggle_label"),
                      checked: !hasDisableAllModelsRule(item.excludedModels),
                      disabled: disableControls || loading || saving || Boolean(configSwitchingKey),
                      onChange: (value) => void setConfigEnabled("gemini", index2, value)
                    }
                  )
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Card,
            {
              title: t2("ai_providers.codex_title"),
              extra: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  size: "sm",
                  onClick: () => openProviderModal("codex", null),
                  disabled: disableControls || saving || Boolean(configSwitchingKey),
                  children: t2("ai_providers.codex_add_button")
                }
              ),
              children: renderList(
                codexConfigs,
                (item) => item.apiKey,
                (item, _index) => {
                  var _a3;
                  const stats2 = getStatsBySource(item.apiKey, keyStats, maskApiKey);
                  const headerEntries = Object.entries(item.headers || {});
                  const configDisabled = hasDisableAllModelsRule(item.excludedModels);
                  const excludedModels2 = (_a3 = item.excludedModels) != null ? _a3 : [];
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-title", children: t2("ai_providers.codex_item_title") }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.fieldRow, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.fieldLabel, children: [
                        t2("common.api_key"),
                        ":"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldValue, children: maskApiKey(item.apiKey) })
                    ] }),
                    item.baseUrl && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.fieldRow, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.fieldLabel, children: [
                        t2("common.base_url"),
                        ":"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldValue, children: item.baseUrl })
                    ] }),
                    item.proxyUrl && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.fieldRow, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.fieldLabel, children: [
                        t2("common.proxy_url"),
                        ":"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldValue, children: item.proxyUrl })
                    ] }),
                    headerEntries.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.headerBadgeList, children: headerEntries.map(([key, value]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.headerBadge, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
                        key,
                        ":"
                      ] }),
                      " ",
                      value
                    ] }, key)) }),
                    configDisabled && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-badge warning", style: { marginTop: 8, marginBottom: 0 }, children: t2("ai_providers.config_disabled_badge") }),
                    excludedModels2.length ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.excludedModelsSection, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.excludedModelsLabel, children: t2("ai_providers.excluded_models_count", { count: excludedModels2.length }) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.modelTagList, children: excludedModels2.map((model) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          className: `${styles$6.modelTag} ${styles$6.excludedModelTag}`,
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.modelName, children: model })
                        },
                        model
                      )) })
                    ] }) : null,
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.cardStats, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$6.statPill} ${styles$6.statSuccess}`, children: [
                        t2("stats.success"),
                        ": ",
                        stats2.success
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$6.statPill} ${styles$6.statFailure}`, children: [
                        t2("stats.failure"),
                        ": ",
                        stats2.failure
                      ] })
                    ] })
                  ] });
                },
                (index2) => openProviderModal("codex", index2),
                (item) => deleteProviderEntry("codex", item.apiKey),
                t2("ai_providers.codex_add_button"),
                void 0,
                {
                  getRowDisabled: (item) => hasDisableAllModelsRule(item.excludedModels),
                  renderExtraActions: (item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ToggleSwitch,
                    {
                      label: t2("ai_providers.config_toggle_label"),
                      checked: !hasDisableAllModelsRule(item.excludedModels),
                      disabled: disableControls || loading || saving || Boolean(configSwitchingKey),
                      onChange: (value) => void setConfigEnabled("codex", index2, value)
                    }
                  )
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Card,
            {
              title: t2("ai_providers.claude_title"),
              extra: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  size: "sm",
                  onClick: () => openProviderModal("claude", null),
                  disabled: disableControls || saving || Boolean(configSwitchingKey),
                  children: t2("ai_providers.claude_add_button")
                }
              ),
              children: renderList(
                claudeConfigs,
                (item) => item.apiKey,
                (item, _index) => {
                  var _a3, _b2;
                  const stats2 = getStatsBySource(item.apiKey, keyStats, maskApiKey);
                  const headerEntries = Object.entries(item.headers || {});
                  const configDisabled = hasDisableAllModelsRule(item.excludedModels);
                  const excludedModels2 = (_a3 = item.excludedModels) != null ? _a3 : [];
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-title", children: t2("ai_providers.claude_item_title") }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.fieldRow, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.fieldLabel, children: [
                        t2("common.api_key"),
                        ":"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldValue, children: maskApiKey(item.apiKey) })
                    ] }),
                    item.baseUrl && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.fieldRow, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.fieldLabel, children: [
                        t2("common.base_url"),
                        ":"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldValue, children: item.baseUrl })
                    ] }),
                    item.proxyUrl && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.fieldRow, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.fieldLabel, children: [
                        t2("common.proxy_url"),
                        ":"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldValue, children: item.proxyUrl })
                    ] }),
                    headerEntries.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.headerBadgeList, children: headerEntries.map(([key, value]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.headerBadge, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
                        key,
                        ":"
                      ] }),
                      " ",
                      value
                    ] }, key)) }),
                    configDisabled && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-badge warning", style: { marginTop: 8, marginBottom: 0 }, children: t2("ai_providers.config_disabled_badge") }),
                    ((_b2 = item.models) == null ? void 0 : _b2.length) ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.modelTagList, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.modelCountLabel, children: [
                        t2("ai_providers.claude_models_count"),
                        ": ",
                        item.models.length
                      ] }),
                      item.models.map((model) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.modelTag, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.modelName, children: model.name }),
                        model.alias && model.alias !== model.name && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.modelAlias, children: model.alias })
                      ] }, model.name))
                    ] }) : null,
                    excludedModels2.length ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.excludedModelsSection, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.excludedModelsLabel, children: t2("ai_providers.excluded_models_count", { count: excludedModels2.length }) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.modelTagList, children: excludedModels2.map((model) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          className: `${styles$6.modelTag} ${styles$6.excludedModelTag}`,
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.modelName, children: model })
                        },
                        model
                      )) })
                    ] }) : null,
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.cardStats, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$6.statPill} ${styles$6.statSuccess}`, children: [
                        t2("stats.success"),
                        ": ",
                        stats2.success
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$6.statPill} ${styles$6.statFailure}`, children: [
                        t2("stats.failure"),
                        ": ",
                        stats2.failure
                      ] })
                    ] })
                  ] });
                },
                (index2) => openProviderModal("claude", index2),
                (item) => deleteProviderEntry("claude", item.apiKey),
                t2("ai_providers.claude_add_button"),
                void 0,
                {
                  getRowDisabled: (item) => hasDisableAllModelsRule(item.excludedModels),
                  renderExtraActions: (item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ToggleSwitch,
                    {
                      label: t2("ai_providers.config_toggle_label"),
                      checked: !hasDisableAllModelsRule(item.excludedModels),
                      disabled: disableControls || loading || saving || Boolean(configSwitchingKey),
                      onChange: (value) => void setConfigEnabled("claude", index2, value)
                    }
                  )
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Card,
            {
              title: t2("ai_providers.ampcode_title"),
              extra: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  size: "sm",
                  onClick: openAmpcodeModal,
                  disabled: disableControls || saving || ampcodeSaving || Boolean(configSwitchingKey),
                  children: t2("common.edit")
                }
              ),
              children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("common.loading") }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.fieldRow, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.fieldLabel, children: [
                    t2("ai_providers.ampcode_upstream_url_label"),
                    ":"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldValue, children: ((_a2 = config2 == null ? void 0 : config2.ampcode) == null ? void 0 : _a2.upstreamUrl) || t2("common.not_set") })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.fieldRow, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.fieldLabel, children: [
                    t2("ai_providers.ampcode_upstream_api_key_label"),
                    ":"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldValue, children: ((_b = config2 == null ? void 0 : config2.ampcode) == null ? void 0 : _b.upstreamApiKey) ? maskApiKey(config2.ampcode.upstreamApiKey) : t2("common.not_set") })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.fieldRow, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.fieldLabel, children: [
                    t2("ai_providers.ampcode_restrict_management_label"),
                    ":"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldValue, children: ((_d = (_c = config2 == null ? void 0 : config2.ampcode) == null ? void 0 : _c.restrictManagementToLocalhost) != null ? _d : true) ? t2("common.yes") : t2("common.no") })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.fieldRow, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.fieldLabel, children: [
                    t2("ai_providers.ampcode_force_model_mappings_label"),
                    ":"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldValue, children: ((_f = (_e = config2 == null ? void 0 : config2.ampcode) == null ? void 0 : _e.forceModelMappings) != null ? _f : false) ? t2("common.yes") : t2("common.no") })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.fieldRow, style: { marginTop: 8 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.fieldLabel, children: [
                    t2("ai_providers.ampcode_model_mappings_count"),
                    ":"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldValue, children: ((_h = (_g = config2 == null ? void 0 : config2.ampcode) == null ? void 0 : _g.modelMappings) == null ? void 0 : _h.length) || 0 })
                ] }),
                ((_j = (_i = config2 == null ? void 0 : config2.ampcode) == null ? void 0 : _i.modelMappings) == null ? void 0 : _j.length) ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.modelTagList, children: [
                  config2.ampcode.modelMappings.slice(0, 5).map((mapping) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.modelTag, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.modelName, children: mapping.from }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.modelAlias, children: mapping.to })
                  ] }, `${mapping.from}${mapping.to}`)),
                  config2.ampcode.modelMappings.length > 5 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.modelTag, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.modelName, children: [
                    "+",
                    config2.ampcode.modelMappings.length - 5
                  ] }) })
                ] }) : null
              ] })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Card,
            {
              title: t2("ai_providers.openai_title"),
              extra: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  size: "sm",
                  onClick: () => openOpenaiModal(null),
                  disabled: disableControls || saving || Boolean(configSwitchingKey),
                  children: t2("ai_providers.openai_add_button")
                }
              ),
              children: renderList(
                openaiProviders,
                (item) => item.name,
                (item, _index) => {
                  var _a3, _b2;
                  const stats2 = getOpenAIProviderStats(item.apiKeyEntries, keyStats, maskApiKey);
                  const headerEntries = Object.entries(item.headers || {});
                  const apiKeyEntries = item.apiKeyEntries || [];
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-title", children: item.name }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.fieldRow, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.fieldLabel, children: [
                        t2("common.base_url"),
                        ":"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldValue, children: item.baseUrl })
                    ] }),
                    headerEntries.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.headerBadgeList, children: headerEntries.map(([key, value]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.headerBadge, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
                        key,
                        ":"
                      ] }),
                      " ",
                      value
                    ] }, key)) }),
                    apiKeyEntries.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.apiKeyEntriesSection, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.apiKeyEntriesLabel, children: [
                        t2("ai_providers.openai_keys_count"),
                        ": ",
                        apiKeyEntries.length
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.apiKeyEntryList, children: apiKeyEntries.map((entry, entryIndex) => {
                        const entryStats = getStatsBySource(entry.apiKey, keyStats, maskApiKey);
                        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.apiKeyEntryCard, children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.apiKeyEntryIndex, children: entryIndex + 1 }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.apiKeyEntryKey, children: maskApiKey(entry.apiKey) }),
                          entry.proxyUrl && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.apiKeyEntryProxy, children: entry.proxyUrl }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.apiKeyEntryStats, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsxs(
                              "span",
                              {
                                className: `${styles$6.apiKeyEntryStat} ${styles$6.apiKeyEntryStatSuccess}`,
                                children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsx(IconCheck, { size: 12 }),
                                  " ",
                                  entryStats.success
                                ]
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs(
                              "span",
                              {
                                className: `${styles$6.apiKeyEntryStat} ${styles$6.apiKeyEntryStatFailure}`,
                                children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsx(IconX, { size: 12 }),
                                  " ",
                                  entryStats.failure
                                ]
                              }
                            )
                          ] })
                        ] }, entryIndex);
                      }) })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.fieldRow, style: { marginTop: "8px" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.fieldLabel, children: [
                        t2("ai_providers.openai_models_count"),
                        ":"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldValue, children: ((_a3 = item.models) == null ? void 0 : _a3.length) || 0 })
                    ] }),
                    ((_b2 = item.models) == null ? void 0 : _b2.length) ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.modelTagList, children: item.models.map((model) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$6.modelTag, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.modelName, children: model.name }),
                      model.alias && model.alias !== model.name && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.modelAlias, children: model.alias })
                    ] }, model.name)) }) : null,
                    item.testModel && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.fieldRow, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldLabel, children: "Test Model:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.fieldValue, children: item.testModel })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.cardStats, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$6.statPill} ${styles$6.statSuccess}`, children: [
                        t2("stats.success"),
                        ": ",
                        stats2.success
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$6.statPill} ${styles$6.statFailure}`, children: [
                        t2("stats.failure"),
                        ": ",
                        stats2.failure
                      ] })
                    ] })
                  ] });
                },
                (index2) => openOpenaiModal(index2),
                (item) => deleteOpenai(item.name),
                t2("ai_providers.openai_add_button")
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Modal,
            {
              open: (modal == null ? void 0 : modal.type) === "ampcode",
              onClose: closeModal,
              title: t2("ai_providers.ampcode_modal_title"),
              footer: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: closeModal, disabled: ampcodeSaving, children: t2("common.cancel") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    onClick: saveAmpcode,
                    loading: ampcodeSaving,
                    disabled: disableControls || ampcodeModalLoading,
                    children: t2("common.save")
                  }
                )
              ] }),
              children: [
                ampcodeModalError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-box", children: ampcodeModalError }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    label: t2("ai_providers.ampcode_upstream_url_label"),
                    placeholder: t2("ai_providers.ampcode_upstream_url_placeholder"),
                    value: ampcodeForm.upstreamUrl,
                    onChange: (e) => setAmpcodeForm((prev) => __spreadProps(__spreadValues({}, prev), { upstreamUrl: e.target.value })),
                    disabled: ampcodeModalLoading || ampcodeSaving,
                    hint: t2("ai_providers.ampcode_upstream_url_hint")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    label: t2("ai_providers.ampcode_upstream_api_key_label"),
                    placeholder: t2("ai_providers.ampcode_upstream_api_key_placeholder"),
                    type: "password",
                    value: ampcodeForm.upstreamApiKey,
                    onChange: (e) => setAmpcodeForm((prev) => __spreadProps(__spreadValues({}, prev), { upstreamApiKey: e.target.value })),
                    disabled: ampcodeModalLoading || ampcodeSaving,
                    hint: t2("ai_providers.ampcode_upstream_api_key_hint")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      display: "flex",
                      gap: 8,
                      alignItems: "center",
                      marginTop: -8,
                      marginBottom: 12,
                      flexWrap: "wrap"
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", style: { margin: 0 }, children: t2("ai_providers.ampcode_upstream_api_key_current", {
                        key: ((_k = config2 == null ? void 0 : config2.ampcode) == null ? void 0 : _k.upstreamApiKey) ? maskApiKey(config2.ampcode.upstreamApiKey) : t2("common.not_set")
                      }) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Button,
                        {
                          variant: "danger",
                          size: "sm",
                          onClick: clearAmpcodeUpstreamApiKey,
                          disabled: ampcodeModalLoading || ampcodeSaving || !((_l = config2 == null ? void 0 : config2.ampcode) == null ? void 0 : _l.upstreamApiKey),
                          children: t2("ai_providers.ampcode_clear_upstream_api_key")
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ToggleSwitch,
                    {
                      label: t2("ai_providers.ampcode_restrict_management_label"),
                      checked: ampcodeForm.restrictManagementToLocalhost,
                      onChange: (value) => setAmpcodeForm((prev) => __spreadProps(__spreadValues({}, prev), { restrictManagementToLocalhost: value })),
                      disabled: ampcodeModalLoading || ampcodeSaving
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("ai_providers.ampcode_restrict_management_hint") })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ToggleSwitch,
                    {
                      label: t2("ai_providers.ampcode_force_model_mappings_label"),
                      checked: ampcodeForm.forceModelMappings,
                      onChange: (value) => setAmpcodeForm((prev) => __spreadProps(__spreadValues({}, prev), { forceModelMappings: value })),
                      disabled: ampcodeModalLoading || ampcodeSaving
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("ai_providers.ampcode_force_model_mappings_hint") })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("ai_providers.ampcode_model_mappings_label") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ModelInputList,
                    {
                      entries: ampcodeForm.mappingEntries,
                      onChange: (entries) => {
                        setAmpcodeMappingsDirty(true);
                        setAmpcodeForm((prev) => __spreadProps(__spreadValues({}, prev), { mappingEntries: entries }));
                      },
                      addLabel: t2("ai_providers.ampcode_model_mappings_add_btn"),
                      namePlaceholder: t2("ai_providers.ampcode_model_mappings_from_placeholder"),
                      aliasPlaceholder: t2("ai_providers.ampcode_model_mappings_to_placeholder"),
                      disabled: ampcodeModalLoading || ampcodeSaving
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("ai_providers.ampcode_model_mappings_hint") })
                ] })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Modal,
            {
              open: (modal == null ? void 0 : modal.type) === "gemini",
              onClose: closeModal,
              title: (modal == null ? void 0 : modal.index) !== null ? t2("ai_providers.gemini_edit_modal_title") : t2("ai_providers.gemini_add_modal_title"),
              footer: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: closeModal, disabled: saving, children: t2("common.cancel") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: saveGemini, loading: saving, children: t2("common.save") })
              ] }),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    label: t2("ai_providers.gemini_add_modal_key_label"),
                    placeholder: t2("ai_providers.gemini_add_modal_key_placeholder"),
                    value: geminiForm.apiKey,
                    onChange: (e) => setGeminiForm((prev) => __spreadProps(__spreadValues({}, prev), { apiKey: e.target.value }))
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    label: t2("ai_providers.gemini_base_url_label"),
                    placeholder: t2("ai_providers.gemini_base_url_placeholder"),
                    value: (_m = geminiForm.baseUrl) != null ? _m : "",
                    onChange: (e) => setGeminiForm((prev) => __spreadProps(__spreadValues({}, prev), { baseUrl: e.target.value }))
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  HeaderInputList,
                  {
                    entries: headersToEntries(geminiForm.headers),
                    onChange: (entries) => setGeminiForm((prev) => __spreadProps(__spreadValues({}, prev), { headers: buildHeaderObject(entries) })),
                    addLabel: t2("common.custom_headers_add"),
                    keyPlaceholder: t2("common.custom_headers_key_placeholder"),
                    valuePlaceholder: t2("common.custom_headers_value_placeholder")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("ai_providers.excluded_models_label") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "textarea",
                    {
                      className: "input",
                      placeholder: t2("ai_providers.excluded_models_placeholder"),
                      value: geminiForm.excludedText,
                      onChange: (e) => setGeminiForm((prev) => __spreadProps(__spreadValues({}, prev), { excludedText: e.target.value })),
                      rows: 4
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("ai_providers.excluded_models_hint") })
                ] })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Modal,
            {
              open: (modal == null ? void 0 : modal.type) === "codex" || (modal == null ? void 0 : modal.type) === "claude",
              onClose: closeModal,
              title: (modal == null ? void 0 : modal.type) === "codex" ? modal.index !== null ? t2("ai_providers.codex_edit_modal_title") : t2("ai_providers.codex_add_modal_title") : (modal == null ? void 0 : modal.type) === "claude" && modal.index !== null ? t2("ai_providers.claude_edit_modal_title") : t2("ai_providers.claude_add_modal_title"),
              footer: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: closeModal, disabled: saving, children: t2("common.cancel") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    onClick: () => saveProvider(modal == null ? void 0 : modal.type),
                    loading: saving,
                    children: t2("common.save")
                  }
                )
              ] }),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    label: (modal == null ? void 0 : modal.type) === "codex" ? t2("ai_providers.codex_add_modal_key_label") : t2("ai_providers.claude_add_modal_key_label"),
                    value: providerForm.apiKey,
                    onChange: (e) => setProviderForm((prev) => __spreadProps(__spreadValues({}, prev), { apiKey: e.target.value }))
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    label: (modal == null ? void 0 : modal.type) === "codex" ? t2("ai_providers.codex_add_modal_url_label") : t2("ai_providers.claude_add_modal_url_label"),
                    value: (_n = providerForm.baseUrl) != null ? _n : "",
                    onChange: (e) => setProviderForm((prev) => __spreadProps(__spreadValues({}, prev), { baseUrl: e.target.value }))
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    label: (modal == null ? void 0 : modal.type) === "codex" ? t2("ai_providers.codex_add_modal_proxy_label") : t2("ai_providers.claude_add_modal_proxy_label"),
                    value: (_o = providerForm.proxyUrl) != null ? _o : "",
                    onChange: (e) => setProviderForm((prev) => __spreadProps(__spreadValues({}, prev), { proxyUrl: e.target.value }))
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  HeaderInputList,
                  {
                    entries: headersToEntries(providerForm.headers),
                    onChange: (entries) => setProviderForm((prev) => __spreadProps(__spreadValues({}, prev), { headers: buildHeaderObject(entries) })),
                    addLabel: t2("common.custom_headers_add"),
                    keyPlaceholder: t2("common.custom_headers_key_placeholder"),
                    valuePlaceholder: t2("common.custom_headers_value_placeholder")
                  }
                ),
                (modal == null ? void 0 : modal.type) === "claude" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("ai_providers.claude_models_label") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ModelInputList,
                    {
                      entries: providerForm.modelEntries,
                      onChange: (entries) => setProviderForm((prev) => __spreadProps(__spreadValues({}, prev), { modelEntries: entries })),
                      addLabel: t2("ai_providers.claude_models_add_btn"),
                      namePlaceholder: t2("common.model_name_placeholder"),
                      aliasPlaceholder: t2("common.model_alias_placeholder"),
                      disabled: saving
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("ai_providers.excluded_models_label") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "textarea",
                    {
                      className: "input",
                      placeholder: t2("ai_providers.excluded_models_placeholder"),
                      value: providerForm.excludedText,
                      onChange: (e) => setProviderForm((prev) => __spreadProps(__spreadValues({}, prev), { excludedText: e.target.value })),
                      rows: 4
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("ai_providers.excluded_models_hint") })
                ] })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Modal,
            {
              open: (modal == null ? void 0 : modal.type) === "openai",
              onClose: closeModal,
              title: (modal == null ? void 0 : modal.index) !== null ? t2("ai_providers.openai_edit_modal_title") : t2("ai_providers.openai_add_modal_title"),
              footer: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: closeModal, disabled: saving, children: t2("common.cancel") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: saveOpenai, loading: saving, children: t2("common.save") })
              ] }),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    label: t2("ai_providers.openai_add_modal_name_label"),
                    value: openaiForm.name,
                    onChange: (e) => setOpenaiForm((prev) => __spreadProps(__spreadValues({}, prev), { name: e.target.value }))
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    label: t2("ai_providers.openai_add_modal_url_label"),
                    value: openaiForm.baseUrl,
                    onChange: (e) => setOpenaiForm((prev) => __spreadProps(__spreadValues({}, prev), { baseUrl: e.target.value }))
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  HeaderInputList,
                  {
                    entries: openaiForm.headers,
                    onChange: (entries) => setOpenaiForm((prev) => __spreadProps(__spreadValues({}, prev), { headers: entries })),
                    addLabel: t2("common.custom_headers_add"),
                    keyPlaceholder: t2("common.custom_headers_key_placeholder"),
                    valuePlaceholder: t2("common.custom_headers_value_placeholder")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: (modal == null ? void 0 : modal.index) !== null ? t2("ai_providers.openai_edit_modal_models_label") : t2("ai_providers.openai_add_modal_models_label") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("ai_providers.openai_models_hint") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ModelInputList,
                    {
                      entries: openaiForm.modelEntries,
                      onChange: (entries) => setOpenaiForm((prev) => __spreadProps(__spreadValues({}, prev), { modelEntries: entries })),
                      addLabel: t2("ai_providers.openai_models_add_btn"),
                      namePlaceholder: t2("common.model_name_placeholder"),
                      aliasPlaceholder: t2("common.model_alias_placeholder"),
                      disabled: saving
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      variant: "secondary",
                      size: "sm",
                      onClick: openOpenaiModelDiscovery,
                      disabled: saving,
                      children: t2("ai_providers.openai_models_fetch_button")
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("ai_providers.openai_test_title") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("ai_providers.openai_test_hint") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8, alignItems: "center" }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "select",
                      {
                        className: `input ${styles$6.openaiTestSelect}`,
                        value: openaiTestModel,
                        onChange: (e) => {
                          setOpenaiTestModel(e.target.value);
                          setOpenaiTestStatus("idle");
                          setOpenaiTestMessage("");
                        },
                        disabled: saving || openaiAvailableModels.length === 0,
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: openaiAvailableModels.length ? t2("ai_providers.openai_test_select_placeholder") : t2("ai_providers.openai_test_select_empty") }),
                          openaiForm.modelEntries.filter((entry) => entry.name.trim()).map((entry, idx) => {
                            const name2 = entry.name.trim();
                            const alias = entry.alias.trim();
                            const label = alias && alias !== name2 ? `${name2} (${alias})` : name2;
                            return /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: name2, children: label }, `${name2}-${idx}`);
                          })
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        variant: openaiTestStatus === "error" ? "danger" : "secondary",
                        className: `${styles$6.openaiTestButton} ${openaiTestStatus === "success" ? styles$6.openaiTestButtonSuccess : ""}`,
                        onClick: testOpenaiProviderConnection,
                        loading: openaiTestStatus === "loading",
                        disabled: saving || openaiAvailableModels.length === 0,
                        children: t2("ai_providers.openai_test_action")
                      }
                    )
                  ] }),
                  openaiTestMessage && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: `status-badge ${openaiTestStatus === "error" ? "error" : openaiTestStatus === "success" ? "success" : "muted"}`,
                      children: openaiTestMessage
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("ai_providers.openai_add_modal_keys_label") }),
                  renderKeyEntries(openaiForm.apiKeyEntries)
                ] })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Modal,
            {
              open: openaiDiscoveryOpen,
              onClose: closeOpenaiModelDiscovery,
              title: t2("ai_providers.openai_models_fetch_title"),
              width: 720,
              footer: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "secondary",
                    onClick: closeOpenaiModelDiscovery,
                    disabled: openaiDiscoveryLoading,
                    children: t2("ai_providers.openai_models_fetch_back")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    onClick: applyOpenaiModelDiscoverySelection,
                    disabled: openaiDiscoveryLoading,
                    children: t2("ai_providers.openai_models_fetch_apply")
                  }
                )
              ] }),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", style: { marginBottom: 8 }, children: t2("ai_providers.openai_models_fetch_hint") }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("ai_providers.openai_models_fetch_url_label") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8, alignItems: "center" }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("input", { className: "input", readOnly: true, value: openaiDiscoveryEndpoint }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        variant: "secondary",
                        size: "sm",
                        onClick: () => fetchOpenaiModelDiscovery({ allowFallback: true }),
                        loading: openaiDiscoveryLoading,
                        children: t2("ai_providers.openai_models_fetch_refresh")
                      }
                    )
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    label: t2("ai_providers.openai_models_search_label"),
                    placeholder: t2("ai_providers.openai_models_search_placeholder"),
                    value: openaiDiscoverySearch,
                    onChange: (e) => setOpenaiDiscoverySearch(e.target.value)
                  }
                ),
                openaiDiscoveryError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-box", children: openaiDiscoveryError }),
                openaiDiscoveryLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("ai_providers.openai_models_fetch_loading") }) : openaiDiscoveryModels.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("ai_providers.openai_models_fetch_empty") }) : filteredOpenaiDiscoveryModels.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("ai_providers.openai_models_search_empty") }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.modelDiscoveryList, children: filteredOpenaiDiscoveryModels.map((model) => {
                  const checked = openaiDiscoverySelected.has(model.name);
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "label",
                    {
                      className: `${styles$6.modelDiscoveryRow} ${checked ? styles$6.modelDiscoveryRowSelected : ""}`,
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "input",
                          {
                            type: "checkbox",
                            checked,
                            onChange: () => toggleOpenaiModelSelection(model.name)
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.modelDiscoveryMeta, children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.modelDiscoveryName, children: [
                            model.name,
                            model.alias && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$6.modelDiscoveryAlias, children: model.alias })
                          ] }),
                          model.description && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.modelDiscoveryDesc, children: model.description })
                        ] })
                      ]
                    },
                    model.name
                  );
                }) })
              ]
            }
          )
        ] })
      ] });
    }
    const container$5 = "AuthFilesPage-module__container___u1c4k";
    const pageHeader = "AuthFilesPage-module__pageHeader___DVV58";
    const pageTitle$5 = "AuthFilesPage-module__pageTitle___1TOZn";
    const description$1 = "AuthFilesPage-module__description___N3RjR";
    const headerActions = "AuthFilesPage-module__headerActions___j0ROO";
    const errorBox$1 = "AuthFilesPage-module__errorBox___A9vF2";
    const filterSection = "AuthFilesPage-module__filterSection___qQ3Zo";
    const filterTags = "AuthFilesPage-module__filterTags___A24A3";
    const filterTag = "AuthFilesPage-module__filterTag___-YnCU";
    const filterTagActive = "AuthFilesPage-module__filterTagActive___Rnbcs";
    const filterControls = "AuthFilesPage-module__filterControls___PfZDU";
    const filterItem = "AuthFilesPage-module__filterItem___Kko4o";
    const pageSizeSelect = "AuthFilesPage-module__pageSizeSelect___yEBvp";
    const statsInfo = "AuthFilesPage-module__statsInfo___ALHH7";
    const fileGrid = "AuthFilesPage-module__fileGrid___ajvi5";
    const fileCard = "AuthFilesPage-module__fileCard___j9Jtq";
    const cardHeader = "AuthFilesPage-module__cardHeader___uJMtL";
    const typeBadge = "AuthFilesPage-module__typeBadge___Dtm6A";
    const fileName = "AuthFilesPage-module__fileName___DZ39s";
    const cardMeta = "AuthFilesPage-module__cardMeta___H6kAQ";
    const priorityWrapper = "AuthFilesPage-module__priorityWrapper___AiPqt";
    const priorityInput = "AuthFilesPage-module__priorityInput___nK62G";
    const priorityConfirmBtn = "AuthFilesPage-module__priorityConfirmBtn___9jbyA";
    const cardStats = "AuthFilesPage-module__cardStats___JQ4ig";
    const statPill = "AuthFilesPage-module__statPill___wFsBu";
    const statSuccess = "AuthFilesPage-module__statSuccess___mh8iR";
    const statFailure = "AuthFilesPage-module__statFailure___ivDGu";
    const cardActions = "AuthFilesPage-module__cardActions___mJgkW";
    const iconButton = "AuthFilesPage-module__iconButton___XT5TY";
    const actionIcon = "AuthFilesPage-module__actionIcon___F2TRI";
    const virtualBadge = "AuthFilesPage-module__virtualBadge___s32vc";
    const pagination = "AuthFilesPage-module__pagination___Hwpg2";
    const pageInfo$1 = "AuthFilesPage-module__pageInfo___Fkfbg";
    const excludedList = "AuthFilesPage-module__excludedList___9OGiS";
    const excludedItem = "AuthFilesPage-module__excludedItem___J3Xxa";
    const excludedInfo = "AuthFilesPage-module__excludedInfo___0hKQa";
    const excludedProvider = "AuthFilesPage-module__excludedProvider___6pkYz";
    const excludedModels = "AuthFilesPage-module__excludedModels___QdpJB";
    const excludedActions = "AuthFilesPage-module__excludedActions___jP49M";
    const detailContent = "AuthFilesPage-module__detailContent___K3wet";
    const jsonContent = "AuthFilesPage-module__jsonContent___5lYBo";
    const formGroup = "AuthFilesPage-module__formGroup___1YGlp";
    const textarea = "AuthFilesPage-module__textarea___IAg4a";
    const hint$1 = "AuthFilesPage-module__hint___YExGS";
    const modelsList = "AuthFilesPage-module__modelsList___KKhRE";
    const modelItem = "AuthFilesPage-module__modelItem___VMfPD";
    const modelId = "AuthFilesPage-module__modelId___4wMUh";
    const modelDisplayName = "AuthFilesPage-module__modelDisplayName___znKrk";
    const modelType = "AuthFilesPage-module__modelType___B0C7D";
    const modelItemExcluded = "AuthFilesPage-module__modelItemExcluded___I5sBn";
    const modelExcludedBadge = "AuthFilesPage-module__modelExcludedBadge___FyRdH";
    const quotaInfo = "AuthFilesPage-module__quotaInfo___APAGI";
    const quotaTitle = "AuthFilesPage-module__quotaTitle___zf-Cs";
    const quotaItem = "AuthFilesPage-module__quotaItem___HMmZr";
    const quotaHeader = "AuthFilesPage-module__quotaHeader___se3GH";
    const quotaModel = "AuthFilesPage-module__quotaModel___huwv6";
    const quotaValue = "AuthFilesPage-module__quotaValue___0ADP8";
    const progressBar = "AuthFilesPage-module__progressBar___2jafj";
    const progressFill = "AuthFilesPage-module__progressFill___LPOla";
    const progressNormal = "AuthFilesPage-module__progressNormal___zaTIT";
    const progressWarning = "AuthFilesPage-module__progressWarning___B0gsj";
    const progressDanger = "AuthFilesPage-module__progressDanger___2JoAM";
    const quotaReset = "AuthFilesPage-module__quotaReset___bmEse";
    const styles$5 = {
      container: container$5,
      pageHeader,
      pageTitle: pageTitle$5,
      description: description$1,
      headerActions,
      errorBox: errorBox$1,
      filterSection,
      filterTags,
      filterTag,
      filterTagActive,
      filterControls,
      filterItem,
      pageSizeSelect,
      statsInfo,
      fileGrid,
      fileCard,
      cardHeader,
      typeBadge,
      fileName,
      cardMeta,
      priorityWrapper,
      priorityInput,
      priorityConfirmBtn,
      cardStats,
      statPill,
      statSuccess,
      statFailure,
      cardActions,
      iconButton,
      actionIcon,
      virtualBadge,
      pagination,
      pageInfo: pageInfo$1,
      excludedList,
      excludedItem,
      excludedInfo,
      excludedProvider,
      excludedModels,
      excludedActions,
      detailContent,
      jsonContent,
      formGroup,
      textarea,
      hint: hint$1,
      modelsList,
      modelItem,
      modelId,
      modelDisplayName,
      modelType,
      modelItemExcluded,
      modelExcludedBadge,
      quotaInfo,
      quotaTitle,
      quotaItem,
      quotaHeader,
      quotaModel,
      quotaValue,
      progressBar,
      progressFill,
      progressNormal,
      progressWarning,
      progressDanger,
      quotaReset
    };
    const TYPE_COLORS = {
      qwen: {
        light: { bg: "#e8f5e9", text: "#2e7d32" },
        dark: { bg: "#1b5e20", text: "#81c784" }
      },
      gemini: {
        light: { bg: "#e3f2fd", text: "#1565c0" },
        dark: { bg: "#0d47a1", text: "#64b5f6" }
      },
      "gemini-cli": {
        light: { bg: "#e7efff", text: "#1e4fa3" },
        dark: { bg: "#1c3f73", text: "#a8c7ff" }
      },
      aistudio: {
        light: { bg: "#f0f2f5", text: "#2f343c" },
        dark: { bg: "#373c42", text: "#cfd3db" }
      },
      claude: {
        light: { bg: "#fce4ec", text: "#c2185b" },
        dark: { bg: "#880e4f", text: "#f48fb1" }
      },
      codex: {
        light: { bg: "#fff3e0", text: "#ef6c00" },
        dark: { bg: "#e65100", text: "#ffb74d" }
      },
      antigravity: {
        light: { bg: "#e0f7fa", text: "#006064" },
        dark: { bg: "#004d40", text: "#80deea" }
      },
      iflow: {
        light: { bg: "#f3e5f5", text: "#7b1fa2" },
        dark: { bg: "#4a148c", text: "#ce93d8" }
      },
      kiro: {
        light: { bg: "#fff8e1", text: "#ff8f00" },
        dark: { bg: "#ff6f00", text: "#ffe082" }
      },
      empty: {
        light: { bg: "#f5f5f5", text: "#616161" },
        dark: { bg: "#424242", text: "#bdbdbd" }
      },
      unknown: {
        light: { bg: "#f0f0f0", text: "#666666", border: "1px dashed #999999" },
        dark: { bg: "#3a3a3a", text: "#aaaaaa", border: "1px dashed #666666" }
      }
    };
    function normalizeAuthIndexValue(value) {
      if (typeof value === "number" && Number.isFinite(value)) {
        return value.toString();
      }
      if (typeof value === "string") {
        const trimmed = value.trim();
        return trimmed ? trimmed : null;
      }
      return null;
    }
    function isRuntimeOnlyAuthFile(file) {
      var _a2;
      const raw = (_a2 = file["runtime_only"]) != null ? _a2 : file.runtimeOnly;
      if (typeof raw === "boolean") return raw;
      if (typeof raw === "string") return raw.trim().toLowerCase() === "true";
      return false;
    }
    function resolveAuthFileStats(file, stats2) {
      var _a2, _b, _c, _d;
      const defaultStats = { success: 0, failure: 0 };
      const rawFileName = (file == null ? void 0 : file.name) || "";
      const rawAuthIndex = (_a2 = file["auth_index"]) != null ? _a2 : file.authIndex;
      const authIndexKey = normalizeAuthIndexValue(rawAuthIndex);
      if (authIndexKey && ((_b = stats2.byAuthIndex) == null ? void 0 : _b[authIndexKey])) {
        return stats2.byAuthIndex[authIndexKey];
      }
      if (rawFileName && ((_c = stats2.bySource) == null ? void 0 : _c[rawFileName])) {
        const fromName = stats2.bySource[rawFileName];
        if (fromName.success > 0 || fromName.failure > 0) {
          return fromName;
        }
      }
      if (rawFileName) {
        const nameWithoutExt = rawFileName.replace(/\.[^/.]+$/, "");
        if (nameWithoutExt && nameWithoutExt !== rawFileName) {
          const fromNameWithoutExt = (_d = stats2.bySource) == null ? void 0 : _d[nameWithoutExt];
          if (fromNameWithoutExt && (fromNameWithoutExt.success > 0 || fromNameWithoutExt.failure > 0)) {
            return fromNameWithoutExt;
          }
        }
      }
      return defaultStats;
    }
    const formatTimeUntilReset = (resetTime, now) => {
      if (!resetTime) return "";
      const resetDate = new Date(resetTime);
      const ms = resetDate.getTime() - now.getTime();
      if (ms <= 0) {
        return "";
      }
      const seconds = Math.floor(ms / 1e3);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);
      if (days > 0) {
        return `${days}${hours % 24}`;
      } else if (hours > 0) {
        return `${hours}${minutes % 60}`;
      } else if (minutes > 0) {
        return `${minutes}${seconds % 60}`;
      }
      return `${seconds}`;
    };
    function AuthFilesPage() {
      const { t: t2 } = useTranslation();
      const { showNotification } = useNotificationStore();
      const connectionStatus = useAuthStore((state) => state.connectionStatus);
      const theme2 = useThemeStore((state) => state.theme);
      const [files, setFiles] = reactExports.useState([]);
      const [loading, setLoading] = reactExports.useState(true);
      const [error2, setError] = reactExports.useState("");
      const [filter, setFilter] = reactExports.useState("all");
      const [search2, setSearch] = reactExports.useState("");
      const [page, setPage] = reactExports.useState(1);
      const [pageSize, setPageSize] = reactExports.useState(9);
      const [uploading, setUploading] = reactExports.useState(false);
      const [deleting, setDeleting] = reactExports.useState(null);
      const [deletingAll, setDeletingAll] = reactExports.useState(false);
      const [keyStats, setKeyStats] = reactExports.useState({ bySource: {}, byAuthIndex: {} });
      const [antigravityQuotas, setAntigravityQuotas] = reactExports.useState({});
      const [kiroUsageLimits, setKiroUsageLimits] = reactExports.useState({});
      const [quotaRefreshInterval, setQuotaRefreshInterval] = reactExports.useState(() => {
        const saved2 = localStorage.getItem("quotaRefreshInterval");
        return saved2 ? parseInt(saved2) : 1;
      });
      const [currentTime, setCurrentTime] = reactExports.useState(/* @__PURE__ */ new Date());
      const [priorityInputs, setPriorityInputs] = reactExports.useState({});
      const [detailModalOpen, setDetailModalOpen] = reactExports.useState(false);
      const [selectedFile, setSelectedFile] = reactExports.useState(null);
      const [modelsModalOpen, setModelsModalOpen] = reactExports.useState(false);
      const [modelsLoading, setModelsLoading] = reactExports.useState(false);
      const [modelsList2, setModelsList] = reactExports.useState([]);
      const [modelsFileName, setModelsFileName] = reactExports.useState("");
      const [modelsFileType, setModelsFileType] = reactExports.useState("");
      const [modelsError, setModelsError] = reactExports.useState(null);
      const [excluded, setExcluded] = reactExports.useState({});
      const [excludedError, setExcludedError] = reactExports.useState(null);
      const [excludedModalOpen, setExcludedModalOpen] = reactExports.useState(false);
      const [excludedForm, setExcludedForm] = reactExports.useState({ provider: "", modelsText: "" });
      const [savingExcluded, setSavingExcluded] = reactExports.useState(false);
      const fileInputRef = reactExports.useRef(null);
      const excludedUnsupportedRef = reactExports.useRef(false);
      const disableControls = connectionStatus !== "connected";
      const formatModified = (item) => {
        var _a2;
        const raw = (_a2 = item["modtime"]) != null ? _a2 : item.modified;
        if (!raw) return "-";
        const asNumber = Number(raw);
        const date = Number.isFinite(asNumber) && !Number.isNaN(asNumber) ? new Date(asNumber < 1e12 ? asNumber * 1e3 : asNumber) : new Date(String(raw));
        return Number.isNaN(date.getTime()) ? "-" : date.toLocaleString();
      };
      const loadFiles = reactExports.useCallback(() => __async(null, null, function* () {
        setLoading(true);
        setError("");
        try {
          const data = yield authFilesApi.list();
          setFiles((data == null ? void 0 : data.files) || []);
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : t2("notification.refresh_failed");
          setError(errorMessage);
        } finally {
          setLoading(false);
        }
      }), [t2]);
      const loadKeyStats = reactExports.useCallback(() => __async(null, null, function* () {
        try {
          const stats2 = yield usageApi.getKeyStats();
          setKeyStats(stats2);
        } catch (e) {
        }
      }), []);
      const loadAntigravityQuotas = reactExports.useCallback(() => __async(null, null, function* () {
        try {
          const quotas = yield authFilesApi.getAntigravityQuotas();
          setAntigravityQuotas(quotas);
        } catch (e) {
        }
      }), []);
      const loadKiroUsageLimits = reactExports.useCallback((fileList) => __async(null, null, function* () {
        const kiroFiles = fileList.filter((f) => f.type === "kiro");
        if (kiroFiles.length === 0) return;
        const newLimits = {};
        for (const file of kiroFiles) {
          try {
            const usage = yield authFilesApi.getKiroUsageLimits(file.name);
            if (usage) {
              newLimits[file.name] = usage;
            }
          } catch (e) {
          }
        }
        setKiroUsageLimits(newLimits);
      }), []);
      const loadExcluded = reactExports.useCallback(() => __async(null, null, function* () {
        try {
          const res = yield authFilesApi.getOauthExcludedModels();
          excludedUnsupportedRef.current = false;
          setExcluded(res || {});
          setExcludedError(null);
        } catch (err) {
          const status2 = typeof err === "object" && err !== null && "status" in err ? err.status : void 0;
          if (status2 === 404) {
            setExcluded({});
            setExcludedError("unsupported");
            if (!excludedUnsupportedRef.current) {
              excludedUnsupportedRef.current = true;
              showNotification(t2("oauth_excluded.upgrade_required"), "warning");
            }
            return;
          }
        }
      }), [showNotification, t2]);
      reactExports.useEffect(() => {
        localStorage.setItem("quotaRefreshInterval", quotaRefreshInterval.toString());
      }, [quotaRefreshInterval]);
      reactExports.useEffect(() => {
        loadFiles();
        loadKeyStats();
        loadAntigravityQuotas();
        loadExcluded();
        const quotaRefreshIntervalId = setInterval(() => {
          loadAntigravityQuotas();
          authFilesApi.list().then((data) => {
            if (data == null ? void 0 : data.files) {
              loadKiroUsageLimits(data.files);
            }
          }).catch(() => {
          });
        }, quotaRefreshInterval * 60 * 1e3);
        const timeUpdateIntervalId = setInterval(() => {
          setCurrentTime(/* @__PURE__ */ new Date());
        }, 1e3);
        return () => {
          clearInterval(quotaRefreshIntervalId);
          clearInterval(timeUpdateIntervalId);
        };
      }, [loadFiles, loadKeyStats, loadExcluded, loadAntigravityQuotas, quotaRefreshInterval]);
      reactExports.useEffect(() => {
        if (files.length > 0) {
          loadKiroUsageLimits(files);
        }
      }, [files, loadKiroUsageLimits]);
      const existingTypes = reactExports.useMemo(() => {
        const types2 = /* @__PURE__ */ new Set(["all"]);
        files.forEach((file) => {
          if (file.type) {
            types2.add(file.type);
          }
        });
        return Array.from(types2);
      }, [files]);
      const filtered = reactExports.useMemo(() => {
        return files.filter((item) => {
          const matchType = filter === "all" || item.type === filter;
          const term = search2.trim().toLowerCase();
          const matchSearch = !term || item.name.toLowerCase().includes(term) || (item.type || "").toString().toLowerCase().includes(term) || (item.provider || "").toString().toLowerCase().includes(term);
          return matchType && matchSearch;
        });
      }, [files, filter, search2]);
      const totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
      const currentPage = Math.min(page, totalPages);
      const start = (currentPage - 1) * pageSize;
      const pageItems = filtered.slice(start, start + pageSize);
      const totalSize = reactExports.useMemo(() => files.reduce((sum, item) => sum + (item.size || 0), 0), [files]);
      const handleUploadClick = () => {
        var _a2;
        (_a2 = fileInputRef.current) == null ? void 0 : _a2.click();
      };
      const handleFileChange = (event) => __async(null, null, function* () {
        const fileList = event.target.files;
        if (!fileList || fileList.length === 0) return;
        const filesToUpload = Array.from(fileList);
        const validFiles = [];
        const invalidFiles = [];
        filesToUpload.forEach((file) => {
          if (file.name.endsWith(".json")) {
            validFiles.push(file);
          } else {
            invalidFiles.push(file.name);
          }
        });
        if (invalidFiles.length > 0) {
          showNotification(t2("auth_files.upload_error_json"), "error");
        }
        if (validFiles.length === 0) {
          event.target.value = "";
          return;
        }
        setUploading(true);
        let successCount = 0;
        const failed = [];
        for (const file of validFiles) {
          try {
            yield authFilesApi.upload(file);
            successCount++;
          } catch (err) {
            const errorMessage = err instanceof Error ? err.message : "Unknown error";
            failed.push({ name: file.name, message: errorMessage });
          }
        }
        if (successCount > 0) {
          const suffix = validFiles.length > 1 ? ` (${successCount}/${validFiles.length})` : "";
          showNotification(`${t2("auth_files.upload_success")}${suffix}`, failed.length ? "warning" : "success");
          yield loadFiles();
          yield loadKeyStats();
        }
        if (failed.length > 0) {
          const details = failed.map((item) => `${item.name}: ${item.message}`).join("; ");
          showNotification(`${t2("notification.upload_failed")}: ${details}`, "error");
        }
        setUploading(false);
        event.target.value = "";
      });
      const handlePriorityChange = (name2, priority) => __async(null, null, function* () {
        try {
          yield authFilesApi.updatePriority(name2, priority);
          setFiles(
            (prev) => prev.map(
              (file) => file.name === name2 ? __spreadProps(__spreadValues({}, file), { priority }) : file
            )
          );
          setPriorityInputs((prev) => {
            const newInputs = __spreadValues({}, prev);
            delete newInputs[name2];
            return newInputs;
          });
          showNotification(t2("auth_files.priority_update_success", { defaultValue: "" }), "success");
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : "";
          showNotification(`${t2("auth_files.priority_update_failed", { defaultValue: "" })}: ${errorMessage}`, "error");
        }
      });
      const getPriorityValue = (name2, filePriority) => {
        return priorityInputs[name2] !== void 0 ? priorityInputs[name2] : filePriority || 0;
      };
      const handleDelete = (name2) => __async(null, null, function* () {
        if (!window.confirm(`${t2("auth_files.delete_confirm")} "${name2}" ?`)) return;
        setDeleting(name2);
        try {
          yield authFilesApi.deleteFile(name2);
          showNotification(t2("auth_files.delete_success"), "success");
          setFiles((prev) => prev.filter((item) => item.name !== name2));
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : "";
          showNotification(`${t2("notification.delete_failed")}: ${errorMessage}`, "error");
        } finally {
          setDeleting(null);
        }
      });
      const handleDeleteAll = () => __async(null, null, function* () {
        const isFiltered = filter !== "all";
        const typeLabel = isFiltered ? getTypeLabel(filter) : t2("auth_files.filter_all");
        const confirmMessage = isFiltered ? t2("auth_files.delete_filtered_confirm", { type: typeLabel }) : t2("auth_files.delete_all_confirm");
        if (!window.confirm(confirmMessage)) return;
        setDeletingAll(true);
        try {
          if (!isFiltered) {
            yield authFilesApi.deleteAll();
            showNotification(t2("auth_files.delete_all_success"), "success");
            setFiles((prev) => prev.filter((file) => isRuntimeOnlyAuthFile(file)));
          } else {
            const filesToDelete = files.filter(
              (f) => f.type === filter && !isRuntimeOnlyAuthFile(f)
            );
            if (filesToDelete.length === 0) {
              showNotification(t2("auth_files.delete_filtered_none", { type: typeLabel }), "info");
              setDeletingAll(false);
              return;
            }
            let success = 0;
            let failed = 0;
            const deletedNames = [];
            for (const file of filesToDelete) {
              try {
                yield authFilesApi.deleteFile(file.name);
                success++;
                deletedNames.push(file.name);
              } catch (e) {
                failed++;
              }
            }
            setFiles((prev) => prev.filter((f) => !deletedNames.includes(f.name)));
            if (failed === 0) {
              showNotification(
                t2("auth_files.delete_filtered_success", { count: success, type: typeLabel }),
                "success"
              );
            } else {
              showNotification(
                t2("auth_files.delete_filtered_partial", { success, failed, type: typeLabel }),
                "warning"
              );
            }
            setFilter("all");
          }
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : "";
          showNotification(`${t2("notification.delete_failed")}: ${errorMessage}`, "error");
        } finally {
          setDeletingAll(false);
        }
      });
      const handleDownload = (name2) => __async(null, null, function* () {
        try {
          const response = yield apiClient.getRaw(`/auth-files/download?name=${encodeURIComponent(name2)}`, {
            responseType: "blob"
          });
          const blob = new Blob([response.data]);
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = name2;
          a.click();
          window.URL.revokeObjectURL(url);
          showNotification(t2("auth_files.download_success"), "success");
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : "";
          showNotification(`${t2("notification.download_failed")}: ${errorMessage}`, "error");
        }
      });
      const showDetails = (file) => {
        setSelectedFile(file);
        setDetailModalOpen(true);
      };
      const showModels = (item) => __async(null, null, function* () {
        setModelsFileName(item.name);
        setModelsFileType(item.type || "");
        setModelsList([]);
        setModelsError(null);
        setModelsModalOpen(true);
        setModelsLoading(true);
        try {
          const models = yield authFilesApi.getModelsForAuthFile(item.name);
          setModelsList(models);
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : "";
          if (errorMessage.includes("404") || errorMessage.includes("not found") || errorMessage.includes("Not Found")) {
            setModelsError("unsupported");
          } else {
            showNotification(`${t2("notification.load_failed")}: ${errorMessage}`, "error");
          }
        } finally {
          setModelsLoading(false);
        }
      });
      const isModelExcluded = (modelId2, providerType) => {
        const excludedModels2 = excluded[providerType] || [];
        return excludedModels2.some((pattern) => {
          if (pattern.includes("*")) {
            const regex = new RegExp("^" + pattern.replace(/\*/g, ".*") + "$", "i");
            return regex.test(modelId2);
          }
          return pattern.toLowerCase() === modelId2.toLowerCase();
        });
      };
      const getTypeLabel = (type) => {
        const key = `auth_files.filter_${type}`;
        const translated = t2(key);
        if (translated !== key) return translated;
        if (type.toLowerCase() === "iflow") return "iFlow";
        return type.charAt(0).toUpperCase() + type.slice(1);
      };
      const getTypeColor = (type) => {
        const set2 = TYPE_COLORS[type] || TYPE_COLORS.unknown;
        return theme2 === "dark" && set2.dark ? set2.dark : set2.light;
      };
      const openExcludedModal = (provider) => {
        const models = provider ? excluded[provider] : [];
        setExcludedForm({
          provider: provider || "",
          modelsText: Array.isArray(models) ? models.join("\n") : ""
        });
        setExcludedModalOpen(true);
      };
      const saveExcludedModels = () => __async(null, null, function* () {
        const provider = excludedForm.provider.trim();
        if (!provider) {
          showNotification(t2("oauth_excluded.provider_required"), "error");
          return;
        }
        const models = excludedForm.modelsText.split(/[\n,]+/).map((item) => item.trim()).filter(Boolean);
        setSavingExcluded(true);
        try {
          if (models.length) {
            yield authFilesApi.saveOauthExcludedModels(provider, models);
          } else {
            yield authFilesApi.deleteOauthExcludedEntry(provider);
          }
          yield loadExcluded();
          showNotification(t2("oauth_excluded.save_success"), "success");
          setExcludedModalOpen(false);
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : "";
          showNotification(`${t2("oauth_excluded.save_failed")}: ${errorMessage}`, "error");
        } finally {
          setSavingExcluded(false);
        }
      });
      const deleteExcluded = (provider) => __async(null, null, function* () {
        if (!window.confirm(t2("oauth_excluded.delete_confirm", { provider }))) return;
        try {
          yield authFilesApi.deleteOauthExcludedEntry(provider);
          yield loadExcluded();
          showNotification(t2("oauth_excluded.delete_success"), "success");
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : "";
          showNotification(`${t2("oauth_excluded.delete_failed")}: ${errorMessage}`, "error");
        }
      });
      const renderFilterTags = () => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.filterTags, children: existingTypes.map((type) => {
        const isActive = filter === type;
        const color2 = type === "all" ? { bg: "var(--bg-tertiary)", text: "var(--text-primary)" } : getTypeColor(type);
        const activeTextColor = theme2 === "dark" ? "#111827" : "#fff";
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `${styles$5.filterTag} ${isActive ? styles$5.filterTagActive : ""}`,
            style: {
              backgroundColor: isActive ? color2.text : color2.bg,
              color: isActive ? activeTextColor : color2.text,
              borderColor: color2.text
            },
            onClick: () => {
              setFilter(type);
              setPage(1);
            },
            children: getTypeLabel(type)
          },
          type
        );
      }) });
      const renderFileCard = (item) => {
        var _a2, _b, _c;
        const fileStats = resolveAuthFileStats(item, keyStats);
        const isRuntimeOnly = isRuntimeOnlyAuthFile(item);
        const typeColor = getTypeColor(item.type || "unknown");
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.fileCard, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.cardHeader, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: styles$5.typeBadge,
                style: __spreadValues({
                  backgroundColor: typeColor.bg,
                  color: typeColor.text
                }, typeColor.border ? { border: typeColor.border } : {}),
                children: getTypeLabel(item.type || "unknown")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.fileName, children: item.name })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.cardMeta, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              t2("auth_files.file_size"),
              ": ",
              item.size ? formatFileSize(item.size) : "-"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              t2("auth_files.file_modified"),
              ": ",
              formatModified(item)
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5.priorityWrapper, children: [
              t2("auth_files.priority", { defaultValue: "" }),
              ":",
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "number",
                  value: getPriorityValue(item.name, item.priority),
                  onChange: (e) => setPriorityInputs((prev) => __spreadProps(__spreadValues({}, prev), { [item.name]: parseInt(e.target.value) || 0 })),
                  className: styles$5.priorityInput,
                  disabled: disableControls,
                  title: t2("auth_files.priority_hint", { defaultValue: "" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: styles$5.priorityConfirmBtn,
                  onClick: () => handlePriorityChange(item.name, getPriorityValue(item.name, item.priority)),
                  disabled: disableControls || priorityInputs[item.name] === void 0,
                  title: "",
                  children: ""
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.cardStats, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$5.statPill} ${styles$5.statSuccess}`, children: [
              t2("stats.success"),
              ": ",
              fileStats.success
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$5.statPill} ${styles$5.statFailure}`, children: [
              t2("stats.failure"),
              ": ",
              fileStats.failure
            ] })
          ] }),
          item.type === "antigravity" && antigravityQuotas[item.name] && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.quotaInfo, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.quotaTitle, children: [
              " (",
              Object.keys(antigravityQuotas[item.name]).length,
              " )"
            ] }),
            Object.entries(antigravityQuotas[item.name]).map(([modelId2, quota]) => {
              const remainingPercent = quota.remaining * 100;
              const progressClass = remainingPercent >= 70 ? styles$5.progressNormal : remainingPercent >= 30 ? styles$5.progressWarning : styles$5.progressDanger;
              const resetCountdown = formatTimeUntilReset(quota.resetTime, currentTime);
              return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.quotaItem, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.quotaHeader, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.quotaModel, children: modelId2 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5.quotaValue, children: [
                    ": ",
                    remainingPercent.toFixed(1),
                    "%"
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${styles$5.progressBar} ${progressClass}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.progressFill, style: { width: `${remainingPercent}%` } }) }),
                resetCountdown && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.quotaReset, children: resetCountdown })
              ] }, modelId2);
            })
          ] }),
          item.type === "kiro" && kiroUsageLimits[item.name] && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.quotaInfo, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.quotaTitle, children: [
              " ",
              ((_a2 = kiroUsageLimits[item.name].userInfo) == null ? void 0 : _a2.email) && `(${(_b = kiroUsageLimits[item.name].userInfo) == null ? void 0 : _b.email})`
            ] }),
            (_c = kiroUsageLimits[item.name].usageBreakdownList) == null ? void 0 : _c.map((breakdown, idx) => {
              var _a3, _b2, _c2, _d, _e, _f, _g, _h, _i, _j, _k, _l;
              const baseUsed = (_b2 = (_a3 = breakdown.currentUsageWithPrecision) != null ? _a3 : breakdown.currentUsage) != null ? _b2 : 0;
              const baseTotal = (_d = (_c2 = breakdown.usageLimitWithPrecision) != null ? _c2 : breakdown.usageLimit) != null ? _d : 0;
              const trialUsed = (_h = (_g = (_e = breakdown.freeTrialInfo) == null ? void 0 : _e.currentUsageWithPrecision) != null ? _g : (_f = breakdown.freeTrialInfo) == null ? void 0 : _f.currentUsage) != null ? _h : 0;
              const trialTotal = (_l = (_k = (_i = breakdown.freeTrialInfo) == null ? void 0 : _i.usageLimitWithPrecision) != null ? _k : (_j = breakdown.freeTrialInfo) == null ? void 0 : _j.usageLimit) != null ? _l : 0;
              const totalUsed = baseUsed + trialUsed;
              const totalLimit = baseTotal + trialTotal;
              const totalUsedPercent = totalLimit > 0 ? Math.min(totalUsed / totalLimit * 100, 100) : 0;
              const totalRemainingPercent = 100 - totalUsedPercent;
              const totalProgressClass = totalRemainingPercent >= 70 ? styles$5.progressNormal : totalRemainingPercent >= 30 ? styles$5.progressWarning : styles$5.progressDanger;
              const resetTime = breakdown.nextDateReset ? new Date(breakdown.nextDateReset * 1e3).toISOString() : null;
              const resetCountdown = resetTime ? formatTimeUntilReset(resetTime, currentTime) : null;
              return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.quotaItem, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.quotaHeader, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5.quotaModel, children: [
                    " ",
                    breakdown.displayName || breakdown.resourceType || "Usage",
                    " ()"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5.quotaValue, children: [
                    totalUsed.toFixed(2),
                    "/",
                    totalLimit
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${styles$5.progressBar} ${totalProgressClass}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.progressFill, style: { width: `${totalRemainingPercent}%` } }) }),
                resetCountdown && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.quotaReset, children: resetCountdown }),
                baseTotal > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.quotaItem, style: { marginTop: "8px", paddingLeft: "12px", borderLeft: "2px solid #1890ff" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.quotaHeader, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.quotaModel, style: { color: "#1890ff" }, children: " " }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5.quotaValue, children: [
                    baseUsed,
                    "/",
                    baseTotal
                  ] })
                ] }) }),
                breakdown.freeTrialInfo && breakdown.freeTrialInfo.freeTrialStatus === "ACTIVE" && (() => {
                  const trialExpiry = breakdown.freeTrialInfo.freeTrialExpiry ? formatTimeUntilReset(new Date(breakdown.freeTrialInfo.freeTrialExpiry * 1e3).toISOString(), currentTime) : null;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.quotaItem, style: { marginTop: "8px", paddingLeft: "12px", borderLeft: "2px solid #52c41a" }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.quotaHeader, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.quotaModel, style: { color: "#52c41a" }, children: " " }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5.quotaValue, children: [
                        trialUsed.toFixed(2),
                        "/",
                        trialTotal
                      ] })
                    ] }),
                    trialExpiry && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.quotaReset, style: { fontSize: "11px", color: "#888" }, children: [
                      ": ",
                      trialExpiry
                    ] })
                  ] });
                })(),
                breakdown.bonuses && breakdown.bonuses.length > 0 && breakdown.bonuses.map((bonus, bonusIdx) => {
                  var _a4, _b3;
                  const bonusUsed = (_a4 = bonus.currentUsage) != null ? _a4 : 0;
                  const bonusTotal = (_b3 = bonus.usageLimit) != null ? _b3 : 1;
                  const bonusUsedPercent = Math.min(bonusUsed / bonusTotal * 100, 100);
                  const bonusRemainingPercent = 100 - bonusUsedPercent;
                  const bonusProgressClass = bonusRemainingPercent >= 70 ? styles$5.progressNormal : bonusRemainingPercent >= 30 ? styles$5.progressWarning : styles$5.progressDanger;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.quotaItem, style: { marginTop: "8px", paddingLeft: "12px", borderLeft: "2px solid #faad14" }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.quotaHeader, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5.quotaModel, style: { color: "#faad14" }, children: [
                        " ",
                        bonus.displayName || bonus.bonusCode || ""
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5.quotaValue, children: [
                        bonusUsed,
                        "/",
                        bonusTotal
                      ] })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${styles$5.progressBar} ${bonusProgressClass}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.progressFill, style: { width: `${bonusRemainingPercent}%` } }) }),
                    bonus.description && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.quotaReset, style: { fontSize: "11px", color: "#888" }, children: bonus.description })
                  ] }, `bonus-${bonusIdx}`);
                })
              ] }, idx);
            })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.cardActions, children: isRuntimeOnly ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.virtualBadge, children: t2("auth_files.type_virtual") || "" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "secondary",
                size: "sm",
                onClick: () => showModels(item),
                className: styles$5.iconButton,
                title: t2("auth_files.models_button", { defaultValue: "" }),
                disabled: disableControls,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBot, { className: styles$5.actionIcon, size: 16 })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "secondary",
                size: "sm",
                onClick: () => showDetails(item),
                className: styles$5.iconButton,
                title: t2("common.info", { defaultValue: "" }),
                disabled: disableControls,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconInfo, { className: styles$5.actionIcon, size: 16 })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "secondary",
                size: "sm",
                onClick: () => handleDownload(item.name),
                className: styles$5.iconButton,
                title: t2("auth_files.download_button"),
                disabled: disableControls,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconDownload, { className: styles$5.actionIcon, size: 16 })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "danger",
                size: "sm",
                onClick: () => handleDelete(item.name),
                className: styles$5.iconButton,
                title: t2("auth_files.delete_button"),
                disabled: disableControls || deleting === item.name,
                children: deleting === item.name ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: 14 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(IconTrash2, { className: styles$5.actionIcon, size: 16 })
              }
            )
          ] }) })
        ] }, item.name);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.container, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.pageHeader, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$5.pageTitle, children: t2("auth_files.title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$5.description, children: t2("auth_files.description") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Card,
          {
            title: t2("auth_files.title_section"),
            extra: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.headerActions, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", size: "sm", onClick: () => {
                loadFiles();
                loadKeyStats();
                loadAntigravityQuotas();
              }, disabled: loading, children: t2("common.refresh") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "secondary",
                  size: "sm",
                  onClick: handleDeleteAll,
                  disabled: disableControls || loading || deletingAll,
                  loading: deletingAll,
                  children: filter === "all" ? t2("auth_files.delete_all_button") : `${t2("common.delete")} ${getTypeLabel(filter)}`
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "sm", onClick: handleUploadClick, disabled: disableControls || uploading, loading: uploading, children: t2("auth_files.upload_button") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  ref: fileInputRef,
                  type: "file",
                  accept: ".json,application/json",
                  multiple: true,
                  style: { display: "none" },
                  onChange: handleFileChange
                }
              )
            ] }),
            children: [
              error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.errorBox, children: error2 }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.filterSection, children: [
                renderFilterTags(),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.filterControls, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.filterItem, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("auth_files.search_label") }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Input,
                      {
                        value: search2,
                        onChange: (e) => {
                          setSearch(e.target.value);
                          setPage(1);
                        },
                        placeholder: t2("auth_files.search_placeholder")
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.filterItem, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("auth_files.page_size_label") }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "select",
                      {
                        className: styles$5.pageSizeSelect,
                        value: pageSize,
                        onChange: (e) => {
                          setPageSize(Number(e.target.value) || 9);
                          setPage(1);
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: 6, children: "6" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: 9, children: "9" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: 12, children: "12" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: 18, children: "18" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: 24, children: "24" })
                        ]
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.filterItem, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("common.info") }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.statsInfo, children: [
                      files.length,
                      " ",
                      t2("auth_files.files_count"),
                      "  ",
                      formatFileSize(totalSize)
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.filterItem, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Input,
                      {
                        type: "number",
                        value: quotaRefreshInterval,
                        onChange: (e) => {
                          const value = parseInt(e.target.value) || 1;
                          setQuotaRefreshInterval(Math.max(1, Math.min(60, value)));
                        },
                        placeholder: "1",
                        min: 1,
                        max: 60,
                        style: { width: "100px" }
                      }
                    )
                  ] })
                ] })
              ] }),
              loading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.hint, children: t2("common.loading") }) : pageItems.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyState, { title: t2("auth_files.search_empty_title"), description: t2("auth_files.search_empty_desc") }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.fileGrid, children: pageItems.map(renderFileCard) }),
              !loading && filtered.length > pageSize && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.pagination, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "secondary",
                    size: "sm",
                    onClick: () => setPage(Math.max(1, currentPage - 1)),
                    disabled: currentPage <= 1,
                    children: t2("auth_files.pagination_prev")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.pageInfo, children: t2("auth_files.pagination_info", {
                  current: currentPage,
                  total: totalPages,
                  count: filtered.length
                }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "secondary",
                    size: "sm",
                    onClick: () => setPage(Math.min(totalPages, currentPage + 1)),
                    disabled: currentPage >= totalPages,
                    children: t2("auth_files.pagination_next")
                  }
                )
              ] })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Card,
          {
            title: t2("oauth_excluded.title"),
            extra: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                size: "sm",
                onClick: () => openExcludedModal(),
                disabled: disableControls || excludedError === "unsupported",
                children: t2("oauth_excluded.add")
              }
            ),
            children: excludedError === "unsupported" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              EmptyState,
              {
                title: t2("oauth_excluded.upgrade_required_title"),
                description: t2("oauth_excluded.upgrade_required_desc")
              }
            ) : Object.keys(excluded).length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyState, { title: t2("oauth_excluded.list_empty_all") }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.excludedList, children: Object.entries(excluded).map(([provider, models]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.excludedItem, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.excludedInfo, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.excludedProvider, children: provider }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.excludedModels, children: (models == null ? void 0 : models.length) ? t2("oauth_excluded.model_count", { count: models.length }) : t2("oauth_excluded.no_models") })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.excludedActions, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", size: "sm", onClick: () => openExcludedModal(provider), children: t2("common.edit") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "danger", size: "sm", onClick: () => deleteExcluded(provider), children: t2("oauth_excluded.delete") })
              ] })
            ] }, provider)) })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            open: detailModalOpen,
            onClose: () => setDetailModalOpen(false),
            title: (selectedFile == null ? void 0 : selectedFile.name) || t2("auth_files.title_section"),
            footer: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: () => setDetailModalOpen(false), children: t2("common.close") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    if (selectedFile) {
                      const text = JSON.stringify(selectedFile, null, 2);
                      navigator.clipboard.writeText(text).then(() => {
                        showNotification(t2("notification.link_copied"), "success");
                      });
                    }
                  },
                  children: t2("common.copy")
                }
              )
            ] }),
            children: selectedFile && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.detailContent, children: /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: styles$5.jsonContent, children: JSON.stringify(selectedFile, null, 2) }) })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            open: modelsModalOpen,
            onClose: () => setModelsModalOpen(false),
            title: t2("auth_files.models_title", { defaultValue: "" }) + ` - ${modelsFileName}`,
            footer: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: () => setModelsModalOpen(false), children: t2("common.close") }),
            children: modelsLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.hint, children: t2("auth_files.models_loading", { defaultValue: "..." }) }) : modelsError === "unsupported" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              EmptyState,
              {
                title: t2("auth_files.models_unsupported", { defaultValue: "" }),
                description: t2("auth_files.models_unsupported_desc", { defaultValue: " CLI Proxy API " })
              }
            ) : modelsList2.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              EmptyState,
              {
                title: t2("auth_files.models_empty", { defaultValue: "" }),
                description: t2("auth_files.models_empty_desc", { defaultValue: "" })
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.modelsList, children: modelsList2.map((model) => {
              const isExcluded = isModelExcluded(model.id, modelsFileType);
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `${styles$5.modelItem} ${isExcluded ? styles$5.modelItemExcluded : ""}`,
                  onClick: () => {
                    navigator.clipboard.writeText(model.id);
                    showNotification(t2("notification.link_copied", { defaultValue: "" }), "success");
                  },
                  title: isExcluded ? t2("auth_files.models_excluded_hint", { defaultValue: " OAuth " }) : t2("common.copy", { defaultValue: "" }),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.modelId, children: model.id }),
                    model.display_name && model.display_name !== model.id && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.modelDisplayName, children: model.display_name }),
                    model.type && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.modelType, children: model.type }),
                    isExcluded && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.modelExcludedBadge, children: t2("auth_files.models_excluded_badge", { defaultValue: "" }) })
                  ]
                },
                model.id
              );
            }) })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            open: excludedModalOpen,
            onClose: () => setExcludedModalOpen(false),
            title: t2("oauth_excluded.add_title"),
            footer: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: () => setExcludedModalOpen(false), disabled: savingExcluded, children: t2("common.cancel") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: saveExcludedModels, loading: savingExcluded, children: t2("oauth_excluded.save") })
            ] }),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  label: t2("oauth_excluded.provider_label"),
                  placeholder: t2("oauth_excluded.provider_placeholder"),
                  value: excludedForm.provider,
                  onChange: (e) => setExcludedForm((prev) => __spreadProps(__spreadValues({}, prev), { provider: e.target.value }))
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.formGroup, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("oauth_excluded.models_label") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "textarea",
                  {
                    className: styles$5.textarea,
                    rows: 4,
                    placeholder: t2("oauth_excluded.models_placeholder"),
                    value: excludedForm.modelsText,
                    onChange: (e) => setExcludedForm((prev) => __spreadProps(__spreadValues({}, prev), { modelsText: e.target.value }))
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.hint, children: t2("oauth_excluded.models_hint") })
              ] })
            ]
          }
        )
      ] });
    }
    const container$4 = "OAuthPage-module__container___LCCdH";
    const pageTitle$4 = "OAuthPage-module__pageTitle___BQQ2z";
    const content$4 = "OAuthPage-module__content___Phg9V";
    const callbackSection = "OAuthPage-module__callbackSection___8kA31";
    const callbackActions = "OAuthPage-module__callbackActions___wtkMI";
    const authUrlBox = "OAuthPage-module__authUrlBox___Iu1d4";
    const authUrlLabel = "OAuthPage-module__authUrlLabel___mYFJB";
    const authUrlValue = "OAuthPage-module__authUrlValue___axvUJ";
    const authUrlActions = "OAuthPage-module__authUrlActions___venPj";
    const styles$4 = {
      container: container$4,
      pageTitle: pageTitle$4,
      content: content$4,
      callbackSection,
      callbackActions,
      authUrlBox,
      authUrlLabel,
      authUrlValue,
      authUrlActions
    };
    const PROVIDERS = [
      { id: "codex", titleKey: "auth_login.codex_oauth_title", hintKey: "auth_login.codex_oauth_hint", urlLabelKey: "auth_login.codex_oauth_url_label" },
      { id: "anthropic", titleKey: "auth_login.anthropic_oauth_title", hintKey: "auth_login.anthropic_oauth_hint", urlLabelKey: "auth_login.anthropic_oauth_url_label" },
      { id: "antigravity", titleKey: "auth_login.antigravity_oauth_title", hintKey: "auth_login.antigravity_oauth_hint", urlLabelKey: "auth_login.antigravity_oauth_url_label" },
      { id: "gemini-cli", titleKey: "auth_login.gemini_cli_oauth_title", hintKey: "auth_login.gemini_cli_oauth_hint", urlLabelKey: "auth_login.gemini_cli_oauth_url_label" },
      { id: "qwen", titleKey: "auth_login.qwen_oauth_title", hintKey: "auth_login.qwen_oauth_hint", urlLabelKey: "auth_login.qwen_oauth_url_label" },
      { id: "iflow", titleKey: "auth_login.iflow_oauth_title", hintKey: "auth_login.iflow_oauth_hint", urlLabelKey: "auth_login.iflow_oauth_url_label" }
    ];
    const CALLBACK_SUPPORTED = ["codex", "anthropic", "antigravity", "gemini-cli", "iflow"];
    function OAuthPage() {
      const { t: t2 } = useTranslation();
      const { showNotification } = useNotificationStore();
      const [states, setStates] = reactExports.useState({});
      const [iflowCookie, setIflowCookie] = reactExports.useState({ cookie: "", loading: false });
      const [kiroCred, setKiroCred] = reactExports.useState({ credPath: "", loading: false, uploading: false });
      const timers = reactExports.useRef({});
      reactExports.useEffect(() => {
        return () => {
          Object.values(timers.current).forEach((timer) => window.clearInterval(timer));
        };
      }, []);
      const updateProviderState = (provider, next) => {
        setStates((prev) => {
          var _a2;
          return __spreadProps(__spreadValues({}, prev), {
            [provider]: __spreadValues(__spreadValues({}, (_a2 = prev[provider]) != null ? _a2 : {}), next)
          });
        });
      };
      const startPolling = (provider, state) => {
        if (timers.current[provider]) {
          clearInterval(timers.current[provider]);
        }
        const timer = window.setInterval(() => __async(null, null, function* () {
          try {
            const res = yield oauthApi.getAuthStatus(state);
            if (res.status === "ok") {
              updateProviderState(provider, { status: "success", polling: false });
              showNotification(t2("auth_login.codex_oauth_status_success"), "success");
              window.clearInterval(timer);
              delete timers.current[provider];
            } else if (res.status === "error") {
              updateProviderState(provider, { status: "error", error: res.error, polling: false });
              showNotification(`${t2("auth_login.codex_oauth_status_error")} ${res.error || ""}`, "error");
              window.clearInterval(timer);
              delete timers.current[provider];
            }
          } catch (err) {
            updateProviderState(provider, { status: "error", error: err == null ? void 0 : err.message, polling: false });
            window.clearInterval(timer);
            delete timers.current[provider];
          }
        }), 3e3);
        timers.current[provider] = timer;
      };
      const startAuth = (provider) => __async(null, null, function* () {
        var _a2;
        const projectId = provider === "gemini-cli" ? (((_a2 = states[provider]) == null ? void 0 : _a2.projectId) || "").trim() : void 0;
        if (provider === "gemini-cli" && !projectId) {
          const message2 = t2("auth_login.gemini_cli_project_id_required");
          updateProviderState(provider, { projectIdError: message2 });
          showNotification(message2, "warning");
          return;
        }
        if (provider === "gemini-cli") {
          updateProviderState(provider, { projectIdError: void 0 });
        }
        updateProviderState(provider, {
          status: "waiting",
          polling: true,
          error: void 0,
          callbackStatus: void 0,
          callbackError: void 0,
          callbackUrl: ""
        });
        try {
          const res = yield oauthApi.startAuth(
            provider,
            provider === "gemini-cli" ? { projectId } : void 0
          );
          updateProviderState(provider, { url: res.url, state: res.state, status: "waiting", polling: true });
          if (res.state) {
            startPolling(provider, res.state);
          }
        } catch (err) {
          updateProviderState(provider, { status: "error", error: err == null ? void 0 : err.message, polling: false });
          showNotification(`${t2("auth_login.codex_oauth_start_error")} ${(err == null ? void 0 : err.message) || ""}`, "error");
        }
      });
      const copyLink = (url) => __async(null, null, function* () {
        if (!url) return;
        try {
          yield navigator.clipboard.writeText(url);
          showNotification(t2("notification.link_copied"), "success");
        } catch (e) {
          showNotification("Copy failed", "error");
        }
      });
      const submitCallback = (provider) => __async(null, null, function* () {
        var _a2;
        const redirectUrl = (((_a2 = states[provider]) == null ? void 0 : _a2.callbackUrl) || "").trim();
        if (!redirectUrl) {
          showNotification(t2("auth_login.oauth_callback_required"), "warning");
          return;
        }
        updateProviderState(provider, {
          callbackSubmitting: true,
          callbackStatus: void 0,
          callbackError: void 0
        });
        try {
          yield oauthApi.submitCallback(provider, redirectUrl);
          updateProviderState(provider, { callbackSubmitting: false, callbackStatus: "success" });
          showNotification(t2("auth_login.oauth_callback_success"), "success");
        } catch (err) {
          const errorMessage = (err == null ? void 0 : err.status) === 404 ? t2("auth_login.oauth_callback_upgrade_hint", {
            defaultValue: "Please update CLI Proxy API or check the connection."
          }) : err == null ? void 0 : err.message;
          updateProviderState(provider, {
            callbackSubmitting: false,
            callbackStatus: "error",
            callbackError: errorMessage
          });
          const notificationMessage = errorMessage ? `${t2("auth_login.oauth_callback_error")} ${errorMessage}` : t2("auth_login.oauth_callback_error");
          showNotification(notificationMessage, "error");
        }
      });
      const submitIflowCookie = () => __async(null, null, function* () {
        const cookie = iflowCookie.cookie.trim();
        if (!cookie) {
          showNotification(t2("auth_login.iflow_cookie_required"), "warning");
          return;
        }
        setIflowCookie((prev) => __spreadProps(__spreadValues({}, prev), {
          loading: true,
          error: void 0,
          errorType: void 0,
          result: void 0
        }));
        try {
          const res = yield oauthApi.iflowCookieAuth(cookie);
          if (res.status === "ok") {
            setIflowCookie((prev) => __spreadProps(__spreadValues({}, prev), { loading: false, result: res }));
            showNotification(t2("auth_login.iflow_cookie_status_success"), "success");
          } else {
            setIflowCookie((prev) => __spreadProps(__spreadValues({}, prev), {
              loading: false,
              error: res.error,
              errorType: "error"
            }));
            showNotification(`${t2("auth_login.iflow_cookie_status_error")} ${res.error || ""}`, "error");
          }
        } catch (err) {
          if ((err == null ? void 0 : err.status) === 409) {
            const message2 = t2("auth_login.iflow_cookie_config_duplicate");
            setIflowCookie((prev) => __spreadProps(__spreadValues({}, prev), { loading: false, error: message2, errorType: "warning" }));
            showNotification(message2, "warning");
            return;
          }
          setIflowCookie((prev) => __spreadProps(__spreadValues({}, prev), { loading: false, error: err == null ? void 0 : err.message, errorType: "error" }));
          showNotification(`${t2("auth_login.iflow_cookie_start_error")} ${(err == null ? void 0 : err.message) || ""}`, "error");
        }
      });
      const submitKiroCred = () => __async(null, null, function* () {
        const credPath = kiroCred.credPath.trim();
        setKiroCred((prev) => __spreadProps(__spreadValues({}, prev), {
          loading: true,
          error: void 0,
          errorType: void 0,
          result: void 0
        }));
        try {
          const res = yield oauthApi.kiroCredentialAuth(credPath || void 0);
          if (res.status === "ok") {
            setKiroCred((prev) => __spreadProps(__spreadValues({}, prev), { loading: false, result: res }));
            showNotification(t2("auth_login.kiro_status_success"), "success");
          } else {
            setKiroCred((prev) => __spreadProps(__spreadValues({}, prev), {
              loading: false,
              error: res.error,
              errorType: "error"
            }));
            showNotification(`${t2("auth_login.kiro_status_error")} ${res.error || ""}`, "error");
          }
        } catch (err) {
          if ((err == null ? void 0 : err.status) === 409) {
            const message2 = t2("auth_login.kiro_config_duplicate");
            setKiroCred((prev) => __spreadProps(__spreadValues({}, prev), { loading: false, error: message2, errorType: "warning" }));
            showNotification(message2, "warning");
            return;
          }
          setKiroCred((prev) => __spreadProps(__spreadValues({}, prev), { loading: false, error: err == null ? void 0 : err.message, errorType: "error" }));
          showNotification(`${t2("auth_login.kiro_start_error")} ${(err == null ? void 0 : err.message) || ""}`, "error");
        }
      });
      const handleKiroFileUpload = (event) => __async(null, null, function* () {
        var _a2;
        const file = (_a2 = event.target.files) == null ? void 0 : _a2[0];
        if (!file) return;
        setKiroCred((prev) => __spreadProps(__spreadValues({}, prev), {
          uploading: true,
          error: void 0,
          errorType: void 0
        }));
        try {
          const res = yield oauthApi.kiroUploadCredential(file);
          if (res.status === "ok" && res.file_path) {
            setKiroCred((prev) => __spreadProps(__spreadValues({}, prev), { uploading: false, credPath: res.file_path || "" }));
            showNotification(t2("auth_login.kiro_upload_success"), "success");
          } else {
            setKiroCred((prev) => __spreadProps(__spreadValues({}, prev), {
              uploading: false,
              error: res.error,
              errorType: "error"
            }));
            showNotification(`${t2("auth_login.kiro_upload_error")} ${res.error || ""}`, "error");
          }
        } catch (err) {
          setKiroCred((prev) => __spreadProps(__spreadValues({}, prev), { uploading: false, error: err == null ? void 0 : err.message, errorType: "error" }));
          showNotification(`${t2("auth_login.kiro_upload_error")} ${(err == null ? void 0 : err.message) || ""}`, "error");
        }
        event.target.value = "";
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$4.container, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$4.pageTitle, children: t2("nav.oauth", { defaultValue: "OAuth" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$4.content, children: [
          PROVIDERS.map((provider) => {
            const state = states[provider.id] || {};
            const canSubmitCallback = CALLBACK_SUPPORTED.includes(provider.id) && Boolean(state.url);
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Card,
              {
                title: t2(provider.titleKey),
                extra: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => startAuth(provider.id), loading: state.polling, children: t2("common.login") }),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2(provider.hintKey) }),
                  provider.id === "gemini-cli" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      label: t2("auth_login.gemini_cli_project_id_label"),
                      hint: t2("auth_login.gemini_cli_project_id_hint"),
                      value: state.projectId || "",
                      error: state.projectIdError,
                      onChange: (e) => updateProviderState(provider.id, {
                        projectId: e.target.value,
                        projectIdError: void 0
                      }),
                      placeholder: t2("auth_login.gemini_cli_project_id_placeholder")
                    }
                  ),
                  state.url && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `connection-box ${styles$4.authUrlBox}`, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$4.authUrlLabel, children: t2(provider.urlLabelKey) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$4.authUrlValue, children: state.url }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$4.authUrlActions, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", size: "sm", onClick: () => copyLink(state.url), children: t2("auth_login.codex_copy_link") }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Button,
                        {
                          variant: "secondary",
                          size: "sm",
                          onClick: () => window.open(state.url, "_blank", "noopener,noreferrer"),
                          children: t2("auth_login.codex_open_link")
                        }
                      )
                    ] })
                  ] }),
                  canSubmitCallback && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$4.callbackSection, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Input,
                      {
                        label: t2("auth_login.oauth_callback_label"),
                        hint: t2("auth_login.oauth_callback_hint"),
                        value: state.callbackUrl || "",
                        onChange: (e) => updateProviderState(provider.id, {
                          callbackUrl: e.target.value,
                          callbackStatus: void 0,
                          callbackError: void 0
                        }),
                        placeholder: t2("auth_login.oauth_callback_placeholder")
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$4.callbackActions, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        variant: "secondary",
                        size: "sm",
                        onClick: () => submitCallback(provider.id),
                        loading: state.callbackSubmitting,
                        children: t2("auth_login.oauth_callback_button")
                      }
                    ) }),
                    state.callbackStatus === "success" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-badge success", style: { marginTop: 8 }, children: t2("auth_login.oauth_callback_status_success") }),
                    state.callbackStatus === "error" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "status-badge error", style: { marginTop: 8 }, children: [
                      t2("auth_login.oauth_callback_status_error"),
                      " ",
                      state.callbackError || ""
                    ] })
                  ] }),
                  state.status && state.status !== "idle" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-badge", style: { marginTop: 8 }, children: state.status === "success" ? t2("auth_login.codex_oauth_status_success") : state.status === "error" ? `${t2("auth_login.codex_oauth_status_error")} ${state.error || ""}` : t2("auth_login.codex_oauth_status_waiting") })
                ]
              }
            ) }, provider.id);
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Card,
            {
              title: t2("auth_login.kiro_title"),
              extra: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: submitKiroCred, loading: kiroCred.loading, children: t2("auth_login.kiro_button") }),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("auth_login.kiro_hint") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", style: { marginTop: 4 }, children: t2("auth_login.kiro_path_hint") }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-item", style: { marginTop: 12 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "label", children: t2("auth_login.kiro_file_path_label") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { flex: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Input,
                      {
                        value: kiroCred.credPath,
                        onChange: (e) => setKiroCred((prev) => __spreadProps(__spreadValues({}, prev), { credPath: e.target.value })),
                        placeholder: t2("auth_login.kiro_file_path_placeholder")
                      }
                    ) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "input",
                        {
                          id: "kiro-file-upload",
                          type: "file",
                          accept: ".json",
                          onChange: handleKiroFileUpload,
                          style: { display: "none" }
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Button,
                        {
                          variant: "secondary",
                          loading: kiroCred.uploading,
                          onClick: () => {
                            var _a2;
                            return (_a2 = document.getElementById("kiro-file-upload")) == null ? void 0 : _a2.click();
                          },
                          children: t2("auth_login.kiro_upload_button")
                        }
                      )
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", style: { marginTop: 4 }, children: t2("auth_login.kiro_file_path_hint") })
                ] }),
                kiroCred.error && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: `status-badge ${kiroCred.errorType === "warning" ? "warning" : "error"}`,
                    style: { marginTop: 8 },
                    children: [
                      kiroCred.errorType === "warning" ? t2("auth_login.kiro_status_duplicate") : t2("auth_login.kiro_status_error"),
                      " ",
                      kiroCred.error
                    ]
                  }
                ),
                kiroCred.result && kiroCred.result.status === "ok" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "connection-box", style: { marginTop: 12 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "label", children: t2("auth_login.kiro_result_title") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "key-value-list", children: [
                    kiroCred.result.region && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "key-value-item", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "key", children: t2("auth_login.kiro_result_region") }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: kiroCred.result.region })
                    ] }),
                    kiroCred.result.saved_path && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "key-value-item", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "key", children: t2("auth_login.kiro_result_path") }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: kiroCred.result.saved_path })
                    ] }),
                    kiroCred.result.type && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "key-value-item", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "key", children: t2("auth_login.kiro_result_type") }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: kiroCred.result.type })
                    ] })
                  ] })
                ] })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Card,
            {
              title: t2("auth_login.iflow_cookie_title"),
              extra: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: submitIflowCookie, loading: iflowCookie.loading, children: t2("auth_login.iflow_cookie_button") }),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("auth_login.iflow_cookie_hint") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", style: { marginTop: 4 }, children: t2("auth_login.iflow_cookie_key_hint") }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-item", style: { marginTop: 12 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "label", children: t2("auth_login.iflow_cookie_label") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      value: iflowCookie.cookie,
                      onChange: (e) => setIflowCookie((prev) => __spreadProps(__spreadValues({}, prev), { cookie: e.target.value })),
                      placeholder: t2("auth_login.iflow_cookie_placeholder")
                    }
                  )
                ] }),
                iflowCookie.error && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: `status-badge ${iflowCookie.errorType === "warning" ? "warning" : "error"}`,
                    style: { marginTop: 8 },
                    children: [
                      iflowCookie.errorType === "warning" ? t2("auth_login.iflow_cookie_status_duplicate") : t2("auth_login.iflow_cookie_status_error"),
                      " ",
                      iflowCookie.error
                    ]
                  }
                ),
                iflowCookie.result && iflowCookie.result.status === "ok" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "connection-box", style: { marginTop: 12 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "label", children: t2("auth_login.iflow_cookie_result_title") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "key-value-list", children: [
                    iflowCookie.result.email && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "key-value-item", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "key", children: t2("auth_login.iflow_cookie_result_email") }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: iflowCookie.result.email })
                    ] }),
                    iflowCookie.result.expired && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "key-value-item", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "key", children: t2("auth_login.iflow_cookie_result_expired") }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: iflowCookie.result.expired })
                    ] }),
                    iflowCookie.result.saved_path && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "key-value-item", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "key", children: t2("auth_login.iflow_cookie_result_path") }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: iflowCookie.result.saved_path })
                    ] }),
                    iflowCookie.result.type && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "key-value-item", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "key", children: t2("auth_login.iflow_cookie_result_type") }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: iflowCookie.result.type })
                    ] })
                  ] })
                ] })
              ]
            }
          )
        ] })
      ] });
    }
    function round(v) {
      return v + 0.5 | 0;
    }
    const lim = (v, l, h) => Math.max(Math.min(v, h), l);
    function p2b(v) {
      return lim(round(v * 2.55), 0, 255);
    }
    function n2b(v) {
      return lim(round(v * 255), 0, 255);
    }
    function b2n(v) {
      return lim(round(v / 2.55) / 100, 0, 1);
    }
    function n2p(v) {
      return lim(round(v * 100), 0, 100);
    }
    const map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
    const hex = [..."0123456789ABCDEF"];
    const h1 = (b) => hex[b & 15];
    const h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
    const eq = (b) => (b & 240) >> 4 === (b & 15);
    const isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
    function hexParse(str) {
      var len = str.length;
      var ret;
      if (str[0] === "#") {
        if (len === 4 || len === 5) {
          ret = {
            r: 255 & map$1[str[1]] * 17,
            g: 255 & map$1[str[2]] * 17,
            b: 255 & map$1[str[3]] * 17,
            a: len === 5 ? map$1[str[4]] * 17 : 255
          };
        } else if (len === 7 || len === 9) {
          ret = {
            r: map$1[str[1]] << 4 | map$1[str[2]],
            g: map$1[str[3]] << 4 | map$1[str[4]],
            b: map$1[str[5]] << 4 | map$1[str[6]],
            a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
          };
        }
      }
      return ret;
    }
    const alpha = (a, f) => a < 255 ? f(a) : "";
    function hexString(v) {
      var f = isShort(v) ? h1 : h2;
      return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
    }
    const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
    function hsl2rgbn(h, s, l) {
      const a = s * Math.min(l, 1 - l);
      const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      return [f(0), f(8), f(4)];
    }
    function hsv2rgbn(h, s, v) {
      const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
      return [f(5), f(3), f(1)];
    }
    function hwb2rgbn(h, w, b) {
      const rgb = hsl2rgbn(h, 1, 0.5);
      let i2;
      if (w + b > 1) {
        i2 = 1 / (w + b);
        w *= i2;
        b *= i2;
      }
      for (i2 = 0; i2 < 3; i2++) {
        rgb[i2] *= 1 - w - b;
        rgb[i2] += w;
      }
      return rgb;
    }
    function hueValue(r, g, b, d, max) {
      if (r === max) {
        return (g - b) / d + (g < b ? 6 : 0);
      }
      if (g === max) {
        return (b - r) / d + 2;
      }
      return (r - g) / d + 4;
    }
    function rgb2hsl(v) {
      const range = 255;
      const r = v.r / range;
      const g = v.g / range;
      const b = v.b / range;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const l = (max + min) / 2;
      let h, s, d;
      if (max !== min) {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = hueValue(r, g, b, d, max);
        h = h * 60 + 0.5;
      }
      return [h | 0, s || 0, l];
    }
    function calln(f, a, b, c) {
      return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
    }
    function hsl2rgb(h, s, l) {
      return calln(hsl2rgbn, h, s, l);
    }
    function hwb2rgb(h, w, b) {
      return calln(hwb2rgbn, h, w, b);
    }
    function hsv2rgb(h, s, v) {
      return calln(hsv2rgbn, h, s, v);
    }
    function hue(h) {
      return (h % 360 + 360) % 360;
    }
    function hueParse(str) {
      const m = HUE_RE.exec(str);
      let a = 255;
      let v;
      if (!m) {
        return;
      }
      if (m[5] !== v) {
        a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
      }
      const h = hue(+m[2]);
      const p1 = +m[3] / 100;
      const p2 = +m[4] / 100;
      if (m[1] === "hwb") {
        v = hwb2rgb(h, p1, p2);
      } else if (m[1] === "hsv") {
        v = hsv2rgb(h, p1, p2);
      } else {
        v = hsl2rgb(h, p1, p2);
      }
      return {
        r: v[0],
        g: v[1],
        b: v[2],
        a
      };
    }
    function rotate(v, deg) {
      var h = rgb2hsl(v);
      h[0] = hue(h[0] + deg);
      h = hsl2rgb(h);
      v.r = h[0];
      v.g = h[1];
      v.b = h[2];
    }
    function hslString(v) {
      if (!v) {
        return;
      }
      const a = rgb2hsl(v);
      const h = a[0];
      const s = n2p(a[1]);
      const l = n2p(a[2]);
      return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
    }
    const map = {
      x: "dark",
      Z: "light",
      Y: "re",
      X: "blu",
      W: "gr",
      V: "medium",
      U: "slate",
      A: "ee",
      T: "ol",
      S: "or",
      B: "ra",
      C: "lateg",
      D: "ights",
      R: "in",
      Q: "turquois",
      E: "hi",
      P: "ro",
      O: "al",
      N: "le",
      M: "de",
      L: "yello",
      F: "en",
      K: "ch",
      G: "arks",
      H: "ea",
      I: "ightg",
      J: "wh"
    };
    const names$1 = {
      OiceXe: "f0f8ff",
      antiquewEte: "faebd7",
      aqua: "ffff",
      aquamarRe: "7fffd4",
      azuY: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "0",
      blanKedOmond: "ffebcd",
      Xe: "ff",
      XeviTet: "8a2be2",
      bPwn: "a52a2a",
      burlywood: "deb887",
      caMtXe: "5f9ea0",
      KartYuse: "7fff00",
      KocTate: "d2691e",
      cSO: "ff7f50",
      cSnflowerXe: "6495ed",
      cSnsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "ffff",
      xXe: "8b",
      xcyan: "8b8b",
      xgTMnPd: "b8860b",
      xWay: "a9a9a9",
      xgYF: "6400",
      xgYy: "a9a9a9",
      xkhaki: "bdb76b",
      xmagFta: "8b008b",
      xTivegYF: "556b2f",
      xSange: "ff8c00",
      xScEd: "9932cc",
      xYd: "8b0000",
      xsOmon: "e9967a",
      xsHgYF: "8fbc8f",
      xUXe: "483d8b",
      xUWay: "2f4f4f",
      xUgYy: "2f4f4f",
      xQe: "ced1",
      xviTet: "9400d3",
      dAppRk: "ff1493",
      dApskyXe: "bfff",
      dimWay: "696969",
      dimgYy: "696969",
      dodgerXe: "1e90ff",
      fiYbrick: "b22222",
      flSOwEte: "fffaf0",
      foYstWAn: "228b22",
      fuKsia: "ff00ff",
      gaRsbSo: "dcdcdc",
      ghostwEte: "f8f8ff",
      gTd: "ffd700",
      gTMnPd: "daa520",
      Way: "808080",
      gYF: "8000",
      gYFLw: "adff2f",
      gYy: "808080",
      honeyMw: "f0fff0",
      hotpRk: "ff69b4",
      RdianYd: "cd5c5c",
      Rdigo: "4b0082",
      ivSy: "fffff0",
      khaki: "f0e68c",
      lavFMr: "e6e6fa",
      lavFMrXsh: "fff0f5",
      lawngYF: "7cfc00",
      NmoncEffon: "fffacd",
      ZXe: "add8e6",
      ZcSO: "f08080",
      Zcyan: "e0ffff",
      ZgTMnPdLw: "fafad2",
      ZWay: "d3d3d3",
      ZgYF: "90ee90",
      ZgYy: "d3d3d3",
      ZpRk: "ffb6c1",
      ZsOmon: "ffa07a",
      ZsHgYF: "20b2aa",
      ZskyXe: "87cefa",
      ZUWay: "778899",
      ZUgYy: "778899",
      ZstAlXe: "b0c4de",
      ZLw: "ffffe0",
      lime: "ff00",
      limegYF: "32cd32",
      lRF: "faf0e6",
      magFta: "ff00ff",
      maPon: "800000",
      VaquamarRe: "66cdaa",
      VXe: "cd",
      VScEd: "ba55d3",
      VpurpN: "9370db",
      VsHgYF: "3cb371",
      VUXe: "7b68ee",
      VsprRggYF: "fa9a",
      VQe: "48d1cc",
      VviTetYd: "c71585",
      midnightXe: "191970",
      mRtcYam: "f5fffa",
      mistyPse: "ffe4e1",
      moccasR: "ffe4b5",
      navajowEte: "ffdead",
      navy: "80",
      Tdlace: "fdf5e6",
      Tive: "808000",
      TivedBb: "6b8e23",
      Sange: "ffa500",
      SangeYd: "ff4500",
      ScEd: "da70d6",
      pOegTMnPd: "eee8aa",
      pOegYF: "98fb98",
      pOeQe: "afeeee",
      pOeviTetYd: "db7093",
      papayawEp: "ffefd5",
      pHKpuff: "ffdab9",
      peru: "cd853f",
      pRk: "ffc0cb",
      plum: "dda0dd",
      powMrXe: "b0e0e6",
      purpN: "800080",
      YbeccapurpN: "663399",
      Yd: "ff0000",
      Psybrown: "bc8f8f",
      PyOXe: "4169e1",
      saddNbPwn: "8b4513",
      sOmon: "fa8072",
      sandybPwn: "f4a460",
      sHgYF: "2e8b57",
      sHshell: "fff5ee",
      siFna: "a0522d",
      silver: "c0c0c0",
      skyXe: "87ceeb",
      UXe: "6a5acd",
      UWay: "708090",
      UgYy: "708090",
      snow: "fffafa",
      sprRggYF: "ff7f",
      stAlXe: "4682b4",
      tan: "d2b48c",
      teO: "8080",
      tEstN: "d8bfd8",
      tomato: "ff6347",
      Qe: "40e0d0",
      viTet: "ee82ee",
      JHt: "f5deb3",
      wEte: "ffffff",
      wEtesmoke: "f5f5f5",
      Lw: "ffff00",
      LwgYF: "9acd32"
    };
    function unpack() {
      const unpacked = {};
      const keys2 = Object.keys(names$1);
      const tkeys = Object.keys(map);
      let i2, j, k, ok, nk;
      for (i2 = 0; i2 < keys2.length; i2++) {
        ok = nk = keys2[i2];
        for (j = 0; j < tkeys.length; j++) {
          k = tkeys[j];
          nk = nk.replace(k, map[k]);
        }
        k = parseInt(names$1[ok], 16);
        unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
      }
      return unpacked;
    }
    let names;
    function nameParse(str) {
      if (!names) {
        names = unpack();
        names.transparent = [0, 0, 0, 0];
      }
      const a = names[str.toLowerCase()];
      return a && {
        r: a[0],
        g: a[1],
        b: a[2],
        a: a.length === 4 ? a[3] : 255
      };
    }
    const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
    function rgbParse(str) {
      const m = RGB_RE.exec(str);
      let a = 255;
      let r, g, b;
      if (!m) {
        return;
      }
      if (m[7] !== r) {
        const v = +m[7];
        a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
      }
      r = +m[1];
      g = +m[3];
      b = +m[5];
      r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
      g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
      b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
      return {
        r,
        g,
        b,
        a
      };
    }
    function rgbString(v) {
      return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
    }
    const to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
    const from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
    function interpolate$1(rgb1, rgb2, t2) {
      const r = from(b2n(rgb1.r));
      const g = from(b2n(rgb1.g));
      const b = from(b2n(rgb1.b));
      return {
        r: n2b(to(r + t2 * (from(b2n(rgb2.r)) - r))),
        g: n2b(to(g + t2 * (from(b2n(rgb2.g)) - g))),
        b: n2b(to(b + t2 * (from(b2n(rgb2.b)) - b))),
        a: rgb1.a + t2 * (rgb2.a - rgb1.a)
      };
    }
    function modHSL(v, i2, ratio) {
      if (v) {
        let tmp = rgb2hsl(v);
        tmp[i2] = Math.max(0, Math.min(tmp[i2] + tmp[i2] * ratio, i2 === 0 ? 360 : 1));
        tmp = hsl2rgb(tmp);
        v.r = tmp[0];
        v.g = tmp[1];
        v.b = tmp[2];
      }
    }
    function clone$1(v, proto) {
      return v ? Object.assign(proto || {}, v) : v;
    }
    function fromObject(input) {
      var v = { r: 0, g: 0, b: 0, a: 255 };
      if (Array.isArray(input)) {
        if (input.length >= 3) {
          v = { r: input[0], g: input[1], b: input[2], a: 255 };
          if (input.length > 3) {
            v.a = n2b(input[3]);
          }
        }
      } else {
        v = clone$1(input, { r: 0, g: 0, b: 0, a: 1 });
        v.a = n2b(v.a);
      }
      return v;
    }
    function functionParse(str) {
      if (str.charAt(0) === "r") {
        return rgbParse(str);
      }
      return hueParse(str);
    }
    class Color {
      constructor(input) {
        if (input instanceof Color) {
          return input;
        }
        const type = typeof input;
        let v;
        if (type === "object") {
          v = fromObject(input);
        } else if (type === "string") {
          v = hexParse(input) || nameParse(input) || functionParse(input);
        }
        this._rgb = v;
        this._valid = !!v;
      }
      get valid() {
        return this._valid;
      }
      get rgb() {
        var v = clone$1(this._rgb);
        if (v) {
          v.a = b2n(v.a);
        }
        return v;
      }
      set rgb(obj) {
        this._rgb = fromObject(obj);
      }
      rgbString() {
        return this._valid ? rgbString(this._rgb) : void 0;
      }
      hexString() {
        return this._valid ? hexString(this._rgb) : void 0;
      }
      hslString() {
        return this._valid ? hslString(this._rgb) : void 0;
      }
      mix(color2, weight) {
        if (color2) {
          const c1 = this.rgb;
          const c2 = color2.rgb;
          let w2;
          const p = weight === w2 ? 0.5 : weight;
          const w = 2 * p - 1;
          const a = c1.a - c2.a;
          const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
          w2 = 1 - w1;
          c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
          c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
          c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
          c1.a = p * c1.a + (1 - p) * c2.a;
          this.rgb = c1;
        }
        return this;
      }
      interpolate(color2, t2) {
        if (color2) {
          this._rgb = interpolate$1(this._rgb, color2._rgb, t2);
        }
        return this;
      }
      clone() {
        return new Color(this.rgb);
      }
      alpha(a) {
        this._rgb.a = n2b(a);
        return this;
      }
      clearer(ratio) {
        const rgb = this._rgb;
        rgb.a *= 1 - ratio;
        return this;
      }
      greyscale() {
        const rgb = this._rgb;
        const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
        rgb.r = rgb.g = rgb.b = val;
        return this;
      }
      opaquer(ratio) {
        const rgb = this._rgb;
        rgb.a *= 1 + ratio;
        return this;
      }
      negate() {
        const v = this._rgb;
        v.r = 255 - v.r;
        v.g = 255 - v.g;
        v.b = 255 - v.b;
        return this;
      }
      lighten(ratio) {
        modHSL(this._rgb, 2, ratio);
        return this;
      }
      darken(ratio) {
        modHSL(this._rgb, 2, -ratio);
        return this;
      }
      saturate(ratio) {
        modHSL(this._rgb, 1, ratio);
        return this;
      }
      desaturate(ratio) {
        modHSL(this._rgb, 1, -ratio);
        return this;
      }
      rotate(deg) {
        rotate(this._rgb, deg);
        return this;
      }
    }
    function noop() {
    }
    const uid = /* @__PURE__ */ (() => {
      let id2 = 0;
      return () => id2++;
    })();
    function isNullOrUndef(value) {
      return value === null || value === void 0;
    }
    function isArray(value) {
      if (Array.isArray && Array.isArray(value)) {
        return true;
      }
      const type = Object.prototype.toString.call(value);
      if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
        return true;
      }
      return false;
    }
    function isObject(value) {
      return value !== null && Object.prototype.toString.call(value) === "[object Object]";
    }
    function isNumberFinite(value) {
      return (typeof value === "number" || value instanceof Number) && isFinite(+value);
    }
    function finiteOrDefault(value, defaultValue) {
      return isNumberFinite(value) ? value : defaultValue;
    }
    function valueOrDefault(value, defaultValue) {
      return typeof value === "undefined" ? defaultValue : value;
    }
    const toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
    function callback(fn, args, thisArg) {
      if (fn && typeof fn.call === "function") {
        return fn.apply(thisArg, args);
      }
    }
    function each(loopable, fn, thisArg, reverse) {
      let i2, len, keys2;
      if (isArray(loopable)) {
        len = loopable.length;
        {
          for (i2 = 0; i2 < len; i2++) {
            fn.call(thisArg, loopable[i2], i2);
          }
        }
      } else if (isObject(loopable)) {
        keys2 = Object.keys(loopable);
        len = keys2.length;
        for (i2 = 0; i2 < len; i2++) {
          fn.call(thisArg, loopable[keys2[i2]], keys2[i2]);
        }
      }
    }
    function _elementsEqual(a0, a1) {
      let i2, ilen, v0, v1;
      if (!a0 || !a1 || a0.length !== a1.length) {
        return false;
      }
      for (i2 = 0, ilen = a0.length; i2 < ilen; ++i2) {
        v0 = a0[i2];
        v1 = a1[i2];
        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
          return false;
        }
      }
      return true;
    }
    function clone(source2) {
      if (isArray(source2)) {
        return source2.map(clone);
      }
      if (isObject(source2)) {
        const target = /* @__PURE__ */ Object.create(null);
        const keys2 = Object.keys(source2);
        const klen = keys2.length;
        let k = 0;
        for (; k < klen; ++k) {
          target[keys2[k]] = clone(source2[keys2[k]]);
        }
        return target;
      }
      return source2;
    }
    function isValidKey(key) {
      return [
        "__proto__",
        "prototype",
        "constructor"
      ].indexOf(key) === -1;
    }
    function _merger(key, target, source2, options) {
      if (!isValidKey(key)) {
        return;
      }
      const tval = target[key];
      const sval = source2[key];
      if (isObject(tval) && isObject(sval)) {
        merge(tval, sval, options);
      } else {
        target[key] = clone(sval);
      }
    }
    function merge(target, source2, options) {
      const sources = isArray(source2) ? source2 : [
        source2
      ];
      const ilen = sources.length;
      if (!isObject(target)) {
        return target;
      }
      options = options || {};
      const merger = options.merger || _merger;
      let current;
      for (let i2 = 0; i2 < ilen; ++i2) {
        current = sources[i2];
        if (!isObject(current)) {
          continue;
        }
        const keys2 = Object.keys(current);
        for (let k = 0, klen = keys2.length; k < klen; ++k) {
          merger(keys2[k], target, current, options);
        }
      }
      return target;
    }
    function mergeIf(target, source2) {
      return merge(target, source2, {
        merger: _mergerIf
      });
    }
    function _mergerIf(key, target, source2) {
      if (!isValidKey(key)) {
        return;
      }
      const tval = target[key];
      const sval = source2[key];
      if (isObject(tval) && isObject(sval)) {
        mergeIf(tval, sval);
      } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
        target[key] = clone(sval);
      }
    }
    const keyResolvers = {
      // Chart.helpers.core resolveObjectKey should resolve empty key to root object
      "": (v) => v,
      // default resolvers
      x: (o) => o.x,
      y: (o) => o.y
    };
    function _splitKey(key) {
      const parts = key.split(".");
      const keys2 = [];
      let tmp = "";
      for (const part of parts) {
        tmp += part;
        if (tmp.endsWith("\\")) {
          tmp = tmp.slice(0, -1) + ".";
        } else {
          keys2.push(tmp);
          tmp = "";
        }
      }
      return keys2;
    }
    function _getKeyResolver(key) {
      const keys2 = _splitKey(key);
      return (obj) => {
        for (const k of keys2) {
          if (k === "") {
            break;
          }
          obj = obj && obj[k];
        }
        return obj;
      };
    }
    function resolveObjectKey(obj, key) {
      const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
      return resolver(obj);
    }
    function _capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    const defined = (value) => typeof value !== "undefined";
    const isFunction = (value) => typeof value === "function";
    const setsEqual = (a, b) => {
      if (a.size !== b.size) {
        return false;
      }
      for (const item of a) {
        if (!b.has(item)) {
          return false;
        }
      }
      return true;
    };
    function _isClickEvent(e) {
      return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
    }
    const PI = Math.PI;
    const TAU = 2 * PI;
    const PITAU = TAU + PI;
    const INFINITY = Number.POSITIVE_INFINITY;
    const RAD_PER_DEG = PI / 180;
    const HALF_PI = PI / 2;
    const QUARTER_PI = PI / 4;
    const TWO_THIRDS_PI = PI * 2 / 3;
    const log10 = Math.log10;
    const sign = Math.sign;
    function almostEquals(x, y, epsilon) {
      return Math.abs(x - y) < epsilon;
    }
    function niceNum(range) {
      const roundedRange = Math.round(range);
      range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
      const niceRange = Math.pow(10, Math.floor(log10(range)));
      const fraction = range / niceRange;
      const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
      return niceFraction * niceRange;
    }
    function _factorize(value) {
      const result = [];
      const sqrt = Math.sqrt(value);
      let i2;
      for (i2 = 1; i2 < sqrt; i2++) {
        if (value % i2 === 0) {
          result.push(i2);
          result.push(value / i2);
        }
      }
      if (sqrt === (sqrt | 0)) {
        result.push(sqrt);
      }
      result.sort((a, b) => a - b).pop();
      return result;
    }
    function isNonPrimitive(n) {
      return typeof n === "symbol" || typeof n === "object" && n !== null && !(Symbol.toPrimitive in n || "toString" in n || "valueOf" in n);
    }
    function isNumber(n) {
      return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);
    }
    function almostWhole(x, epsilon) {
      const rounded = Math.round(x);
      return rounded - epsilon <= x && rounded + epsilon >= x;
    }
    function _setMinAndMaxByKey(array, target, property) {
      let i2, ilen, value;
      for (i2 = 0, ilen = array.length; i2 < ilen; i2++) {
        value = array[i2][property];
        if (!isNaN(value)) {
          target.min = Math.min(target.min, value);
          target.max = Math.max(target.max, value);
        }
      }
    }
    function toRadians(degrees) {
      return degrees * (PI / 180);
    }
    function toDegrees(radians) {
      return radians * (180 / PI);
    }
    function _decimalPlaces(x) {
      if (!isNumberFinite(x)) {
        return;
      }
      let e = 1;
      let p = 0;
      while (Math.round(x * e) / e !== x) {
        e *= 10;
        p++;
      }
      return p;
    }
    function getAngleFromPoint(centrePoint, anglePoint) {
      const distanceFromXCenter = anglePoint.x - centrePoint.x;
      const distanceFromYCenter = anglePoint.y - centrePoint.y;
      const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
      let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
      if (angle < -0.5 * PI) {
        angle += TAU;
      }
      return {
        angle,
        distance: radialDistanceFromCenter
      };
    }
    function distanceBetweenPoints(pt1, pt2) {
      return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
    }
    function _angleDiff(a, b) {
      return (a - b + PITAU) % TAU - PI;
    }
    function _normalizeAngle(a) {
      return (a % TAU + TAU) % TAU;
    }
    function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
      const a = _normalizeAngle(angle);
      const s = _normalizeAngle(start);
      const e = _normalizeAngle(end);
      const angleToStart = _normalizeAngle(s - a);
      const angleToEnd = _normalizeAngle(e - a);
      const startToAngle = _normalizeAngle(a - s);
      const endToAngle = _normalizeAngle(a - e);
      return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
    }
    function _limitValue(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }
    function _int16Range(value) {
      return _limitValue(value, -32768, 32767);
    }
    function _isBetween(value, start, end, epsilon = 1e-6) {
      return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
    }
    function _lookup(table2, value, cmp) {
      cmp = cmp || ((index2) => table2[index2] < value);
      let hi = table2.length - 1;
      let lo = 0;
      let mid;
      while (hi - lo > 1) {
        mid = lo + hi >> 1;
        if (cmp(mid)) {
          lo = mid;
        } else {
          hi = mid;
        }
      }
      return {
        lo,
        hi
      };
    }
    const _lookupByKey = (table2, key, value, last) => _lookup(table2, value, last ? (index2) => {
      const ti = table2[index2][key];
      return ti < value || ti === value && table2[index2 + 1][key] === value;
    } : (index2) => table2[index2][key] < value);
    const _rlookupByKey = (table2, key, value) => _lookup(table2, value, (index2) => table2[index2][key] >= value);
    function _filterBetween(values, min, max) {
      let start = 0;
      let end = values.length;
      while (start < end && values[start] < min) {
        start++;
      }
      while (end > start && values[end - 1] > max) {
        end--;
      }
      return start > 0 || end < values.length ? values.slice(start, end) : values;
    }
    const arrayEvents = [
      "push",
      "pop",
      "shift",
      "splice",
      "unshift"
    ];
    function listenArrayEvents(array, listener) {
      if (array._chartjs) {
        array._chartjs.listeners.push(listener);
        return;
      }
      Object.defineProperty(array, "_chartjs", {
        configurable: true,
        enumerable: false,
        value: {
          listeners: [
            listener
          ]
        }
      });
      arrayEvents.forEach((key) => {
        const method = "_onData" + _capitalize(key);
        const base2 = array[key];
        Object.defineProperty(array, key, {
          configurable: true,
          enumerable: false,
          value(...args) {
            const res = base2.apply(this, args);
            array._chartjs.listeners.forEach((object) => {
              if (typeof object[method] === "function") {
                object[method](...args);
              }
            });
            return res;
          }
        });
      });
    }
    function unlistenArrayEvents(array, listener) {
      const stub = array._chartjs;
      if (!stub) {
        return;
      }
      const listeners = stub.listeners;
      const index2 = listeners.indexOf(listener);
      if (index2 !== -1) {
        listeners.splice(index2, 1);
      }
      if (listeners.length > 0) {
        return;
      }
      arrayEvents.forEach((key) => {
        delete array[key];
      });
      delete array._chartjs;
    }
    function _arrayUnique(items) {
      const set2 = new Set(items);
      if (set2.size === items.length) {
        return items;
      }
      return Array.from(set2);
    }
    const requestAnimFrame = (function() {
      if (typeof window === "undefined") {
        return function(callback2) {
          return callback2();
        };
      }
      return window.requestAnimationFrame;
    })();
    function throttled(fn, thisArg) {
      let argsToUse = [];
      let ticking = false;
      return function(...args) {
        argsToUse = args;
        if (!ticking) {
          ticking = true;
          requestAnimFrame.call(window, () => {
            ticking = false;
            fn.apply(thisArg, argsToUse);
          });
        }
      };
    }
    function debounce(fn, delay) {
      let timeout;
      return function(...args) {
        if (delay) {
          clearTimeout(timeout);
          timeout = setTimeout(fn, delay, args);
        } else {
          fn.apply(this, args);
        }
        return delay;
      };
    }
    const _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
    const _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
    const _textX = (align, left, right, rtl) => {
      const check = rtl ? "left" : "right";
      return align === check ? right : align === "center" ? (left + right) / 2 : left;
    };
    function _getStartAndCountOfVisiblePoints(meta2, points, animationsDisabled) {
      const pointCount = points.length;
      let start = 0;
      let count = pointCount;
      if (meta2._sorted) {
        const { iScale, vScale, _parsed } = meta2;
        const spanGaps = meta2.dataset ? meta2.dataset.options ? meta2.dataset.options.spanGaps : null : null;
        const axis = iScale.axis;
        const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
        if (minDefined) {
          start = Math.min(
            // @ts-expect-error Need to type _parsed
            _lookupByKey(_parsed, axis, min).lo,
            // @ts-expect-error Need to fix types on _lookupByKey
            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
          );
          if (spanGaps) {
            const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
            start -= Math.max(0, distanceToDefinedLo);
          }
          start = _limitValue(start, 0, pointCount - 1);
        }
        if (maxDefined) {
          let end = Math.max(
            // @ts-expect-error Need to type _parsed
            _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
            // @ts-expect-error Need to fix types on _lookupByKey
            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
          );
          if (spanGaps) {
            const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
            end += Math.max(0, distanceToDefinedHi);
          }
          count = _limitValue(end, start, pointCount) - start;
        } else {
          count = pointCount - start;
        }
      }
      return {
        start,
        count
      };
    }
    function _scaleRangesChanged(meta2) {
      const { xScale, yScale, _scaleRanges } = meta2;
      const newRanges = {
        xmin: xScale.min,
        xmax: xScale.max,
        ymin: yScale.min,
        ymax: yScale.max
      };
      if (!_scaleRanges) {
        meta2._scaleRanges = newRanges;
        return true;
      }
      const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
      Object.assign(_scaleRanges, newRanges);
      return changed;
    }
    const atEdge = (t2) => t2 === 0 || t2 === 1;
    const elasticIn = (t2, s, p) => -(Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s) * TAU / p));
    const elasticOut = (t2, s, p) => Math.pow(2, -10 * t2) * Math.sin((t2 - s) * TAU / p) + 1;
    const effects = {
      linear: (t2) => t2,
      easeInQuad: (t2) => t2 * t2,
      easeOutQuad: (t2) => -t2 * (t2 - 2),
      easeInOutQuad: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1),
      easeInCubic: (t2) => t2 * t2 * t2,
      easeOutCubic: (t2) => (t2 -= 1) * t2 * t2 + 1,
      easeInOutCubic: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2),
      easeInQuart: (t2) => t2 * t2 * t2 * t2,
      easeOutQuart: (t2) => -((t2 -= 1) * t2 * t2 * t2 - 1),
      easeInOutQuart: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2),
      easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
      easeOutQuint: (t2) => (t2 -= 1) * t2 * t2 * t2 * t2 + 1,
      easeInOutQuint: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2),
      easeInSine: (t2) => -Math.cos(t2 * HALF_PI) + 1,
      easeOutSine: (t2) => Math.sin(t2 * HALF_PI),
      easeInOutSine: (t2) => -0.5 * (Math.cos(PI * t2) - 1),
      easeInExpo: (t2) => t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1)),
      easeOutExpo: (t2) => t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1,
      easeInOutExpo: (t2) => atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 10 * (t2 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t2 * 2 - 1)) + 2),
      easeInCirc: (t2) => t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1),
      easeOutCirc: (t2) => Math.sqrt(1 - (t2 -= 1) * t2),
      easeInOutCirc: (t2) => (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1),
      easeInElastic: (t2) => atEdge(t2) ? t2 : elasticIn(t2, 0.075, 0.3),
      easeOutElastic: (t2) => atEdge(t2) ? t2 : elasticOut(t2, 0.075, 0.3),
      easeInOutElastic(t2) {
        const s = 0.1125;
        const p = 0.45;
        return atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * elasticIn(t2 * 2, s, p) : 0.5 + 0.5 * elasticOut(t2 * 2 - 1, s, p);
      },
      easeInBack(t2) {
        const s = 1.70158;
        return t2 * t2 * ((s + 1) * t2 - s);
      },
      easeOutBack(t2) {
        const s = 1.70158;
        return (t2 -= 1) * t2 * ((s + 1) * t2 + s) + 1;
      },
      easeInOutBack(t2) {
        let s = 1.70158;
        if ((t2 /= 0.5) < 1) {
          return 0.5 * (t2 * t2 * (((s *= 1.525) + 1) * t2 - s));
        }
        return 0.5 * ((t2 -= 2) * t2 * (((s *= 1.525) + 1) * t2 + s) + 2);
      },
      easeInBounce: (t2) => 1 - effects.easeOutBounce(1 - t2),
      easeOutBounce(t2) {
        const m = 7.5625;
        const d = 2.75;
        if (t2 < 1 / d) {
          return m * t2 * t2;
        }
        if (t2 < 2 / d) {
          return m * (t2 -= 1.5 / d) * t2 + 0.75;
        }
        if (t2 < 2.5 / d) {
          return m * (t2 -= 2.25 / d) * t2 + 0.9375;
        }
        return m * (t2 -= 2.625 / d) * t2 + 0.984375;
      },
      easeInOutBounce: (t2) => t2 < 0.5 ? effects.easeInBounce(t2 * 2) * 0.5 : effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5
    };
    function isPatternOrGradient(value) {
      if (value && typeof value === "object") {
        const type = value.toString();
        return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
      }
      return false;
    }
    function color(value) {
      return isPatternOrGradient(value) ? value : new Color(value);
    }
    function getHoverColor(value) {
      return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
    }
    const numbers = [
      "x",
      "y",
      "borderWidth",
      "radius",
      "tension"
    ];
    const colors = [
      "color",
      "borderColor",
      "backgroundColor"
    ];
    function applyAnimationsDefaults(defaults2) {
      defaults2.set("animation", {
        delay: void 0,
        duration: 1e3,
        easing: "easeOutQuart",
        fn: void 0,
        from: void 0,
        loop: void 0,
        to: void 0,
        type: void 0
      });
      defaults2.describe("animation", {
        _fallback: false,
        _indexable: false,
        _scriptable: (name2) => name2 !== "onProgress" && name2 !== "onComplete" && name2 !== "fn"
      });
      defaults2.set("animations", {
        colors: {
          type: "color",
          properties: colors
        },
        numbers: {
          type: "number",
          properties: numbers
        }
      });
      defaults2.describe("animations", {
        _fallback: "animation"
      });
      defaults2.set("transitions", {
        active: {
          animation: {
            duration: 400
          }
        },
        resize: {
          animation: {
            duration: 0
          }
        },
        show: {
          animations: {
            colors: {
              from: "transparent"
            },
            visible: {
              type: "boolean",
              duration: 0
            }
          }
        },
        hide: {
          animations: {
            colors: {
              to: "transparent"
            },
            visible: {
              type: "boolean",
              easing: "linear",
              fn: (v) => v | 0
            }
          }
        }
      });
    }
    function applyLayoutsDefaults(defaults2) {
      defaults2.set("layout", {
        autoPadding: true,
        padding: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }
      });
    }
    const intlCache = /* @__PURE__ */ new Map();
    function getNumberFormat(locale, options) {
      options = options || {};
      const cacheKey = locale + JSON.stringify(options);
      let formatter = intlCache.get(cacheKey);
      if (!formatter) {
        formatter = new Intl.NumberFormat(locale, options);
        intlCache.set(cacheKey, formatter);
      }
      return formatter;
    }
    function formatNumber$1(num, locale, options) {
      return getNumberFormat(locale, options).format(num);
    }
    const formatters = {
      values(value) {
        return isArray(value) ? value : "" + value;
      },
      numeric(tickValue, index2, ticks) {
        if (tickValue === 0) {
          return "0";
        }
        const locale = this.chart.options.locale;
        let notation;
        let delta = tickValue;
        if (ticks.length > 1) {
          const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
          if (maxTick < 1e-4 || maxTick > 1e15) {
            notation = "scientific";
          }
          delta = calculateDelta(tickValue, ticks);
        }
        const logDelta = log10(Math.abs(delta));
        const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
        const options = {
          notation,
          minimumFractionDigits: numDecimal,
          maximumFractionDigits: numDecimal
        };
        Object.assign(options, this.options.ticks.format);
        return formatNumber$1(tickValue, locale, options);
      }
    };
    function calculateDelta(tickValue, ticks) {
      let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
      if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
        delta = tickValue - Math.floor(tickValue);
      }
      return delta;
    }
    var Ticks = {
      formatters
    };
    function applyScaleDefaults(defaults2) {
      defaults2.set("scale", {
        display: true,
        offset: false,
        reverse: false,
        beginAtZero: false,
        bounds: "ticks",
        clip: true,
        grace: 0,
        grid: {
          display: true,
          lineWidth: 1,
          drawOnChartArea: true,
          drawTicks: true,
          tickLength: 8,
          tickWidth: (_ctx, options) => options.lineWidth,
          tickColor: (_ctx, options) => options.color,
          offset: false
        },
        border: {
          display: true,
          dash: [],
          dashOffset: 0,
          width: 1
        },
        title: {
          display: false,
          text: "",
          padding: {
            top: 4,
            bottom: 4
          }
        },
        ticks: {
          minRotation: 0,
          maxRotation: 50,
          mirror: false,
          textStrokeWidth: 0,
          textStrokeColor: "",
          padding: 3,
          display: true,
          autoSkip: true,
          autoSkipPadding: 3,
          labelOffset: 0,
          callback: Ticks.formatters.values,
          minor: {},
          major: {},
          align: "center",
          crossAlign: "near",
          showLabelBackdrop: false,
          backdropColor: "rgba(255, 255, 255, 0.75)",
          backdropPadding: 2
        }
      });
      defaults2.route("scale.ticks", "color", "", "color");
      defaults2.route("scale.grid", "color", "", "borderColor");
      defaults2.route("scale.border", "color", "", "borderColor");
      defaults2.route("scale.title", "color", "", "color");
      defaults2.describe("scale", {
        _fallback: false,
        _scriptable: (name2) => !name2.startsWith("before") && !name2.startsWith("after") && name2 !== "callback" && name2 !== "parser",
        _indexable: (name2) => name2 !== "borderDash" && name2 !== "tickBorderDash" && name2 !== "dash"
      });
      defaults2.describe("scales", {
        _fallback: "scale"
      });
      defaults2.describe("scale.ticks", {
        _scriptable: (name2) => name2 !== "backdropPadding" && name2 !== "callback",
        _indexable: (name2) => name2 !== "backdropPadding"
      });
    }
    const overrides$1 = /* @__PURE__ */ Object.create(null);
    const descriptors = /* @__PURE__ */ Object.create(null);
    function getScope$1(node, key) {
      if (!key) {
        return node;
      }
      const keys2 = key.split(".");
      for (let i2 = 0, n = keys2.length; i2 < n; ++i2) {
        const k = keys2[i2];
        node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
      }
      return node;
    }
    function set(root, scope, values) {
      if (typeof scope === "string") {
        return merge(getScope$1(root, scope), values);
      }
      return merge(getScope$1(root, ""), scope);
    }
    class Defaults {
      constructor(_descriptors2, _appliers) {
        this.animation = void 0;
        this.backgroundColor = "rgba(0,0,0,0.1)";
        this.borderColor = "rgba(0,0,0,0.1)";
        this.color = "#666";
        this.datasets = {};
        this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
        this.elements = {};
        this.events = [
          "mousemove",
          "mouseout",
          "click",
          "touchstart",
          "touchmove"
        ];
        this.font = {
          family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
          size: 12,
          style: "normal",
          lineHeight: 1.2,
          weight: null
        };
        this.hover = {};
        this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
        this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
        this.hoverColor = (ctx, options) => getHoverColor(options.color);
        this.indexAxis = "x";
        this.interaction = {
          mode: "nearest",
          intersect: true,
          includeInvisible: false
        };
        this.maintainAspectRatio = true;
        this.onHover = null;
        this.onClick = null;
        this.parsing = true;
        this.plugins = {};
        this.responsive = true;
        this.scale = void 0;
        this.scales = {};
        this.showLine = true;
        this.drawActiveElementsOnTop = true;
        this.describe(_descriptors2);
        this.apply(_appliers);
      }
      set(scope, values) {
        return set(this, scope, values);
      }
      get(scope) {
        return getScope$1(this, scope);
      }
      describe(scope, values) {
        return set(descriptors, scope, values);
      }
      override(scope, values) {
        return set(overrides$1, scope, values);
      }
      route(scope, name2, targetScope, targetName) {
        const scopeObject = getScope$1(this, scope);
        const targetScopeObject = getScope$1(this, targetScope);
        const privateName = "_" + name2;
        Object.defineProperties(scopeObject, {
          [privateName]: {
            value: scopeObject[name2],
            writable: true
          },
          [name2]: {
            enumerable: true,
            get() {
              const local = this[privateName];
              const target = targetScopeObject[targetName];
              if (isObject(local)) {
                return Object.assign({}, target, local);
              }
              return valueOrDefault(local, target);
            },
            set(value) {
              this[privateName] = value;
            }
          }
        });
      }
      apply(appliers) {
        appliers.forEach((apply) => apply(this));
      }
    }
    var defaults$2 = /* @__PURE__ */ new Defaults({
      _scriptable: (name2) => !name2.startsWith("on"),
      _indexable: (name2) => name2 !== "events",
      hover: {
        _fallback: "interaction"
      },
      interaction: {
        _scriptable: false,
        _indexable: false
      }
    }, [
      applyAnimationsDefaults,
      applyLayoutsDefaults,
      applyScaleDefaults
    ]);
    function toFontString(font) {
      if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
        return null;
      }
      return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
    }
    function _measureText(ctx, data, gc, longest, string2) {
      let textWidth = data[string2];
      if (!textWidth) {
        textWidth = data[string2] = ctx.measureText(string2).width;
        gc.push(string2);
      }
      if (textWidth > longest) {
        longest = textWidth;
      }
      return longest;
    }
    function _alignPixel(chart, pixel, width) {
      const devicePixelRatio = chart.currentDevicePixelRatio;
      const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
      return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
    }
    function clearCanvas(canvas, ctx) {
      if (!ctx && !canvas) {
        return;
      }
      ctx = ctx || canvas.getContext("2d");
      ctx.save();
      ctx.resetTransform();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }
    function drawPoint(ctx, options, x, y) {
      drawPointLegend(ctx, options, x, y, null);
    }
    function drawPointLegend(ctx, options, x, y, w) {
      let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
      const style = options.pointStyle;
      const rotation = options.rotation;
      const radius = options.radius;
      let rad = (rotation || 0) * RAD_PER_DEG;
      if (style && typeof style === "object") {
        type = style.toString();
        if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(rad);
          ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
          ctx.restore();
          return;
        }
      }
      if (isNaN(radius) || radius <= 0) {
        return;
      }
      ctx.beginPath();
      switch (style) {
        // Default includes circle
        default:
          if (w) {
            ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
          } else {
            ctx.arc(x, y, radius, 0, TAU);
          }
          ctx.closePath();
          break;
        case "triangle":
          width = w ? w / 2 : radius;
          ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
          rad += TWO_THIRDS_PI;
          ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
          rad += TWO_THIRDS_PI;
          ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
          ctx.closePath();
          break;
        case "rectRounded":
          cornerRadius = radius * 0.516;
          size = radius - cornerRadius;
          xOffset = Math.cos(rad + QUARTER_PI) * size;
          xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
          yOffset = Math.sin(rad + QUARTER_PI) * size;
          yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
          ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
          ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
          ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
          ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
          ctx.closePath();
          break;
        case "rect":
          if (!rotation) {
            size = Math.SQRT1_2 * radius;
            width = w ? w / 2 : size;
            ctx.rect(x - width, y - size, 2 * width, 2 * size);
            break;
          }
          rad += QUARTER_PI;
        /* falls through */
        case "rectRot":
          xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
          ctx.moveTo(x - xOffsetW, y - yOffset);
          ctx.lineTo(x + yOffsetW, y - xOffset);
          ctx.lineTo(x + xOffsetW, y + yOffset);
          ctx.lineTo(x - yOffsetW, y + xOffset);
          ctx.closePath();
          break;
        case "crossRot":
          rad += QUARTER_PI;
        /* falls through */
        case "cross":
          xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
          ctx.moveTo(x - xOffsetW, y - yOffset);
          ctx.lineTo(x + xOffsetW, y + yOffset);
          ctx.moveTo(x + yOffsetW, y - xOffset);
          ctx.lineTo(x - yOffsetW, y + xOffset);
          break;
        case "star":
          xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
          ctx.moveTo(x - xOffsetW, y - yOffset);
          ctx.lineTo(x + xOffsetW, y + yOffset);
          ctx.moveTo(x + yOffsetW, y - xOffset);
          ctx.lineTo(x - yOffsetW, y + xOffset);
          rad += QUARTER_PI;
          xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
          ctx.moveTo(x - xOffsetW, y - yOffset);
          ctx.lineTo(x + xOffsetW, y + yOffset);
          ctx.moveTo(x + yOffsetW, y - xOffset);
          ctx.lineTo(x - yOffsetW, y + xOffset);
          break;
        case "line":
          xOffset = w ? w / 2 : Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          break;
        case "dash":
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
          break;
        case false:
          ctx.closePath();
          break;
      }
      ctx.fill();
      if (options.borderWidth > 0) {
        ctx.stroke();
      }
    }
    function _isPointInArea(point, area, margin) {
      margin = margin || 0.5;
      return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
    }
    function clipArea(ctx, area) {
      ctx.save();
      ctx.beginPath();
      ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
      ctx.clip();
    }
    function unclipArea(ctx) {
      ctx.restore();
    }
    function _steppedLineTo(ctx, previous, target, flip, mode) {
      if (!previous) {
        return ctx.lineTo(target.x, target.y);
      }
      if (mode === "middle") {
        const midpoint = (previous.x + target.x) / 2;
        ctx.lineTo(midpoint, previous.y);
        ctx.lineTo(midpoint, target.y);
      } else if (mode === "after" !== !!flip) {
        ctx.lineTo(previous.x, target.y);
      } else {
        ctx.lineTo(target.x, previous.y);
      }
      ctx.lineTo(target.x, target.y);
    }
    function _bezierCurveTo(ctx, previous, target, flip) {
      if (!previous) {
        return ctx.lineTo(target.x, target.y);
      }
      ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
    }
    function setRenderOpts(ctx, opts) {
      if (opts.translation) {
        ctx.translate(opts.translation[0], opts.translation[1]);
      }
      if (!isNullOrUndef(opts.rotation)) {
        ctx.rotate(opts.rotation);
      }
      if (opts.color) {
        ctx.fillStyle = opts.color;
      }
      if (opts.textAlign) {
        ctx.textAlign = opts.textAlign;
      }
      if (opts.textBaseline) {
        ctx.textBaseline = opts.textBaseline;
      }
    }
    function decorateText(ctx, x, y, line, opts) {
      if (opts.strikethrough || opts.underline) {
        const metrics = ctx.measureText(line);
        const left = x - metrics.actualBoundingBoxLeft;
        const right = x + metrics.actualBoundingBoxRight;
        const top2 = y - metrics.actualBoundingBoxAscent;
        const bottom = y + metrics.actualBoundingBoxDescent;
        const yDecoration = opts.strikethrough ? (top2 + bottom) / 2 : bottom;
        ctx.strokeStyle = ctx.fillStyle;
        ctx.beginPath();
        ctx.lineWidth = opts.decorationWidth || 2;
        ctx.moveTo(left, yDecoration);
        ctx.lineTo(right, yDecoration);
        ctx.stroke();
      }
    }
    function drawBackdrop(ctx, opts) {
      const oldColor = ctx.fillStyle;
      ctx.fillStyle = opts.color;
      ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
      ctx.fillStyle = oldColor;
    }
    function renderText(ctx, text, x, y, font, opts = {}) {
      const lines = isArray(text) ? text : [
        text
      ];
      const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
      let i2, line;
      ctx.save();
      ctx.font = font.string;
      setRenderOpts(ctx, opts);
      for (i2 = 0; i2 < lines.length; ++i2) {
        line = lines[i2];
        if (opts.backdrop) {
          drawBackdrop(ctx, opts.backdrop);
        }
        if (stroke) {
          if (opts.strokeColor) {
            ctx.strokeStyle = opts.strokeColor;
          }
          if (!isNullOrUndef(opts.strokeWidth)) {
            ctx.lineWidth = opts.strokeWidth;
          }
          ctx.strokeText(line, x, y, opts.maxWidth);
        }
        ctx.fillText(line, x, y, opts.maxWidth);
        decorateText(ctx, x, y, line, opts);
        y += Number(font.lineHeight);
      }
      ctx.restore();
    }
    function addRoundedRectPath(ctx, rect) {
      const { x, y, w, h, radius } = rect;
      ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
      ctx.lineTo(x, y + h - radius.bottomLeft);
      ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
      ctx.lineTo(x + w - radius.bottomRight, y + h);
      ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
      ctx.lineTo(x + w, y + radius.topRight);
      ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
      ctx.lineTo(x + radius.topLeft, y);
    }
    const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
    const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
    function toLineHeight(value, size) {
      const matches = ("" + value).match(LINE_HEIGHT);
      if (!matches || matches[1] === "normal") {
        return size * 1.2;
      }
      value = +matches[2];
      switch (matches[3]) {
        case "px":
          return value;
        case "%":
          value /= 100;
          break;
      }
      return size * value;
    }
    const numberOrZero = (v) => +v || 0;
    function _readValueToProps(value, props) {
      const ret = {};
      const objProps = isObject(props);
      const keys2 = objProps ? Object.keys(props) : props;
      const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
      for (const prop of keys2) {
        ret[prop] = numberOrZero(read(prop));
      }
      return ret;
    }
    function toTRBL(value) {
      return _readValueToProps(value, {
        top: "y",
        right: "x",
        bottom: "y",
        left: "x"
      });
    }
    function toTRBLCorners(value) {
      return _readValueToProps(value, [
        "topLeft",
        "topRight",
        "bottomLeft",
        "bottomRight"
      ]);
    }
    function toPadding(value) {
      const obj = toTRBL(value);
      obj.width = obj.left + obj.right;
      obj.height = obj.top + obj.bottom;
      return obj;
    }
    function toFont(options, fallback) {
      options = options || {};
      fallback = fallback || defaults$2.font;
      let size = valueOrDefault(options.size, fallback.size);
      if (typeof size === "string") {
        size = parseInt(size, 10);
      }
      let style = valueOrDefault(options.style, fallback.style);
      if (style && !("" + style).match(FONT_STYLE)) {
        console.warn('Invalid font style specified: "' + style + '"');
        style = void 0;
      }
      const font = {
        family: valueOrDefault(options.family, fallback.family),
        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
        size,
        style,
        weight: valueOrDefault(options.weight, fallback.weight),
        string: ""
      };
      font.string = toFontString(font);
      return font;
    }
    function resolve(inputs, context, index2, info) {
      let i2, ilen, value;
      for (i2 = 0, ilen = inputs.length; i2 < ilen; ++i2) {
        value = inputs[i2];
        if (value === void 0) {
          continue;
        }
        if (value !== void 0) {
          return value;
        }
      }
    }
    function _addGrace(minmax, grace, beginAtZero) {
      const { min, max } = minmax;
      const change = toDimension(grace, (max - min) / 2);
      const keepZero = (value, add2) => beginAtZero && value === 0 ? 0 : value + add2;
      return {
        min: keepZero(min, -Math.abs(change)),
        max: keepZero(max, change)
      };
    }
    function createContext(parentContext, context) {
      return Object.assign(Object.create(parentContext), context);
    }
    function _createResolver(scopes, prefixes = [
      ""
    ], rootScopes, fallback, getTarget = () => scopes[0]) {
      const finalRootScopes = rootScopes || scopes;
      if (typeof fallback === "undefined") {
        fallback = _resolve("_fallback", scopes);
      }
      const cache = {
        [Symbol.toStringTag]: "Object",
        _cacheable: true,
        _scopes: scopes,
        _rootScopes: finalRootScopes,
        _fallback: fallback,
        _getTarget: getTarget,
        override: (scope) => _createResolver([
          scope,
          ...scopes
        ], prefixes, finalRootScopes, fallback)
      };
      return new Proxy(cache, {
        /**
        * A trap for the delete operator.
        */
        deleteProperty(target, prop) {
          delete target[prop];
          delete target._keys;
          delete scopes[0][prop];
          return true;
        },
        /**
        * A trap for getting property values.
        */
        get(target, prop) {
          return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
        },
        /**
        * A trap for Object.getOwnPropertyDescriptor.
        * Also used by Object.hasOwnProperty.
        */
        getOwnPropertyDescriptor(target, prop) {
          return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
        },
        /**
        * A trap for Object.getPrototypeOf.
        */
        getPrototypeOf() {
          return Reflect.getPrototypeOf(scopes[0]);
        },
        /**
        * A trap for the in operator.
        */
        has(target, prop) {
          return getKeysFromAllScopes(target).includes(prop);
        },
        /**
        * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
        */
        ownKeys(target) {
          return getKeysFromAllScopes(target);
        },
        /**
        * A trap for setting property values.
        */
        set(target, prop, value) {
          const storage = target._storage || (target._storage = getTarget());
          target[prop] = storage[prop] = value;
          delete target._keys;
          return true;
        }
      });
    }
    function _attachContext(proxy, context, subProxy, descriptorDefaults) {
      const cache = {
        _cacheable: false,
        _proxy: proxy,
        _context: context,
        _subProxy: subProxy,
        _stack: /* @__PURE__ */ new Set(),
        _descriptors: _descriptors(proxy, descriptorDefaults),
        setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
        override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
      };
      return new Proxy(cache, {
        /**
        * A trap for the delete operator.
        */
        deleteProperty(target, prop) {
          delete target[prop];
          delete proxy[prop];
          return true;
        },
        /**
        * A trap for getting property values.
        */
        get(target, prop, receiver) {
          return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
        },
        /**
        * A trap for Object.getOwnPropertyDescriptor.
        * Also used by Object.hasOwnProperty.
        */
        getOwnPropertyDescriptor(target, prop) {
          return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
            enumerable: true,
            configurable: true
          } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
        },
        /**
        * A trap for Object.getPrototypeOf.
        */
        getPrototypeOf() {
          return Reflect.getPrototypeOf(proxy);
        },
        /**
        * A trap for the in operator.
        */
        has(target, prop) {
          return Reflect.has(proxy, prop);
        },
        /**
        * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
        */
        ownKeys() {
          return Reflect.ownKeys(proxy);
        },
        /**
        * A trap for setting property values.
        */
        set(target, prop, value) {
          proxy[prop] = value;
          delete target[prop];
          return true;
        }
      });
    }
    function _descriptors(proxy, defaults2 = {
      scriptable: true,
      indexable: true
    }) {
      const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
      return {
        allKeys: _allKeys,
        scriptable: _scriptable,
        indexable: _indexable,
        isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
        isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
      };
    }
    const readKey = (prefix, name2) => prefix ? prefix + _capitalize(name2) : name2;
    const needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
    function _cached(target, prop, resolve2) {
      if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") {
        return target[prop];
      }
      const value = resolve2();
      target[prop] = value;
      return value;
    }
    function _resolveWithContext(target, prop, receiver) {
      const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
      let value = _proxy[prop];
      if (isFunction(value) && descriptors2.isScriptable(prop)) {
        value = _resolveScriptable(prop, value, target, receiver);
      }
      if (isArray(value) && value.length) {
        value = _resolveArray(prop, value, target, descriptors2.isIndexable);
      }
      if (needsSubResolver(prop, value)) {
        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
      }
      return value;
    }
    function _resolveScriptable(prop, getValue, target, receiver) {
      const { _proxy, _context, _subProxy, _stack } = target;
      if (_stack.has(prop)) {
        throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
      }
      _stack.add(prop);
      let value = getValue(_context, _subProxy || receiver);
      _stack.delete(prop);
      if (needsSubResolver(prop, value)) {
        value = createSubResolver(_proxy._scopes, _proxy, prop, value);
      }
      return value;
    }
    function _resolveArray(prop, value, target, isIndexable) {
      const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
      if (typeof _context.index !== "undefined" && isIndexable(prop)) {
        return value[_context.index % value.length];
      } else if (isObject(value[0])) {
        const arr = value;
        const scopes = _proxy._scopes.filter((s) => s !== arr);
        value = [];
        for (const item of arr) {
          const resolver = createSubResolver(scopes, _proxy, prop, item);
          value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
        }
      }
      return value;
    }
    function resolveFallback(fallback, prop, value) {
      return isFunction(fallback) ? fallback(prop, value) : fallback;
    }
    const getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
    function addScopes(set2, parentScopes, key, parentFallback, value) {
      for (const parent of parentScopes) {
        const scope = getScope(key, parent);
        if (scope) {
          set2.add(scope);
          const fallback = resolveFallback(scope._fallback, key, value);
          if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
            return fallback;
          }
        } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
          return null;
        }
      }
      return false;
    }
    function createSubResolver(parentScopes, resolver, prop, value) {
      const rootScopes = resolver._rootScopes;
      const fallback = resolveFallback(resolver._fallback, prop, value);
      const allScopes = [
        ...parentScopes,
        ...rootScopes
      ];
      const set2 = /* @__PURE__ */ new Set();
      set2.add(value);
      let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
      if (key === null) {
        return false;
      }
      if (typeof fallback !== "undefined" && fallback !== prop) {
        key = addScopesFromKey(set2, allScopes, fallback, key, value);
        if (key === null) {
          return false;
        }
      }
      return _createResolver(Array.from(set2), [
        ""
      ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
    }
    function addScopesFromKey(set2, allScopes, key, fallback, item) {
      while (key) {
        key = addScopes(set2, allScopes, key, fallback, item);
      }
      return key;
    }
    function subGetTarget(resolver, prop, value) {
      const parent = resolver._getTarget();
      if (!(prop in parent)) {
        parent[prop] = {};
      }
      const target = parent[prop];
      if (isArray(target) && isObject(value)) {
        return value;
      }
      return target || {};
    }
    function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
      let value;
      for (const prefix of prefixes) {
        value = _resolve(readKey(prefix, prop), scopes);
        if (typeof value !== "undefined") {
          return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
        }
      }
    }
    function _resolve(key, scopes) {
      for (const scope of scopes) {
        if (!scope) {
          continue;
        }
        const value = scope[key];
        if (typeof value !== "undefined") {
          return value;
        }
      }
    }
    function getKeysFromAllScopes(target) {
      let keys2 = target._keys;
      if (!keys2) {
        keys2 = target._keys = resolveKeysFromAllScopes(target._scopes);
      }
      return keys2;
    }
    function resolveKeysFromAllScopes(scopes) {
      const set2 = /* @__PURE__ */ new Set();
      for (const scope of scopes) {
        for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
          set2.add(key);
        }
      }
      return Array.from(set2);
    }
    const EPSILON = Number.EPSILON || 1e-14;
    const getPoint = (points, i2) => i2 < points.length && !points[i2].skip && points[i2];
    const getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
    function splineCurve(firstPoint, middlePoint, afterPoint, t2) {
      const previous = firstPoint.skip ? middlePoint : firstPoint;
      const current = middlePoint;
      const next = afterPoint.skip ? middlePoint : afterPoint;
      const d01 = distanceBetweenPoints(current, previous);
      const d12 = distanceBetweenPoints(next, current);
      let s01 = d01 / (d01 + d12);
      let s12 = d12 / (d01 + d12);
      s01 = isNaN(s01) ? 0 : s01;
      s12 = isNaN(s12) ? 0 : s12;
      const fa = t2 * s01;
      const fb = t2 * s12;
      return {
        previous: {
          x: current.x - fa * (next.x - previous.x),
          y: current.y - fa * (next.y - previous.y)
        },
        next: {
          x: current.x + fb * (next.x - previous.x),
          y: current.y + fb * (next.y - previous.y)
        }
      };
    }
    function monotoneAdjust(points, deltaK, mK) {
      const pointsLen = points.length;
      let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
      let pointAfter = getPoint(points, 0);
      for (let i2 = 0; i2 < pointsLen - 1; ++i2) {
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i2 + 1);
        if (!pointCurrent || !pointAfter) {
          continue;
        }
        if (almostEquals(deltaK[i2], 0, EPSILON)) {
          mK[i2] = mK[i2 + 1] = 0;
          continue;
        }
        alphaK = mK[i2] / deltaK[i2];
        betaK = mK[i2 + 1] / deltaK[i2];
        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
        if (squaredMagnitude <= 9) {
          continue;
        }
        tauK = 3 / Math.sqrt(squaredMagnitude);
        mK[i2] = alphaK * tauK * deltaK[i2];
        mK[i2 + 1] = betaK * tauK * deltaK[i2];
      }
    }
    function monotoneCompute(points, mK, indexAxis = "x") {
      const valueAxis = getValueAxis(indexAxis);
      const pointsLen = points.length;
      let delta, pointBefore, pointCurrent;
      let pointAfter = getPoint(points, 0);
      for (let i2 = 0; i2 < pointsLen; ++i2) {
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i2 + 1);
        if (!pointCurrent) {
          continue;
        }
        const iPixel = pointCurrent[indexAxis];
        const vPixel = pointCurrent[valueAxis];
        if (pointBefore) {
          delta = (iPixel - pointBefore[indexAxis]) / 3;
          pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
          pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i2];
        }
        if (pointAfter) {
          delta = (pointAfter[indexAxis] - iPixel) / 3;
          pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
          pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i2];
        }
      }
    }
    function splineCurveMonotone(points, indexAxis = "x") {
      const valueAxis = getValueAxis(indexAxis);
      const pointsLen = points.length;
      const deltaK = Array(pointsLen).fill(0);
      const mK = Array(pointsLen);
      let i2, pointBefore, pointCurrent;
      let pointAfter = getPoint(points, 0);
      for (i2 = 0; i2 < pointsLen; ++i2) {
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i2 + 1);
        if (!pointCurrent) {
          continue;
        }
        if (pointAfter) {
          const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
          deltaK[i2] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
        }
        mK[i2] = !pointBefore ? deltaK[i2] : !pointAfter ? deltaK[i2 - 1] : sign(deltaK[i2 - 1]) !== sign(deltaK[i2]) ? 0 : (deltaK[i2 - 1] + deltaK[i2]) / 2;
      }
      monotoneAdjust(points, deltaK, mK);
      monotoneCompute(points, mK, indexAxis);
    }
    function capControlPoint(pt, min, max) {
      return Math.max(Math.min(pt, max), min);
    }
    function capBezierPoints(points, area) {
      let i2, ilen, point, inArea, inAreaPrev;
      let inAreaNext = _isPointInArea(points[0], area);
      for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
        inAreaPrev = inArea;
        inArea = inAreaNext;
        inAreaNext = i2 < ilen - 1 && _isPointInArea(points[i2 + 1], area);
        if (!inArea) {
          continue;
        }
        point = points[i2];
        if (inAreaPrev) {
          point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
          point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
        }
        if (inAreaNext) {
          point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
          point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
        }
      }
    }
    function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
      let i2, ilen, point, controlPoints;
      if (options.spanGaps) {
        points = points.filter((pt) => !pt.skip);
      }
      if (options.cubicInterpolationMode === "monotone") {
        splineCurveMonotone(points, indexAxis);
      } else {
        let prev = loop ? points[points.length - 1] : points[0];
        for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
          point = points[i2];
          controlPoints = splineCurve(prev, point, points[Math.min(i2 + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
          point.cp1x = controlPoints.previous.x;
          point.cp1y = controlPoints.previous.y;
          point.cp2x = controlPoints.next.x;
          point.cp2y = controlPoints.next.y;
          prev = point;
        }
      }
      if (options.capBezierPoints) {
        capBezierPoints(points, area);
      }
    }
    function _isDomSupported() {
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function _getParentNode(domNode) {
      let parent = domNode.parentNode;
      if (parent && parent.toString() === "[object ShadowRoot]") {
        parent = parent.host;
      }
      return parent;
    }
    function parseMaxStyle(styleValue, node, parentProperty) {
      let valueInPixels;
      if (typeof styleValue === "string") {
        valueInPixels = parseInt(styleValue, 10);
        if (styleValue.indexOf("%") !== -1) {
          valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
        }
      } else {
        valueInPixels = styleValue;
      }
      return valueInPixels;
    }
    const getComputedStyle$1 = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
    function getStyle(el, property) {
      return getComputedStyle$1(el).getPropertyValue(property);
    }
    const positions = [
      "top",
      "right",
      "bottom",
      "left"
    ];
    function getPositionedStyle(styles2, style, suffix) {
      const result = {};
      suffix = suffix ? "-" + suffix : "";
      for (let i2 = 0; i2 < 4; i2++) {
        const pos = positions[i2];
        result[pos] = parseFloat(styles2[style + "-" + pos + suffix]) || 0;
      }
      result.width = result.left + result.right;
      result.height = result.top + result.bottom;
      return result;
    }
    const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
    function getCanvasPosition(e, canvas) {
      const touches = e.touches;
      const source2 = touches && touches.length ? touches[0] : e;
      const { offsetX, offsetY } = source2;
      let box = false;
      let x, y;
      if (useOffsetPos(offsetX, offsetY, e.target)) {
        x = offsetX;
        y = offsetY;
      } else {
        const rect = canvas.getBoundingClientRect();
        x = source2.clientX - rect.left;
        y = source2.clientY - rect.top;
        box = true;
      }
      return {
        x,
        y,
        box
      };
    }
    function getRelativePosition(event, chart) {
      if ("native" in event) {
        return event;
      }
      const { canvas, currentDevicePixelRatio } = chart;
      const style = getComputedStyle$1(canvas);
      const borderBox = style.boxSizing === "border-box";
      const paddings = getPositionedStyle(style, "padding");
      const borders = getPositionedStyle(style, "border", "width");
      const { x, y, box } = getCanvasPosition(event, canvas);
      const xOffset = paddings.left + (box && borders.left);
      const yOffset = paddings.top + (box && borders.top);
      let { width, height } = chart;
      if (borderBox) {
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
      }
      return {
        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
      };
    }
    function getContainerSize(canvas, width, height) {
      let maxWidth, maxHeight;
      if (width === void 0 || height === void 0) {
        const container2 = canvas && _getParentNode(canvas);
        if (!container2) {
          width = canvas.clientWidth;
          height = canvas.clientHeight;
        } else {
          const rect = container2.getBoundingClientRect();
          const containerStyle = getComputedStyle$1(container2);
          const containerBorder = getPositionedStyle(containerStyle, "border", "width");
          const containerPadding = getPositionedStyle(containerStyle, "padding");
          width = rect.width - containerPadding.width - containerBorder.width;
          height = rect.height - containerPadding.height - containerBorder.height;
          maxWidth = parseMaxStyle(containerStyle.maxWidth, container2, "clientWidth");
          maxHeight = parseMaxStyle(containerStyle.maxHeight, container2, "clientHeight");
        }
      }
      return {
        width,
        height,
        maxWidth: maxWidth || INFINITY,
        maxHeight: maxHeight || INFINITY
      };
    }
    const round1 = (v) => Math.round(v * 10) / 10;
    function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
      const style = getComputedStyle$1(canvas);
      const margins = getPositionedStyle(style, "margin");
      const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
      const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
      const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
      let { width, height } = containerSize;
      if (style.boxSizing === "content-box") {
        const borders = getPositionedStyle(style, "border", "width");
        const paddings = getPositionedStyle(style, "padding");
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
      }
      width = Math.max(0, width - margins.width);
      height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
      width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
      height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
      if (width && !height) {
        height = round1(width / 2);
      }
      const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
      if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
        height = containerSize.height;
        width = round1(Math.floor(height * aspectRatio));
      }
      return {
        width,
        height
      };
    }
    function retinaScale(chart, forceRatio, forceStyle) {
      const pixelRatio = forceRatio || 1;
      const deviceHeight = round1(chart.height * pixelRatio);
      const deviceWidth = round1(chart.width * pixelRatio);
      chart.height = round1(chart.height);
      chart.width = round1(chart.width);
      const canvas = chart.canvas;
      if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
        canvas.style.height = `${chart.height}px`;
        canvas.style.width = `${chart.width}px`;
      }
      if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
        chart.currentDevicePixelRatio = pixelRatio;
        canvas.height = deviceHeight;
        canvas.width = deviceWidth;
        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        return true;
      }
      return false;
    }
    const supportsEventListenerOptions = (function() {
      let passiveSupported = false;
      try {
        const options = {
          get passive() {
            passiveSupported = true;
            return false;
          }
        };
        if (_isDomSupported()) {
          window.addEventListener("test", null, options);
          window.removeEventListener("test", null, options);
        }
      } catch (e) {
      }
      return passiveSupported;
    })();
    function readUsedSize(element, property) {
      const value = getStyle(element, property);
      const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
      return matches ? +matches[1] : void 0;
    }
    function _pointInLine(p1, p2, t2, mode) {
      return {
        x: p1.x + t2 * (p2.x - p1.x),
        y: p1.y + t2 * (p2.y - p1.y)
      };
    }
    function _steppedInterpolation(p1, p2, t2, mode) {
      return {
        x: p1.x + t2 * (p2.x - p1.x),
        y: mode === "middle" ? t2 < 0.5 ? p1.y : p2.y : mode === "after" ? t2 < 1 ? p1.y : p2.y : t2 > 0 ? p2.y : p1.y
      };
    }
    function _bezierInterpolation(p1, p2, t2, mode) {
      const cp1 = {
        x: p1.cp2x,
        y: p1.cp2y
      };
      const cp2 = {
        x: p2.cp1x,
        y: p2.cp1y
      };
      const a = _pointInLine(p1, cp1, t2);
      const b = _pointInLine(cp1, cp2, t2);
      const c = _pointInLine(cp2, p2, t2);
      const d = _pointInLine(a, b, t2);
      const e = _pointInLine(b, c, t2);
      return _pointInLine(d, e, t2);
    }
    const getRightToLeftAdapter = function(rectX, width) {
      return {
        x(x) {
          return rectX + rectX + width - x;
        },
        setWidth(w) {
          width = w;
        },
        textAlign(align) {
          if (align === "center") {
            return align;
          }
          return align === "right" ? "left" : "right";
        },
        xPlus(x, value) {
          return x - value;
        },
        leftForLtr(x, itemWidth) {
          return x - itemWidth;
        }
      };
    };
    const getLeftToRightAdapter = function() {
      return {
        x(x) {
          return x;
        },
        setWidth(w) {
        },
        textAlign(align) {
          return align;
        },
        xPlus(x, value) {
          return x + value;
        },
        leftForLtr(x, _itemWidth) {
          return x;
        }
      };
    };
    function getRtlAdapter(rtl, rectX, width) {
      return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
    }
    function overrideTextDirection(ctx, direction) {
      let style, original;
      if (direction === "ltr" || direction === "rtl") {
        style = ctx.canvas.style;
        original = [
          style.getPropertyValue("direction"),
          style.getPropertyPriority("direction")
        ];
        style.setProperty("direction", direction, "important");
        ctx.prevTextDirection = original;
      }
    }
    function restoreTextDirection(ctx, original) {
      if (original !== void 0) {
        delete ctx.prevTextDirection;
        ctx.canvas.style.setProperty("direction", original[0], original[1]);
      }
    }
    function propertyFn(property) {
      if (property === "angle") {
        return {
          between: _angleBetween,
          compare: _angleDiff,
          normalize: _normalizeAngle
        };
      }
      return {
        between: _isBetween,
        compare: (a, b) => a - b,
        normalize: (x) => x
      };
    }
    function normalizeSegment({ start, end, count, loop, style }) {
      return {
        start: start % count,
        end: end % count,
        loop: loop && (end - start + 1) % count === 0,
        style
      };
    }
    function getSegment(segment, points, bounds) {
      const { property, start: startBound, end: endBound } = bounds;
      const { between, normalize } = propertyFn(property);
      const count = points.length;
      let { start, end, loop } = segment;
      let i2, ilen;
      if (loop) {
        start += count;
        end += count;
        for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
          if (!between(normalize(points[start % count][property]), startBound, endBound)) {
            break;
          }
          start--;
          end--;
        }
        start %= count;
        end %= count;
      }
      if (end < start) {
        end += count;
      }
      return {
        start,
        end,
        loop,
        style: segment.style
      };
    }
    function _boundSegment(segment, points, bounds) {
      if (!bounds) {
        return [
          segment
        ];
      }
      const { property, start: startBound, end: endBound } = bounds;
      const count = points.length;
      const { compare: compare2, between, normalize } = propertyFn(property);
      const { start, end, loop, style } = getSegment(segment, points, bounds);
      const result = [];
      let inside2 = false;
      let subStart = null;
      let value, point, prevValue;
      const startIsBefore = () => between(startBound, prevValue, value) && compare2(startBound, prevValue) !== 0;
      const endIsBefore = () => compare2(endBound, value) === 0 || between(endBound, prevValue, value);
      const shouldStart = () => inside2 || startIsBefore();
      const shouldStop = () => !inside2 || endIsBefore();
      for (let i2 = start, prev = start; i2 <= end; ++i2) {
        point = points[i2 % count];
        if (point.skip) {
          continue;
        }
        value = normalize(point[property]);
        if (value === prevValue) {
          continue;
        }
        inside2 = between(value, startBound, endBound);
        if (subStart === null && shouldStart()) {
          subStart = compare2(value, startBound) === 0 ? i2 : prev;
        }
        if (subStart !== null && shouldStop()) {
          result.push(normalizeSegment({
            start: subStart,
            end: i2,
            loop,
            count,
            style
          }));
          subStart = null;
        }
        prev = i2;
        prevValue = value;
      }
      if (subStart !== null) {
        result.push(normalizeSegment({
          start: subStart,
          end,
          loop,
          count,
          style
        }));
      }
      return result;
    }
    function _boundSegments(line, bounds) {
      const result = [];
      const segments = line.segments;
      for (let i2 = 0; i2 < segments.length; i2++) {
        const sub = _boundSegment(segments[i2], line.points, bounds);
        if (sub.length) {
          result.push(...sub);
        }
      }
      return result;
    }
    function findStartAndEnd(points, count, loop, spanGaps) {
      let start = 0;
      let end = count - 1;
      if (loop && !spanGaps) {
        while (start < count && !points[start].skip) {
          start++;
        }
      }
      while (start < count && points[start].skip) {
        start++;
      }
      start %= count;
      if (loop) {
        end += start;
      }
      while (end > start && points[end % count].skip) {
        end--;
      }
      end %= count;
      return {
        start,
        end
      };
    }
    function solidSegments(points, start, max, loop) {
      const count = points.length;
      const result = [];
      let last = start;
      let prev = points[start];
      let end;
      for (end = start + 1; end <= max; ++end) {
        const cur2 = points[end % count];
        if (cur2.skip || cur2.stop) {
          if (!prev.skip) {
            loop = false;
            result.push({
              start: start % count,
              end: (end - 1) % count,
              loop
            });
            start = last = cur2.stop ? end : null;
          }
        } else {
          last = end;
          if (prev.skip) {
            start = end;
          }
        }
        prev = cur2;
      }
      if (last !== null) {
        result.push({
          start: start % count,
          end: last % count,
          loop
        });
      }
      return result;
    }
    function _computeSegments(line, segmentOptions) {
      const points = line.points;
      const spanGaps = line.options.spanGaps;
      const count = points.length;
      if (!count) {
        return [];
      }
      const loop = !!line._loop;
      const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
      if (spanGaps === true) {
        return splitByStyles(line, [
          {
            start,
            end,
            loop
          }
        ], points, segmentOptions);
      }
      const max = end < start ? end + count : end;
      const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
      return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
    }
    function splitByStyles(line, segments, points, segmentOptions) {
      if (!segmentOptions || !segmentOptions.setContext || !points) {
        return segments;
      }
      return doSplitByStyles(line, segments, points, segmentOptions);
    }
    function doSplitByStyles(line, segments, points, segmentOptions) {
      const chartContext = line._chart.getContext();
      const baseStyle = readStyle(line.options);
      const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
      const count = points.length;
      const result = [];
      let prevStyle = baseStyle;
      let start = segments[0].start;
      let i2 = start;
      function addStyle(s, e, l, st) {
        const dir = spanGaps ? -1 : 1;
        if (s === e) {
          return;
        }
        s += count;
        while (points[s % count].skip) {
          s -= dir;
        }
        while (points[e % count].skip) {
          e += dir;
        }
        if (s % count !== e % count) {
          result.push({
            start: s % count,
            end: e % count,
            loop: l,
            style: st
          });
          prevStyle = st;
          start = e % count;
        }
      }
      for (const segment of segments) {
        start = spanGaps ? start : segment.start;
        let prev = points[start % count];
        let style;
        for (i2 = start + 1; i2 <= segment.end; i2++) {
          const pt = points[i2 % count];
          style = readStyle(segmentOptions.setContext(createContext(chartContext, {
            type: "segment",
            p0: prev,
            p1: pt,
            p0DataIndex: (i2 - 1) % count,
            p1DataIndex: i2 % count,
            datasetIndex
          })));
          if (styleChanged(style, prevStyle)) {
            addStyle(start, i2 - 1, segment.loop, prevStyle);
          }
          prev = pt;
          prevStyle = style;
        }
        if (start < i2 - 1) {
          addStyle(start, i2 - 1, segment.loop, prevStyle);
        }
      }
      return result;
    }
    function readStyle(options) {
      return {
        backgroundColor: options.backgroundColor,
        borderCapStyle: options.borderCapStyle,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderJoinStyle: options.borderJoinStyle,
        borderWidth: options.borderWidth,
        borderColor: options.borderColor
      };
    }
    function styleChanged(style, prevStyle) {
      if (!prevStyle) {
        return false;
      }
      const cache = [];
      const replacer = function(key, value) {
        if (!isPatternOrGradient(value)) {
          return value;
        }
        if (!cache.includes(value)) {
          cache.push(value);
        }
        return cache.indexOf(value);
      };
      return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
    }
    function getSizeForArea(scale, chartArea2, field) {
      return scale.options.clip ? scale[field] : chartArea2[field];
    }
    function getDatasetArea(meta2, chartArea2) {
      const { xScale, yScale } = meta2;
      if (xScale && yScale) {
        return {
          left: getSizeForArea(xScale, chartArea2, "left"),
          right: getSizeForArea(xScale, chartArea2, "right"),
          top: getSizeForArea(yScale, chartArea2, "top"),
          bottom: getSizeForArea(yScale, chartArea2, "bottom")
        };
      }
      return chartArea2;
    }
    function getDatasetClipArea(chart, meta2) {
      const clip2 = meta2._clip;
      if (clip2.disabled) {
        return false;
      }
      const area = getDatasetArea(meta2, chart.chartArea);
      return {
        left: clip2.left === false ? 0 : area.left - (clip2.left === true ? 0 : clip2.left),
        right: clip2.right === false ? chart.width : area.right + (clip2.right === true ? 0 : clip2.right),
        top: clip2.top === false ? 0 : area.top - (clip2.top === true ? 0 : clip2.top),
        bottom: clip2.bottom === false ? chart.height : area.bottom + (clip2.bottom === true ? 0 : clip2.bottom)
      };
    }
    class Animator {
      constructor() {
        this._request = null;
        this._charts = /* @__PURE__ */ new Map();
        this._running = false;
        this._lastDate = void 0;
      }
      _notify(chart, anims, date, type) {
        const callbacks = anims.listeners[type];
        const numSteps = anims.duration;
        callbacks.forEach((fn) => fn({
          chart,
          initial: anims.initial,
          numSteps,
          currentStep: Math.min(date - anims.start, numSteps)
        }));
      }
      _refresh() {
        if (this._request) {
          return;
        }
        this._running = true;
        this._request = requestAnimFrame.call(window, () => {
          this._update();
          this._request = null;
          if (this._running) {
            this._refresh();
          }
        });
      }
      _update(date = Date.now()) {
        let remaining = 0;
        this._charts.forEach((anims, chart) => {
          if (!anims.running || !anims.items.length) {
            return;
          }
          const items = anims.items;
          let i2 = items.length - 1;
          let draw2 = false;
          let item;
          for (; i2 >= 0; --i2) {
            item = items[i2];
            if (item._active) {
              if (item._total > anims.duration) {
                anims.duration = item._total;
              }
              item.tick(date);
              draw2 = true;
            } else {
              items[i2] = items[items.length - 1];
              items.pop();
            }
          }
          if (draw2) {
            chart.draw();
            this._notify(chart, anims, date, "progress");
          }
          if (!items.length) {
            anims.running = false;
            this._notify(chart, anims, date, "complete");
            anims.initial = false;
          }
          remaining += items.length;
        });
        this._lastDate = date;
        if (remaining === 0) {
          this._running = false;
        }
      }
      _getAnims(chart) {
        const charts = this._charts;
        let anims = charts.get(chart);
        if (!anims) {
          anims = {
            running: false,
            initial: true,
            items: [],
            listeners: {
              complete: [],
              progress: []
            }
          };
          charts.set(chart, anims);
        }
        return anims;
      }
      listen(chart, event, cb) {
        this._getAnims(chart).listeners[event].push(cb);
      }
      add(chart, items) {
        if (!items || !items.length) {
          return;
        }
        this._getAnims(chart).items.push(...items);
      }
      has(chart) {
        return this._getAnims(chart).items.length > 0;
      }
      start(chart) {
        const anims = this._charts.get(chart);
        if (!anims) {
          return;
        }
        anims.running = true;
        anims.start = Date.now();
        anims.duration = anims.items.reduce((acc, cur2) => Math.max(acc, cur2._duration), 0);
        this._refresh();
      }
      running(chart) {
        if (!this._running) {
          return false;
        }
        const anims = this._charts.get(chart);
        if (!anims || !anims.running || !anims.items.length) {
          return false;
        }
        return true;
      }
      stop(chart) {
        const anims = this._charts.get(chart);
        if (!anims || !anims.items.length) {
          return;
        }
        const items = anims.items;
        let i2 = items.length - 1;
        for (; i2 >= 0; --i2) {
          items[i2].cancel();
        }
        anims.items = [];
        this._notify(chart, anims, Date.now(), "complete");
      }
      remove(chart) {
        return this._charts.delete(chart);
      }
    }
    var animator = /* @__PURE__ */ new Animator();
    const transparent = "transparent";
    const interpolators = {
      boolean(from2, to2, factor) {
        return factor > 0.5 ? to2 : from2;
      },
      color(from2, to2, factor) {
        const c0 = color(from2 || transparent);
        const c1 = c0.valid && color(to2 || transparent);
        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
      },
      number(from2, to2, factor) {
        return from2 + (to2 - from2) * factor;
      }
    };
    class Animation {
      constructor(cfg, target, prop, to2) {
        const currentValue = target[prop];
        to2 = resolve([
          cfg.to,
          to2,
          currentValue,
          cfg.from
        ]);
        const from2 = resolve([
          cfg.from,
          currentValue,
          to2
        ]);
        this._active = true;
        this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
        this._easing = effects[cfg.easing] || effects.linear;
        this._start = Math.floor(Date.now() + (cfg.delay || 0));
        this._duration = this._total = Math.floor(cfg.duration);
        this._loop = !!cfg.loop;
        this._target = target;
        this._prop = prop;
        this._from = from2;
        this._to = to2;
        this._promises = void 0;
      }
      active() {
        return this._active;
      }
      update(cfg, to2, date) {
        if (this._active) {
          this._notify(false);
          const currentValue = this._target[this._prop];
          const elapsed = date - this._start;
          const remain = this._duration - elapsed;
          this._start = date;
          this._duration = Math.floor(Math.max(remain, cfg.duration));
          this._total += elapsed;
          this._loop = !!cfg.loop;
          this._to = resolve([
            cfg.to,
            to2,
            currentValue,
            cfg.from
          ]);
          this._from = resolve([
            cfg.from,
            currentValue,
            to2
          ]);
        }
      }
      cancel() {
        if (this._active) {
          this.tick(Date.now());
          this._active = false;
          this._notify(false);
        }
      }
      tick(date) {
        const elapsed = date - this._start;
        const duration = this._duration;
        const prop = this._prop;
        const from2 = this._from;
        const loop = this._loop;
        const to2 = this._to;
        let factor;
        this._active = from2 !== to2 && (loop || elapsed < duration);
        if (!this._active) {
          this._target[prop] = to2;
          this._notify(true);
          return;
        }
        if (elapsed < 0) {
          this._target[prop] = from2;
          return;
        }
        factor = elapsed / duration % 2;
        factor = loop && factor > 1 ? 2 - factor : factor;
        factor = this._easing(Math.min(1, Math.max(0, factor)));
        this._target[prop] = this._fn(from2, to2, factor);
      }
      wait() {
        const promises = this._promises || (this._promises = []);
        return new Promise((res, rej) => {
          promises.push({
            res,
            rej
          });
        });
      }
      _notify(resolved) {
        const method = resolved ? "res" : "rej";
        const promises = this._promises || [];
        for (let i2 = 0; i2 < promises.length; i2++) {
          promises[i2][method]();
        }
      }
    }
    class Animations {
      constructor(chart, config2) {
        this._chart = chart;
        this._properties = /* @__PURE__ */ new Map();
        this.configure(config2);
      }
      configure(config2) {
        if (!isObject(config2)) {
          return;
        }
        const animationOptions = Object.keys(defaults$2.animation);
        const animatedProps = this._properties;
        Object.getOwnPropertyNames(config2).forEach((key) => {
          const cfg = config2[key];
          if (!isObject(cfg)) {
            return;
          }
          const resolved = {};
          for (const option of animationOptions) {
            resolved[option] = cfg[option];
          }
          (isArray(cfg.properties) && cfg.properties || [
            key
          ]).forEach((prop) => {
            if (prop === key || !animatedProps.has(prop)) {
              animatedProps.set(prop, resolved);
            }
          });
        });
      }
      _animateOptions(target, values) {
        const newOptions = values.options;
        const options = resolveTargetOptions(target, newOptions);
        if (!options) {
          return [];
        }
        const animations = this._createAnimations(options, newOptions);
        if (newOptions.$shared) {
          awaitAll(target.options.$animations, newOptions).then(() => {
            target.options = newOptions;
          }, () => {
          });
        }
        return animations;
      }
      _createAnimations(target, values) {
        const animatedProps = this._properties;
        const animations = [];
        const running = target.$animations || (target.$animations = {});
        const props = Object.keys(values);
        const date = Date.now();
        let i2;
        for (i2 = props.length - 1; i2 >= 0; --i2) {
          const prop = props[i2];
          if (prop.charAt(0) === "$") {
            continue;
          }
          if (prop === "options") {
            animations.push(...this._animateOptions(target, values));
            continue;
          }
          const value = values[prop];
          let animation = running[prop];
          const cfg = animatedProps.get(prop);
          if (animation) {
            if (cfg && animation.active()) {
              animation.update(cfg, value, date);
              continue;
            } else {
              animation.cancel();
            }
          }
          if (!cfg || !cfg.duration) {
            target[prop] = value;
            continue;
          }
          running[prop] = animation = new Animation(cfg, target, prop, value);
          animations.push(animation);
        }
        return animations;
      }
      update(target, values) {
        if (this._properties.size === 0) {
          Object.assign(target, values);
          return;
        }
        const animations = this._createAnimations(target, values);
        if (animations.length) {
          animator.add(this._chart, animations);
          return true;
        }
      }
    }
    function awaitAll(animations, properties) {
      const running = [];
      const keys2 = Object.keys(properties);
      for (let i2 = 0; i2 < keys2.length; i2++) {
        const anim = animations[keys2[i2]];
        if (anim && anim.active()) {
          running.push(anim.wait());
        }
      }
      return Promise.all(running);
    }
    function resolveTargetOptions(target, newOptions) {
      if (!newOptions) {
        return;
      }
      let options = target.options;
      if (!options) {
        target.options = newOptions;
        return;
      }
      if (options.$shared) {
        target.options = options = Object.assign({}, options, {
          $shared: false,
          $animations: {}
        });
      }
      return options;
    }
    function scaleClip(scale, allowedOverflow) {
      const opts = scale && scale.options || {};
      const reverse = opts.reverse;
      const min = opts.min === void 0 ? allowedOverflow : 0;
      const max = opts.max === void 0 ? allowedOverflow : 0;
      return {
        start: reverse ? max : min,
        end: reverse ? min : max
      };
    }
    function defaultClip(xScale, yScale, allowedOverflow) {
      if (allowedOverflow === false) {
        return false;
      }
      const x = scaleClip(xScale, allowedOverflow);
      const y = scaleClip(yScale, allowedOverflow);
      return {
        top: y.end,
        right: x.end,
        bottom: y.start,
        left: x.start
      };
    }
    function toClip(value) {
      let t2, r, b, l;
      if (isObject(value)) {
        t2 = value.top;
        r = value.right;
        b = value.bottom;
        l = value.left;
      } else {
        t2 = r = b = l = value;
      }
      return {
        top: t2,
        right: r,
        bottom: b,
        left: l,
        disabled: value === false
      };
    }
    function getSortedDatasetIndices(chart, filterVisible) {
      const keys2 = [];
      const metasets = chart._getSortedDatasetMetas(filterVisible);
      let i2, ilen;
      for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
        keys2.push(metasets[i2].index);
      }
      return keys2;
    }
    function applyStack(stack, value, dsIndex, options = {}) {
      const keys2 = stack.keys;
      const singleMode = options.mode === "single";
      let i2, ilen, datasetIndex, otherValue;
      if (value === null) {
        return;
      }
      let found = false;
      for (i2 = 0, ilen = keys2.length; i2 < ilen; ++i2) {
        datasetIndex = +keys2[i2];
        if (datasetIndex === dsIndex) {
          found = true;
          if (options.all) {
            continue;
          }
          break;
        }
        otherValue = stack.values[datasetIndex];
        if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
          value += otherValue;
        }
      }
      if (!found && !options.all) {
        return 0;
      }
      return value;
    }
    function convertObjectDataToArray(data, meta2) {
      const { iScale, vScale } = meta2;
      const iAxisKey = iScale.axis === "x" ? "x" : "y";
      const vAxisKey = vScale.axis === "x" ? "x" : "y";
      const keys2 = Object.keys(data);
      const adata = new Array(keys2.length);
      let i2, ilen, key;
      for (i2 = 0, ilen = keys2.length; i2 < ilen; ++i2) {
        key = keys2[i2];
        adata[i2] = {
          [iAxisKey]: key,
          [vAxisKey]: data[key]
        };
      }
      return adata;
    }
    function isStacked(scale, meta2) {
      const stacked = scale && scale.options.stacked;
      return stacked || stacked === void 0 && meta2.stack !== void 0;
    }
    function getStackKey(indexScale, valueScale, meta2) {
      return `${indexScale.id}.${valueScale.id}.${meta2.stack || meta2.type}`;
    }
    function getUserBounds(scale) {
      const { min, max, minDefined, maxDefined } = scale.getUserBounds();
      return {
        min: minDefined ? min : Number.NEGATIVE_INFINITY,
        max: maxDefined ? max : Number.POSITIVE_INFINITY
      };
    }
    function getOrCreateStack(stacks, stackKey, indexValue) {
      const subStack = stacks[stackKey] || (stacks[stackKey] = {});
      return subStack[indexValue] || (subStack[indexValue] = {});
    }
    function getLastIndexInStack(stack, vScale, positive, type) {
      for (const meta2 of vScale.getMatchingVisibleMetas(type).reverse()) {
        const value = stack[meta2.index];
        if (positive && value > 0 || !positive && value < 0) {
          return meta2.index;
        }
      }
      return null;
    }
    function updateStacks(controller, parsed) {
      const { chart, _cachedMeta: meta2 } = controller;
      const stacks = chart._stacks || (chart._stacks = {});
      const { iScale, vScale, index: datasetIndex } = meta2;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const key = getStackKey(iScale, vScale, meta2);
      const ilen = parsed.length;
      let stack;
      for (let i2 = 0; i2 < ilen; ++i2) {
        const item = parsed[i2];
        const { [iAxis]: index2, [vAxis]: value } = item;
        const itemStacks = item._stacks || (item._stacks = {});
        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
        stack[datasetIndex] = value;
        stack._top = getLastIndexInStack(stack, vScale, true, meta2.type);
        stack._bottom = getLastIndexInStack(stack, vScale, false, meta2.type);
        const visualValues = stack._visualValues || (stack._visualValues = {});
        visualValues[datasetIndex] = value;
      }
    }
    function getFirstScaleId(chart, axis) {
      const scales = chart.scales;
      return Object.keys(scales).filter((key) => scales[key].axis === axis).shift();
    }
    function createDatasetContext(parent, index2) {
      return createContext(parent, {
        active: false,
        dataset: void 0,
        datasetIndex: index2,
        index: index2,
        mode: "default",
        type: "dataset"
      });
    }
    function createDataContext(parent, index2, element) {
      return createContext(parent, {
        active: false,
        dataIndex: index2,
        parsed: void 0,
        raw: void 0,
        element,
        index: index2,
        mode: "default",
        type: "data"
      });
    }
    function clearStacks(meta2, items) {
      const datasetIndex = meta2.controller.index;
      const axis = meta2.vScale && meta2.vScale.axis;
      if (!axis) {
        return;
      }
      items = items || meta2._parsed;
      for (const parsed of items) {
        const stacks = parsed._stacks;
        if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
          return;
        }
        delete stacks[axis][datasetIndex];
        if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
          delete stacks[axis]._visualValues[datasetIndex];
        }
      }
    }
    const isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
    const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
    const createStack = (canStack, meta2, chart) => canStack && !meta2.hidden && meta2._stacked && {
      keys: getSortedDatasetIndices(chart, true),
      values: null
    };
    class DatasetController {
      constructor(chart, datasetIndex) {
        this.chart = chart;
        this._ctx = chart.ctx;
        this.index = datasetIndex;
        this._cachedDataOpts = {};
        this._cachedMeta = this.getMeta();
        this._type = this._cachedMeta.type;
        this.options = void 0;
        this._parsing = false;
        this._data = void 0;
        this._objectData = void 0;
        this._sharedOptions = void 0;
        this._drawStart = void 0;
        this._drawCount = void 0;
        this.enableOptionSharing = false;
        this.supportsDecimation = false;
        this.$context = void 0;
        this._syncList = [];
        this.datasetElementType = new.target.datasetElementType;
        this.dataElementType = new.target.dataElementType;
        this.initialize();
      }
      initialize() {
        const meta2 = this._cachedMeta;
        this.configure();
        this.linkScales();
        meta2._stacked = isStacked(meta2.vScale, meta2);
        this.addElements();
        if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
          console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
        }
      }
      updateIndex(datasetIndex) {
        if (this.index !== datasetIndex) {
          clearStacks(this._cachedMeta);
        }
        this.index = datasetIndex;
      }
      linkScales() {
        const chart = this.chart;
        const meta2 = this._cachedMeta;
        const dataset = this.getDataset();
        const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
        const xid = meta2.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
        const yid = meta2.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
        const rid = meta2.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
        const indexAxis = meta2.indexAxis;
        const iid = meta2.iAxisID = chooseId(indexAxis, xid, yid, rid);
        const vid = meta2.vAxisID = chooseId(indexAxis, yid, xid, rid);
        meta2.xScale = this.getScaleForId(xid);
        meta2.yScale = this.getScaleForId(yid);
        meta2.rScale = this.getScaleForId(rid);
        meta2.iScale = this.getScaleForId(iid);
        meta2.vScale = this.getScaleForId(vid);
      }
      getDataset() {
        return this.chart.data.datasets[this.index];
      }
      getMeta() {
        return this.chart.getDatasetMeta(this.index);
      }
      getScaleForId(scaleID) {
        return this.chart.scales[scaleID];
      }
      _getOtherScale(scale) {
        const meta2 = this._cachedMeta;
        return scale === meta2.iScale ? meta2.vScale : meta2.iScale;
      }
      reset() {
        this._update("reset");
      }
      _destroy() {
        const meta2 = this._cachedMeta;
        if (this._data) {
          unlistenArrayEvents(this._data, this);
        }
        if (meta2._stacked) {
          clearStacks(meta2);
        }
      }
      _dataCheck() {
        const dataset = this.getDataset();
        const data = dataset.data || (dataset.data = []);
        const _data = this._data;
        if (isObject(data)) {
          const meta2 = this._cachedMeta;
          this._data = convertObjectDataToArray(data, meta2);
        } else if (_data !== data) {
          if (_data) {
            unlistenArrayEvents(_data, this);
            const meta2 = this._cachedMeta;
            clearStacks(meta2);
            meta2._parsed = [];
          }
          if (data && Object.isExtensible(data)) {
            listenArrayEvents(data, this);
          }
          this._syncList = [];
          this._data = data;
        }
      }
      addElements() {
        const meta2 = this._cachedMeta;
        this._dataCheck();
        if (this.datasetElementType) {
          meta2.dataset = new this.datasetElementType();
        }
      }
      buildOrUpdateElements(resetNewElements) {
        const meta2 = this._cachedMeta;
        const dataset = this.getDataset();
        let stackChanged = false;
        this._dataCheck();
        const oldStacked = meta2._stacked;
        meta2._stacked = isStacked(meta2.vScale, meta2);
        if (meta2.stack !== dataset.stack) {
          stackChanged = true;
          clearStacks(meta2);
          meta2.stack = dataset.stack;
        }
        this._resyncElements(resetNewElements);
        if (stackChanged || oldStacked !== meta2._stacked) {
          updateStacks(this, meta2._parsed);
          meta2._stacked = isStacked(meta2.vScale, meta2);
        }
      }
      configure() {
        const config2 = this.chart.config;
        const scopeKeys = config2.datasetScopeKeys(this._type);
        const scopes = config2.getOptionScopes(this.getDataset(), scopeKeys, true);
        this.options = config2.createResolver(scopes, this.getContext());
        this._parsing = this.options.parsing;
        this._cachedDataOpts = {};
      }
      parse(start, count) {
        const { _cachedMeta: meta2, _data: data } = this;
        const { iScale, _stacked } = meta2;
        const iAxis = iScale.axis;
        let sorted = start === 0 && count === data.length ? true : meta2._sorted;
        let prev = start > 0 && meta2._parsed[start - 1];
        let i2, cur2, parsed;
        if (this._parsing === false) {
          meta2._parsed = data;
          meta2._sorted = true;
          parsed = data;
        } else {
          if (isArray(data[start])) {
            parsed = this.parseArrayData(meta2, data, start, count);
          } else if (isObject(data[start])) {
            parsed = this.parseObjectData(meta2, data, start, count);
          } else {
            parsed = this.parsePrimitiveData(meta2, data, start, count);
          }
          const isNotInOrderComparedToPrev = () => cur2[iAxis] === null || prev && cur2[iAxis] < prev[iAxis];
          for (i2 = 0; i2 < count; ++i2) {
            meta2._parsed[i2 + start] = cur2 = parsed[i2];
            if (sorted) {
              if (isNotInOrderComparedToPrev()) {
                sorted = false;
              }
              prev = cur2;
            }
          }
          meta2._sorted = sorted;
        }
        if (_stacked) {
          updateStacks(this, parsed);
        }
      }
      parsePrimitiveData(meta2, data, start, count) {
        const { iScale, vScale } = meta2;
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const labels = iScale.getLabels();
        const singleScale = iScale === vScale;
        const parsed = new Array(count);
        let i2, ilen, index2;
        for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
          index2 = i2 + start;
          parsed[i2] = {
            [iAxis]: singleScale || iScale.parse(labels[index2], index2),
            [vAxis]: vScale.parse(data[index2], index2)
          };
        }
        return parsed;
      }
      parseArrayData(meta2, data, start, count) {
        const { xScale, yScale } = meta2;
        const parsed = new Array(count);
        let i2, ilen, index2, item;
        for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
          index2 = i2 + start;
          item = data[index2];
          parsed[i2] = {
            x: xScale.parse(item[0], index2),
            y: yScale.parse(item[1], index2)
          };
        }
        return parsed;
      }
      parseObjectData(meta2, data, start, count) {
        const { xScale, yScale } = meta2;
        const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
        const parsed = new Array(count);
        let i2, ilen, index2, item;
        for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
          index2 = i2 + start;
          item = data[index2];
          parsed[i2] = {
            x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
            y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
          };
        }
        return parsed;
      }
      getParsed(index2) {
        return this._cachedMeta._parsed[index2];
      }
      getDataElement(index2) {
        return this._cachedMeta.data[index2];
      }
      applyStack(scale, parsed, mode) {
        const chart = this.chart;
        const meta2 = this._cachedMeta;
        const value = parsed[scale.axis];
        const stack = {
          keys: getSortedDatasetIndices(chart, true),
          values: parsed._stacks[scale.axis]._visualValues
        };
        return applyStack(stack, value, meta2.index, {
          mode
        });
      }
      updateRangeFromParsed(range, scale, parsed, stack) {
        const parsedValue = parsed[scale.axis];
        let value = parsedValue === null ? NaN : parsedValue;
        const values = stack && parsed._stacks[scale.axis];
        if (stack && values) {
          stack.values = values;
          value = applyStack(stack, parsedValue, this._cachedMeta.index);
        }
        range.min = Math.min(range.min, value);
        range.max = Math.max(range.max, value);
      }
      getMinMax(scale, canStack) {
        const meta2 = this._cachedMeta;
        const _parsed = meta2._parsed;
        const sorted = meta2._sorted && scale === meta2.iScale;
        const ilen = _parsed.length;
        const otherScale = this._getOtherScale(scale);
        const stack = createStack(canStack, meta2, this.chart);
        const range = {
          min: Number.POSITIVE_INFINITY,
          max: Number.NEGATIVE_INFINITY
        };
        const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
        let i2, parsed;
        function _skip() {
          parsed = _parsed[i2];
          const otherValue = parsed[otherScale.axis];
          return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
        }
        for (i2 = 0; i2 < ilen; ++i2) {
          if (_skip()) {
            continue;
          }
          this.updateRangeFromParsed(range, scale, parsed, stack);
          if (sorted) {
            break;
          }
        }
        if (sorted) {
          for (i2 = ilen - 1; i2 >= 0; --i2) {
            if (_skip()) {
              continue;
            }
            this.updateRangeFromParsed(range, scale, parsed, stack);
            break;
          }
        }
        return range;
      }
      getAllParsedValues(scale) {
        const parsed = this._cachedMeta._parsed;
        const values = [];
        let i2, ilen, value;
        for (i2 = 0, ilen = parsed.length; i2 < ilen; ++i2) {
          value = parsed[i2][scale.axis];
          if (isNumberFinite(value)) {
            values.push(value);
          }
        }
        return values;
      }
      getMaxOverflow() {
        return false;
      }
      getLabelAndValue(index2) {
        const meta2 = this._cachedMeta;
        const iScale = meta2.iScale;
        const vScale = meta2.vScale;
        const parsed = this.getParsed(index2);
        return {
          label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
          value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
        };
      }
      _update(mode) {
        const meta2 = this._cachedMeta;
        this.update(mode || "default");
        meta2._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta2.xScale, meta2.yScale, this.getMaxOverflow())));
      }
      update(mode) {
      }
      draw() {
        const ctx = this._ctx;
        const chart = this.chart;
        const meta2 = this._cachedMeta;
        const elements = meta2.data || [];
        const area = chart.chartArea;
        const active = [];
        const start = this._drawStart || 0;
        const count = this._drawCount || elements.length - start;
        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
        let i2;
        if (meta2.dataset) {
          meta2.dataset.draw(ctx, area, start, count);
        }
        for (i2 = start; i2 < start + count; ++i2) {
          const element = elements[i2];
          if (element.hidden) {
            continue;
          }
          if (element.active && drawActiveElementsOnTop) {
            active.push(element);
          } else {
            element.draw(ctx, area);
          }
        }
        for (i2 = 0; i2 < active.length; ++i2) {
          active[i2].draw(ctx, area);
        }
      }
      getStyle(index2, active) {
        const mode = active ? "active" : "default";
        return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
      }
      getContext(index2, active, mode) {
        const dataset = this.getDataset();
        let context;
        if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
          const element = this._cachedMeta.data[index2];
          context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
          context.parsed = this.getParsed(index2);
          context.raw = dataset.data[index2];
          context.index = context.dataIndex = index2;
        } else {
          context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
          context.dataset = dataset;
          context.index = context.datasetIndex = this.index;
        }
        context.active = !!active;
        context.mode = mode;
        return context;
      }
      resolveDatasetElementOptions(mode) {
        return this._resolveElementOptions(this.datasetElementType.id, mode);
      }
      resolveDataElementOptions(index2, mode) {
        return this._resolveElementOptions(this.dataElementType.id, mode, index2);
      }
      _resolveElementOptions(elementType, mode = "default", index2) {
        const active = mode === "active";
        const cache = this._cachedDataOpts;
        const cacheKey = elementType + "-" + mode;
        const cached = cache[cacheKey];
        const sharing = this.enableOptionSharing && defined(index2);
        if (cached) {
          return cloneIfNotShared(cached, sharing);
        }
        const config2 = this.chart.config;
        const scopeKeys = config2.datasetElementScopeKeys(this._type, elementType);
        const prefixes = active ? [
          `${elementType}Hover`,
          "hover",
          elementType,
          ""
        ] : [
          elementType,
          ""
        ];
        const scopes = config2.getOptionScopes(this.getDataset(), scopeKeys);
        const names2 = Object.keys(defaults$2.elements[elementType]);
        const context = () => this.getContext(index2, active, mode);
        const values = config2.resolveNamedOptions(scopes, names2, context, prefixes);
        if (values.$shared) {
          values.$shared = sharing;
          cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
        }
        return values;
      }
      _resolveAnimations(index2, transition, active) {
        const chart = this.chart;
        const cache = this._cachedDataOpts;
        const cacheKey = `animation-${transition}`;
        const cached = cache[cacheKey];
        if (cached) {
          return cached;
        }
        let options;
        if (chart.options.animation !== false) {
          const config2 = this.chart.config;
          const scopeKeys = config2.datasetAnimationScopeKeys(this._type, transition);
          const scopes = config2.getOptionScopes(this.getDataset(), scopeKeys);
          options = config2.createResolver(scopes, this.getContext(index2, active, transition));
        }
        const animations = new Animations(chart, options && options.animations);
        if (options && options._cacheable) {
          cache[cacheKey] = Object.freeze(animations);
        }
        return animations;
      }
      getSharedOptions(options) {
        if (!options.$shared) {
          return;
        }
        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
      }
      includeOptions(mode, sharedOptions) {
        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
      }
      _getSharedOptions(start, mode) {
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const previouslySharedOptions = this._sharedOptions;
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
        return {
          sharedOptions,
          includeOptions
        };
      }
      updateElement(element, index2, properties, mode) {
        if (isDirectUpdateMode(mode)) {
          Object.assign(element, properties);
        } else {
          this._resolveAnimations(index2, mode).update(element, properties);
        }
      }
      updateSharedOptions(sharedOptions, mode, newOptions) {
        if (sharedOptions && !isDirectUpdateMode(mode)) {
          this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
        }
      }
      _setStyle(element, index2, mode, active) {
        element.active = active;
        const options = this.getStyle(index2, active);
        this._resolveAnimations(index2, mode, active).update(element, {
          options: !active && this.getSharedOptions(options) || options
        });
      }
      removeHoverStyle(element, datasetIndex, index2) {
        this._setStyle(element, index2, "active", false);
      }
      setHoverStyle(element, datasetIndex, index2) {
        this._setStyle(element, index2, "active", true);
      }
      _removeDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) {
          this._setStyle(element, void 0, "active", false);
        }
      }
      _setDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) {
          this._setStyle(element, void 0, "active", true);
        }
      }
      _resyncElements(resetNewElements) {
        const data = this._data;
        const elements = this._cachedMeta.data;
        for (const [method, arg1, arg2] of this._syncList) {
          this[method](arg1, arg2);
        }
        this._syncList = [];
        const numMeta = elements.length;
        const numData = data.length;
        const count = Math.min(numData, numMeta);
        if (count) {
          this.parse(0, count);
        }
        if (numData > numMeta) {
          this._insertElements(numMeta, numData - numMeta, resetNewElements);
        } else if (numData < numMeta) {
          this._removeElements(numData, numMeta - numData);
        }
      }
      _insertElements(start, count, resetNewElements = true) {
        const meta2 = this._cachedMeta;
        const data = meta2.data;
        const end = start + count;
        let i2;
        const move = (arr) => {
          arr.length += count;
          for (i2 = arr.length - 1; i2 >= end; i2--) {
            arr[i2] = arr[i2 - count];
          }
        };
        move(data);
        for (i2 = start; i2 < end; ++i2) {
          data[i2] = new this.dataElementType();
        }
        if (this._parsing) {
          move(meta2._parsed);
        }
        this.parse(start, count);
        if (resetNewElements) {
          this.updateElements(data, start, count, "reset");
        }
      }
      updateElements(element, start, count, mode) {
      }
      _removeElements(start, count) {
        const meta2 = this._cachedMeta;
        if (this._parsing) {
          const removed = meta2._parsed.splice(start, count);
          if (meta2._stacked) {
            clearStacks(meta2, removed);
          }
        }
        meta2.data.splice(start, count);
      }
      _sync(args) {
        if (this._parsing) {
          this._syncList.push(args);
        } else {
          const [method, arg1, arg2] = args;
          this[method](arg1, arg2);
        }
        this.chart._dataChanges.push([
          this.index,
          ...args
        ]);
      }
      _onDataPush() {
        const count = arguments.length;
        this._sync([
          "_insertElements",
          this.getDataset().data.length - count,
          count
        ]);
      }
      _onDataPop() {
        this._sync([
          "_removeElements",
          this._cachedMeta.data.length - 1,
          1
        ]);
      }
      _onDataShift() {
        this._sync([
          "_removeElements",
          0,
          1
        ]);
      }
      _onDataSplice(start, count) {
        if (count) {
          this._sync([
            "_removeElements",
            start,
            count
          ]);
        }
        const newCount = arguments.length - 2;
        if (newCount) {
          this._sync([
            "_insertElements",
            start,
            newCount
          ]);
        }
      }
      _onDataUnshift() {
        this._sync([
          "_insertElements",
          0,
          arguments.length
        ]);
      }
    }
    __publicField(DatasetController, "defaults", {});
    __publicField(DatasetController, "datasetElementType", null);
    __publicField(DatasetController, "dataElementType", null);
    class LineController extends DatasetController {
      initialize() {
        this.enableOptionSharing = true;
        this.supportsDecimation = true;
        super.initialize();
      }
      update(mode) {
        const meta2 = this._cachedMeta;
        const { dataset: line, data: points = [], _dataset } = meta2;
        const animationsDisabled = this.chart._animationsDisabled;
        let { start, count } = _getStartAndCountOfVisiblePoints(meta2, points, animationsDisabled);
        this._drawStart = start;
        this._drawCount = count;
        if (_scaleRangesChanged(meta2)) {
          start = 0;
          count = points.length;
        }
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
          options.borderWidth = 0;
        }
        options.segment = this.options.segment;
        this.updateElement(line, void 0, {
          animated: !animationsDisabled,
          options
        }, mode);
        this.updateElements(points, start, count, mode);
      }
      updateElements(points, start, count, mode) {
        const reset = mode === "reset";
        const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const { spanGaps, segment } = this.options;
        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
        const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
        const end = start + count;
        const pointsCount = points.length;
        let prevParsed = start > 0 && this.getParsed(start - 1);
        for (let i2 = 0; i2 < pointsCount; ++i2) {
          const point = points[i2];
          const properties = directUpdate ? point : {};
          if (i2 < start || i2 >= end) {
            properties.skip = true;
            continue;
          }
          const parsed = this.getParsed(i2);
          const nullData = isNullOrUndef(parsed[vAxis]);
          const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
          const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
          properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
          properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
          if (segment) {
            properties.parsed = parsed;
            properties.raw = _dataset.data[i2];
          }
          if (includeOptions) {
            properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
          }
          if (!directUpdate) {
            this.updateElement(point, i2, properties, mode);
          }
          prevParsed = parsed;
        }
      }
      getMaxOverflow() {
        const meta2 = this._cachedMeta;
        const dataset = meta2.dataset;
        const border = dataset.options && dataset.options.borderWidth || 0;
        const data = meta2.data || [];
        if (!data.length) {
          return border;
        }
        const firstPoint = data[0].size(this.resolveDataElementOptions(0));
        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
        return Math.max(border, firstPoint, lastPoint) / 2;
      }
      draw() {
        const meta2 = this._cachedMeta;
        meta2.dataset.updateControlPoints(this.chart.chartArea, meta2.iScale.axis);
        super.draw();
      }
    }
    __publicField(LineController, "id", "line");
    __publicField(LineController, "defaults", {
      datasetElementType: "line",
      dataElementType: "point",
      showLine: true,
      spanGaps: false
    });
    __publicField(LineController, "overrides", {
      scales: {
        _index_: {
          type: "category"
        },
        _value_: {
          type: "linear"
        }
      }
    });
    function abstract() {
      throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
    }
    class DateAdapterBase {
      constructor(options) {
        __publicField(this, "options");
        this.options = options || {};
      }
      /**
      * Override default date adapter methods.
      * Accepts type parameter to define options type.
      * @example
      * Chart._adapters._date.override<{myAdapterOption: string}>({
      *   init() {
      *     console.log(this.options.myAdapterOption);
      *   }
      * })
      */
      static override(members) {
        Object.assign(DateAdapterBase.prototype, members);
      }
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      init() {
      }
      formats() {
        return abstract();
      }
      parse() {
        return abstract();
      }
      format() {
        return abstract();
      }
      add() {
        return abstract();
      }
      diff() {
        return abstract();
      }
      startOf() {
        return abstract();
      }
      endOf() {
        return abstract();
      }
    }
    var adapters = {
      _date: DateAdapterBase
    };
    function binarySearch(metaset, axis, value, intersect) {
      const { controller, data, _sorted } = metaset;
      const iScale = controller._cachedMeta.iScale;
      const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;
      if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
        const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
        if (!intersect) {
          const result = lookupMethod(data, axis, value);
          if (spanGaps) {
            const { vScale } = controller._cachedMeta;
            const { _parsed } = metaset;
            const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
            result.lo -= Math.max(0, distanceToDefinedLo);
            const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
            result.hi += Math.max(0, distanceToDefinedHi);
          }
          return result;
        } else if (controller._sharedOptions) {
          const el = data[0];
          const range = typeof el.getRange === "function" && el.getRange(axis);
          if (range) {
            const start = lookupMethod(data, axis, value - range);
            const end = lookupMethod(data, axis, value + range);
            return {
              lo: start.lo,
              hi: end.hi
            };
          }
        }
      }
      return {
        lo: 0,
        hi: data.length - 1
      };
    }
    function evaluateInteractionItems(chart, axis, position, handler, intersect) {
      const metasets = chart.getSortedVisibleDatasetMetas();
      const value = position[axis];
      for (let i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
        const { index: index2, data } = metasets[i2];
        const { lo, hi } = binarySearch(metasets[i2], axis, value, intersect);
        for (let j = lo; j <= hi; ++j) {
          const element = data[j];
          if (!element.skip) {
            handler(element, index2, j);
          }
        }
      }
    }
    function getDistanceMetricForAxis(axis) {
      const useX = axis.indexOf("x") !== -1;
      const useY = axis.indexOf("y") !== -1;
      return function(pt1, pt2) {
        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
      };
    }
    function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
      const items = [];
      if (!includeInvisible && !chart.isPointInArea(position)) {
        return items;
      }
      const evaluationFunc = function(element, datasetIndex, index2) {
        if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
          return;
        }
        if (element.inRange(position.x, position.y, useFinalPosition)) {
          items.push({
            element,
            datasetIndex,
            index: index2
          });
        }
      };
      evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
      return items;
    }
    function getNearestRadialItems(chart, position, axis, useFinalPosition) {
      let items = [];
      function evaluationFunc(element, datasetIndex, index2) {
        const { startAngle, endAngle } = element.getProps([
          "startAngle",
          "endAngle"
        ], useFinalPosition);
        const { angle } = getAngleFromPoint(element, {
          x: position.x,
          y: position.y
        });
        if (_angleBetween(angle, startAngle, endAngle)) {
          items.push({
            element,
            datasetIndex,
            index: index2
          });
        }
      }
      evaluateInteractionItems(chart, axis, position, evaluationFunc);
      return items;
    }
    function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
      let items = [];
      const distanceMetric = getDistanceMetricForAxis(axis);
      let minDistance = Number.POSITIVE_INFINITY;
      function evaluationFunc(element, datasetIndex, index2) {
        const inRange = element.inRange(position.x, position.y, useFinalPosition);
        if (intersect && !inRange) {
          return;
        }
        const center = element.getCenterPoint(useFinalPosition);
        const pointInArea = !!includeInvisible || chart.isPointInArea(center);
        if (!pointInArea && !inRange) {
          return;
        }
        const distance = distanceMetric(position, center);
        if (distance < minDistance) {
          items = [
            {
              element,
              datasetIndex,
              index: index2
            }
          ];
          minDistance = distance;
        } else if (distance === minDistance) {
          items.push({
            element,
            datasetIndex,
            index: index2
          });
        }
      }
      evaluateInteractionItems(chart, axis, position, evaluationFunc);
      return items;
    }
    function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
      if (!includeInvisible && !chart.isPointInArea(position)) {
        return [];
      }
      return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
    }
    function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
      const items = [];
      const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
      let intersectsItem = false;
      evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
        if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
          items.push({
            element,
            datasetIndex,
            index: index2
          });
          intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
        }
      });
      if (intersect && !intersectsItem) {
        return [];
      }
      return items;
    }
    var Interaction = {
      modes: {
        index(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          const axis = options.axis || "x";
          const includeInvisible = options.includeInvisible || false;
          const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
          const elements = [];
          if (!items.length) {
            return [];
          }
          chart.getSortedVisibleDatasetMetas().forEach((meta2) => {
            const index2 = items[0].index;
            const element = meta2.data[index2];
            if (element && !element.skip) {
              elements.push({
                element,
                datasetIndex: meta2.index,
                index: index2
              });
            }
          });
          return elements;
        },
        dataset(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          const axis = options.axis || "xy";
          const includeInvisible = options.includeInvisible || false;
          let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
          if (items.length > 0) {
            const datasetIndex = items[0].datasetIndex;
            const data = chart.getDatasetMeta(datasetIndex).data;
            items = [];
            for (let i2 = 0; i2 < data.length; ++i2) {
              items.push({
                element: data[i2],
                datasetIndex,
                index: i2
              });
            }
          }
          return items;
        },
        point(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          const axis = options.axis || "xy";
          const includeInvisible = options.includeInvisible || false;
          return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
        },
        nearest(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          const axis = options.axis || "xy";
          const includeInvisible = options.includeInvisible || false;
          return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
        },
        x(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
        },
        y(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
        }
      }
    };
    const STATIC_POSITIONS = [
      "left",
      "top",
      "right",
      "bottom"
    ];
    function filterByPosition(array, position) {
      return array.filter((v) => v.pos === position);
    }
    function filterDynamicPositionByAxis(array, axis) {
      return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
    }
    function sortByWeight(array, reverse) {
      return array.sort((a, b) => {
        const v0 = reverse ? b : a;
        const v1 = reverse ? a : b;
        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
      });
    }
    function wrapBoxes(boxes) {
      const layoutBoxes = [];
      let i2, ilen, box, pos, stack, stackWeight;
      for (i2 = 0, ilen = (boxes || []).length; i2 < ilen; ++i2) {
        box = boxes[i2];
        ({ position: pos, options: { stack, stackWeight = 1 } } = box);
        layoutBoxes.push({
          index: i2,
          box,
          pos,
          horizontal: box.isHorizontal(),
          weight: box.weight,
          stack: stack && pos + stack,
          stackWeight
        });
      }
      return layoutBoxes;
    }
    function buildStacks(layouts2) {
      const stacks = {};
      for (const wrap of layouts2) {
        const { stack, pos, stackWeight } = wrap;
        if (!stack || !STATIC_POSITIONS.includes(pos)) {
          continue;
        }
        const _stack = stacks[stack] || (stacks[stack] = {
          count: 0,
          placed: 0,
          weight: 0,
          size: 0
        });
        _stack.count++;
        _stack.weight += stackWeight;
      }
      return stacks;
    }
    function setLayoutDims(layouts2, params) {
      const stacks = buildStacks(layouts2);
      const { vBoxMaxWidth, hBoxMaxHeight } = params;
      let i2, ilen, layout;
      for (i2 = 0, ilen = layouts2.length; i2 < ilen; ++i2) {
        layout = layouts2[i2];
        const { fullSize } = layout.box;
        const stack = stacks[layout.stack];
        const factor = stack && layout.stackWeight / stack.weight;
        if (layout.horizontal) {
          layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
          layout.height = hBoxMaxHeight;
        } else {
          layout.width = vBoxMaxWidth;
          layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
        }
      }
      return stacks;
    }
    function buildLayoutBoxes(boxes) {
      const layoutBoxes = wrapBoxes(boxes);
      const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
      const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
      const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
      const top2 = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
      const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
      const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
      const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
      return {
        fullSize,
        leftAndTop: left.concat(top2),
        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
        chartArea: filterByPosition(layoutBoxes, "chartArea"),
        vertical: left.concat(right).concat(centerVertical),
        horizontal: top2.concat(bottom).concat(centerHorizontal)
      };
    }
    function getCombinedMax(maxPadding, chartArea2, a, b) {
      return Math.max(maxPadding[a], chartArea2[a]) + Math.max(maxPadding[b], chartArea2[b]);
    }
    function updateMaxPadding(maxPadding, boxPadding) {
      maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
      maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
      maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
      maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
    }
    function updateDims(chartArea2, params, layout, stacks) {
      const { pos, box } = layout;
      const maxPadding = chartArea2.maxPadding;
      if (!isObject(pos)) {
        if (layout.size) {
          chartArea2[pos] -= layout.size;
        }
        const stack = stacks[layout.stack] || {
          size: 0,
          count: 1
        };
        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
        layout.size = stack.size / stack.count;
        chartArea2[pos] += layout.size;
      }
      if (box.getPadding) {
        updateMaxPadding(maxPadding, box.getPadding());
      }
      const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea2, "left", "right"));
      const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea2, "top", "bottom"));
      const widthChanged = newWidth !== chartArea2.w;
      const heightChanged = newHeight !== chartArea2.h;
      chartArea2.w = newWidth;
      chartArea2.h = newHeight;
      return layout.horizontal ? {
        same: widthChanged,
        other: heightChanged
      } : {
        same: heightChanged,
        other: widthChanged
      };
    }
    function handleMaxPadding(chartArea2) {
      const maxPadding = chartArea2.maxPadding;
      function updatePos(pos) {
        const change = Math.max(maxPadding[pos] - chartArea2[pos], 0);
        chartArea2[pos] += change;
        return change;
      }
      chartArea2.y += updatePos("top");
      chartArea2.x += updatePos("left");
      updatePos("right");
      updatePos("bottom");
    }
    function getMargins(horizontal, chartArea2) {
      const maxPadding = chartArea2.maxPadding;
      function marginForPositions(positions2) {
        const margin = {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        };
        positions2.forEach((pos) => {
          margin[pos] = Math.max(chartArea2[pos], maxPadding[pos]);
        });
        return margin;
      }
      return horizontal ? marginForPositions([
        "left",
        "right"
      ]) : marginForPositions([
        "top",
        "bottom"
      ]);
    }
    function fitBoxes(boxes, chartArea2, params, stacks) {
      const refitBoxes = [];
      let i2, ilen, layout, box, refit, changed;
      for (i2 = 0, ilen = boxes.length, refit = 0; i2 < ilen; ++i2) {
        layout = boxes[i2];
        box = layout.box;
        box.update(layout.width || chartArea2.w, layout.height || chartArea2.h, getMargins(layout.horizontal, chartArea2));
        const { same, other } = updateDims(chartArea2, params, layout, stacks);
        refit |= same && refitBoxes.length;
        changed = changed || other;
        if (!box.fullSize) {
          refitBoxes.push(layout);
        }
      }
      return refit && fitBoxes(refitBoxes, chartArea2, params, stacks) || changed;
    }
    function setBoxDims(box, left, top2, width, height) {
      box.top = top2;
      box.left = left;
      box.right = left + width;
      box.bottom = top2 + height;
      box.width = width;
      box.height = height;
    }
    function placeBoxes(boxes, chartArea2, params, stacks) {
      const userPadding = params.padding;
      let { x, y } = chartArea2;
      for (const layout of boxes) {
        const box = layout.box;
        const stack = stacks[layout.stack] || {
          placed: 0,
          weight: 1
        };
        const weight = layout.stackWeight / stack.weight || 1;
        if (layout.horizontal) {
          const width = chartArea2.w * weight;
          const height = stack.size || box.height;
          if (defined(stack.start)) {
            y = stack.start;
          }
          if (box.fullSize) {
            setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
          } else {
            setBoxDims(box, chartArea2.left + stack.placed, y, width, height);
          }
          stack.start = y;
          stack.placed += width;
          y = box.bottom;
        } else {
          const height = chartArea2.h * weight;
          const width = stack.size || box.width;
          if (defined(stack.start)) {
            x = stack.start;
          }
          if (box.fullSize) {
            setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
          } else {
            setBoxDims(box, x, chartArea2.top + stack.placed, width, height);
          }
          stack.start = x;
          stack.placed += height;
          x = box.right;
        }
      }
      chartArea2.x = x;
      chartArea2.y = y;
    }
    var layouts = {
      addBox(chart, item) {
        if (!chart.boxes) {
          chart.boxes = [];
        }
        item.fullSize = item.fullSize || false;
        item.position = item.position || "top";
        item.weight = item.weight || 0;
        item._layers = item._layers || function() {
          return [
            {
              z: 0,
              draw(chartArea2) {
                item.draw(chartArea2);
              }
            }
          ];
        };
        chart.boxes.push(item);
      },
      removeBox(chart, layoutItem) {
        const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
        if (index2 !== -1) {
          chart.boxes.splice(index2, 1);
        }
      },
      configure(chart, item, options) {
        item.fullSize = options.fullSize;
        item.position = options.position;
        item.weight = options.weight;
      },
      update(chart, width, height, minPadding) {
        if (!chart) {
          return;
        }
        const padding = toPadding(chart.options.layout.padding);
        const availableWidth = Math.max(width - padding.width, 0);
        const availableHeight = Math.max(height - padding.height, 0);
        const boxes = buildLayoutBoxes(chart.boxes);
        const verticalBoxes = boxes.vertical;
        const horizontalBoxes = boxes.horizontal;
        each(chart.boxes, (box) => {
          if (typeof box.beforeLayout === "function") {
            box.beforeLayout();
          }
        });
        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
        const params = Object.freeze({
          outerWidth: width,
          outerHeight: height,
          padding,
          availableWidth,
          availableHeight,
          vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
          hBoxMaxHeight: availableHeight / 2
        });
        const maxPadding = Object.assign({}, padding);
        updateMaxPadding(maxPadding, toPadding(minPadding));
        const chartArea2 = Object.assign({
          maxPadding,
          w: availableWidth,
          h: availableHeight,
          x: padding.left,
          y: padding.top
        }, padding);
        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
        fitBoxes(boxes.fullSize, chartArea2, params, stacks);
        fitBoxes(verticalBoxes, chartArea2, params, stacks);
        if (fitBoxes(horizontalBoxes, chartArea2, params, stacks)) {
          fitBoxes(verticalBoxes, chartArea2, params, stacks);
        }
        handleMaxPadding(chartArea2);
        placeBoxes(boxes.leftAndTop, chartArea2, params, stacks);
        chartArea2.x += chartArea2.w;
        chartArea2.y += chartArea2.h;
        placeBoxes(boxes.rightAndBottom, chartArea2, params, stacks);
        chart.chartArea = {
          left: chartArea2.left,
          top: chartArea2.top,
          right: chartArea2.left + chartArea2.w,
          bottom: chartArea2.top + chartArea2.h,
          height: chartArea2.h,
          width: chartArea2.w
        };
        each(boxes.chartArea, (layout) => {
          const box = layout.box;
          Object.assign(box, chart.chartArea);
          box.update(chartArea2.w, chartArea2.h, {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          });
        });
      }
    };
    class BasePlatform {
      acquireContext(canvas, aspectRatio) {
      }
      releaseContext(context) {
        return false;
      }
      addEventListener(chart, type, listener) {
      }
      removeEventListener(chart, type, listener) {
      }
      getDevicePixelRatio() {
        return 1;
      }
      getMaximumSize(element, width, height, aspectRatio) {
        width = Math.max(0, width || element.width);
        height = height || element.height;
        return {
          width,
          height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
        };
      }
      isAttached(canvas) {
        return true;
      }
      updateConfig(config2) {
      }
    }
    class BasicPlatform extends BasePlatform {
      acquireContext(item) {
        return item && item.getContext && item.getContext("2d") || null;
      }
      updateConfig(config2) {
        config2.options.animation = false;
      }
    }
    const EXPANDO_KEY = "$chartjs";
    const EVENT_TYPES = {
      touchstart: "mousedown",
      touchmove: "mousemove",
      touchend: "mouseup",
      pointerenter: "mouseenter",
      pointerdown: "mousedown",
      pointermove: "mousemove",
      pointerup: "mouseup",
      pointerleave: "mouseout",
      pointerout: "mouseout"
    };
    const isNullOrEmpty = (value) => value === null || value === "";
    function initCanvas(canvas, aspectRatio) {
      const style = canvas.style;
      const renderHeight = canvas.getAttribute("height");
      const renderWidth = canvas.getAttribute("width");
      canvas[EXPANDO_KEY] = {
        initial: {
          height: renderHeight,
          width: renderWidth,
          style: {
            display: style.display,
            height: style.height,
            width: style.width
          }
        }
      };
      style.display = style.display || "block";
      style.boxSizing = style.boxSizing || "border-box";
      if (isNullOrEmpty(renderWidth)) {
        const displayWidth = readUsedSize(canvas, "width");
        if (displayWidth !== void 0) {
          canvas.width = displayWidth;
        }
      }
      if (isNullOrEmpty(renderHeight)) {
        if (canvas.style.height === "") {
          canvas.height = canvas.width / (aspectRatio || 2);
        } else {
          const displayHeight = readUsedSize(canvas, "height");
          if (displayHeight !== void 0) {
            canvas.height = displayHeight;
          }
        }
      }
      return canvas;
    }
    const eventListenerOptions = supportsEventListenerOptions ? {
      passive: true
    } : false;
    function addListener(node, type, listener) {
      if (node) {
        node.addEventListener(type, listener, eventListenerOptions);
      }
    }
    function removeListener(chart, type, listener) {
      if (chart && chart.canvas) {
        chart.canvas.removeEventListener(type, listener, eventListenerOptions);
      }
    }
    function fromNativeEvent(event, chart) {
      const type = EVENT_TYPES[event.type] || event.type;
      const { x, y } = getRelativePosition(event, chart);
      return {
        type,
        chart,
        native: event,
        x: x !== void 0 ? x : null,
        y: y !== void 0 ? y : null
      };
    }
    function nodeListContains(nodeList, canvas) {
      for (const node of nodeList) {
        if (node === canvas || node.contains(canvas)) {
          return true;
        }
      }
    }
    function createAttachObserver(chart, type, listener) {
      const canvas = chart.canvas;
      const observer = new MutationObserver((entries) => {
        let trigger = false;
        for (const entry of entries) {
          trigger = trigger || nodeListContains(entry.addedNodes, canvas);
          trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
        }
        if (trigger) {
          listener();
        }
      });
      observer.observe(document, {
        childList: true,
        subtree: true
      });
      return observer;
    }
    function createDetachObserver(chart, type, listener) {
      const canvas = chart.canvas;
      const observer = new MutationObserver((entries) => {
        let trigger = false;
        for (const entry of entries) {
          trigger = trigger || nodeListContains(entry.removedNodes, canvas);
          trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
        }
        if (trigger) {
          listener();
        }
      });
      observer.observe(document, {
        childList: true,
        subtree: true
      });
      return observer;
    }
    const drpListeningCharts = /* @__PURE__ */ new Map();
    let oldDevicePixelRatio = 0;
    function onWindowResize() {
      const dpr = window.devicePixelRatio;
      if (dpr === oldDevicePixelRatio) {
        return;
      }
      oldDevicePixelRatio = dpr;
      drpListeningCharts.forEach((resize, chart) => {
        if (chart.currentDevicePixelRatio !== dpr) {
          resize();
        }
      });
    }
    function listenDevicePixelRatioChanges(chart, resize) {
      if (!drpListeningCharts.size) {
        window.addEventListener("resize", onWindowResize);
      }
      drpListeningCharts.set(chart, resize);
    }
    function unlistenDevicePixelRatioChanges(chart) {
      drpListeningCharts.delete(chart);
      if (!drpListeningCharts.size) {
        window.removeEventListener("resize", onWindowResize);
      }
    }
    function createResizeObserver(chart, type, listener) {
      const canvas = chart.canvas;
      const container2 = canvas && _getParentNode(canvas);
      if (!container2) {
        return;
      }
      const resize = throttled((width, height) => {
        const w = container2.clientWidth;
        listener(width, height);
        if (w < container2.clientWidth) {
          listener();
        }
      }, window);
      const observer = new ResizeObserver((entries) => {
        const entry = entries[0];
        const width = entry.contentRect.width;
        const height = entry.contentRect.height;
        if (width === 0 && height === 0) {
          return;
        }
        resize(width, height);
      });
      observer.observe(container2);
      listenDevicePixelRatioChanges(chart, resize);
      return observer;
    }
    function releaseObserver(chart, type, observer) {
      if (observer) {
        observer.disconnect();
      }
      if (type === "resize") {
        unlistenDevicePixelRatioChanges(chart);
      }
    }
    function createProxyAndListen(chart, type, listener) {
      const canvas = chart.canvas;
      const proxy = throttled((event) => {
        if (chart.ctx !== null) {
          listener(fromNativeEvent(event, chart));
        }
      }, chart);
      addListener(canvas, type, proxy);
      return proxy;
    }
    class DomPlatform extends BasePlatform {
      acquireContext(canvas, aspectRatio) {
        const context = canvas && canvas.getContext && canvas.getContext("2d");
        if (context && context.canvas === canvas) {
          initCanvas(canvas, aspectRatio);
          return context;
        }
        return null;
      }
      releaseContext(context) {
        const canvas = context.canvas;
        if (!canvas[EXPANDO_KEY]) {
          return false;
        }
        const initial = canvas[EXPANDO_KEY].initial;
        [
          "height",
          "width"
        ].forEach((prop) => {
          const value = initial[prop];
          if (isNullOrUndef(value)) {
            canvas.removeAttribute(prop);
          } else {
            canvas.setAttribute(prop, value);
          }
        });
        const style = initial.style || {};
        Object.keys(style).forEach((key) => {
          canvas.style[key] = style[key];
        });
        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
        return true;
      }
      addEventListener(chart, type, listener) {
        this.removeEventListener(chart, type);
        const proxies = chart.$proxies || (chart.$proxies = {});
        const handlers2 = {
          attach: createAttachObserver,
          detach: createDetachObserver,
          resize: createResizeObserver
        };
        const handler = handlers2[type] || createProxyAndListen;
        proxies[type] = handler(chart, type, listener);
      }
      removeEventListener(chart, type) {
        const proxies = chart.$proxies || (chart.$proxies = {});
        const proxy = proxies[type];
        if (!proxy) {
          return;
        }
        const handlers2 = {
          attach: releaseObserver,
          detach: releaseObserver,
          resize: releaseObserver
        };
        const handler = handlers2[type] || removeListener;
        handler(chart, type, proxy);
        proxies[type] = void 0;
      }
      getDevicePixelRatio() {
        return window.devicePixelRatio;
      }
      getMaximumSize(canvas, width, height, aspectRatio) {
        return getMaximumSize(canvas, width, height, aspectRatio);
      }
      isAttached(canvas) {
        const container2 = canvas && _getParentNode(canvas);
        return !!(container2 && container2.isConnected);
      }
    }
    function _detectPlatform(canvas) {
      if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
        return BasicPlatform;
      }
      return DomPlatform;
    }
    class Element {
      constructor() {
        __publicField(this, "x");
        __publicField(this, "y");
        __publicField(this, "active", false);
        __publicField(this, "options");
        __publicField(this, "$animations");
      }
      tooltipPosition(useFinalPosition) {
        const { x, y } = this.getProps([
          "x",
          "y"
        ], useFinalPosition);
        return {
          x,
          y
        };
      }
      hasValue() {
        return isNumber(this.x) && isNumber(this.y);
      }
      getProps(props, final) {
        const anims = this.$animations;
        if (!final || !anims) {
          return this;
        }
        const ret = {};
        props.forEach((prop) => {
          ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
        });
        return ret;
      }
    }
    __publicField(Element, "defaults", {});
    __publicField(Element, "defaultRoutes");
    function autoSkip(scale, ticks) {
      const tickOpts = scale.options.ticks;
      const determinedMaxTicks = determineMaxTicks(scale);
      const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
      const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
      const numMajorIndices = majorIndices.length;
      const first = majorIndices[0];
      const last = majorIndices[numMajorIndices - 1];
      const newTicks = [];
      if (numMajorIndices > ticksLimit) {
        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
        return newTicks;
      }
      const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
      if (numMajorIndices > 0) {
        let i2, ilen;
        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
        skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
        for (i2 = 0, ilen = numMajorIndices - 1; i2 < ilen; i2++) {
          skip(ticks, newTicks, spacing, majorIndices[i2], majorIndices[i2 + 1]);
        }
        skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
        return newTicks;
      }
      skip(ticks, newTicks, spacing);
      return newTicks;
    }
    function determineMaxTicks(scale) {
      const offset = scale.options.offset;
      const tickLength = scale._tickSize();
      const maxScale = scale._length / tickLength + (offset ? 0 : 1);
      const maxChart = scale._maxLength / tickLength;
      return Math.floor(Math.min(maxScale, maxChart));
    }
    function calculateSpacing(majorIndices, ticks, ticksLimit) {
      const evenMajorSpacing = getEvenSpacing(majorIndices);
      const spacing = ticks.length / ticksLimit;
      if (!evenMajorSpacing) {
        return Math.max(spacing, 1);
      }
      const factors = _factorize(evenMajorSpacing);
      for (let i2 = 0, ilen = factors.length - 1; i2 < ilen; i2++) {
        const factor = factors[i2];
        if (factor > spacing) {
          return factor;
        }
      }
      return Math.max(spacing, 1);
    }
    function getMajorIndices(ticks) {
      const result = [];
      let i2, ilen;
      for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
        if (ticks[i2].major) {
          result.push(i2);
        }
      }
      return result;
    }
    function skipMajors(ticks, newTicks, majorIndices, spacing) {
      let count = 0;
      let next = majorIndices[0];
      let i2;
      spacing = Math.ceil(spacing);
      for (i2 = 0; i2 < ticks.length; i2++) {
        if (i2 === next) {
          newTicks.push(ticks[i2]);
          count++;
          next = majorIndices[count * spacing];
        }
      }
    }
    function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
      const start = valueOrDefault(majorStart, 0);
      const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
      let count = 0;
      let length, i2, next;
      spacing = Math.ceil(spacing);
      if (majorEnd) {
        length = majorEnd - majorStart;
        spacing = length / Math.floor(length / spacing);
      }
      next = start;
      while (next < 0) {
        count++;
        next = Math.round(start + count * spacing);
      }
      for (i2 = Math.max(start, 0); i2 < end; i2++) {
        if (i2 === next) {
          newTicks.push(ticks[i2]);
          count++;
          next = Math.round(start + count * spacing);
        }
      }
    }
    function getEvenSpacing(arr) {
      const len = arr.length;
      let i2, diff;
      if (len < 2) {
        return false;
      }
      for (diff = arr[0], i2 = 1; i2 < len; ++i2) {
        if (arr[i2] - arr[i2 - 1] !== diff) {
          return false;
        }
      }
      return diff;
    }
    const reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
    const offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
    const getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
    function sample(arr, numItems) {
      const result = [];
      const increment = arr.length / numItems;
      const len = arr.length;
      let i2 = 0;
      for (; i2 < len; i2 += increment) {
        result.push(arr[Math.floor(i2)]);
      }
      return result;
    }
    function getPixelForGridLine(scale, index2, offsetGridLines) {
      const length = scale.ticks.length;
      const validIndex2 = Math.min(index2, length - 1);
      const start = scale._startPixel;
      const end = scale._endPixel;
      const epsilon = 1e-6;
      let lineValue = scale.getPixelForTick(validIndex2);
      let offset;
      if (offsetGridLines) {
        if (length === 1) {
          offset = Math.max(lineValue - start, end - lineValue);
        } else if (index2 === 0) {
          offset = (scale.getPixelForTick(1) - lineValue) / 2;
        } else {
          offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
        }
        lineValue += validIndex2 < index2 ? offset : -offset;
        if (lineValue < start - epsilon || lineValue > end + epsilon) {
          return;
        }
      }
      return lineValue;
    }
    function garbageCollect(caches, length) {
      each(caches, (cache) => {
        const gc = cache.gc;
        const gcLen = gc.length / 2;
        let i2;
        if (gcLen > length) {
          for (i2 = 0; i2 < gcLen; ++i2) {
            delete cache.data[gc[i2]];
          }
          gc.splice(0, gcLen);
        }
      });
    }
    function getTickMarkLength(options) {
      return options.drawTicks ? options.tickLength : 0;
    }
    function getTitleHeight(options, fallback) {
      if (!options.display) {
        return 0;
      }
      const font = toFont(options.font, fallback);
      const padding = toPadding(options.padding);
      const lines = isArray(options.text) ? options.text.length : 1;
      return lines * font.lineHeight + padding.height;
    }
    function createScaleContext(parent, scale) {
      return createContext(parent, {
        scale,
        type: "scale"
      });
    }
    function createTickContext(parent, index2, tick) {
      return createContext(parent, {
        tick,
        index: index2,
        type: "tick"
      });
    }
    function titleAlign(align, position, reverse) {
      let ret = _toLeftRightCenter(align);
      if (reverse && position !== "right" || !reverse && position === "right") {
        ret = reverseAlign(ret);
      }
      return ret;
    }
    function titleArgs(scale, offset, position, align) {
      const { top: top2, left, bottom, right, chart } = scale;
      const { chartArea: chartArea2, scales } = chart;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      const height = bottom - top2;
      const width = right - left;
      if (scale.isHorizontal()) {
        titleX = _alignStartEnd(align, left, right);
        if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
        } else if (position === "center") {
          titleY = (chartArea2.bottom + chartArea2.top) / 2 + height - offset;
        } else {
          titleY = offsetFromEdge(scale, position, offset);
        }
        maxWidth = right - left;
      } else {
        if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
        } else if (position === "center") {
          titleX = (chartArea2.left + chartArea2.right) / 2 - width + offset;
        } else {
          titleX = offsetFromEdge(scale, position, offset);
        }
        titleY = _alignStartEnd(align, bottom, top2);
        rotation = position === "left" ? -HALF_PI : HALF_PI;
      }
      return {
        titleX,
        titleY,
        maxWidth,
        rotation
      };
    }
    class Scale extends Element {
      constructor(cfg) {
        super();
        this.id = cfg.id;
        this.type = cfg.type;
        this.options = void 0;
        this.ctx = cfg.ctx;
        this.chart = cfg.chart;
        this.top = void 0;
        this.bottom = void 0;
        this.left = void 0;
        this.right = void 0;
        this.width = void 0;
        this.height = void 0;
        this._margins = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        };
        this.maxWidth = void 0;
        this.maxHeight = void 0;
        this.paddingTop = void 0;
        this.paddingBottom = void 0;
        this.paddingLeft = void 0;
        this.paddingRight = void 0;
        this.axis = void 0;
        this.labelRotation = void 0;
        this.min = void 0;
        this.max = void 0;
        this._range = void 0;
        this.ticks = [];
        this._gridLineItems = null;
        this._labelItems = null;
        this._labelSizes = null;
        this._length = 0;
        this._maxLength = 0;
        this._longestTextCache = {};
        this._startPixel = void 0;
        this._endPixel = void 0;
        this._reversePixels = false;
        this._userMax = void 0;
        this._userMin = void 0;
        this._suggestedMax = void 0;
        this._suggestedMin = void 0;
        this._ticksLength = 0;
        this._borderValue = 0;
        this._cache = {};
        this._dataLimitsCached = false;
        this.$context = void 0;
      }
      init(options) {
        this.options = options.setContext(this.getContext());
        this.axis = options.axis;
        this._userMin = this.parse(options.min);
        this._userMax = this.parse(options.max);
        this._suggestedMin = this.parse(options.suggestedMin);
        this._suggestedMax = this.parse(options.suggestedMax);
      }
      parse(raw, index2) {
        return raw;
      }
      getUserBounds() {
        let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
        _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
        _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
        _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
        _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
        return {
          min: finiteOrDefault(_userMin, _suggestedMin),
          max: finiteOrDefault(_userMax, _suggestedMax),
          minDefined: isNumberFinite(_userMin),
          maxDefined: isNumberFinite(_userMax)
        };
      }
      getMinMax(canStack) {
        let { min, max, minDefined, maxDefined } = this.getUserBounds();
        let range;
        if (minDefined && maxDefined) {
          return {
            min,
            max
          };
        }
        const metas = this.getMatchingVisibleMetas();
        for (let i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
          range = metas[i2].controller.getMinMax(this, canStack);
          if (!minDefined) {
            min = Math.min(min, range.min);
          }
          if (!maxDefined) {
            max = Math.max(max, range.max);
          }
        }
        min = maxDefined && min > max ? max : min;
        max = minDefined && min > max ? min : max;
        return {
          min: finiteOrDefault(min, finiteOrDefault(max, min)),
          max: finiteOrDefault(max, finiteOrDefault(min, max))
        };
      }
      getPadding() {
        return {
          left: this.paddingLeft || 0,
          top: this.paddingTop || 0,
          right: this.paddingRight || 0,
          bottom: this.paddingBottom || 0
        };
      }
      getTicks() {
        return this.ticks;
      }
      getLabels() {
        const data = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
      }
      getLabelItems(chartArea2 = this.chart.chartArea) {
        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea2));
        return items;
      }
      beforeLayout() {
        this._cache = {};
        this._dataLimitsCached = false;
      }
      beforeUpdate() {
        callback(this.options.beforeUpdate, [
          this
        ]);
      }
      update(maxWidth, maxHeight, margins) {
        const { beginAtZero, grace, ticks: tickOpts } = this.options;
        const sampleSize = tickOpts.sampleSize;
        this.beforeUpdate();
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins = Object.assign({
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        }, margins);
        this.ticks = null;
        this._labelSizes = null;
        this._gridLineItems = null;
        this._labelItems = null;
        this.beforeSetDimensions();
        this.setDimensions();
        this.afterSetDimensions();
        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
        if (!this._dataLimitsCached) {
          this.beforeDataLimits();
          this.determineDataLimits();
          this.afterDataLimits();
          this._range = _addGrace(this, grace, beginAtZero);
          this._dataLimitsCached = true;
        }
        this.beforeBuildTicks();
        this.ticks = this.buildTicks() || [];
        this.afterBuildTicks();
        const samplingEnabled = sampleSize < this.ticks.length;
        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
        this.configure();
        this.beforeCalculateLabelRotation();
        this.calculateLabelRotation();
        this.afterCalculateLabelRotation();
        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
          this.ticks = autoSkip(this, this.ticks);
          this._labelSizes = null;
          this.afterAutoSkip();
        }
        if (samplingEnabled) {
          this._convertTicksToLabels(this.ticks);
        }
        this.beforeFit();
        this.fit();
        this.afterFit();
        this.afterUpdate();
      }
      configure() {
        let reversePixels = this.options.reverse;
        let startPixel, endPixel;
        if (this.isHorizontal()) {
          startPixel = this.left;
          endPixel = this.right;
        } else {
          startPixel = this.top;
          endPixel = this.bottom;
          reversePixels = !reversePixels;
        }
        this._startPixel = startPixel;
        this._endPixel = endPixel;
        this._reversePixels = reversePixels;
        this._length = endPixel - startPixel;
        this._alignToPixels = this.options.alignToPixels;
      }
      afterUpdate() {
        callback(this.options.afterUpdate, [
          this
        ]);
      }
      beforeSetDimensions() {
        callback(this.options.beforeSetDimensions, [
          this
        ]);
      }
      setDimensions() {
        if (this.isHorizontal()) {
          this.width = this.maxWidth;
          this.left = 0;
          this.right = this.width;
        } else {
          this.height = this.maxHeight;
          this.top = 0;
          this.bottom = this.height;
        }
        this.paddingLeft = 0;
        this.paddingTop = 0;
        this.paddingRight = 0;
        this.paddingBottom = 0;
      }
      afterSetDimensions() {
        callback(this.options.afterSetDimensions, [
          this
        ]);
      }
      _callHooks(name2) {
        this.chart.notifyPlugins(name2, this.getContext());
        callback(this.options[name2], [
          this
        ]);
      }
      beforeDataLimits() {
        this._callHooks("beforeDataLimits");
      }
      determineDataLimits() {
      }
      afterDataLimits() {
        this._callHooks("afterDataLimits");
      }
      beforeBuildTicks() {
        this._callHooks("beforeBuildTicks");
      }
      buildTicks() {
        return [];
      }
      afterBuildTicks() {
        this._callHooks("afterBuildTicks");
      }
      beforeTickToLabelConversion() {
        callback(this.options.beforeTickToLabelConversion, [
          this
        ]);
      }
      generateTickLabels(ticks) {
        const tickOpts = this.options.ticks;
        let i2, ilen, tick;
        for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
          tick = ticks[i2];
          tick.label = callback(tickOpts.callback, [
            tick.value,
            i2,
            ticks
          ], this);
        }
      }
      afterTickToLabelConversion() {
        callback(this.options.afterTickToLabelConversion, [
          this
        ]);
      }
      beforeCalculateLabelRotation() {
        callback(this.options.beforeCalculateLabelRotation, [
          this
        ]);
      }
      calculateLabelRotation() {
        const options = this.options;
        const tickOpts = options.ticks;
        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
        const minRotation = tickOpts.minRotation || 0;
        const maxRotation = tickOpts.maxRotation;
        let labelRotation = minRotation;
        let tickWidth, maxHeight, maxLabelDiagonal;
        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
          this.labelRotation = minRotation;
          return;
        }
        const labelSizes = this._getLabelSizes();
        const maxLabelWidth = labelSizes.widest.width;
        const maxLabelHeight = labelSizes.highest.height;
        const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
        if (maxLabelWidth + 6 > tickWidth) {
          tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
          maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
          maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
          labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
          labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
        }
        this.labelRotation = labelRotation;
      }
      afterCalculateLabelRotation() {
        callback(this.options.afterCalculateLabelRotation, [
          this
        ]);
      }
      afterAutoSkip() {
      }
      beforeFit() {
        callback(this.options.beforeFit, [
          this
        ]);
      }
      fit() {
        const minSize = {
          width: 0,
          height: 0
        };
        const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
        const display = this._isVisible();
        const isHorizontal = this.isHorizontal();
        if (display) {
          const titleHeight = getTitleHeight(titleOpts, chart.options.font);
          if (isHorizontal) {
            minSize.width = this.maxWidth;
            minSize.height = getTickMarkLength(gridOpts) + titleHeight;
          } else {
            minSize.height = this.maxHeight;
            minSize.width = getTickMarkLength(gridOpts) + titleHeight;
          }
          if (tickOpts.display && this.ticks.length) {
            const { first, last, widest, highest } = this._getLabelSizes();
            const tickPadding = tickOpts.padding * 2;
            const angleRadians = toRadians(this.labelRotation);
            const cos = Math.cos(angleRadians);
            const sin = Math.sin(angleRadians);
            if (isHorizontal) {
              const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
              minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
            } else {
              const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
              minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
            }
            this._calculatePadding(first, last, sin, cos);
          }
        }
        this._handleMargins();
        if (isHorizontal) {
          this.width = this._length = chart.width - this._margins.left - this._margins.right;
          this.height = minSize.height;
        } else {
          this.width = minSize.width;
          this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
        }
      }
      _calculatePadding(first, last, sin, cos) {
        const { ticks: { align, padding }, position } = this.options;
        const isRotated = this.labelRotation !== 0;
        const labelsBelowTicks = position !== "top" && this.axis === "x";
        if (this.isHorizontal()) {
          const offsetLeft = this.getPixelForTick(0) - this.left;
          const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
          let paddingLeft = 0;
          let paddingRight = 0;
          if (isRotated) {
            if (labelsBelowTicks) {
              paddingLeft = cos * first.width;
              paddingRight = sin * last.height;
            } else {
              paddingLeft = sin * first.height;
              paddingRight = cos * last.width;
            }
          } else if (align === "start") {
            paddingRight = last.width;
          } else if (align === "end") {
            paddingLeft = first.width;
          } else if (align !== "inner") {
            paddingLeft = first.width / 2;
            paddingRight = last.width / 2;
          }
          this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
          this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
        } else {
          let paddingTop = last.height / 2;
          let paddingBottom = first.height / 2;
          if (align === "start") {
            paddingTop = 0;
            paddingBottom = first.height;
          } else if (align === "end") {
            paddingTop = last.height;
            paddingBottom = 0;
          }
          this.paddingTop = paddingTop + padding;
          this.paddingBottom = paddingBottom + padding;
        }
      }
      _handleMargins() {
        if (this._margins) {
          this._margins.left = Math.max(this.paddingLeft, this._margins.left);
          this._margins.top = Math.max(this.paddingTop, this._margins.top);
          this._margins.right = Math.max(this.paddingRight, this._margins.right);
          this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
        }
      }
      afterFit() {
        callback(this.options.afterFit, [
          this
        ]);
      }
      isHorizontal() {
        const { axis, position } = this.options;
        return position === "top" || position === "bottom" || axis === "x";
      }
      isFullSize() {
        return this.options.fullSize;
      }
      _convertTicksToLabels(ticks) {
        this.beforeTickToLabelConversion();
        this.generateTickLabels(ticks);
        let i2, ilen;
        for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
          if (isNullOrUndef(ticks[i2].label)) {
            ticks.splice(i2, 1);
            ilen--;
            i2--;
          }
        }
        this.afterTickToLabelConversion();
      }
      _getLabelSizes() {
        let labelSizes = this._labelSizes;
        if (!labelSizes) {
          const sampleSize = this.options.ticks.sampleSize;
          let ticks = this.ticks;
          if (sampleSize < ticks.length) {
            ticks = sample(ticks, sampleSize);
          }
          this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
        }
        return labelSizes;
      }
      _computeLabelSizes(ticks, length, maxTicksLimit) {
        const { ctx, _longestTextCache: caches } = this;
        const widths = [];
        const heights = [];
        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
        let widestLabelSize = 0;
        let highestLabelSize = 0;
        let i2, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
        for (i2 = 0; i2 < length; i2 += increment) {
          label = ticks[i2].label;
          tickFont = this._resolveTickFontOptions(i2);
          ctx.font = fontString = tickFont.string;
          cache = caches[fontString] = caches[fontString] || {
            data: {},
            gc: []
          };
          lineHeight = tickFont.lineHeight;
          width = height = 0;
          if (!isNullOrUndef(label) && !isArray(label)) {
            width = _measureText(ctx, cache.data, cache.gc, width, label);
            height = lineHeight;
          } else if (isArray(label)) {
            for (j = 0, jlen = label.length; j < jlen; ++j) {
              nestedLabel = label[j];
              if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                height += lineHeight;
              }
            }
          }
          widths.push(width);
          heights.push(height);
          widestLabelSize = Math.max(width, widestLabelSize);
          highestLabelSize = Math.max(height, highestLabelSize);
        }
        garbageCollect(caches, length);
        const widest = widths.indexOf(widestLabelSize);
        const highest = heights.indexOf(highestLabelSize);
        const valueAt = (idx) => ({
          width: widths[idx] || 0,
          height: heights[idx] || 0
        });
        return {
          first: valueAt(0),
          last: valueAt(length - 1),
          widest: valueAt(widest),
          highest: valueAt(highest),
          widths,
          heights
        };
      }
      getLabelForValue(value) {
        return value;
      }
      getPixelForValue(value, index2) {
        return NaN;
      }
      getValueForPixel(pixel) {
      }
      getPixelForTick(index2) {
        const ticks = this.ticks;
        if (index2 < 0 || index2 > ticks.length - 1) {
          return null;
        }
        return this.getPixelForValue(ticks[index2].value);
      }
      getPixelForDecimal(decimal) {
        if (this._reversePixels) {
          decimal = 1 - decimal;
        }
        const pixel = this._startPixel + decimal * this._length;
        return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
      }
      getDecimalForPixel(pixel) {
        const decimal = (pixel - this._startPixel) / this._length;
        return this._reversePixels ? 1 - decimal : decimal;
      }
      getBasePixel() {
        return this.getPixelForValue(this.getBaseValue());
      }
      getBaseValue() {
        const { min, max } = this;
        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
      }
      getContext(index2) {
        const ticks = this.ticks || [];
        if (index2 >= 0 && index2 < ticks.length) {
          const tick = ticks[index2];
          return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
        }
        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
      }
      _tickSize() {
        const optionTicks = this.options.ticks;
        const rot = toRadians(this.labelRotation);
        const cos = Math.abs(Math.cos(rot));
        const sin = Math.abs(Math.sin(rot));
        const labelSizes = this._getLabelSizes();
        const padding = optionTicks.autoSkipPadding || 0;
        const w = labelSizes ? labelSizes.widest.width + padding : 0;
        const h = labelSizes ? labelSizes.highest.height + padding : 0;
        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
      }
      _isVisible() {
        const display = this.options.display;
        if (display !== "auto") {
          return !!display;
        }
        return this.getMatchingVisibleMetas().length > 0;
      }
      _computeGridLineItems(chartArea2) {
        const axis = this.axis;
        const chart = this.chart;
        const options = this.options;
        const { grid: grid2, position, border } = options;
        const offset = grid2.offset;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const ticksLength = ticks.length + (offset ? 1 : 0);
        const tl = getTickMarkLength(grid2);
        const items = [];
        const borderOpts = border.setContext(this.getContext());
        const axisWidth = borderOpts.display ? borderOpts.width : 0;
        const axisHalfWidth = axisWidth / 2;
        const alignBorderValue = function(pixel) {
          return _alignPixel(chart, pixel, axisWidth);
        };
        let borderValue, i2, lineValue, alignedLineValue;
        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
        if (position === "top") {
          borderValue = alignBorderValue(this.bottom);
          ty1 = this.bottom - tl;
          ty2 = borderValue - axisHalfWidth;
          y1 = alignBorderValue(chartArea2.top) + axisHalfWidth;
          y2 = chartArea2.bottom;
        } else if (position === "bottom") {
          borderValue = alignBorderValue(this.top);
          y1 = chartArea2.top;
          y2 = alignBorderValue(chartArea2.bottom) - axisHalfWidth;
          ty1 = borderValue + axisHalfWidth;
          ty2 = this.top + tl;
        } else if (position === "left") {
          borderValue = alignBorderValue(this.right);
          tx1 = this.right - tl;
          tx2 = borderValue - axisHalfWidth;
          x1 = alignBorderValue(chartArea2.left) + axisHalfWidth;
          x2 = chartArea2.right;
        } else if (position === "right") {
          borderValue = alignBorderValue(this.left);
          x1 = chartArea2.left;
          x2 = alignBorderValue(chartArea2.right) - axisHalfWidth;
          tx1 = borderValue + axisHalfWidth;
          tx2 = this.left + tl;
        } else if (axis === "x") {
          if (position === "center") {
            borderValue = alignBorderValue((chartArea2.top + chartArea2.bottom) / 2 + 0.5);
          } else if (isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
          }
          y1 = chartArea2.top;
          y2 = chartArea2.bottom;
          ty1 = borderValue + axisHalfWidth;
          ty2 = ty1 + tl;
        } else if (axis === "y") {
          if (position === "center") {
            borderValue = alignBorderValue((chartArea2.left + chartArea2.right) / 2);
          } else if (isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
          }
          tx1 = borderValue - axisHalfWidth;
          tx2 = tx1 - tl;
          x1 = chartArea2.left;
          x2 = chartArea2.right;
        }
        const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
        const step = Math.max(1, Math.ceil(ticksLength / limit));
        for (i2 = 0; i2 < ticksLength; i2 += step) {
          const context = this.getContext(i2);
          const optsAtIndex = grid2.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          const lineWidth = optsAtIndex.lineWidth;
          const lineColor = optsAtIndex.color;
          const borderDash = optsAtIndexBorder.dash || [];
          const borderDashOffset = optsAtIndexBorder.dashOffset;
          const tickWidth = optsAtIndex.tickWidth;
          const tickColor = optsAtIndex.tickColor;
          const tickBorderDash = optsAtIndex.tickBorderDash || [];
          const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
          lineValue = getPixelForGridLine(this, i2, offset);
          if (lineValue === void 0) {
            continue;
          }
          alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
          if (isHorizontal) {
            tx1 = tx2 = x1 = x2 = alignedLineValue;
          } else {
            ty1 = ty2 = y1 = y2 = alignedLineValue;
          }
          items.push({
            tx1,
            ty1,
            tx2,
            ty2,
            x1,
            y1,
            x2,
            y2,
            width: lineWidth,
            color: lineColor,
            borderDash,
            borderDashOffset,
            tickWidth,
            tickColor,
            tickBorderDash,
            tickBorderDashOffset
          });
        }
        this._ticksLength = ticksLength;
        this._borderValue = borderValue;
        return items;
      }
      _computeLabelItems(chartArea2) {
        const axis = this.axis;
        const options = this.options;
        const { position, ticks: optionTicks } = options;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const { align, crossAlign, padding, mirror } = optionTicks;
        const tl = getTickMarkLength(options.grid);
        const tickAndPadding = tl + padding;
        const hTickAndPadding = mirror ? -padding : tickAndPadding;
        const rotation = -toRadians(this.labelRotation);
        const items = [];
        let i2, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
        let textBaseline = "middle";
        if (position === "top") {
          y = this.bottom - hTickAndPadding;
          textAlign = this._getXAxisLabelAlignment();
        } else if (position === "bottom") {
          y = this.top + hTickAndPadding;
          textAlign = this._getXAxisLabelAlignment();
        } else if (position === "left") {
          const ret = this._getYAxisLabelAlignment(tl);
          textAlign = ret.textAlign;
          x = ret.x;
        } else if (position === "right") {
          const ret = this._getYAxisLabelAlignment(tl);
          textAlign = ret.textAlign;
          x = ret.x;
        } else if (axis === "x") {
          if (position === "center") {
            y = (chartArea2.top + chartArea2.bottom) / 2 + tickAndPadding;
          } else if (isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
          }
          textAlign = this._getXAxisLabelAlignment();
        } else if (axis === "y") {
          if (position === "center") {
            x = (chartArea2.left + chartArea2.right) / 2 - tickAndPadding;
          } else if (isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            x = this.chart.scales[positionAxisID].getPixelForValue(value);
          }
          textAlign = this._getYAxisLabelAlignment(tl).textAlign;
        }
        if (axis === "y") {
          if (align === "start") {
            textBaseline = "top";
          } else if (align === "end") {
            textBaseline = "bottom";
          }
        }
        const labelSizes = this._getLabelSizes();
        for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
          tick = ticks[i2];
          label = tick.label;
          const optsAtIndex = optionTicks.setContext(this.getContext(i2));
          pixel = this.getPixelForTick(i2) + optionTicks.labelOffset;
          font = this._resolveTickFontOptions(i2);
          lineHeight = font.lineHeight;
          lineCount = isArray(label) ? label.length : 1;
          const halfCount = lineCount / 2;
          const color2 = optsAtIndex.color;
          const strokeColor = optsAtIndex.textStrokeColor;
          const strokeWidth = optsAtIndex.textStrokeWidth;
          let tickTextAlign = textAlign;
          if (isHorizontal) {
            x = pixel;
            if (textAlign === "inner") {
              if (i2 === ilen - 1) {
                tickTextAlign = !this.options.reverse ? "right" : "left";
              } else if (i2 === 0) {
                tickTextAlign = !this.options.reverse ? "left" : "right";
              } else {
                tickTextAlign = "center";
              }
            }
            if (position === "top") {
              if (crossAlign === "near" || rotation !== 0) {
                textOffset = -lineCount * lineHeight + lineHeight / 2;
              } else if (crossAlign === "center") {
                textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
              } else {
                textOffset = -labelSizes.highest.height + lineHeight / 2;
              }
            } else {
              if (crossAlign === "near" || rotation !== 0) {
                textOffset = lineHeight / 2;
              } else if (crossAlign === "center") {
                textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
              } else {
                textOffset = labelSizes.highest.height - lineCount * lineHeight;
              }
            }
            if (mirror) {
              textOffset *= -1;
            }
            if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
              x += lineHeight / 2 * Math.sin(rotation);
            }
          } else {
            y = pixel;
            textOffset = (1 - lineCount) * lineHeight / 2;
          }
          let backdrop;
          if (optsAtIndex.showLabelBackdrop) {
            const labelPadding = toPadding(optsAtIndex.backdropPadding);
            const height = labelSizes.heights[i2];
            const width = labelSizes.widths[i2];
            let top2 = textOffset - labelPadding.top;
            let left = 0 - labelPadding.left;
            switch (textBaseline) {
              case "middle":
                top2 -= height / 2;
                break;
              case "bottom":
                top2 -= height;
                break;
            }
            switch (textAlign) {
              case "center":
                left -= width / 2;
                break;
              case "right":
                left -= width;
                break;
              case "inner":
                if (i2 === ilen - 1) {
                  left -= width;
                } else if (i2 > 0) {
                  left -= width / 2;
                }
                break;
            }
            backdrop = {
              left,
              top: top2,
              width: width + labelPadding.width,
              height: height + labelPadding.height,
              color: optsAtIndex.backdropColor
            };
          }
          items.push({
            label,
            font,
            textOffset,
            options: {
              rotation,
              color: color2,
              strokeColor,
              strokeWidth,
              textAlign: tickTextAlign,
              textBaseline,
              translation: [
                x,
                y
              ],
              backdrop
            }
          });
        }
        return items;
      }
      _getXAxisLabelAlignment() {
        const { position, ticks } = this.options;
        const rotation = -toRadians(this.labelRotation);
        if (rotation) {
          return position === "top" ? "left" : "right";
        }
        let align = "center";
        if (ticks.align === "start") {
          align = "left";
        } else if (ticks.align === "end") {
          align = "right";
        } else if (ticks.align === "inner") {
          align = "inner";
        }
        return align;
      }
      _getYAxisLabelAlignment(tl) {
        const { position, ticks: { crossAlign, mirror, padding } } = this.options;
        const labelSizes = this._getLabelSizes();
        const tickAndPadding = tl + padding;
        const widest = labelSizes.widest.width;
        let textAlign;
        let x;
        if (position === "left") {
          if (mirror) {
            x = this.right + padding;
            if (crossAlign === "near") {
              textAlign = "left";
            } else if (crossAlign === "center") {
              textAlign = "center";
              x += widest / 2;
            } else {
              textAlign = "right";
              x += widest;
            }
          } else {
            x = this.right - tickAndPadding;
            if (crossAlign === "near") {
              textAlign = "right";
            } else if (crossAlign === "center") {
              textAlign = "center";
              x -= widest / 2;
            } else {
              textAlign = "left";
              x = this.left;
            }
          }
        } else if (position === "right") {
          if (mirror) {
            x = this.left + padding;
            if (crossAlign === "near") {
              textAlign = "right";
            } else if (crossAlign === "center") {
              textAlign = "center";
              x -= widest / 2;
            } else {
              textAlign = "left";
              x -= widest;
            }
          } else {
            x = this.left + tickAndPadding;
            if (crossAlign === "near") {
              textAlign = "left";
            } else if (crossAlign === "center") {
              textAlign = "center";
              x += widest / 2;
            } else {
              textAlign = "right";
              x = this.right;
            }
          }
        } else {
          textAlign = "right";
        }
        return {
          textAlign,
          x
        };
      }
      _computeLabelArea() {
        if (this.options.ticks.mirror) {
          return;
        }
        const chart = this.chart;
        const position = this.options.position;
        if (position === "left" || position === "right") {
          return {
            top: 0,
            left: this.left,
            bottom: chart.height,
            right: this.right
          };
        }
        if (position === "top" || position === "bottom") {
          return {
            top: this.top,
            left: 0,
            bottom: this.bottom,
            right: chart.width
          };
        }
      }
      drawBackground() {
        const { ctx, options: { backgroundColor }, left, top: top2, width, height } = this;
        if (backgroundColor) {
          ctx.save();
          ctx.fillStyle = backgroundColor;
          ctx.fillRect(left, top2, width, height);
          ctx.restore();
        }
      }
      getLineWidthForValue(value) {
        const grid2 = this.options.grid;
        if (!this._isVisible() || !grid2.display) {
          return 0;
        }
        const ticks = this.ticks;
        const index2 = ticks.findIndex((t2) => t2.value === value);
        if (index2 >= 0) {
          const opts = grid2.setContext(this.getContext(index2));
          return opts.lineWidth;
        }
        return 0;
      }
      drawGrid(chartArea2) {
        const grid2 = this.options.grid;
        const ctx = this.ctx;
        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea2));
        let i2, ilen;
        const drawLine = (p1, p2, style) => {
          if (!style.width || !style.color) {
            return;
          }
          ctx.save();
          ctx.lineWidth = style.width;
          ctx.strokeStyle = style.color;
          ctx.setLineDash(style.borderDash || []);
          ctx.lineDashOffset = style.borderDashOffset;
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
          ctx.restore();
        };
        if (grid2.display) {
          for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
            const item = items[i2];
            if (grid2.drawOnChartArea) {
              drawLine({
                x: item.x1,
                y: item.y1
              }, {
                x: item.x2,
                y: item.y2
              }, item);
            }
            if (grid2.drawTicks) {
              drawLine({
                x: item.tx1,
                y: item.ty1
              }, {
                x: item.tx2,
                y: item.ty2
              }, {
                color: item.tickColor,
                width: item.tickWidth,
                borderDash: item.tickBorderDash,
                borderDashOffset: item.tickBorderDashOffset
              });
            }
          }
        }
      }
      drawBorder() {
        const { chart, ctx, options: { border, grid: grid2 } } = this;
        const borderOpts = border.setContext(this.getContext());
        const axisWidth = border.display ? borderOpts.width : 0;
        if (!axisWidth) {
          return;
        }
        const lastLineWidth = grid2.setContext(this.getContext(0)).lineWidth;
        const borderValue = this._borderValue;
        let x1, x2, y1, y2;
        if (this.isHorizontal()) {
          x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
          x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
          y1 = y2 = borderValue;
        } else {
          y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
          y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
          x1 = x2 = borderValue;
        }
        ctx.save();
        ctx.lineWidth = borderOpts.width;
        ctx.strokeStyle = borderOpts.color;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.restore();
      }
      drawLabels(chartArea2) {
        const optionTicks = this.options.ticks;
        if (!optionTicks.display) {
          return;
        }
        const ctx = this.ctx;
        const area = this._computeLabelArea();
        if (area) {
          clipArea(ctx, area);
        }
        const items = this.getLabelItems(chartArea2);
        for (const item of items) {
          const renderTextOptions = item.options;
          const tickFont = item.font;
          const label = item.label;
          const y = item.textOffset;
          renderText(ctx, label, 0, y, tickFont, renderTextOptions);
        }
        if (area) {
          unclipArea(ctx);
        }
      }
      drawTitle() {
        const { ctx, options: { position, title: title2, reverse } } = this;
        if (!title2.display) {
          return;
        }
        const font = toFont(title2.font);
        const padding = toPadding(title2.padding);
        const align = title2.align;
        let offset = font.lineHeight / 2;
        if (position === "bottom" || position === "center" || isObject(position)) {
          offset += padding.bottom;
          if (isArray(title2.text)) {
            offset += font.lineHeight * (title2.text.length - 1);
          }
        } else {
          offset += padding.top;
        }
        const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
        renderText(ctx, title2.text, 0, 0, font, {
          color: title2.color,
          maxWidth,
          rotation,
          textAlign: titleAlign(align, position, reverse),
          textBaseline: "middle",
          translation: [
            titleX,
            titleY
          ]
        });
      }
      draw(chartArea2) {
        if (!this._isVisible()) {
          return;
        }
        this.drawBackground();
        this.drawGrid(chartArea2);
        this.drawBorder();
        this.drawTitle();
        this.drawLabels(chartArea2);
      }
      _layers() {
        const opts = this.options;
        const tz = opts.ticks && opts.ticks.z || 0;
        const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
        const bz = valueOrDefault(opts.border && opts.border.z, 0);
        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
          return [
            {
              z: tz,
              draw: (chartArea2) => {
                this.draw(chartArea2);
              }
            }
          ];
        }
        return [
          {
            z: gz,
            draw: (chartArea2) => {
              this.drawBackground();
              this.drawGrid(chartArea2);
              this.drawTitle();
            }
          },
          {
            z: bz,
            draw: () => {
              this.drawBorder();
            }
          },
          {
            z: tz,
            draw: (chartArea2) => {
              this.drawLabels(chartArea2);
            }
          }
        ];
      }
      getMatchingVisibleMetas(type) {
        const metas = this.chart.getSortedVisibleDatasetMetas();
        const axisID = this.axis + "AxisID";
        const result = [];
        let i2, ilen;
        for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
          const meta2 = metas[i2];
          if (meta2[axisID] === this.id && (!type || meta2.type === type)) {
            result.push(meta2);
          }
        }
        return result;
      }
      _resolveTickFontOptions(index2) {
        const opts = this.options.ticks.setContext(this.getContext(index2));
        return toFont(opts.font);
      }
      _maxDigits() {
        const fontSize = this._resolveTickFontOptions(0).lineHeight;
        return (this.isHorizontal() ? this.width : this.height) / fontSize;
      }
    }
    class TypedRegistry {
      constructor(type, scope, override) {
        this.type = type;
        this.scope = scope;
        this.override = override;
        this.items = /* @__PURE__ */ Object.create(null);
      }
      isForType(type) {
        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
      }
      register(item) {
        const proto = Object.getPrototypeOf(item);
        let parentScope;
        if (isIChartComponent(proto)) {
          parentScope = this.register(proto);
        }
        const items = this.items;
        const id2 = item.id;
        const scope = this.scope + "." + id2;
        if (!id2) {
          throw new Error("class does not have id: " + item);
        }
        if (id2 in items) {
          return scope;
        }
        items[id2] = item;
        registerDefaults(item, scope, parentScope);
        if (this.override) {
          defaults$2.override(item.id, item.overrides);
        }
        return scope;
      }
      get(id2) {
        return this.items[id2];
      }
      unregister(item) {
        const items = this.items;
        const id2 = item.id;
        const scope = this.scope;
        if (id2 in items) {
          delete items[id2];
        }
        if (scope && id2 in defaults$2[scope]) {
          delete defaults$2[scope][id2];
          if (this.override) {
            delete overrides$1[id2];
          }
        }
      }
    }
    function registerDefaults(item, scope, parentScope) {
      const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
        parentScope ? defaults$2.get(parentScope) : {},
        defaults$2.get(scope),
        item.defaults
      ]);
      defaults$2.set(scope, itemDefaults);
      if (item.defaultRoutes) {
        routeDefaults(scope, item.defaultRoutes);
      }
      if (item.descriptors) {
        defaults$2.describe(scope, item.descriptors);
      }
    }
    function routeDefaults(scope, routes) {
      Object.keys(routes).forEach((property) => {
        const propertyParts = property.split(".");
        const sourceName = propertyParts.pop();
        const sourceScope = [
          scope
        ].concat(propertyParts).join(".");
        const parts = routes[property].split(".");
        const targetName = parts.pop();
        const targetScope = parts.join(".");
        defaults$2.route(sourceScope, sourceName, targetScope, targetName);
      });
    }
    function isIChartComponent(proto) {
      return "id" in proto && "defaults" in proto;
    }
    class Registry {
      constructor() {
        this.controllers = new TypedRegistry(DatasetController, "datasets", true);
        this.elements = new TypedRegistry(Element, "elements");
        this.plugins = new TypedRegistry(Object, "plugins");
        this.scales = new TypedRegistry(Scale, "scales");
        this._typedRegistries = [
          this.controllers,
          this.scales,
          this.elements
        ];
      }
      add(...args) {
        this._each("register", args);
      }
      remove(...args) {
        this._each("unregister", args);
      }
      addControllers(...args) {
        this._each("register", args, this.controllers);
      }
      addElements(...args) {
        this._each("register", args, this.elements);
      }
      addPlugins(...args) {
        this._each("register", args, this.plugins);
      }
      addScales(...args) {
        this._each("register", args, this.scales);
      }
      getController(id2) {
        return this._get(id2, this.controllers, "controller");
      }
      getElement(id2) {
        return this._get(id2, this.elements, "element");
      }
      getPlugin(id2) {
        return this._get(id2, this.plugins, "plugin");
      }
      getScale(id2) {
        return this._get(id2, this.scales, "scale");
      }
      removeControllers(...args) {
        this._each("unregister", args, this.controllers);
      }
      removeElements(...args) {
        this._each("unregister", args, this.elements);
      }
      removePlugins(...args) {
        this._each("unregister", args, this.plugins);
      }
      removeScales(...args) {
        this._each("unregister", args, this.scales);
      }
      _each(method, args, typedRegistry) {
        [
          ...args
        ].forEach((arg) => {
          const reg = typedRegistry || this._getRegistryForType(arg);
          if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
            this._exec(method, reg, arg);
          } else {
            each(arg, (item) => {
              const itemReg = typedRegistry || this._getRegistryForType(item);
              this._exec(method, itemReg, item);
            });
          }
        });
      }
      _exec(method, registry2, component) {
        const camelMethod = _capitalize(method);
        callback(component["before" + camelMethod], [], component);
        registry2[method](component);
        callback(component["after" + camelMethod], [], component);
      }
      _getRegistryForType(type) {
        for (let i2 = 0; i2 < this._typedRegistries.length; i2++) {
          const reg = this._typedRegistries[i2];
          if (reg.isForType(type)) {
            return reg;
          }
        }
        return this.plugins;
      }
      _get(id2, typedRegistry, type) {
        const item = typedRegistry.get(id2);
        if (item === void 0) {
          throw new Error('"' + id2 + '" is not a registered ' + type + ".");
        }
        return item;
      }
    }
    var registry = /* @__PURE__ */ new Registry();
    class PluginService {
      constructor() {
        this._init = void 0;
      }
      notify(chart, hook, args, filter) {
        if (hook === "beforeInit") {
          this._init = this._createDescriptors(chart, true);
          this._notify(this._init, chart, "install");
        }
        if (this._init === void 0) {
          return;
        }
        const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
        const result = this._notify(descriptors2, chart, hook, args);
        if (hook === "afterDestroy") {
          this._notify(descriptors2, chart, "stop");
          this._notify(this._init, chart, "uninstall");
          this._init = void 0;
        }
        return result;
      }
      _notify(descriptors2, chart, hook, args) {
        args = args || {};
        for (const descriptor of descriptors2) {
          const plugin = descriptor.plugin;
          const method = plugin[hook];
          const params = [
            chart,
            args,
            descriptor.options
          ];
          if (callback(method, params, plugin) === false && args.cancelable) {
            return false;
          }
        }
        return true;
      }
      invalidate() {
        if (!isNullOrUndef(this._cache)) {
          this._oldCache = this._cache;
          this._cache = void 0;
        }
      }
      _descriptors(chart) {
        if (this._cache) {
          return this._cache;
        }
        const descriptors2 = this._cache = this._createDescriptors(chart);
        this._notifyStateChanges(chart);
        return descriptors2;
      }
      _createDescriptors(chart, all2) {
        const config2 = chart && chart.config;
        const options = valueOrDefault(config2.options && config2.options.plugins, {});
        const plugins = allPlugins(config2);
        return options === false && !all2 ? [] : createDescriptors(chart, plugins, options, all2);
      }
      _notifyStateChanges(chart) {
        const previousDescriptors = this._oldCache || [];
        const descriptors2 = this._cache;
        const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
        this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
        this._notify(diff(descriptors2, previousDescriptors), chart, "start");
      }
    }
    function allPlugins(config2) {
      const localIds = {};
      const plugins = [];
      const keys2 = Object.keys(registry.plugins.items);
      for (let i2 = 0; i2 < keys2.length; i2++) {
        plugins.push(registry.getPlugin(keys2[i2]));
      }
      const local = config2.plugins || [];
      for (let i2 = 0; i2 < local.length; i2++) {
        const plugin = local[i2];
        if (plugins.indexOf(plugin) === -1) {
          plugins.push(plugin);
          localIds[plugin.id] = true;
        }
      }
      return {
        plugins,
        localIds
      };
    }
    function getOpts(options, all2) {
      if (!all2 && options === false) {
        return null;
      }
      if (options === true) {
        return {};
      }
      return options;
    }
    function createDescriptors(chart, { plugins, localIds }, options, all2) {
      const result = [];
      const context = chart.getContext();
      for (const plugin of plugins) {
        const id2 = plugin.id;
        const opts = getOpts(options[id2], all2);
        if (opts === null) {
          continue;
        }
        result.push({
          plugin,
          options: pluginOpts(chart.config, {
            plugin,
            local: localIds[id2]
          }, opts, context)
        });
      }
      return result;
    }
    function pluginOpts(config2, { plugin, local }, opts, context) {
      const keys2 = config2.pluginScopeKeys(plugin);
      const scopes = config2.getOptionScopes(opts, keys2);
      if (local && plugin.defaults) {
        scopes.push(plugin.defaults);
      }
      return config2.createResolver(scopes, context, [
        ""
      ], {
        scriptable: false,
        indexable: false,
        allKeys: true
      });
    }
    function getIndexAxis(type, options) {
      const datasetDefaults = defaults$2.datasets[type] || {};
      const datasetOptions = (options.datasets || {})[type] || {};
      return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
    }
    function getAxisFromDefaultScaleID(id2, indexAxis) {
      let axis = id2;
      if (id2 === "_index_") {
        axis = indexAxis;
      } else if (id2 === "_value_") {
        axis = indexAxis === "x" ? "y" : "x";
      }
      return axis;
    }
    function getDefaultScaleIDFromAxis(axis, indexAxis) {
      return axis === indexAxis ? "_index_" : "_value_";
    }
    function idMatchesAxis(id2) {
      if (id2 === "x" || id2 === "y" || id2 === "r") {
        return id2;
      }
    }
    function axisFromPosition(position) {
      if (position === "top" || position === "bottom") {
        return "x";
      }
      if (position === "left" || position === "right") {
        return "y";
      }
    }
    function determineAxis(id2, ...scaleOptions) {
      if (idMatchesAxis(id2)) {
        return id2;
      }
      for (const opts of scaleOptions) {
        const axis = opts.axis || axisFromPosition(opts.position) || id2.length > 1 && idMatchesAxis(id2[0].toLowerCase());
        if (axis) {
          return axis;
        }
      }
      throw new Error(`Cannot determine type of '${id2}' axis. Please provide 'axis' or 'position' option.`);
    }
    function getAxisFromDataset(id2, axis, dataset) {
      if (dataset[axis + "AxisID"] === id2) {
        return {
          axis
        };
      }
    }
    function retrieveAxisFromDatasets(id2, config2) {
      if (config2.data && config2.data.datasets) {
        const boundDs = config2.data.datasets.filter((d) => d.xAxisID === id2 || d.yAxisID === id2);
        if (boundDs.length) {
          return getAxisFromDataset(id2, "x", boundDs[0]) || getAxisFromDataset(id2, "y", boundDs[0]);
        }
      }
      return {};
    }
    function mergeScaleConfig(config2, options) {
      const chartDefaults = overrides$1[config2.type] || {
        scales: {}
      };
      const configScales = options.scales || {};
      const chartIndexAxis = getIndexAxis(config2.type, options);
      const scales = /* @__PURE__ */ Object.create(null);
      Object.keys(configScales).forEach((id2) => {
        const scaleConf = configScales[id2];
        if (!isObject(scaleConf)) {
          return console.error(`Invalid scale configuration for scale: ${id2}`);
        }
        if (scaleConf._proxy) {
          return console.warn(`Ignoring resolver passed as options for scale: ${id2}`);
        }
        const axis = determineAxis(id2, scaleConf, retrieveAxisFromDatasets(id2, config2), defaults$2.scales[scaleConf.type]);
        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
        const defaultScaleOptions = chartDefaults.scales || {};
        scales[id2] = mergeIf(/* @__PURE__ */ Object.create(null), [
          {
            axis
          },
          scaleConf,
          defaultScaleOptions[axis],
          defaultScaleOptions[defaultId]
        ]);
      });
      config2.data.datasets.forEach((dataset) => {
        const type = dataset.type || config2.type;
        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
        const datasetDefaults = overrides$1[type] || {};
        const defaultScaleOptions = datasetDefaults.scales || {};
        Object.keys(defaultScaleOptions).forEach((defaultID) => {
          const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
          const id2 = dataset[axis + "AxisID"] || axis;
          scales[id2] = scales[id2] || /* @__PURE__ */ Object.create(null);
          mergeIf(scales[id2], [
            {
              axis
            },
            configScales[id2],
            defaultScaleOptions[defaultID]
          ]);
        });
      });
      Object.keys(scales).forEach((key) => {
        const scale = scales[key];
        mergeIf(scale, [
          defaults$2.scales[scale.type],
          defaults$2.scale
        ]);
      });
      return scales;
    }
    function initOptions(config2) {
      const options = config2.options || (config2.options = {});
      options.plugins = valueOrDefault(options.plugins, {});
      options.scales = mergeScaleConfig(config2, options);
    }
    function initData(data) {
      data = data || {};
      data.datasets = data.datasets || [];
      data.labels = data.labels || [];
      return data;
    }
    function initConfig(config2) {
      config2 = config2 || {};
      config2.data = initData(config2.data);
      initOptions(config2);
      return config2;
    }
    const keyCache = /* @__PURE__ */ new Map();
    const keysCached = /* @__PURE__ */ new Set();
    function cachedKeys(cacheKey, generate) {
      let keys2 = keyCache.get(cacheKey);
      if (!keys2) {
        keys2 = generate();
        keyCache.set(cacheKey, keys2);
        keysCached.add(keys2);
      }
      return keys2;
    }
    const addIfFound = (set2, obj, key) => {
      const opts = resolveObjectKey(obj, key);
      if (opts !== void 0) {
        set2.add(opts);
      }
    };
    class Config {
      constructor(config2) {
        this._config = initConfig(config2);
        this._scopeCache = /* @__PURE__ */ new Map();
        this._resolverCache = /* @__PURE__ */ new Map();
      }
      get platform() {
        return this._config.platform;
      }
      get type() {
        return this._config.type;
      }
      set type(type) {
        this._config.type = type;
      }
      get data() {
        return this._config.data;
      }
      set data(data) {
        this._config.data = initData(data);
      }
      get options() {
        return this._config.options;
      }
      set options(options) {
        this._config.options = options;
      }
      get plugins() {
        return this._config.plugins;
      }
      update() {
        const config2 = this._config;
        this.clearCache();
        initOptions(config2);
      }
      clearCache() {
        this._scopeCache.clear();
        this._resolverCache.clear();
      }
      datasetScopeKeys(datasetType) {
        return cachedKeys(datasetType, () => [
          [
            `datasets.${datasetType}`,
            ""
          ]
        ]);
      }
      datasetAnimationScopeKeys(datasetType, transition) {
        return cachedKeys(`${datasetType}.transition.${transition}`, () => [
          [
            `datasets.${datasetType}.transitions.${transition}`,
            `transitions.${transition}`
          ],
          [
            `datasets.${datasetType}`,
            ""
          ]
        ]);
      }
      datasetElementScopeKeys(datasetType, elementType) {
        return cachedKeys(`${datasetType}-${elementType}`, () => [
          [
            `datasets.${datasetType}.elements.${elementType}`,
            `datasets.${datasetType}`,
            `elements.${elementType}`,
            ""
          ]
        ]);
      }
      pluginScopeKeys(plugin) {
        const id2 = plugin.id;
        const type = this.type;
        return cachedKeys(`${type}-plugin-${id2}`, () => [
          [
            `plugins.${id2}`,
            ...plugin.additionalOptionScopes || []
          ]
        ]);
      }
      _cachedScopes(mainScope, resetCache) {
        const _scopeCache = this._scopeCache;
        let cache = _scopeCache.get(mainScope);
        if (!cache || resetCache) {
          cache = /* @__PURE__ */ new Map();
          _scopeCache.set(mainScope, cache);
        }
        return cache;
      }
      getOptionScopes(mainScope, keyLists, resetCache) {
        const { options, type } = this;
        const cache = this._cachedScopes(mainScope, resetCache);
        const cached = cache.get(keyLists);
        if (cached) {
          return cached;
        }
        const scopes = /* @__PURE__ */ new Set();
        keyLists.forEach((keys2) => {
          if (mainScope) {
            scopes.add(mainScope);
            keys2.forEach((key) => addIfFound(scopes, mainScope, key));
          }
          keys2.forEach((key) => addIfFound(scopes, options, key));
          keys2.forEach((key) => addIfFound(scopes, overrides$1[type] || {}, key));
          keys2.forEach((key) => addIfFound(scopes, defaults$2, key));
          keys2.forEach((key) => addIfFound(scopes, descriptors, key));
        });
        const array = Array.from(scopes);
        if (array.length === 0) {
          array.push(/* @__PURE__ */ Object.create(null));
        }
        if (keysCached.has(keyLists)) {
          cache.set(keyLists, array);
        }
        return array;
      }
      chartOptionScopes() {
        const { options, type } = this;
        return [
          options,
          overrides$1[type] || {},
          defaults$2.datasets[type] || {},
          {
            type
          },
          defaults$2,
          descriptors
        ];
      }
      resolveNamedOptions(scopes, names2, context, prefixes = [
        ""
      ]) {
        const result = {
          $shared: true
        };
        const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
        let options = resolver;
        if (needContext(resolver, names2)) {
          result.$shared = false;
          context = isFunction(context) ? context() : context;
          const subResolver = this.createResolver(scopes, context, subPrefixes);
          options = _attachContext(resolver, context, subResolver);
        }
        for (const prop of names2) {
          result[prop] = options[prop];
        }
        return result;
      }
      createResolver(scopes, context, prefixes = [
        ""
      ], descriptorDefaults) {
        const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
        return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
      }
    }
    function getResolver(resolverCache, scopes, prefixes) {
      let cache = resolverCache.get(scopes);
      if (!cache) {
        cache = /* @__PURE__ */ new Map();
        resolverCache.set(scopes, cache);
      }
      const cacheKey = prefixes.join();
      let cached = cache.get(cacheKey);
      if (!cached) {
        const resolver = _createResolver(scopes, prefixes);
        cached = {
          resolver,
          subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
        };
        cache.set(cacheKey, cached);
      }
      return cached;
    }
    const hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
    function needContext(proxy, names2) {
      const { isScriptable, isIndexable } = _descriptors(proxy);
      for (const prop of names2) {
        const scriptable = isScriptable(prop);
        const indexable = isIndexable(prop);
        const value = (indexable || scriptable) && proxy[prop];
        if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
          return true;
        }
      }
      return false;
    }
    var version = "4.5.1";
    const KNOWN_POSITIONS = [
      "top",
      "bottom",
      "left",
      "right",
      "chartArea"
    ];
    function positionIsHorizontal(position, axis) {
      return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
    }
    function compare2Level(l1, l2) {
      return function(a, b) {
        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
      };
    }
    function onAnimationsComplete(context) {
      const chart = context.chart;
      const animationOptions = chart.options.animation;
      chart.notifyPlugins("afterRender");
      callback(animationOptions && animationOptions.onComplete, [
        context
      ], chart);
    }
    function onAnimationProgress(context) {
      const chart = context.chart;
      const animationOptions = chart.options.animation;
      callback(animationOptions && animationOptions.onProgress, [
        context
      ], chart);
    }
    function getCanvas(item) {
      if (_isDomSupported() && typeof item === "string") {
        item = document.getElementById(item);
      } else if (item && item.length) {
        item = item[0];
      }
      if (item && item.canvas) {
        item = item.canvas;
      }
      return item;
    }
    const instances = {};
    const getChart = (key) => {
      const canvas = getCanvas(key);
      return Object.values(instances).filter((c) => c.canvas === canvas).pop();
    };
    function moveNumericKeys(obj, start, move) {
      const keys2 = Object.keys(obj);
      for (const key of keys2) {
        const intKey = +key;
        if (intKey >= start) {
          const value = obj[key];
          delete obj[key];
          if (move > 0 || intKey > start) {
            obj[intKey + move] = value;
          }
        }
      }
    }
    function determineLastEvent(e, lastEvent, inChartArea, isClick) {
      if (!inChartArea || e.type === "mouseout") {
        return null;
      }
      if (isClick) {
        return lastEvent;
      }
      return e;
    }
    let Chart$1 = (_Aa = class {
      static register(...items) {
        registry.add(...items);
        invalidatePlugins();
      }
      static unregister(...items) {
        registry.remove(...items);
        invalidatePlugins();
      }
      constructor(item, userConfig) {
        const config2 = this.config = new Config(userConfig);
        const initialCanvas = getCanvas(item);
        const existingChart = getChart(initialCanvas);
        if (existingChart) {
          throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
        }
        const options = config2.createResolver(config2.chartOptionScopes(), this.getContext());
        this.platform = new (config2.platform || _detectPlatform(initialCanvas))();
        this.platform.updateConfig(config2);
        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
        const canvas = context && context.canvas;
        const height = canvas && canvas.height;
        const width = canvas && canvas.width;
        this.id = uid();
        this.ctx = context;
        this.canvas = canvas;
        this.width = width;
        this.height = height;
        this._options = options;
        this._aspectRatio = this.aspectRatio;
        this._layers = [];
        this._metasets = [];
        this._stacks = void 0;
        this.boxes = [];
        this.currentDevicePixelRatio = void 0;
        this.chartArea = void 0;
        this._active = [];
        this._lastEvent = void 0;
        this._listeners = {};
        this._responsiveListeners = void 0;
        this._sortedMetasets = [];
        this.scales = {};
        this._plugins = new PluginService();
        this.$proxies = {};
        this._hiddenIndices = {};
        this.attached = false;
        this._animationsDisabled = void 0;
        this.$context = void 0;
        this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
        this._dataChanges = [];
        instances[this.id] = this;
        if (!context || !canvas) {
          console.error("Failed to create chart: can't acquire context from the given item");
          return;
        }
        animator.listen(this, "complete", onAnimationsComplete);
        animator.listen(this, "progress", onAnimationProgress);
        this._initialize();
        if (this.attached) {
          this.update();
        }
      }
      get aspectRatio() {
        const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
        if (!isNullOrUndef(aspectRatio)) {
          return aspectRatio;
        }
        if (maintainAspectRatio && _aspectRatio) {
          return _aspectRatio;
        }
        return height ? width / height : null;
      }
      get data() {
        return this.config.data;
      }
      set data(data) {
        this.config.data = data;
      }
      get options() {
        return this._options;
      }
      set options(options) {
        this.config.options = options;
      }
      get registry() {
        return registry;
      }
      _initialize() {
        this.notifyPlugins("beforeInit");
        if (this.options.responsive) {
          this.resize();
        } else {
          retinaScale(this, this.options.devicePixelRatio);
        }
        this.bindEvents();
        this.notifyPlugins("afterInit");
        return this;
      }
      clear() {
        clearCanvas(this.canvas, this.ctx);
        return this;
      }
      stop() {
        animator.stop(this);
        return this;
      }
      resize(width, height) {
        if (!animator.running(this)) {
          this._resize(width, height);
        } else {
          this._resizeBeforeDraw = {
            width,
            height
          };
        }
      }
      _resize(width, height) {
        const options = this.options;
        const canvas = this.canvas;
        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
        const mode = this.width ? "resize" : "attach";
        this.width = newSize.width;
        this.height = newSize.height;
        this._aspectRatio = this.aspectRatio;
        if (!retinaScale(this, newRatio, true)) {
          return;
        }
        this.notifyPlugins("resize", {
          size: newSize
        });
        callback(options.onResize, [
          this,
          newSize
        ], this);
        if (this.attached) {
          if (this._doResize(mode)) {
            this.render();
          }
        }
      }
      ensureScalesHaveIDs() {
        const options = this.options;
        const scalesOptions = options.scales || {};
        each(scalesOptions, (axisOptions, axisID) => {
          axisOptions.id = axisID;
        });
      }
      buildOrUpdateScales() {
        const options = this.options;
        const scaleOpts = options.scales;
        const scales = this.scales;
        const updated = Object.keys(scales).reduce((obj, id2) => {
          obj[id2] = false;
          return obj;
        }, {});
        let items = [];
        if (scaleOpts) {
          items = items.concat(Object.keys(scaleOpts).map((id2) => {
            const scaleOptions = scaleOpts[id2];
            const axis = determineAxis(id2, scaleOptions);
            const isRadial = axis === "r";
            const isHorizontal = axis === "x";
            return {
              options: scaleOptions,
              dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
              dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
            };
          }));
        }
        each(items, (item) => {
          const scaleOptions = item.options;
          const id2 = scaleOptions.id;
          const axis = determineAxis(id2, scaleOptions);
          const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
          if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
            scaleOptions.position = item.dposition;
          }
          updated[id2] = true;
          let scale = null;
          if (id2 in scales && scales[id2].type === scaleType) {
            scale = scales[id2];
          } else {
            const scaleClass = registry.getScale(scaleType);
            scale = new scaleClass({
              id: id2,
              type: scaleType,
              ctx: this.ctx,
              chart: this
            });
            scales[scale.id] = scale;
          }
          scale.init(scaleOptions, options);
        });
        each(updated, (hasUpdated, id2) => {
          if (!hasUpdated) {
            delete scales[id2];
          }
        });
        each(scales, (scale) => {
          layouts.configure(this, scale, scale.options);
          layouts.addBox(this, scale);
        });
      }
      _updateMetasets() {
        const metasets = this._metasets;
        const numData = this.data.datasets.length;
        const numMeta = metasets.length;
        metasets.sort((a, b) => a.index - b.index);
        if (numMeta > numData) {
          for (let i2 = numData; i2 < numMeta; ++i2) {
            this._destroyDatasetMeta(i2);
          }
          metasets.splice(numData, numMeta - numData);
        }
        this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
      }
      _removeUnreferencedMetasets() {
        const { _metasets: metasets, data: { datasets } } = this;
        if (metasets.length > datasets.length) {
          delete this._stacks;
        }
        metasets.forEach((meta2, index2) => {
          if (datasets.filter((x) => x === meta2._dataset).length === 0) {
            this._destroyDatasetMeta(index2);
          }
        });
      }
      buildOrUpdateControllers() {
        const newControllers = [];
        const datasets = this.data.datasets;
        let i2, ilen;
        this._removeUnreferencedMetasets();
        for (i2 = 0, ilen = datasets.length; i2 < ilen; i2++) {
          const dataset = datasets[i2];
          let meta2 = this.getDatasetMeta(i2);
          const type = dataset.type || this.config.type;
          if (meta2.type && meta2.type !== type) {
            this._destroyDatasetMeta(i2);
            meta2 = this.getDatasetMeta(i2);
          }
          meta2.type = type;
          meta2.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
          meta2.order = dataset.order || 0;
          meta2.index = i2;
          meta2.label = "" + dataset.label;
          meta2.visible = this.isDatasetVisible(i2);
          if (meta2.controller) {
            meta2.controller.updateIndex(i2);
            meta2.controller.linkScales();
          } else {
            const ControllerClass = registry.getController(type);
            const { datasetElementType, dataElementType } = defaults$2.datasets[type];
            Object.assign(ControllerClass, {
              dataElementType: registry.getElement(dataElementType),
              datasetElementType: datasetElementType && registry.getElement(datasetElementType)
            });
            meta2.controller = new ControllerClass(this, i2);
            newControllers.push(meta2.controller);
          }
        }
        this._updateMetasets();
        return newControllers;
      }
      _resetElements() {
        each(this.data.datasets, (dataset, datasetIndex) => {
          this.getDatasetMeta(datasetIndex).controller.reset();
        }, this);
      }
      reset() {
        this._resetElements();
        this.notifyPlugins("reset");
      }
      update(mode) {
        const config2 = this.config;
        config2.update();
        const options = this._options = config2.createResolver(config2.chartOptionScopes(), this.getContext());
        const animsDisabled = this._animationsDisabled = !options.animation;
        this._updateScales();
        this._checkEventBindings();
        this._updateHiddenIndices();
        this._plugins.invalidate();
        if (this.notifyPlugins("beforeUpdate", {
          mode,
          cancelable: true
        }) === false) {
          return;
        }
        const newControllers = this.buildOrUpdateControllers();
        this.notifyPlugins("beforeElementsUpdate");
        let minPadding = 0;
        for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; i2++) {
          const { controller } = this.getDatasetMeta(i2);
          const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
          controller.buildOrUpdateElements(reset);
          minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
        }
        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
        this._updateLayout(minPadding);
        if (!animsDisabled) {
          each(newControllers, (controller) => {
            controller.reset();
          });
        }
        this._updateDatasets(mode);
        this.notifyPlugins("afterUpdate", {
          mode
        });
        this._layers.sort(compare2Level("z", "_idx"));
        const { _active, _lastEvent } = this;
        if (_lastEvent) {
          this._eventHandler(_lastEvent, true);
        } else if (_active.length) {
          this._updateHoverStyles(_active, _active, true);
        }
        this.render();
      }
      _updateScales() {
        each(this.scales, (scale) => {
          layouts.removeBox(this, scale);
        });
        this.ensureScalesHaveIDs();
        this.buildOrUpdateScales();
      }
      _checkEventBindings() {
        const options = this.options;
        const existingEvents = new Set(Object.keys(this._listeners));
        const newEvents = new Set(options.events);
        if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
          this.unbindEvents();
          this.bindEvents();
        }
      }
      _updateHiddenIndices() {
        const { _hiddenIndices } = this;
        const changes = this._getUniformDataChanges() || [];
        for (const { method, start, count } of changes) {
          const move = method === "_removeElements" ? -count : count;
          moveNumericKeys(_hiddenIndices, start, move);
        }
      }
      _getUniformDataChanges() {
        const _dataChanges = this._dataChanges;
        if (!_dataChanges || !_dataChanges.length) {
          return;
        }
        this._dataChanges = [];
        const datasetCount = this.data.datasets.length;
        const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i2) => i2 + "," + c.splice(1).join(",")));
        const changeSet = makeSet(0);
        for (let i2 = 1; i2 < datasetCount; i2++) {
          if (!setsEqual(changeSet, makeSet(i2))) {
            return;
          }
        }
        return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
          method: a[1],
          start: +a[2],
          count: +a[3]
        }));
      }
      _updateLayout(minPadding) {
        if (this.notifyPlugins("beforeLayout", {
          cancelable: true
        }) === false) {
          return;
        }
        layouts.update(this, this.width, this.height, minPadding);
        const area = this.chartArea;
        const noArea = area.width <= 0 || area.height <= 0;
        this._layers = [];
        each(this.boxes, (box) => {
          if (noArea && box.position === "chartArea") {
            return;
          }
          if (box.configure) {
            box.configure();
          }
          this._layers.push(...box._layers());
        }, this);
        this._layers.forEach((item, index2) => {
          item._idx = index2;
        });
        this.notifyPlugins("afterLayout");
      }
      _updateDatasets(mode) {
        if (this.notifyPlugins("beforeDatasetsUpdate", {
          mode,
          cancelable: true
        }) === false) {
          return;
        }
        for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
          this.getDatasetMeta(i2).controller.configure();
        }
        for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
          this._updateDataset(i2, isFunction(mode) ? mode({
            datasetIndex: i2
          }) : mode);
        }
        this.notifyPlugins("afterDatasetsUpdate", {
          mode
        });
      }
      _updateDataset(index2, mode) {
        const meta2 = this.getDatasetMeta(index2);
        const args = {
          meta: meta2,
          index: index2,
          mode,
          cancelable: true
        };
        if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
          return;
        }
        meta2.controller._update(mode);
        args.cancelable = false;
        this.notifyPlugins("afterDatasetUpdate", args);
      }
      render() {
        if (this.notifyPlugins("beforeRender", {
          cancelable: true
        }) === false) {
          return;
        }
        if (animator.has(this)) {
          if (this.attached && !animator.running(this)) {
            animator.start(this);
          }
        } else {
          this.draw();
          onAnimationsComplete({
            chart: this
          });
        }
      }
      draw() {
        let i2;
        if (this._resizeBeforeDraw) {
          const { width, height } = this._resizeBeforeDraw;
          this._resizeBeforeDraw = null;
          this._resize(width, height);
        }
        this.clear();
        if (this.width <= 0 || this.height <= 0) {
          return;
        }
        if (this.notifyPlugins("beforeDraw", {
          cancelable: true
        }) === false) {
          return;
        }
        const layers = this._layers;
        for (i2 = 0; i2 < layers.length && layers[i2].z <= 0; ++i2) {
          layers[i2].draw(this.chartArea);
        }
        this._drawDatasets();
        for (; i2 < layers.length; ++i2) {
          layers[i2].draw(this.chartArea);
        }
        this.notifyPlugins("afterDraw");
      }
      _getSortedDatasetMetas(filterVisible) {
        const metasets = this._sortedMetasets;
        const result = [];
        let i2, ilen;
        for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
          const meta2 = metasets[i2];
          if (!filterVisible || meta2.visible) {
            result.push(meta2);
          }
        }
        return result;
      }
      getSortedVisibleDatasetMetas() {
        return this._getSortedDatasetMetas(true);
      }
      _drawDatasets() {
        if (this.notifyPlugins("beforeDatasetsDraw", {
          cancelable: true
        }) === false) {
          return;
        }
        const metasets = this.getSortedVisibleDatasetMetas();
        for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
          this._drawDataset(metasets[i2]);
        }
        this.notifyPlugins("afterDatasetsDraw");
      }
      _drawDataset(meta2) {
        const ctx = this.ctx;
        const args = {
          meta: meta2,
          index: meta2.index,
          cancelable: true
        };
        const clip2 = getDatasetClipArea(this, meta2);
        if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
          return;
        }
        if (clip2) {
          clipArea(ctx, clip2);
        }
        meta2.controller.draw();
        if (clip2) {
          unclipArea(ctx);
        }
        args.cancelable = false;
        this.notifyPlugins("afterDatasetDraw", args);
      }
      isPointInArea(point) {
        return _isPointInArea(point, this.chartArea, this._minPadding);
      }
      getElementsAtEventForMode(e, mode, options, useFinalPosition) {
        const method = Interaction.modes[mode];
        if (typeof method === "function") {
          return method(this, e, options, useFinalPosition);
        }
        return [];
      }
      getDatasetMeta(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        const metasets = this._metasets;
        let meta2 = metasets.filter((x) => x && x._dataset === dataset).pop();
        if (!meta2) {
          meta2 = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            xAxisID: null,
            yAxisID: null,
            order: dataset && dataset.order || 0,
            index: datasetIndex,
            _dataset: dataset,
            _parsed: [],
            _sorted: false
          };
          metasets.push(meta2);
        }
        return meta2;
      }
      getContext() {
        return this.$context || (this.$context = createContext(null, {
          chart: this,
          type: "chart"
        }));
      }
      getVisibleDatasetCount() {
        return this.getSortedVisibleDatasetMetas().length;
      }
      isDatasetVisible(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        if (!dataset) {
          return false;
        }
        const meta2 = this.getDatasetMeta(datasetIndex);
        return typeof meta2.hidden === "boolean" ? !meta2.hidden : !dataset.hidden;
      }
      setDatasetVisibility(datasetIndex, visible) {
        const meta2 = this.getDatasetMeta(datasetIndex);
        meta2.hidden = !visible;
      }
      toggleDataVisibility(index2) {
        this._hiddenIndices[index2] = !this._hiddenIndices[index2];
      }
      getDataVisibility(index2) {
        return !this._hiddenIndices[index2];
      }
      _updateVisibility(datasetIndex, dataIndex, visible) {
        const mode = visible ? "show" : "hide";
        const meta2 = this.getDatasetMeta(datasetIndex);
        const anims = meta2.controller._resolveAnimations(void 0, mode);
        if (defined(dataIndex)) {
          meta2.data[dataIndex].hidden = !visible;
          this.update();
        } else {
          this.setDatasetVisibility(datasetIndex, visible);
          anims.update(meta2, {
            visible
          });
          this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
        }
      }
      hide(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, false);
      }
      show(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, true);
      }
      _destroyDatasetMeta(datasetIndex) {
        const meta2 = this._metasets[datasetIndex];
        if (meta2 && meta2.controller) {
          meta2.controller._destroy();
        }
        delete this._metasets[datasetIndex];
      }
      _stop() {
        let i2, ilen;
        this.stop();
        animator.remove(this);
        for (i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
          this._destroyDatasetMeta(i2);
        }
      }
      destroy() {
        this.notifyPlugins("beforeDestroy");
        const { canvas, ctx } = this;
        this._stop();
        this.config.clearCache();
        if (canvas) {
          this.unbindEvents();
          clearCanvas(canvas, ctx);
          this.platform.releaseContext(ctx);
          this.canvas = null;
          this.ctx = null;
        }
        delete instances[this.id];
        this.notifyPlugins("afterDestroy");
      }
      toBase64Image(...args) {
        return this.canvas.toDataURL(...args);
      }
      bindEvents() {
        this.bindUserEvents();
        if (this.options.responsive) {
          this.bindResponsiveEvents();
        } else {
          this.attached = true;
        }
      }
      bindUserEvents() {
        const listeners = this._listeners;
        const platform2 = this.platform;
        const _add = (type, listener2) => {
          platform2.addEventListener(this, type, listener2);
          listeners[type] = listener2;
        };
        const listener = (e, x, y) => {
          e.offsetX = x;
          e.offsetY = y;
          this._eventHandler(e);
        };
        each(this.options.events, (type) => _add(type, listener));
      }
      bindResponsiveEvents() {
        if (!this._responsiveListeners) {
          this._responsiveListeners = {};
        }
        const listeners = this._responsiveListeners;
        const platform2 = this.platform;
        const _add = (type, listener2) => {
          platform2.addEventListener(this, type, listener2);
          listeners[type] = listener2;
        };
        const _remove = (type, listener2) => {
          if (listeners[type]) {
            platform2.removeEventListener(this, type, listener2);
            delete listeners[type];
          }
        };
        const listener = (width, height) => {
          if (this.canvas) {
            this.resize(width, height);
          }
        };
        let detached;
        const attached = () => {
          _remove("attach", attached);
          this.attached = true;
          this.resize();
          _add("resize", listener);
          _add("detach", detached);
        };
        detached = () => {
          this.attached = false;
          _remove("resize", listener);
          this._stop();
          this._resize(0, 0);
          _add("attach", attached);
        };
        if (platform2.isAttached(this.canvas)) {
          attached();
        } else {
          detached();
        }
      }
      unbindEvents() {
        each(this._listeners, (listener, type) => {
          this.platform.removeEventListener(this, type, listener);
        });
        this._listeners = {};
        each(this._responsiveListeners, (listener, type) => {
          this.platform.removeEventListener(this, type, listener);
        });
        this._responsiveListeners = void 0;
      }
      updateHoverStyle(items, mode, enabled) {
        const prefix = enabled ? "set" : "remove";
        let meta2, item, i2, ilen;
        if (mode === "dataset") {
          meta2 = this.getDatasetMeta(items[0].datasetIndex);
          meta2.controller["_" + prefix + "DatasetHoverStyle"]();
        }
        for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
          item = items[i2];
          const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
          if (controller) {
            controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
          }
        }
      }
      getActiveElements() {
        return this._active || [];
      }
      setActiveElements(activeElements) {
        const lastActive = this._active || [];
        const active = activeElements.map(({ datasetIndex, index: index2 }) => {
          const meta2 = this.getDatasetMeta(datasetIndex);
          if (!meta2) {
            throw new Error("No dataset found at index " + datasetIndex);
          }
          return {
            datasetIndex,
            element: meta2.data[index2],
            index: index2
          };
        });
        const changed = !_elementsEqual(active, lastActive);
        if (changed) {
          this._active = active;
          this._lastEvent = null;
          this._updateHoverStyles(active, lastActive);
        }
      }
      notifyPlugins(hook, args, filter) {
        return this._plugins.notify(this, hook, args, filter);
      }
      isPluginEnabled(pluginId) {
        return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
      }
      _updateHoverStyles(active, lastActive, replay) {
        const hoverOptions = this.options.hover;
        const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
        const deactivated = diff(lastActive, active);
        const activated = replay ? active : diff(active, lastActive);
        if (deactivated.length) {
          this.updateHoverStyle(deactivated, hoverOptions.mode, false);
        }
        if (activated.length && hoverOptions.mode) {
          this.updateHoverStyle(activated, hoverOptions.mode, true);
        }
      }
      _eventHandler(e, replay) {
        const args = {
          event: e,
          replay,
          cancelable: true,
          inChartArea: this.isPointInArea(e)
        };
        const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
        if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
          return;
        }
        const changed = this._handleEvent(e, replay, args.inChartArea);
        args.cancelable = false;
        this.notifyPlugins("afterEvent", args, eventFilter);
        if (changed || args.changed) {
          this.render();
        }
        return this;
      }
      _handleEvent(e, replay, inChartArea) {
        const { _active: lastActive = [], options } = this;
        const useFinalPosition = replay;
        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
        const isClick = _isClickEvent(e);
        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
        if (inChartArea) {
          this._lastEvent = null;
          callback(options.onHover, [
            e,
            active,
            this
          ], this);
          if (isClick) {
            callback(options.onClick, [
              e,
              active,
              this
            ], this);
          }
        }
        const changed = !_elementsEqual(active, lastActive);
        if (changed || replay) {
          this._active = active;
          this._updateHoverStyles(active, lastActive, replay);
        }
        this._lastEvent = lastEvent;
        return changed;
      }
      _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
        if (e.type === "mouseout") {
          return [];
        }
        if (!inChartArea) {
          return lastActive;
        }
        const hoverOptions = this.options.hover;
        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
      }
    }, __publicField(_Aa, "defaults", defaults$2), __publicField(_Aa, "instances", instances), __publicField(_Aa, "overrides", overrides$1), __publicField(_Aa, "registry", registry), __publicField(_Aa, "version", version), __publicField(_Aa, "getChart", getChart), _Aa);
    function invalidatePlugins() {
      return each(Chart$1.instances, (chart) => chart._plugins.invalidate());
    }
    function setStyle(ctx, options, style = options) {
      ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
      ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
      ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
      ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
      ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
      ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
    }
    function lineTo(ctx, previous, target) {
      ctx.lineTo(target.x, target.y);
    }
    function getLineMethod(options) {
      if (options.stepped) {
        return _steppedLineTo;
      }
      if (options.tension || options.cubicInterpolationMode === "monotone") {
        return _bezierCurveTo;
      }
      return lineTo;
    }
    function pathVars(points, segment, params = {}) {
      const count = points.length;
      const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
      const { start: segmentStart, end: segmentEnd } = segment;
      const start = Math.max(paramsStart, segmentStart);
      const end = Math.min(paramsEnd, segmentEnd);
      const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
      return {
        count,
        start,
        loop: segment.loop,
        ilen: end < start && !outside ? count + end - start : end - start
      };
    }
    function pathSegment(ctx, line, segment, params) {
      const { points, options } = line;
      const { count, start, loop, ilen } = pathVars(points, segment, params);
      const lineMethod = getLineMethod(options);
      let { move = true, reverse } = params || {};
      let i2, point, prev;
      for (i2 = 0; i2 <= ilen; ++i2) {
        point = points[(start + (reverse ? ilen - i2 : i2)) % count];
        if (point.skip) {
          continue;
        } else if (move) {
          ctx.moveTo(point.x, point.y);
          move = false;
        } else {
          lineMethod(ctx, prev, point, reverse, options.stepped);
        }
        prev = point;
      }
      if (loop) {
        point = points[(start + (reverse ? ilen : 0)) % count];
        lineMethod(ctx, prev, point, reverse, options.stepped);
      }
      return !!loop;
    }
    function fastPathSegment(ctx, line, segment, params) {
      const points = line.points;
      const { count, start, ilen } = pathVars(points, segment, params);
      const { move = true, reverse } = params || {};
      let avgX = 0;
      let countX = 0;
      let i2, point, prevX, minY, maxY, lastY;
      const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
      const drawX = () => {
        if (minY !== maxY) {
          ctx.lineTo(avgX, maxY);
          ctx.lineTo(avgX, minY);
          ctx.lineTo(avgX, lastY);
        }
      };
      if (move) {
        point = points[pointIndex(0)];
        ctx.moveTo(point.x, point.y);
      }
      for (i2 = 0; i2 <= ilen; ++i2) {
        point = points[pointIndex(i2)];
        if (point.skip) {
          continue;
        }
        const x = point.x;
        const y = point.y;
        const truncX = x | 0;
        if (truncX === prevX) {
          if (y < minY) {
            minY = y;
          } else if (y > maxY) {
            maxY = y;
          }
          avgX = (countX * avgX + x) / ++countX;
        } else {
          drawX();
          ctx.lineTo(x, y);
          prevX = truncX;
          countX = 0;
          minY = maxY = y;
        }
        lastY = y;
      }
      drawX();
    }
    function _getSegmentMethod(line) {
      const opts = line.options;
      const borderDash = opts.borderDash && opts.borderDash.length;
      const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
      return useFastPath ? fastPathSegment : pathSegment;
    }
    function _getInterpolationMethod(options) {
      if (options.stepped) {
        return _steppedInterpolation;
      }
      if (options.tension || options.cubicInterpolationMode === "monotone") {
        return _bezierInterpolation;
      }
      return _pointInLine;
    }
    function strokePathWithCache(ctx, line, start, count) {
      let path2 = line._path;
      if (!path2) {
        path2 = line._path = new Path2D();
        if (line.path(path2, start, count)) {
          path2.closePath();
        }
      }
      setStyle(ctx, line.options);
      ctx.stroke(path2);
    }
    function strokePathDirect(ctx, line, start, count) {
      const { segments, options } = line;
      const segmentMethod = _getSegmentMethod(line);
      for (const segment of segments) {
        setStyle(ctx, options, segment.style);
        ctx.beginPath();
        if (segmentMethod(ctx, line, segment, {
          start,
          end: start + count - 1
        })) {
          ctx.closePath();
        }
        ctx.stroke();
      }
    }
    const usePath2D = typeof Path2D === "function";
    function draw(ctx, line, start, count) {
      if (usePath2D && !line.options.segment) {
        strokePathWithCache(ctx, line, start, count);
      } else {
        strokePathDirect(ctx, line, start, count);
      }
    }
    class LineElement extends Element {
      constructor(cfg) {
        super();
        this.animated = true;
        this.options = void 0;
        this._chart = void 0;
        this._loop = void 0;
        this._fullLoop = void 0;
        this._path = void 0;
        this._points = void 0;
        this._segments = void 0;
        this._decimated = false;
        this._pointsUpdated = false;
        this._datasetIndex = void 0;
        if (cfg) {
          Object.assign(this, cfg);
        }
      }
      updateControlPoints(chartArea2, indexAxis) {
        const options = this.options;
        if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
          const loop = options.spanGaps ? this._loop : this._fullLoop;
          _updateBezierControlPoints(this._points, options, chartArea2, loop, indexAxis);
          this._pointsUpdated = true;
        }
      }
      set points(points) {
        this._points = points;
        delete this._segments;
        delete this._path;
        this._pointsUpdated = false;
      }
      get points() {
        return this._points;
      }
      get segments() {
        return this._segments || (this._segments = _computeSegments(this, this.options.segment));
      }
      first() {
        const segments = this.segments;
        const points = this.points;
        return segments.length && points[segments[0].start];
      }
      last() {
        const segments = this.segments;
        const points = this.points;
        const count = segments.length;
        return count && points[segments[count - 1].end];
      }
      interpolate(point, property) {
        const options = this.options;
        const value = point[property];
        const points = this.points;
        const segments = _boundSegments(this, {
          property,
          start: value,
          end: value
        });
        if (!segments.length) {
          return;
        }
        const result = [];
        const _interpolate = _getInterpolationMethod(options);
        let i2, ilen;
        for (i2 = 0, ilen = segments.length; i2 < ilen; ++i2) {
          const { start, end } = segments[i2];
          const p1 = points[start];
          const p2 = points[end];
          if (p1 === p2) {
            result.push(p1);
            continue;
          }
          const t2 = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
          const interpolated = _interpolate(p1, p2, t2, options.stepped);
          interpolated[property] = point[property];
          result.push(interpolated);
        }
        return result.length === 1 ? result[0] : result;
      }
      pathSegment(ctx, segment, params) {
        const segmentMethod = _getSegmentMethod(this);
        return segmentMethod(ctx, this, segment, params);
      }
      path(ctx, start, count) {
        const segments = this.segments;
        const segmentMethod = _getSegmentMethod(this);
        let loop = this._loop;
        start = start || 0;
        count = count || this.points.length - start;
        for (const segment of segments) {
          loop &= segmentMethod(ctx, this, segment, {
            start,
            end: start + count - 1
          });
        }
        return !!loop;
      }
      draw(ctx, chartArea2, start, count) {
        const options = this.options || {};
        const points = this.points || [];
        if (points.length && options.borderWidth) {
          ctx.save();
          draw(ctx, this, start, count);
          ctx.restore();
        }
        if (this.animated) {
          this._pointsUpdated = false;
          this._path = void 0;
        }
      }
    }
    __publicField(LineElement, "id", "line");
    __publicField(LineElement, "defaults", {
      borderCapStyle: "butt",
      borderDash: [],
      borderDashOffset: 0,
      borderJoinStyle: "miter",
      borderWidth: 3,
      capBezierPoints: true,
      cubicInterpolationMode: "default",
      fill: false,
      spanGaps: false,
      stepped: false,
      tension: 0
    });
    __publicField(LineElement, "defaultRoutes", {
      backgroundColor: "backgroundColor",
      borderColor: "borderColor"
    });
    __publicField(LineElement, "descriptors", {
      _scriptable: true,
      _indexable: (name2) => name2 !== "borderDash" && name2 !== "fill"
    });
    function inRange$1(el, pos, axis, useFinalPosition) {
      const options = el.options;
      const { [axis]: value } = el.getProps([
        axis
      ], useFinalPosition);
      return Math.abs(pos - value) < options.radius + options.hitRadius;
    }
    class PointElement extends Element {
      constructor(cfg) {
        super();
        __publicField(this, "parsed");
        __publicField(this, "skip");
        __publicField(this, "stop");
        this.options = void 0;
        this.parsed = void 0;
        this.skip = void 0;
        this.stop = void 0;
        if (cfg) {
          Object.assign(this, cfg);
        }
      }
      inRange(mouseX, mouseY, useFinalPosition) {
        const options = this.options;
        const { x, y } = this.getProps([
          "x",
          "y"
        ], useFinalPosition);
        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
      }
      inXRange(mouseX, useFinalPosition) {
        return inRange$1(this, mouseX, "x", useFinalPosition);
      }
      inYRange(mouseY, useFinalPosition) {
        return inRange$1(this, mouseY, "y", useFinalPosition);
      }
      getCenterPoint(useFinalPosition) {
        const { x, y } = this.getProps([
          "x",
          "y"
        ], useFinalPosition);
        return {
          x,
          y
        };
      }
      size(options) {
        options = options || this.options || {};
        let radius = options.radius || 0;
        radius = Math.max(radius, radius && options.hoverRadius || 0);
        const borderWidth = radius && options.borderWidth || 0;
        return (radius + borderWidth) * 2;
      }
      draw(ctx, area) {
        const options = this.options;
        if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
          return;
        }
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.fillStyle = options.backgroundColor;
        drawPoint(ctx, options, this.x, this.y);
      }
      getRange() {
        const options = this.options || {};
        return options.radius + options.hitRadius;
      }
    }
    __publicField(PointElement, "id", "point");
    /**
    * @type {any}
    */
    __publicField(PointElement, "defaults", {
      borderWidth: 1,
      hitRadius: 1,
      hoverBorderWidth: 1,
      hoverRadius: 4,
      pointStyle: "circle",
      radius: 3,
      rotation: 0
    });
    /**
    * @type {any}
    */
    __publicField(PointElement, "defaultRoutes", {
      backgroundColor: "backgroundColor",
      borderColor: "borderColor"
    });
    function _segments(line, target, property) {
      const segments = line.segments;
      const points = line.points;
      const tpoints = target.points;
      const parts = [];
      for (const segment of segments) {
        let { start, end } = segment;
        end = _findSegmentEnd(start, end, points);
        const bounds = _getBounds(property, points[start], points[end], segment.loop);
        if (!target.segments) {
          parts.push({
            source: segment,
            target: bounds,
            start: points[start],
            end: points[end]
          });
          continue;
        }
        const targetSegments = _boundSegments(target, bounds);
        for (const tgt of targetSegments) {
          const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
          const fillSources = _boundSegment(segment, points, subBounds);
          for (const fillSource of fillSources) {
            parts.push({
              source: fillSource,
              target: tgt,
              start: {
                [property]: _getEdge(bounds, subBounds, "start", Math.max)
              },
              end: {
                [property]: _getEdge(bounds, subBounds, "end", Math.min)
              }
            });
          }
        }
      }
      return parts;
    }
    function _getBounds(property, first, last, loop) {
      if (loop) {
        return;
      }
      let start = first[property];
      let end = last[property];
      if (property === "angle") {
        start = _normalizeAngle(start);
        end = _normalizeAngle(end);
      }
      return {
        property,
        start,
        end
      };
    }
    function _pointsFromSegments(boundary, line) {
      const { x = null, y = null } = boundary || {};
      const linePoints = line.points;
      const points = [];
      line.segments.forEach(({ start, end }) => {
        end = _findSegmentEnd(start, end, linePoints);
        const first = linePoints[start];
        const last = linePoints[end];
        if (y !== null) {
          points.push({
            x: first.x,
            y
          });
          points.push({
            x: last.x,
            y
          });
        } else if (x !== null) {
          points.push({
            x,
            y: first.y
          });
          points.push({
            x,
            y: last.y
          });
        }
      });
      return points;
    }
    function _findSegmentEnd(start, end, points) {
      for (; end > start; end--) {
        const point = points[end];
        if (!isNaN(point.x) && !isNaN(point.y)) {
          break;
        }
      }
      return end;
    }
    function _getEdge(a, b, prop, fn) {
      if (a && b) {
        return fn(a[prop], b[prop]);
      }
      return a ? a[prop] : b ? b[prop] : 0;
    }
    function _createBoundaryLine(boundary, line) {
      let points = [];
      let _loop = false;
      if (isArray(boundary)) {
        _loop = true;
        points = boundary;
      } else {
        points = _pointsFromSegments(boundary, line);
      }
      return points.length ? new LineElement({
        points,
        options: {
          tension: 0
        },
        _loop,
        _fullLoop: _loop
      }) : null;
    }
    function _shouldApplyFill(source2) {
      return source2 && source2.fill !== false;
    }
    function _resolveTarget(sources, index2, propagate) {
      const source2 = sources[index2];
      let fill2 = source2.fill;
      const visited = [
        index2
      ];
      let target;
      if (!propagate) {
        return fill2;
      }
      while (fill2 !== false && visited.indexOf(fill2) === -1) {
        if (!isNumberFinite(fill2)) {
          return fill2;
        }
        target = sources[fill2];
        if (!target) {
          return false;
        }
        if (target.visible) {
          return fill2;
        }
        visited.push(fill2);
        fill2 = target.fill;
      }
      return false;
    }
    function _decodeFill(line, index2, count) {
      const fill2 = parseFillOption(line);
      if (isObject(fill2)) {
        return isNaN(fill2.value) ? false : fill2;
      }
      let target = parseFloat(fill2);
      if (isNumberFinite(target) && Math.floor(target) === target) {
        return decodeTargetIndex(fill2[0], index2, target, count);
      }
      return [
        "origin",
        "start",
        "end",
        "stack",
        "shape"
      ].indexOf(fill2) >= 0 && fill2;
    }
    function decodeTargetIndex(firstCh, index2, target, count) {
      if (firstCh === "-" || firstCh === "+") {
        target = index2 + target;
      }
      if (target === index2 || target < 0 || target >= count) {
        return false;
      }
      return target;
    }
    function _getTargetPixel(fill2, scale) {
      let pixel = null;
      if (fill2 === "start") {
        pixel = scale.bottom;
      } else if (fill2 === "end") {
        pixel = scale.top;
      } else if (isObject(fill2)) {
        pixel = scale.getPixelForValue(fill2.value);
      } else if (scale.getBasePixel) {
        pixel = scale.getBasePixel();
      }
      return pixel;
    }
    function _getTargetValue(fill2, scale, startValue) {
      let value;
      if (fill2 === "start") {
        value = startValue;
      } else if (fill2 === "end") {
        value = scale.options.reverse ? scale.min : scale.max;
      } else if (isObject(fill2)) {
        value = fill2.value;
      } else {
        value = scale.getBaseValue();
      }
      return value;
    }
    function parseFillOption(line) {
      const options = line.options;
      const fillOption = options.fill;
      let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
      if (fill2 === void 0) {
        fill2 = !!options.backgroundColor;
      }
      if (fill2 === false || fill2 === null) {
        return false;
      }
      if (fill2 === true) {
        return "origin";
      }
      return fill2;
    }
    function _buildStackLine(source2) {
      const { scale, index: index2, line } = source2;
      const points = [];
      const segments = line.segments;
      const sourcePoints = line.points;
      const linesBelow = getLinesBelow(scale, index2);
      linesBelow.push(_createBoundaryLine({
        x: null,
        y: scale.bottom
      }, line));
      for (let i2 = 0; i2 < segments.length; i2++) {
        const segment = segments[i2];
        for (let j = segment.start; j <= segment.end; j++) {
          addPointsBelow(points, sourcePoints[j], linesBelow);
        }
      }
      return new LineElement({
        points,
        options: {}
      });
    }
    function getLinesBelow(scale, index2) {
      const below = [];
      const metas = scale.getMatchingVisibleMetas("line");
      for (let i2 = 0; i2 < metas.length; i2++) {
        const meta2 = metas[i2];
        if (meta2.index === index2) {
          break;
        }
        if (!meta2.hidden) {
          below.unshift(meta2.dataset);
        }
      }
      return below;
    }
    function addPointsBelow(points, sourcePoint, linesBelow) {
      const postponed = [];
      for (let j = 0; j < linesBelow.length; j++) {
        const line = linesBelow[j];
        const { first, last, point } = findPoint(line, sourcePoint, "x");
        if (!point || first && last) {
          continue;
        }
        if (first) {
          postponed.unshift(point);
        } else {
          points.push(point);
          if (!last) {
            break;
          }
        }
      }
      points.push(...postponed);
    }
    function findPoint(line, sourcePoint, property) {
      const point = line.interpolate(sourcePoint, property);
      if (!point) {
        return {};
      }
      const pointValue = point[property];
      const segments = line.segments;
      const linePoints = line.points;
      let first = false;
      let last = false;
      for (let i2 = 0; i2 < segments.length; i2++) {
        const segment = segments[i2];
        const firstValue = linePoints[segment.start][property];
        const lastValue = linePoints[segment.end][property];
        if (_isBetween(pointValue, firstValue, lastValue)) {
          first = pointValue === firstValue;
          last = pointValue === lastValue;
          break;
        }
      }
      return {
        first,
        last,
        point
      };
    }
    class simpleArc {
      constructor(opts) {
        this.x = opts.x;
        this.y = opts.y;
        this.radius = opts.radius;
      }
      pathSegment(ctx, bounds, opts) {
        const { x, y, radius } = this;
        bounds = bounds || {
          start: 0,
          end: TAU
        };
        ctx.arc(x, y, radius, bounds.end, bounds.start, true);
        return !opts.bounds;
      }
      interpolate(point) {
        const { x, y, radius } = this;
        const angle = point.angle;
        return {
          x: x + Math.cos(angle) * radius,
          y: y + Math.sin(angle) * radius,
          angle
        };
      }
    }
    function _getTarget(source2) {
      const { chart, fill: fill2, line } = source2;
      if (isNumberFinite(fill2)) {
        return getLineByIndex(chart, fill2);
      }
      if (fill2 === "stack") {
        return _buildStackLine(source2);
      }
      if (fill2 === "shape") {
        return true;
      }
      const boundary = computeBoundary(source2);
      if (boundary instanceof simpleArc) {
        return boundary;
      }
      return _createBoundaryLine(boundary, line);
    }
    function getLineByIndex(chart, index2) {
      const meta2 = chart.getDatasetMeta(index2);
      const visible = meta2 && chart.isDatasetVisible(index2);
      return visible ? meta2.dataset : null;
    }
    function computeBoundary(source2) {
      const scale = source2.scale || {};
      if (scale.getPointPositionForValue) {
        return computeCircularBoundary(source2);
      }
      return computeLinearBoundary(source2);
    }
    function computeLinearBoundary(source2) {
      const { scale = {}, fill: fill2 } = source2;
      const pixel = _getTargetPixel(fill2, scale);
      if (isNumberFinite(pixel)) {
        const horizontal = scale.isHorizontal();
        return {
          x: horizontal ? pixel : null,
          y: horizontal ? null : pixel
        };
      }
      return null;
    }
    function computeCircularBoundary(source2) {
      const { scale, fill: fill2 } = source2;
      const options = scale.options;
      const length = scale.getLabels().length;
      const start = options.reverse ? scale.max : scale.min;
      const value = _getTargetValue(fill2, scale, start);
      const target = [];
      if (options.grid.circular) {
        const center = scale.getPointPositionForValue(0, start);
        return new simpleArc({
          x: center.x,
          y: center.y,
          radius: scale.getDistanceFromCenterForValue(value)
        });
      }
      for (let i2 = 0; i2 < length; ++i2) {
        target.push(scale.getPointPositionForValue(i2, value));
      }
      return target;
    }
    function _drawfill(ctx, source2, area) {
      const target = _getTarget(source2);
      const { chart, index: index2, line, scale, axis } = source2;
      const lineOpts = line.options;
      const fillOption = lineOpts.fill;
      const color2 = lineOpts.backgroundColor;
      const { above = color2, below = color2 } = fillOption || {};
      const meta2 = chart.getDatasetMeta(index2);
      const clip2 = getDatasetClipArea(chart, meta2);
      if (target && line.points.length) {
        clipArea(ctx, area);
        doFill(ctx, {
          line,
          target,
          above,
          below,
          area,
          scale,
          axis,
          clip: clip2
        });
        unclipArea(ctx);
      }
    }
    function doFill(ctx, cfg) {
      const { line, target, above, below, area, scale, clip: clip2 } = cfg;
      const property = line._loop ? "angle" : cfg.axis;
      ctx.save();
      let fillColor = below;
      if (below !== above) {
        if (property === "x") {
          clipVertical(ctx, target, area.top);
          fill(ctx, {
            line,
            target,
            color: above,
            scale,
            property,
            clip: clip2
          });
          ctx.restore();
          ctx.save();
          clipVertical(ctx, target, area.bottom);
        } else if (property === "y") {
          clipHorizontal(ctx, target, area.left);
          fill(ctx, {
            line,
            target,
            color: below,
            scale,
            property,
            clip: clip2
          });
          ctx.restore();
          ctx.save();
          clipHorizontal(ctx, target, area.right);
          fillColor = above;
        }
      }
      fill(ctx, {
        line,
        target,
        color: fillColor,
        scale,
        property,
        clip: clip2
      });
      ctx.restore();
    }
    function clipVertical(ctx, target, clipY) {
      const { segments, points } = target;
      let first = true;
      let lineLoop = false;
      ctx.beginPath();
      for (const segment of segments) {
        const { start, end } = segment;
        const firstPoint = points[start];
        const lastPoint = points[_findSegmentEnd(start, end, points)];
        if (first) {
          ctx.moveTo(firstPoint.x, firstPoint.y);
          first = false;
        } else {
          ctx.lineTo(firstPoint.x, clipY);
          ctx.lineTo(firstPoint.x, firstPoint.y);
        }
        lineLoop = !!target.pathSegment(ctx, segment, {
          move: lineLoop
        });
        if (lineLoop) {
          ctx.closePath();
        } else {
          ctx.lineTo(lastPoint.x, clipY);
        }
      }
      ctx.lineTo(target.first().x, clipY);
      ctx.closePath();
      ctx.clip();
    }
    function clipHorizontal(ctx, target, clipX) {
      const { segments, points } = target;
      let first = true;
      let lineLoop = false;
      ctx.beginPath();
      for (const segment of segments) {
        const { start, end } = segment;
        const firstPoint = points[start];
        const lastPoint = points[_findSegmentEnd(start, end, points)];
        if (first) {
          ctx.moveTo(firstPoint.x, firstPoint.y);
          first = false;
        } else {
          ctx.lineTo(clipX, firstPoint.y);
          ctx.lineTo(firstPoint.x, firstPoint.y);
        }
        lineLoop = !!target.pathSegment(ctx, segment, {
          move: lineLoop
        });
        if (lineLoop) {
          ctx.closePath();
        } else {
          ctx.lineTo(clipX, lastPoint.y);
        }
      }
      ctx.lineTo(clipX, target.first().y);
      ctx.closePath();
      ctx.clip();
    }
    function fill(ctx, cfg) {
      const { line, target, property, color: color2, scale, clip: clip2 } = cfg;
      const segments = _segments(line, target, property);
      for (const { source: src, target: tgt, start, end } of segments) {
        const { style: { backgroundColor = color2 } = {} } = src;
        const notShape = target !== true;
        ctx.save();
        ctx.fillStyle = backgroundColor;
        clipBounds(ctx, scale, clip2, notShape && _getBounds(property, start, end));
        ctx.beginPath();
        const lineLoop = !!line.pathSegment(ctx, src);
        let loop;
        if (notShape) {
          if (lineLoop) {
            ctx.closePath();
          } else {
            interpolatedLineTo(ctx, target, end, property);
          }
          const targetLoop = !!target.pathSegment(ctx, tgt, {
            move: lineLoop,
            reverse: true
          });
          loop = lineLoop && targetLoop;
          if (!loop) {
            interpolatedLineTo(ctx, target, start, property);
          }
        }
        ctx.closePath();
        ctx.fill(loop ? "evenodd" : "nonzero");
        ctx.restore();
      }
    }
    function clipBounds(ctx, scale, clip2, bounds) {
      const chartArea2 = scale.chart.chartArea;
      const { property, start, end } = bounds || {};
      if (property === "x" || property === "y") {
        let left, top2, right, bottom;
        if (property === "x") {
          left = start;
          top2 = chartArea2.top;
          right = end;
          bottom = chartArea2.bottom;
        } else {
          left = chartArea2.left;
          top2 = start;
          right = chartArea2.right;
          bottom = end;
        }
        ctx.beginPath();
        if (clip2) {
          left = Math.max(left, clip2.left);
          right = Math.min(right, clip2.right);
          top2 = Math.max(top2, clip2.top);
          bottom = Math.min(bottom, clip2.bottom);
        }
        ctx.rect(left, top2, right - left, bottom - top2);
        ctx.clip();
      }
    }
    function interpolatedLineTo(ctx, target, point, property) {
      const interpolatedPoint = target.interpolate(point, property);
      if (interpolatedPoint) {
        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
      }
    }
    var index = {
      id: "filler",
      afterDatasetsUpdate(chart, _args, options) {
        const count = (chart.data.datasets || []).length;
        const sources = [];
        let meta2, i2, line, source2;
        for (i2 = 0; i2 < count; ++i2) {
          meta2 = chart.getDatasetMeta(i2);
          line = meta2.dataset;
          source2 = null;
          if (line && line.options && line instanceof LineElement) {
            source2 = {
              visible: chart.isDatasetVisible(i2),
              index: i2,
              fill: _decodeFill(line, i2, count),
              chart,
              axis: meta2.controller.options.indexAxis,
              scale: meta2.vScale,
              line
            };
          }
          meta2.$filler = source2;
          sources.push(source2);
        }
        for (i2 = 0; i2 < count; ++i2) {
          source2 = sources[i2];
          if (!source2 || source2.fill === false) {
            continue;
          }
          source2.fill = _resolveTarget(sources, i2, options.propagate);
        }
      },
      beforeDraw(chart, _args, options) {
        const draw2 = options.drawTime === "beforeDraw";
        const metasets = chart.getSortedVisibleDatasetMetas();
        const area = chart.chartArea;
        for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
          const source2 = metasets[i2].$filler;
          if (!source2) {
            continue;
          }
          source2.line.updateControlPoints(area, source2.axis);
          if (draw2 && source2.fill) {
            _drawfill(chart.ctx, source2, area);
          }
        }
      },
      beforeDatasetsDraw(chart, _args, options) {
        if (options.drawTime !== "beforeDatasetsDraw") {
          return;
        }
        const metasets = chart.getSortedVisibleDatasetMetas();
        for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
          const source2 = metasets[i2].$filler;
          if (_shouldApplyFill(source2)) {
            _drawfill(chart.ctx, source2, chart.chartArea);
          }
        }
      },
      beforeDatasetDraw(chart, args, options) {
        const source2 = args.meta.$filler;
        if (!_shouldApplyFill(source2) || options.drawTime !== "beforeDatasetDraw") {
          return;
        }
        _drawfill(chart.ctx, source2, chart.chartArea);
      },
      defaults: {
        propagate: true,
        drawTime: "beforeDatasetDraw"
      }
    };
    const getBoxSize = (labelOpts, fontSize) => {
      let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
      if (labelOpts.usePointStyle) {
        boxHeight = Math.min(boxHeight, fontSize);
        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
      }
      return {
        boxWidth,
        boxHeight,
        itemHeight: Math.max(fontSize, boxHeight)
      };
    };
    const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
    class Legend extends Element {
      constructor(config2) {
        super();
        this._added = false;
        this.legendHitBoxes = [];
        this._hoveredItem = null;
        this.doughnutMode = false;
        this.chart = config2.chart;
        this.options = config2.options;
        this.ctx = config2.ctx;
        this.legendItems = void 0;
        this.columnSizes = void 0;
        this.lineWidths = void 0;
        this.maxHeight = void 0;
        this.maxWidth = void 0;
        this.top = void 0;
        this.bottom = void 0;
        this.left = void 0;
        this.right = void 0;
        this.height = void 0;
        this.width = void 0;
        this._margins = void 0;
        this.position = void 0;
        this.weight = void 0;
        this.fullSize = void 0;
      }
      update(maxWidth, maxHeight, margins) {
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins;
        this.setDimensions();
        this.buildLabels();
        this.fit();
      }
      setDimensions() {
        if (this.isHorizontal()) {
          this.width = this.maxWidth;
          this.left = this._margins.left;
          this.right = this.width;
        } else {
          this.height = this.maxHeight;
          this.top = this._margins.top;
          this.bottom = this.height;
        }
      }
      buildLabels() {
        const labelOpts = this.options.labels || {};
        let legendItems = callback(labelOpts.generateLabels, [
          this.chart
        ], this) || [];
        if (labelOpts.filter) {
          legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
        }
        if (labelOpts.sort) {
          legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
        }
        if (this.options.reverse) {
          legendItems.reverse();
        }
        this.legendItems = legendItems;
      }
      fit() {
        const { options, ctx } = this;
        if (!options.display) {
          this.width = this.height = 0;
          return;
        }
        const labelOpts = options.labels;
        const labelFont = toFont(labelOpts.font);
        const fontSize = labelFont.size;
        const titleHeight = this._computeTitleHeight();
        const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
        let width, height;
        ctx.font = labelFont.string;
        if (this.isHorizontal()) {
          width = this.maxWidth;
          height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
        } else {
          height = this.maxHeight;
          width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
        }
        this.width = Math.min(width, options.maxWidth || this.maxWidth);
        this.height = Math.min(height, options.maxHeight || this.maxHeight);
      }
      _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
        const { ctx, maxWidth, options: { labels: { padding } } } = this;
        const hitboxes = this.legendHitBoxes = [];
        const lineWidths = this.lineWidths = [
          0
        ];
        const lineHeight = itemHeight + padding;
        let totalHeight = titleHeight;
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        let row = -1;
        let top2 = -lineHeight;
        this.legendItems.forEach((legendItem2, i2) => {
          const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem2.text).width;
          if (i2 === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
            totalHeight += lineHeight;
            lineWidths[lineWidths.length - (i2 > 0 ? 0 : 1)] = 0;
            top2 += lineHeight;
            row++;
          }
          hitboxes[i2] = {
            left: 0,
            top: top2,
            row,
            width: itemWidth,
            height: itemHeight
          };
          lineWidths[lineWidths.length - 1] += itemWidth + padding;
        });
        return totalHeight;
      }
      _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
        const { ctx, maxHeight, options: { labels: { padding } } } = this;
        const hitboxes = this.legendHitBoxes = [];
        const columnSizes = this.columnSizes = [];
        const heightLimit = maxHeight - titleHeight;
        let totalWidth = padding;
        let currentColWidth = 0;
        let currentColHeight = 0;
        let left = 0;
        let col = 0;
        this.legendItems.forEach((legendItem2, i2) => {
          const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem2, _itemHeight);
          if (i2 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
            totalWidth += currentColWidth + padding;
            columnSizes.push({
              width: currentColWidth,
              height: currentColHeight
            });
            left += currentColWidth + padding;
            col++;
            currentColWidth = currentColHeight = 0;
          }
          hitboxes[i2] = {
            left,
            top: currentColHeight,
            col,
            width: itemWidth,
            height: itemHeight
          };
          currentColWidth = Math.max(currentColWidth, itemWidth);
          currentColHeight += itemHeight + padding;
        });
        totalWidth += currentColWidth;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        return totalWidth;
      }
      adjustHitBoxes() {
        if (!this.options.display) {
          return;
        }
        const titleHeight = this._computeTitleHeight();
        const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
        const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
        if (this.isHorizontal()) {
          let row = 0;
          let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
          for (const hitbox of hitboxes) {
            if (row !== hitbox.row) {
              row = hitbox.row;
              left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
            }
            hitbox.top += this.top + titleHeight + padding;
            hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
            left += hitbox.width + padding;
          }
        } else {
          let col = 0;
          let top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
          for (const hitbox of hitboxes) {
            if (hitbox.col !== col) {
              col = hitbox.col;
              top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
            }
            hitbox.top = top2;
            hitbox.left += this.left + padding;
            hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
            top2 += hitbox.height + padding;
          }
        }
      }
      isHorizontal() {
        return this.options.position === "top" || this.options.position === "bottom";
      }
      draw() {
        if (this.options.display) {
          const ctx = this.ctx;
          clipArea(ctx, this);
          this._draw();
          unclipArea(ctx);
        }
      }
      _draw() {
        const { options: opts, columnSizes, lineWidths, ctx } = this;
        const { align, labels: labelOpts } = opts;
        const defaultColor = defaults$2.color;
        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
        const labelFont = toFont(labelOpts.font);
        const { padding } = labelOpts;
        const fontSize = labelFont.size;
        const halfFontSize = fontSize / 2;
        let cursor2;
        this.drawTitle();
        ctx.textAlign = rtlHelper.textAlign("left");
        ctx.textBaseline = "middle";
        ctx.lineWidth = 0.5;
        ctx.font = labelFont.string;
        const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
        const drawLegendBox = function(x, y, legendItem2) {
          if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
            return;
          }
          ctx.save();
          const lineWidth = valueOrDefault(legendItem2.lineWidth, 1);
          ctx.fillStyle = valueOrDefault(legendItem2.fillStyle, defaultColor);
          ctx.lineCap = valueOrDefault(legendItem2.lineCap, "butt");
          ctx.lineDashOffset = valueOrDefault(legendItem2.lineDashOffset, 0);
          ctx.lineJoin = valueOrDefault(legendItem2.lineJoin, "miter");
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = valueOrDefault(legendItem2.strokeStyle, defaultColor);
          ctx.setLineDash(valueOrDefault(legendItem2.lineDash, []));
          if (labelOpts.usePointStyle) {
            const drawOptions = {
              radius: boxHeight * Math.SQRT2 / 2,
              pointStyle: legendItem2.pointStyle,
              rotation: legendItem2.rotation,
              borderWidth: lineWidth
            };
            const centerX = rtlHelper.xPlus(x, boxWidth / 2);
            const centerY = y + halfFontSize;
            drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
          } else {
            const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
            const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
            const borderRadius = toTRBLCorners(legendItem2.borderRadius);
            ctx.beginPath();
            if (Object.values(borderRadius).some((v) => v !== 0)) {
              addRoundedRectPath(ctx, {
                x: xBoxLeft,
                y: yBoxTop,
                w: boxWidth,
                h: boxHeight,
                radius: borderRadius
              });
            } else {
              ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
            }
            ctx.fill();
            if (lineWidth !== 0) {
              ctx.stroke();
            }
          }
          ctx.restore();
        };
        const fillText = function(x, y, legendItem2) {
          renderText(ctx, legendItem2.text, x, y + itemHeight / 2, labelFont, {
            strikethrough: legendItem2.hidden,
            textAlign: rtlHelper.textAlign(legendItem2.textAlign)
          });
        };
        const isHorizontal = this.isHorizontal();
        const titleHeight = this._computeTitleHeight();
        if (isHorizontal) {
          cursor2 = {
            x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
            y: this.top + padding + titleHeight,
            line: 0
          };
        } else {
          cursor2 = {
            x: this.left + padding,
            y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
            line: 0
          };
        }
        overrideTextDirection(this.ctx, opts.textDirection);
        const lineHeight = itemHeight + padding;
        this.legendItems.forEach((legendItem2, i2) => {
          ctx.strokeStyle = legendItem2.fontColor;
          ctx.fillStyle = legendItem2.fontColor;
          const textWidth = ctx.measureText(legendItem2.text).width;
          const textAlign = rtlHelper.textAlign(legendItem2.textAlign || (legendItem2.textAlign = labelOpts.textAlign));
          const width = boxWidth + halfFontSize + textWidth;
          let x = cursor2.x;
          let y = cursor2.y;
          rtlHelper.setWidth(this.width);
          if (isHorizontal) {
            if (i2 > 0 && x + width + padding > this.right) {
              y = cursor2.y += lineHeight;
              cursor2.line++;
              x = cursor2.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor2.line]);
            }
          } else if (i2 > 0 && y + lineHeight > this.bottom) {
            x = cursor2.x = x + columnSizes[cursor2.line].width + padding;
            cursor2.line++;
            y = cursor2.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor2.line].height);
          }
          const realX = rtlHelper.x(x);
          drawLegendBox(realX, y, legendItem2);
          x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
          fillText(rtlHelper.x(x), y, legendItem2);
          if (isHorizontal) {
            cursor2.x += width + padding;
          } else if (typeof legendItem2.text !== "string") {
            const fontLineHeight = labelFont.lineHeight;
            cursor2.y += calculateLegendItemHeight(legendItem2, fontLineHeight) + padding;
          } else {
            cursor2.y += lineHeight;
          }
        });
        restoreTextDirection(this.ctx, opts.textDirection);
      }
      drawTitle() {
        const opts = this.options;
        const titleOpts = opts.title;
        const titleFont = toFont(titleOpts.font);
        const titlePadding = toPadding(titleOpts.padding);
        if (!titleOpts.display) {
          return;
        }
        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
        const ctx = this.ctx;
        const position = titleOpts.position;
        const halfFontSize = titleFont.size / 2;
        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
        let y;
        let left = this.left;
        let maxWidth = this.width;
        if (this.isHorizontal()) {
          maxWidth = Math.max(...this.lineWidths);
          y = this.top + topPaddingPlusHalfFontSize;
          left = _alignStartEnd(opts.align, left, this.right - maxWidth);
        } else {
          const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
          y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
        }
        const x = _alignStartEnd(position, left, left + maxWidth);
        ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
        ctx.textBaseline = "middle";
        ctx.strokeStyle = titleOpts.color;
        ctx.fillStyle = titleOpts.color;
        ctx.font = titleFont.string;
        renderText(ctx, titleOpts.text, x, y, titleFont);
      }
      _computeTitleHeight() {
        const titleOpts = this.options.title;
        const titleFont = toFont(titleOpts.font);
        const titlePadding = toPadding(titleOpts.padding);
        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
      }
      _getLegendItemAt(x, y) {
        let i2, hitBox, lh;
        if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
          lh = this.legendHitBoxes;
          for (i2 = 0; i2 < lh.length; ++i2) {
            hitBox = lh[i2];
            if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
              return this.legendItems[i2];
            }
          }
        }
        return null;
      }
      handleEvent(e) {
        const opts = this.options;
        if (!isListened(e.type, opts)) {
          return;
        }
        const hoveredItem = this._getLegendItemAt(e.x, e.y);
        if (e.type === "mousemove" || e.type === "mouseout") {
          const previous = this._hoveredItem;
          const sameItem = itemsEqual(previous, hoveredItem);
          if (previous && !sameItem) {
            callback(opts.onLeave, [
              e,
              previous,
              this
            ], this);
          }
          this._hoveredItem = hoveredItem;
          if (hoveredItem && !sameItem) {
            callback(opts.onHover, [
              e,
              hoveredItem,
              this
            ], this);
          }
        } else if (hoveredItem) {
          callback(opts.onClick, [
            e,
            hoveredItem,
            this
          ], this);
        }
      }
    }
    function calculateItemSize(boxWidth, labelFont, ctx, legendItem2, _itemHeight) {
      const itemWidth = calculateItemWidth(legendItem2, boxWidth, labelFont, ctx);
      const itemHeight = calculateItemHeight(_itemHeight, legendItem2, labelFont.lineHeight);
      return {
        itemWidth,
        itemHeight
      };
    }
    function calculateItemWidth(legendItem2, boxWidth, labelFont, ctx) {
      let legendItemText = legendItem2.text;
      if (legendItemText && typeof legendItemText !== "string") {
        legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
      }
      return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
    }
    function calculateItemHeight(_itemHeight, legendItem2, fontLineHeight) {
      let itemHeight = _itemHeight;
      if (typeof legendItem2.text !== "string") {
        itemHeight = calculateLegendItemHeight(legendItem2, fontLineHeight);
      }
      return itemHeight;
    }
    function calculateLegendItemHeight(legendItem2, fontLineHeight) {
      const labelHeight = legendItem2.text ? legendItem2.text.length : 0;
      return fontLineHeight * labelHeight;
    }
    function isListened(type, opts) {
      if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
        return true;
      }
      if (opts.onClick && (type === "click" || type === "mouseup")) {
        return true;
      }
      return false;
    }
    var plugin_legend = {
      id: "legend",
      _element: Legend,
      start(chart, _args, options) {
        const legend = chart.legend = new Legend({
          ctx: chart.ctx,
          options,
          chart
        });
        layouts.configure(chart, legend, options);
        layouts.addBox(chart, legend);
      },
      stop(chart) {
        layouts.removeBox(chart, chart.legend);
        delete chart.legend;
      },
      beforeUpdate(chart, _args, options) {
        const legend = chart.legend;
        layouts.configure(chart, legend, options);
        legend.options = options;
      },
      afterUpdate(chart) {
        const legend = chart.legend;
        legend.buildLabels();
        legend.adjustHitBoxes();
      },
      afterEvent(chart, args) {
        if (!args.replay) {
          chart.legend.handleEvent(args.event);
        }
      },
      defaults: {
        display: true,
        position: "top",
        align: "center",
        fullSize: true,
        reverse: false,
        weight: 1e3,
        onClick(e, legendItem2, legend) {
          const index2 = legendItem2.datasetIndex;
          const ci = legend.chart;
          if (ci.isDatasetVisible(index2)) {
            ci.hide(index2);
            legendItem2.hidden = true;
          } else {
            ci.show(index2);
            legendItem2.hidden = false;
          }
        },
        onHover: null,
        onLeave: null,
        labels: {
          color: (ctx) => ctx.chart.options.color,
          boxWidth: 40,
          padding: 10,
          generateLabels(chart) {
            const datasets = chart.data.datasets;
            const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
            return chart._getSortedDatasetMetas().map((meta2) => {
              const style = meta2.controller.getStyle(usePointStyle ? 0 : void 0);
              const borderWidth = toPadding(style.borderWidth);
              return {
                text: datasets[meta2.index].label,
                fillStyle: style.backgroundColor,
                fontColor: color2,
                hidden: !meta2.visible,
                lineCap: style.borderCapStyle,
                lineDash: style.borderDash,
                lineDashOffset: style.borderDashOffset,
                lineJoin: style.borderJoinStyle,
                lineWidth: (borderWidth.width + borderWidth.height) / 4,
                strokeStyle: style.borderColor,
                pointStyle: pointStyle || style.pointStyle,
                rotation: style.rotation,
                textAlign: textAlign || style.textAlign,
                borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
                datasetIndex: meta2.index
              };
            }, this);
          }
        },
        title: {
          color: (ctx) => ctx.chart.options.color,
          display: false,
          position: "center",
          text: ""
        }
      },
      descriptors: {
        _scriptable: (name2) => !name2.startsWith("on"),
        labels: {
          _scriptable: (name2) => ![
            "generateLabels",
            "filter",
            "sort"
          ].includes(name2)
        }
      }
    };
    class Title extends Element {
      constructor(config2) {
        super();
        this.chart = config2.chart;
        this.options = config2.options;
        this.ctx = config2.ctx;
        this._padding = void 0;
        this.top = void 0;
        this.bottom = void 0;
        this.left = void 0;
        this.right = void 0;
        this.width = void 0;
        this.height = void 0;
        this.position = void 0;
        this.weight = void 0;
        this.fullSize = void 0;
      }
      update(maxWidth, maxHeight) {
        const opts = this.options;
        this.left = 0;
        this.top = 0;
        if (!opts.display) {
          this.width = this.height = this.right = this.bottom = 0;
          return;
        }
        this.width = this.right = maxWidth;
        this.height = this.bottom = maxHeight;
        const lineCount = isArray(opts.text) ? opts.text.length : 1;
        this._padding = toPadding(opts.padding);
        const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
        if (this.isHorizontal()) {
          this.height = textSize;
        } else {
          this.width = textSize;
        }
      }
      isHorizontal() {
        const pos = this.options.position;
        return pos === "top" || pos === "bottom";
      }
      _drawArgs(offset) {
        const { top: top2, left, bottom, right, options } = this;
        const align = options.align;
        let rotation = 0;
        let maxWidth, titleX, titleY;
        if (this.isHorizontal()) {
          titleX = _alignStartEnd(align, left, right);
          titleY = top2 + offset;
          maxWidth = right - left;
        } else {
          if (options.position === "left") {
            titleX = left + offset;
            titleY = _alignStartEnd(align, bottom, top2);
            rotation = PI * -0.5;
          } else {
            titleX = right - offset;
            titleY = _alignStartEnd(align, top2, bottom);
            rotation = PI * 0.5;
          }
          maxWidth = bottom - top2;
        }
        return {
          titleX,
          titleY,
          maxWidth,
          rotation
        };
      }
      draw() {
        const ctx = this.ctx;
        const opts = this.options;
        if (!opts.display) {
          return;
        }
        const fontOpts = toFont(opts.font);
        const lineHeight = fontOpts.lineHeight;
        const offset = lineHeight / 2 + this._padding.top;
        const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
        renderText(ctx, opts.text, 0, 0, fontOpts, {
          color: opts.color,
          maxWidth,
          rotation,
          textAlign: _toLeftRightCenter(opts.align),
          textBaseline: "middle",
          translation: [
            titleX,
            titleY
          ]
        });
      }
    }
    function createTitle(chart, titleOpts) {
      const title2 = new Title({
        ctx: chart.ctx,
        options: titleOpts,
        chart
      });
      layouts.configure(chart, title2, titleOpts);
      layouts.addBox(chart, title2);
      chart.titleBlock = title2;
    }
    var plugin_title = {
      id: "title",
      _element: Title,
      start(chart, _args, options) {
        createTitle(chart, options);
      },
      stop(chart) {
        const titleBlock = chart.titleBlock;
        layouts.removeBox(chart, titleBlock);
        delete chart.titleBlock;
      },
      beforeUpdate(chart, _args, options) {
        const title2 = chart.titleBlock;
        layouts.configure(chart, title2, options);
        title2.options = options;
      },
      defaults: {
        align: "center",
        display: false,
        font: {
          weight: "bold"
        },
        fullSize: true,
        padding: 10,
        position: "top",
        text: "",
        weight: 2e3
      },
      defaultRoutes: {
        color: "color"
      },
      descriptors: {
        _scriptable: true,
        _indexable: false
      }
    };
    const positioners = {
      average(items) {
        if (!items.length) {
          return false;
        }
        let i2, len;
        let xSet = /* @__PURE__ */ new Set();
        let y = 0;
        let count = 0;
        for (i2 = 0, len = items.length; i2 < len; ++i2) {
          const el = items[i2].element;
          if (el && el.hasValue()) {
            const pos = el.tooltipPosition();
            xSet.add(pos.x);
            y += pos.y;
            ++count;
          }
        }
        if (count === 0 || xSet.size === 0) {
          return false;
        }
        const xAverage = [
          ...xSet
        ].reduce((a, b) => a + b) / xSet.size;
        return {
          x: xAverage,
          y: y / count
        };
      },
      nearest(items, eventPosition) {
        if (!items.length) {
          return false;
        }
        let x = eventPosition.x;
        let y = eventPosition.y;
        let minDistance = Number.POSITIVE_INFINITY;
        let i2, len, nearestElement;
        for (i2 = 0, len = items.length; i2 < len; ++i2) {
          const el = items[i2].element;
          if (el && el.hasValue()) {
            const center = el.getCenterPoint();
            const d = distanceBetweenPoints(eventPosition, center);
            if (d < minDistance) {
              minDistance = d;
              nearestElement = el;
            }
          }
        }
        if (nearestElement) {
          const tp = nearestElement.tooltipPosition();
          x = tp.x;
          y = tp.y;
        }
        return {
          x,
          y
        };
      }
    };
    function pushOrConcat(base2, toPush) {
      if (toPush) {
        if (isArray(toPush)) {
          Array.prototype.push.apply(base2, toPush);
        } else {
          base2.push(toPush);
        }
      }
      return base2;
    }
    function splitNewlines(str) {
      if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
        return str.split("\n");
      }
      return str;
    }
    function createTooltipItem(chart, item) {
      const { element, datasetIndex, index: index2 } = item;
      const controller = chart.getDatasetMeta(datasetIndex).controller;
      const { label, value } = controller.getLabelAndValue(index2);
      return {
        chart,
        label,
        parsed: controller.getParsed(index2),
        raw: chart.data.datasets[datasetIndex].data[index2],
        formattedValue: value,
        dataset: controller.getDataset(),
        dataIndex: index2,
        datasetIndex,
        element
      };
    }
    function getTooltipSize(tooltip, options) {
      const ctx = tooltip.chart.ctx;
      const { body, footer: footer2, title: title2 } = tooltip;
      const { boxWidth, boxHeight } = options;
      const bodyFont = toFont(options.bodyFont);
      const titleFont = toFont(options.titleFont);
      const footerFont = toFont(options.footerFont);
      const titleLineCount = title2.length;
      const footerLineCount = footer2.length;
      const bodyLineItemCount = body.length;
      const padding = toPadding(options.padding);
      let height = padding.height;
      let width = 0;
      let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
      combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
      if (titleLineCount) {
        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
      }
      if (combinedBodyLength) {
        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
      }
      if (footerLineCount) {
        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
      }
      let widthPadding = 0;
      const maxLineWidth = function(line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
      };
      ctx.save();
      ctx.font = titleFont.string;
      each(tooltip.title, maxLineWidth);
      ctx.font = bodyFont.string;
      each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
      widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
      each(body, (bodyItem) => {
        each(bodyItem.before, maxLineWidth);
        each(bodyItem.lines, maxLineWidth);
        each(bodyItem.after, maxLineWidth);
      });
      widthPadding = 0;
      ctx.font = footerFont.string;
      each(tooltip.footer, maxLineWidth);
      ctx.restore();
      width += padding.width;
      return {
        width,
        height
      };
    }
    function determineYAlign(chart, size) {
      const { y, height } = size;
      if (y < height / 2) {
        return "top";
      } else if (y > chart.height - height / 2) {
        return "bottom";
      }
      return "center";
    }
    function doesNotFitWithAlign(xAlign, chart, options, size) {
      const { x, width } = size;
      const caret = options.caretSize + options.caretPadding;
      if (xAlign === "left" && x + width + caret > chart.width) {
        return true;
      }
      if (xAlign === "right" && x - width - caret < 0) {
        return true;
      }
    }
    function determineXAlign(chart, options, size, yAlign) {
      const { x, width } = size;
      const { width: chartWidth, chartArea: { left, right } } = chart;
      let xAlign = "center";
      if (yAlign === "center") {
        xAlign = x <= (left + right) / 2 ? "left" : "right";
      } else if (x <= width / 2) {
        xAlign = "left";
      } else if (x >= chartWidth - width / 2) {
        xAlign = "right";
      }
      if (doesNotFitWithAlign(xAlign, chart, options, size)) {
        xAlign = "center";
      }
      return xAlign;
    }
    function determineAlignment(chart, options, size) {
      const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
      return {
        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
        yAlign
      };
    }
    function alignX(size, xAlign) {
      let { x, width } = size;
      if (xAlign === "right") {
        x -= width;
      } else if (xAlign === "center") {
        x -= width / 2;
      }
      return x;
    }
    function alignY(size, yAlign, paddingAndSize) {
      let { y, height } = size;
      if (yAlign === "top") {
        y += paddingAndSize;
      } else if (yAlign === "bottom") {
        y -= height + paddingAndSize;
      } else {
        y -= height / 2;
      }
      return y;
    }
    function getBackgroundPoint(options, size, alignment, chart) {
      const { caretSize, caretPadding, cornerRadius } = options;
      const { xAlign, yAlign } = alignment;
      const paddingAndSize = caretSize + caretPadding;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
      let x = alignX(size, xAlign);
      const y = alignY(size, yAlign, paddingAndSize);
      if (yAlign === "center") {
        if (xAlign === "left") {
          x += paddingAndSize;
        } else if (xAlign === "right") {
          x -= paddingAndSize;
        }
      } else if (xAlign === "left") {
        x -= Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x += Math.max(topRight, bottomRight) + caretSize;
      }
      return {
        x: _limitValue(x, 0, chart.width - size.width),
        y: _limitValue(y, 0, chart.height - size.height)
      };
    }
    function getAlignedX(tooltip, align, options) {
      const padding = toPadding(options.padding);
      return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
    }
    function getBeforeAfterBodyLines(callback2) {
      return pushOrConcat([], splitNewlines(callback2));
    }
    function createTooltipContext(parent, tooltip, tooltipItems) {
      return createContext(parent, {
        tooltip,
        tooltipItems,
        type: "tooltip"
      });
    }
    function overrideCallbacks(callbacks, context) {
      const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
      return override ? callbacks.override(override) : callbacks;
    }
    const defaultCallbacks = {
      beforeTitle: noop,
      title(tooltipItems) {
        if (tooltipItems.length > 0) {
          const item = tooltipItems[0];
          const labels = item.chart.data.labels;
          const labelCount = labels ? labels.length : 0;
          if (this && this.options && this.options.mode === "dataset") {
            return item.dataset.label || "";
          } else if (item.label) {
            return item.label;
          } else if (labelCount > 0 && item.dataIndex < labelCount) {
            return labels[item.dataIndex];
          }
        }
        return "";
      },
      afterTitle: noop,
      beforeBody: noop,
      beforeLabel: noop,
      label(tooltipItem) {
        if (this && this.options && this.options.mode === "dataset") {
          return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || "";
        if (label) {
          label += ": ";
        }
        const value = tooltipItem.formattedValue;
        if (!isNullOrUndef(value)) {
          label += value;
        }
        return label;
      },
      labelColor(tooltipItem) {
        const meta2 = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta2.controller.getStyle(tooltipItem.dataIndex);
        return {
          borderColor: options.borderColor,
          backgroundColor: options.backgroundColor,
          borderWidth: options.borderWidth,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderRadius: 0
        };
      },
      labelTextColor() {
        return this.options.bodyColor;
      },
      labelPointStyle(tooltipItem) {
        const meta2 = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta2.controller.getStyle(tooltipItem.dataIndex);
        return {
          pointStyle: options.pointStyle,
          rotation: options.rotation
        };
      },
      afterLabel: noop,
      afterBody: noop,
      beforeFooter: noop,
      footer: noop,
      afterFooter: noop
    };
    function invokeCallbackWithFallback(callbacks, name2, ctx, arg) {
      const result = callbacks[name2].call(ctx, arg);
      if (typeof result === "undefined") {
        return defaultCallbacks[name2].call(ctx, arg);
      }
      return result;
    }
    class Tooltip extends Element {
      constructor(config2) {
        super();
        this.opacity = 0;
        this._active = [];
        this._eventPosition = void 0;
        this._size = void 0;
        this._cachedAnimations = void 0;
        this._tooltipItems = [];
        this.$animations = void 0;
        this.$context = void 0;
        this.chart = config2.chart;
        this.options = config2.options;
        this.dataPoints = void 0;
        this.title = void 0;
        this.beforeBody = void 0;
        this.body = void 0;
        this.afterBody = void 0;
        this.footer = void 0;
        this.xAlign = void 0;
        this.yAlign = void 0;
        this.x = void 0;
        this.y = void 0;
        this.height = void 0;
        this.width = void 0;
        this.caretX = void 0;
        this.caretY = void 0;
        this.labelColors = void 0;
        this.labelPointStyles = void 0;
        this.labelTextColors = void 0;
      }
      initialize(options) {
        this.options = options;
        this._cachedAnimations = void 0;
        this.$context = void 0;
      }
      _resolveAnimations() {
        const cached = this._cachedAnimations;
        if (cached) {
          return cached;
        }
        const chart = this.chart;
        const options = this.options.setContext(this.getContext());
        const opts = options.enabled && chart.options.animation && options.animations;
        const animations = new Animations(this.chart, opts);
        if (opts._cacheable) {
          this._cachedAnimations = Object.freeze(animations);
        }
        return animations;
      }
      getContext() {
        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
      }
      getTitle(context, options) {
        const { callbacks } = options;
        const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
        const title2 = invokeCallbackWithFallback(callbacks, "title", this, context);
        const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title2));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
      }
      getBeforeBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
      }
      getBody(tooltipItems, options) {
        const { callbacks } = options;
        const bodyItems = [];
        each(tooltipItems, (context) => {
          const bodyItem = {
            before: [],
            lines: [],
            after: []
          };
          const scoped = overrideCallbacks(callbacks, context);
          pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
          pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
          pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
          bodyItems.push(bodyItem);
        });
        return bodyItems;
      }
      getAfterBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
      }
      getFooter(tooltipItems, options) {
        const { callbacks } = options;
        const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
        const footer2 = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
        const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer2));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
      }
      _createItems(options) {
        const active = this._active;
        const data = this.chart.data;
        const labelColors = [];
        const labelPointStyles = [];
        const labelTextColors = [];
        let tooltipItems = [];
        let i2, len;
        for (i2 = 0, len = active.length; i2 < len; ++i2) {
          tooltipItems.push(createTooltipItem(this.chart, active[i2]));
        }
        if (options.filter) {
          tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
        }
        if (options.itemSort) {
          tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
        }
        each(tooltipItems, (context) => {
          const scoped = overrideCallbacks(options.callbacks, context);
          labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
          labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
          labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
        });
        this.labelColors = labelColors;
        this.labelPointStyles = labelPointStyles;
        this.labelTextColors = labelTextColors;
        this.dataPoints = tooltipItems;
        return tooltipItems;
      }
      update(changed, replay) {
        const options = this.options.setContext(this.getContext());
        const active = this._active;
        let properties;
        let tooltipItems = [];
        if (!active.length) {
          if (this.opacity !== 0) {
            properties = {
              opacity: 0
            };
          }
        } else {
          const position = positioners[options.position].call(this, active, this._eventPosition);
          tooltipItems = this._createItems(options);
          this.title = this.getTitle(tooltipItems, options);
          this.beforeBody = this.getBeforeBody(tooltipItems, options);
          this.body = this.getBody(tooltipItems, options);
          this.afterBody = this.getAfterBody(tooltipItems, options);
          this.footer = this.getFooter(tooltipItems, options);
          const size = this._size = getTooltipSize(this, options);
          const positionAndSize = Object.assign({}, position, size);
          const alignment = determineAlignment(this.chart, options, positionAndSize);
          const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
          this.xAlign = alignment.xAlign;
          this.yAlign = alignment.yAlign;
          properties = {
            opacity: 1,
            x: backgroundPoint.x,
            y: backgroundPoint.y,
            width: size.width,
            height: size.height,
            caretX: position.x,
            caretY: position.y
          };
        }
        this._tooltipItems = tooltipItems;
        this.$context = void 0;
        if (properties) {
          this._resolveAnimations().update(this, properties);
        }
        if (changed && options.external) {
          options.external.call(this, {
            chart: this.chart,
            tooltip: this,
            replay
          });
        }
      }
      drawCaret(tooltipPoint, ctx, size, options) {
        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
      }
      getCaretPosition(tooltipPoint, size, options) {
        const { xAlign, yAlign } = this;
        const { caretSize, cornerRadius } = options;
        const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
        const { x: ptX, y: ptY } = tooltipPoint;
        const { width, height } = size;
        let x1, x2, x3, y1, y2, y3;
        if (yAlign === "center") {
          y2 = ptY + height / 2;
          if (xAlign === "left") {
            x1 = ptX;
            x2 = x1 - caretSize;
            y1 = y2 + caretSize;
            y3 = y2 - caretSize;
          } else {
            x1 = ptX + width;
            x2 = x1 + caretSize;
            y1 = y2 - caretSize;
            y3 = y2 + caretSize;
          }
          x3 = x1;
        } else {
          if (xAlign === "left") {
            x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
          } else if (xAlign === "right") {
            x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
          } else {
            x2 = this.caretX;
          }
          if (yAlign === "top") {
            y1 = ptY;
            y2 = y1 - caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else {
            y1 = ptY + height;
            y2 = y1 + caretSize;
            x1 = x2 + caretSize;
            x3 = x2 - caretSize;
          }
          y3 = y1;
        }
        return {
          x1,
          x2,
          x3,
          y1,
          y2,
          y3
        };
      }
      drawTitle(pt, ctx, options) {
        const title2 = this.title;
        const length = title2.length;
        let titleFont, titleSpacing, i2;
        if (length) {
          const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
          pt.x = getAlignedX(this, options.titleAlign, options);
          ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
          ctx.textBaseline = "middle";
          titleFont = toFont(options.titleFont);
          titleSpacing = options.titleSpacing;
          ctx.fillStyle = options.titleColor;
          ctx.font = titleFont.string;
          for (i2 = 0; i2 < length; ++i2) {
            ctx.fillText(title2[i2], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
            pt.y += titleFont.lineHeight + titleSpacing;
            if (i2 + 1 === length) {
              pt.y += options.titleMarginBottom - titleSpacing;
            }
          }
        }
      }
      _drawColorBox(ctx, pt, i2, rtlHelper, options) {
        const labelColor = this.labelColors[i2];
        const labelPointStyle = this.labelPointStyles[i2];
        const { boxHeight, boxWidth } = options;
        const bodyFont = toFont(options.bodyFont);
        const colorX = getAlignedX(this, "left", options);
        const rtlColorX = rtlHelper.x(colorX);
        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
        const colorY = pt.y + yOffSet;
        if (options.usePointStyle) {
          const drawOptions = {
            radius: Math.min(boxWidth, boxHeight) / 2,
            pointStyle: labelPointStyle.pointStyle,
            rotation: labelPointStyle.rotation,
            borderWidth: 1
          };
          const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
          const centerY = colorY + boxHeight / 2;
          ctx.strokeStyle = options.multiKeyBackground;
          ctx.fillStyle = options.multiKeyBackground;
          drawPoint(ctx, drawOptions, centerX, centerY);
          ctx.strokeStyle = labelColor.borderColor;
          ctx.fillStyle = labelColor.backgroundColor;
          drawPoint(ctx, drawOptions, centerX, centerY);
        } else {
          ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
          ctx.strokeStyle = labelColor.borderColor;
          ctx.setLineDash(labelColor.borderDash || []);
          ctx.lineDashOffset = labelColor.borderDashOffset || 0;
          const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
          const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
          const borderRadius = toTRBLCorners(labelColor.borderRadius);
          if (Object.values(borderRadius).some((v) => v !== 0)) {
            ctx.beginPath();
            ctx.fillStyle = options.multiKeyBackground;
            addRoundedRectPath(ctx, {
              x: outerX,
              y: colorY,
              w: boxWidth,
              h: boxHeight,
              radius: borderRadius
            });
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = labelColor.backgroundColor;
            ctx.beginPath();
            addRoundedRectPath(ctx, {
              x: innerX,
              y: colorY + 1,
              w: boxWidth - 2,
              h: boxHeight - 2,
              radius: borderRadius
            });
            ctx.fill();
          } else {
            ctx.fillStyle = options.multiKeyBackground;
            ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
            ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
            ctx.fillStyle = labelColor.backgroundColor;
            ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
          }
        }
        ctx.fillStyle = this.labelTextColors[i2];
      }
      drawBody(pt, ctx, options) {
        const { body } = this;
        const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
        const bodyFont = toFont(options.bodyFont);
        let bodyLineHeight = bodyFont.lineHeight;
        let xLinePadding = 0;
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        const fillLineOfText = function(line) {
          ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
          pt.y += bodyLineHeight + bodySpacing;
        };
        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
        let bodyItem, textColor, lines, i2, j, ilen, jlen;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = "middle";
        ctx.font = bodyFont.string;
        pt.x = getAlignedX(this, bodyAlignForCalculation, options);
        ctx.fillStyle = options.bodyColor;
        each(this.beforeBody, fillLineOfText);
        xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
        for (i2 = 0, ilen = body.length; i2 < ilen; ++i2) {
          bodyItem = body[i2];
          textColor = this.labelTextColors[i2];
          ctx.fillStyle = textColor;
          each(bodyItem.before, fillLineOfText);
          lines = bodyItem.lines;
          if (displayColors && lines.length) {
            this._drawColorBox(ctx, pt, i2, rtlHelper, options);
            bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
          }
          for (j = 0, jlen = lines.length; j < jlen; ++j) {
            fillLineOfText(lines[j]);
            bodyLineHeight = bodyFont.lineHeight;
          }
          each(bodyItem.after, fillLineOfText);
        }
        xLinePadding = 0;
        bodyLineHeight = bodyFont.lineHeight;
        each(this.afterBody, fillLineOfText);
        pt.y -= bodySpacing;
      }
      drawFooter(pt, ctx, options) {
        const footer2 = this.footer;
        const length = footer2.length;
        let footerFont, i2;
        if (length) {
          const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
          pt.x = getAlignedX(this, options.footerAlign, options);
          pt.y += options.footerMarginTop;
          ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
          ctx.textBaseline = "middle";
          footerFont = toFont(options.footerFont);
          ctx.fillStyle = options.footerColor;
          ctx.font = footerFont.string;
          for (i2 = 0; i2 < length; ++i2) {
            ctx.fillText(footer2[i2], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
            pt.y += footerFont.lineHeight + options.footerSpacing;
          }
        }
      }
      drawBackground(pt, ctx, tooltipSize, options) {
        const { xAlign, yAlign } = this;
        const { x, y } = pt;
        const { width, height } = tooltipSize;
        const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.beginPath();
        ctx.moveTo(x + topLeft, y);
        if (yAlign === "top") {
          this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + width - topRight, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
        if (yAlign === "center" && xAlign === "right") {
          this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + width, y + height - bottomRight);
        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
        if (yAlign === "bottom") {
          this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + bottomLeft, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
        if (yAlign === "center" && xAlign === "left") {
          this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x, y + topLeft);
        ctx.quadraticCurveTo(x, y, x + topLeft, y);
        ctx.closePath();
        ctx.fill();
        if (options.borderWidth > 0) {
          ctx.stroke();
        }
      }
      _updateAnimationTarget(options) {
        const chart = this.chart;
        const anims = this.$animations;
        const animX = anims && anims.x;
        const animY = anims && anims.y;
        if (animX || animY) {
          const position = positioners[options.position].call(this, this._active, this._eventPosition);
          if (!position) {
            return;
          }
          const size = this._size = getTooltipSize(this, options);
          const positionAndSize = Object.assign({}, position, this._size);
          const alignment = determineAlignment(chart, options, positionAndSize);
          const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
          if (animX._to !== point.x || animY._to !== point.y) {
            this.xAlign = alignment.xAlign;
            this.yAlign = alignment.yAlign;
            this.width = size.width;
            this.height = size.height;
            this.caretX = position.x;
            this.caretY = position.y;
            this._resolveAnimations().update(this, point);
          }
        }
      }
      _willRender() {
        return !!this.opacity;
      }
      draw(ctx) {
        const options = this.options.setContext(this.getContext());
        let opacity = this.opacity;
        if (!opacity) {
          return;
        }
        this._updateAnimationTarget(options);
        const tooltipSize = {
          width: this.width,
          height: this.height
        };
        const pt = {
          x: this.x,
          y: this.y
        };
        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
        const padding = toPadding(options.padding);
        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
        if (options.enabled && hasTooltipContent) {
          ctx.save();
          ctx.globalAlpha = opacity;
          this.drawBackground(pt, ctx, tooltipSize, options);
          overrideTextDirection(ctx, options.textDirection);
          pt.y += padding.top;
          this.drawTitle(pt, ctx, options);
          this.drawBody(pt, ctx, options);
          this.drawFooter(pt, ctx, options);
          restoreTextDirection(ctx, options.textDirection);
          ctx.restore();
        }
      }
      getActiveElements() {
        return this._active || [];
      }
      setActiveElements(activeElements, eventPosition) {
        const lastActive = this._active;
        const active = activeElements.map(({ datasetIndex, index: index2 }) => {
          const meta2 = this.chart.getDatasetMeta(datasetIndex);
          if (!meta2) {
            throw new Error("Cannot find a dataset at index " + datasetIndex);
          }
          return {
            datasetIndex,
            element: meta2.data[index2],
            index: index2
          };
        });
        const changed = !_elementsEqual(lastActive, active);
        const positionChanged = this._positionChanged(active, eventPosition);
        if (changed || positionChanged) {
          this._active = active;
          this._eventPosition = eventPosition;
          this._ignoreReplayEvents = true;
          this.update(true);
        }
      }
      handleEvent(e, replay, inChartArea = true) {
        if (replay && this._ignoreReplayEvents) {
          return false;
        }
        this._ignoreReplayEvents = false;
        const options = this.options;
        const lastActive = this._active || [];
        const active = this._getActiveElements(e, lastActive, replay, inChartArea);
        const positionChanged = this._positionChanged(active, e);
        const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
        if (changed) {
          this._active = active;
          if (options.enabled || options.external) {
            this._eventPosition = {
              x: e.x,
              y: e.y
            };
            this.update(true, replay);
          }
        }
        return changed;
      }
      _getActiveElements(e, lastActive, replay, inChartArea) {
        const options = this.options;
        if (e.type === "mouseout") {
          return [];
        }
        if (!inChartArea) {
          return lastActive.filter((i2) => this.chart.data.datasets[i2.datasetIndex] && this.chart.getDatasetMeta(i2.datasetIndex).controller.getParsed(i2.index) !== void 0);
        }
        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
        if (options.reverse) {
          active.reverse();
        }
        return active;
      }
      _positionChanged(active, e) {
        const { caretX, caretY, options } = this;
        const position = positioners[options.position].call(this, active, e);
        return position !== false && (caretX !== position.x || caretY !== position.y);
      }
    }
    __publicField(Tooltip, "positioners", positioners);
    var plugin_tooltip = {
      id: "tooltip",
      _element: Tooltip,
      positioners,
      afterInit(chart, _args, options) {
        if (options) {
          chart.tooltip = new Tooltip({
            chart,
            options
          });
        }
      },
      beforeUpdate(chart, _args, options) {
        if (chart.tooltip) {
          chart.tooltip.initialize(options);
        }
      },
      reset(chart, _args, options) {
        if (chart.tooltip) {
          chart.tooltip.initialize(options);
        }
      },
      afterDraw(chart) {
        const tooltip = chart.tooltip;
        if (tooltip && tooltip._willRender()) {
          const args = {
            tooltip
          };
          if (chart.notifyPlugins("beforeTooltipDraw", __spreadProps(__spreadValues({}, args), {
            cancelable: true
          })) === false) {
            return;
          }
          tooltip.draw(chart.ctx);
          chart.notifyPlugins("afterTooltipDraw", args);
        }
      },
      afterEvent(chart, args) {
        if (chart.tooltip) {
          const useFinalPosition = args.replay;
          if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
            args.changed = true;
          }
        }
      },
      defaults: {
        enabled: true,
        external: null,
        position: "average",
        backgroundColor: "rgba(0,0,0,0.8)",
        titleColor: "#fff",
        titleFont: {
          weight: "bold"
        },
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleAlign: "left",
        bodyColor: "#fff",
        bodySpacing: 2,
        bodyFont: {},
        bodyAlign: "left",
        footerColor: "#fff",
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFont: {
          weight: "bold"
        },
        footerAlign: "left",
        padding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        boxHeight: (ctx, opts) => opts.bodyFont.size,
        boxWidth: (ctx, opts) => opts.bodyFont.size,
        multiKeyBackground: "#fff",
        displayColors: true,
        boxPadding: 0,
        borderColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        animation: {
          duration: 400,
          easing: "easeOutQuart"
        },
        animations: {
          numbers: {
            type: "number",
            properties: [
              "x",
              "y",
              "width",
              "height",
              "caretX",
              "caretY"
            ]
          },
          opacity: {
            easing: "linear",
            duration: 200
          }
        },
        callbacks: defaultCallbacks
      },
      defaultRoutes: {
        bodyFont: "font",
        footerFont: "font",
        titleFont: "font"
      },
      descriptors: {
        _scriptable: (name2) => name2 !== "filter" && name2 !== "itemSort" && name2 !== "external",
        _indexable: false,
        callbacks: {
          _scriptable: false,
          _indexable: false
        },
        animation: {
          _fallback: false
        },
        animations: {
          _fallback: "animation"
        }
      },
      additionalOptionScopes: [
        "interaction"
      ]
    };
    const addIfString = (labels, raw, index2, addedLabels) => {
      if (typeof raw === "string") {
        index2 = labels.push(raw) - 1;
        addedLabels.unshift({
          index: index2,
          label: raw
        });
      } else if (isNaN(raw)) {
        index2 = null;
      }
      return index2;
    };
    function findOrAddLabel(labels, raw, index2, addedLabels) {
      const first = labels.indexOf(raw);
      if (first === -1) {
        return addIfString(labels, raw, index2, addedLabels);
      }
      const last = labels.lastIndexOf(raw);
      return first !== last ? index2 : first;
    }
    const validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
    function _getLabelForValue(value) {
      const labels = this.getLabels();
      if (value >= 0 && value < labels.length) {
        return labels[value];
      }
      return value;
    }
    class CategoryScale extends Scale {
      constructor(cfg) {
        super(cfg);
        this._startValue = void 0;
        this._valueRange = 0;
        this._addedLabels = [];
      }
      init(scaleOptions) {
        const added = this._addedLabels;
        if (added.length) {
          const labels = this.getLabels();
          for (const { index: index2, label } of added) {
            if (labels[index2] === label) {
              labels.splice(index2, 1);
            }
          }
          this._addedLabels = [];
        }
        super.init(scaleOptions);
      }
      parse(raw, index2) {
        if (isNullOrUndef(raw)) {
          return null;
        }
        const labels = this.getLabels();
        index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
        return validIndex(index2, labels.length - 1);
      }
      determineDataLimits() {
        const { minDefined, maxDefined } = this.getUserBounds();
        let { min, max } = this.getMinMax(true);
        if (this.options.bounds === "ticks") {
          if (!minDefined) {
            min = 0;
          }
          if (!maxDefined) {
            max = this.getLabels().length - 1;
          }
        }
        this.min = min;
        this.max = max;
      }
      buildTicks() {
        const min = this.min;
        const max = this.max;
        const offset = this.options.offset;
        const ticks = [];
        let labels = this.getLabels();
        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
        this._startValue = this.min - (offset ? 0.5 : 0);
        for (let value = min; value <= max; value++) {
          ticks.push({
            value
          });
        }
        return ticks;
      }
      getLabelForValue(value) {
        return _getLabelForValue.call(this, value);
      }
      configure() {
        super.configure();
        if (!this.isHorizontal()) {
          this._reversePixels = !this._reversePixels;
        }
      }
      getPixelForValue(value) {
        if (typeof value !== "number") {
          value = this.parse(value);
        }
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
      }
      getPixelForTick(index2) {
        const ticks = this.ticks;
        if (index2 < 0 || index2 > ticks.length - 1) {
          return null;
        }
        return this.getPixelForValue(ticks[index2].value);
      }
      getValueForPixel(pixel) {
        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
      }
      getBasePixel() {
        return this.bottom;
      }
    }
    __publicField(CategoryScale, "id", "category");
    __publicField(CategoryScale, "defaults", {
      ticks: {
        callback: _getLabelForValue
      }
    });
    function generateTicks$1(generationOptions, dataRange) {
      const ticks = [];
      const MIN_SPACING = 1e-14;
      const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
      const unit = step || 1;
      const maxSpaces = maxTicks - 1;
      const { min: rmin, max: rmax } = dataRange;
      const minDefined = !isNullOrUndef(min);
      const maxDefined = !isNullOrUndef(max);
      const countDefined = !isNullOrUndef(count);
      const minSpacing = (rmax - rmin) / (maxDigits + 1);
      let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
      let factor, niceMin, niceMax, numSpaces;
      if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
        return [
          {
            value: rmin
          },
          {
            value: rmax
          }
        ];
      }
      numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
      if (numSpaces > maxSpaces) {
        spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
      }
      if (!isNullOrUndef(precision)) {
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
      }
      if (bounds === "ticks") {
        niceMin = Math.floor(rmin / spacing) * spacing;
        niceMax = Math.ceil(rmax / spacing) * spacing;
      } else {
        niceMin = rmin;
        niceMax = rmax;
      }
      if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
        spacing = (max - min) / numSpaces;
        niceMin = min;
        niceMax = max;
      } else if (countDefined) {
        niceMin = minDefined ? min : niceMin;
        niceMax = maxDefined ? max : niceMax;
        numSpaces = count - 1;
        spacing = (niceMax - niceMin) / numSpaces;
      } else {
        numSpaces = (niceMax - niceMin) / spacing;
        if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
          numSpaces = Math.round(numSpaces);
        } else {
          numSpaces = Math.ceil(numSpaces);
        }
      }
      const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
      factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
      niceMin = Math.round(niceMin * factor) / factor;
      niceMax = Math.round(niceMax * factor) / factor;
      let j = 0;
      if (minDefined) {
        if (includeBounds && niceMin !== min) {
          ticks.push({
            value: min
          });
          if (niceMin < min) {
            j++;
          }
          if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
            j++;
          }
        } else if (niceMin < min) {
          j++;
        }
      }
      for (; j < numSpaces; ++j) {
        const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
        if (maxDefined && tickValue > max) {
          break;
        }
        ticks.push({
          value: tickValue
        });
      }
      if (maxDefined && includeBounds && niceMax !== max) {
        if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
          ticks[ticks.length - 1].value = max;
        } else {
          ticks.push({
            value: max
          });
        }
      } else if (!maxDefined || niceMax === max) {
        ticks.push({
          value: niceMax
        });
      }
      return ticks;
    }
    function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
      const rad = toRadians(minRotation);
      const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
      const length = 0.75 * minSpacing * ("" + value).length;
      return Math.min(minSpacing / ratio, length);
    }
    class LinearScaleBase extends Scale {
      constructor(cfg) {
        super(cfg);
        this.start = void 0;
        this.end = void 0;
        this._startValue = void 0;
        this._endValue = void 0;
        this._valueRange = 0;
      }
      parse(raw, index2) {
        if (isNullOrUndef(raw)) {
          return null;
        }
        if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
          return null;
        }
        return +raw;
      }
      handleTickRangeOptions() {
        const { beginAtZero } = this.options;
        const { minDefined, maxDefined } = this.getUserBounds();
        let { min, max } = this;
        const setMin = (v) => min = minDefined ? min : v;
        const setMax = (v) => max = maxDefined ? max : v;
        if (beginAtZero) {
          const minSign = sign(min);
          const maxSign = sign(max);
          if (minSign < 0 && maxSign < 0) {
            setMax(0);
          } else if (minSign > 0 && maxSign > 0) {
            setMin(0);
          }
        }
        if (min === max) {
          let offset = max === 0 ? 1 : Math.abs(max * 0.05);
          setMax(max + offset);
          if (!beginAtZero) {
            setMin(min - offset);
          }
        }
        this.min = min;
        this.max = max;
      }
      getTickLimit() {
        const tickOpts = this.options.ticks;
        let { maxTicksLimit, stepSize } = tickOpts;
        let maxTicks;
        if (stepSize) {
          maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
          if (maxTicks > 1e3) {
            console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
            maxTicks = 1e3;
          }
        } else {
          maxTicks = this.computeTickLimit();
          maxTicksLimit = maxTicksLimit || 11;
        }
        if (maxTicksLimit) {
          maxTicks = Math.min(maxTicksLimit, maxTicks);
        }
        return maxTicks;
      }
      computeTickLimit() {
        return Number.POSITIVE_INFINITY;
      }
      buildTicks() {
        const opts = this.options;
        const tickOpts = opts.ticks;
        let maxTicks = this.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        const numericGeneratorOptions = {
          maxTicks,
          bounds: opts.bounds,
          min: opts.min,
          max: opts.max,
          precision: tickOpts.precision,
          step: tickOpts.stepSize,
          count: tickOpts.count,
          maxDigits: this._maxDigits(),
          horizontal: this.isHorizontal(),
          minRotation: tickOpts.minRotation || 0,
          includeBounds: tickOpts.includeBounds !== false
        };
        const dataRange = this._range || this;
        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
        if (opts.bounds === "ticks") {
          _setMinAndMaxByKey(ticks, this, "value");
        }
        if (opts.reverse) {
          ticks.reverse();
          this.start = this.max;
          this.end = this.min;
        } else {
          this.start = this.min;
          this.end = this.max;
        }
        return ticks;
      }
      configure() {
        const ticks = this.ticks;
        let start = this.min;
        let end = this.max;
        super.configure();
        if (this.options.offset && ticks.length) {
          const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
          start -= offset;
          end += offset;
        }
        this._startValue = start;
        this._endValue = end;
        this._valueRange = end - start;
      }
      getLabelForValue(value) {
        return formatNumber$1(value, this.chart.options.locale, this.options.ticks.format);
      }
    }
    class LinearScale extends LinearScaleBase {
      determineDataLimits() {
        const { min, max } = this.getMinMax(true);
        this.min = isNumberFinite(min) ? min : 0;
        this.max = isNumberFinite(max) ? max : 1;
        this.handleTickRangeOptions();
      }
      computeTickLimit() {
        const horizontal = this.isHorizontal();
        const length = horizontal ? this.width : this.height;
        const minRotation = toRadians(this.options.ticks.minRotation);
        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
        const tickFont = this._resolveTickFontOptions(0);
        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
      }
      getPixelForValue(value) {
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
      }
      getValueForPixel(pixel) {
        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
      }
    }
    __publicField(LinearScale, "id", "linear");
    __publicField(LinearScale, "defaults", {
      ticks: {
        callback: Ticks.formatters.numeric
      }
    });
    const INTERVALS = {
      millisecond: {
        common: true,
        size: 1,
        steps: 1e3
      },
      second: {
        common: true,
        size: 1e3,
        steps: 60
      },
      minute: {
        common: true,
        size: 6e4,
        steps: 60
      },
      hour: {
        common: true,
        size: 36e5,
        steps: 24
      },
      day: {
        common: true,
        size: 864e5,
        steps: 30
      },
      week: {
        common: false,
        size: 6048e5,
        steps: 4
      },
      month: {
        common: true,
        size: 2628e6,
        steps: 12
      },
      quarter: {
        common: false,
        size: 7884e6,
        steps: 4
      },
      year: {
        common: true,
        size: 3154e7
      }
    };
    const UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
    function sorter(a, b) {
      return a - b;
    }
    function parse(scale, input) {
      if (isNullOrUndef(input)) {
        return null;
      }
      const adapter = scale._adapter;
      const { parser: parser2, round: round2, isoWeekday } = scale._parseOpts;
      let value = input;
      if (typeof parser2 === "function") {
        value = parser2(value);
      }
      if (!isNumberFinite(value)) {
        value = typeof parser2 === "string" ? adapter.parse(value, parser2) : adapter.parse(value);
      }
      if (value === null) {
        return null;
      }
      if (round2) {
        value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
      }
      return +value;
    }
    function determineUnitForAutoTicks(minUnit, min, max, capacity) {
      const ilen = UNITS.length;
      for (let i2 = UNITS.indexOf(minUnit); i2 < ilen - 1; ++i2) {
        const interval = INTERVALS[UNITS[i2]];
        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
          return UNITS[i2];
        }
      }
      return UNITS[ilen - 1];
    }
    function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
      for (let i2 = UNITS.length - 1; i2 >= UNITS.indexOf(minUnit); i2--) {
        const unit = UNITS[i2];
        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
          return unit;
        }
      }
      return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
    }
    function determineMajorUnit(unit) {
      for (let i2 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i2 < ilen; ++i2) {
        if (INTERVALS[UNITS[i2]].common) {
          return UNITS[i2];
        }
      }
    }
    function addTick(ticks, time, timestamps) {
      if (!timestamps) {
        ticks[time] = true;
      } else if (timestamps.length) {
        const { lo, hi } = _lookup(timestamps, time);
        const timestamp2 = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
        ticks[timestamp2] = true;
      }
    }
    function setMajorTicks(scale, ticks, map2, majorUnit) {
      const adapter = scale._adapter;
      const first = +adapter.startOf(ticks[0].value, majorUnit);
      const last = ticks[ticks.length - 1].value;
      let major, index2;
      for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
        index2 = map2[major];
        if (index2 >= 0) {
          ticks[index2].major = true;
        }
      }
      return ticks;
    }
    function ticksFromTimestamps(scale, values, majorUnit) {
      const ticks = [];
      const map2 = {};
      const ilen = values.length;
      let i2, value;
      for (i2 = 0; i2 < ilen; ++i2) {
        value = values[i2];
        map2[value] = i2;
        ticks.push({
          value,
          major: false
        });
      }
      return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
    }
    class TimeScale extends Scale {
      constructor(props) {
        super(props);
        this._cache = {
          data: [],
          labels: [],
          all: []
        };
        this._unit = "day";
        this._majorUnit = void 0;
        this._offsets = {};
        this._normalized = false;
        this._parseOpts = void 0;
      }
      init(scaleOpts, opts = {}) {
        const time = scaleOpts.time || (scaleOpts.time = {});
        const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
        adapter.init(opts);
        mergeIf(time.displayFormats, adapter.formats());
        this._parseOpts = {
          parser: time.parser,
          round: time.round,
          isoWeekday: time.isoWeekday
        };
        super.init(scaleOpts);
        this._normalized = opts.normalized;
      }
      parse(raw, index2) {
        if (raw === void 0) {
          return null;
        }
        return parse(this, raw);
      }
      beforeLayout() {
        super.beforeLayout();
        this._cache = {
          data: [],
          labels: [],
          all: []
        };
      }
      determineDataLimits() {
        const options = this.options;
        const adapter = this._adapter;
        const unit = options.time.unit || "day";
        let { min, max, minDefined, maxDefined } = this.getUserBounds();
        function _applyBounds(bounds) {
          if (!minDefined && !isNaN(bounds.min)) {
            min = Math.min(min, bounds.min);
          }
          if (!maxDefined && !isNaN(bounds.max)) {
            max = Math.max(max, bounds.max);
          }
        }
        if (!minDefined || !maxDefined) {
          _applyBounds(this._getLabelBounds());
          if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
            _applyBounds(this.getMinMax(false));
          }
        }
        min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
        max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
        this.min = Math.min(min, max - 1);
        this.max = Math.max(min + 1, max);
      }
      _getLabelBounds() {
        const arr = this.getLabelTimestamps();
        let min = Number.POSITIVE_INFINITY;
        let max = Number.NEGATIVE_INFINITY;
        if (arr.length) {
          min = arr[0];
          max = arr[arr.length - 1];
        }
        return {
          min,
          max
        };
      }
      buildTicks() {
        const options = this.options;
        const timeOpts = options.time;
        const tickOpts = options.ticks;
        const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
        if (options.bounds === "ticks" && timestamps.length) {
          this.min = this._userMin || timestamps[0];
          this.max = this._userMax || timestamps[timestamps.length - 1];
        }
        const min = this.min;
        const max = this.max;
        const ticks = _filterBetween(timestamps, min, max);
        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
        this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
        this.initOffsets(timestamps);
        if (options.reverse) {
          ticks.reverse();
        }
        return ticksFromTimestamps(this, ticks, this._majorUnit);
      }
      afterAutoSkip() {
        if (this.options.offsetAfterAutoskip) {
          this.initOffsets(this.ticks.map((tick) => +tick.value));
        }
      }
      initOffsets(timestamps = []) {
        let start = 0;
        let end = 0;
        let first, last;
        if (this.options.offset && timestamps.length) {
          first = this.getDecimalForValue(timestamps[0]);
          if (timestamps.length === 1) {
            start = 1 - first;
          } else {
            start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
          }
          last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
          if (timestamps.length === 1) {
            end = last;
          } else {
            end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
          }
        }
        const limit = timestamps.length < 3 ? 0.5 : 0.25;
        start = _limitValue(start, 0, limit);
        end = _limitValue(end, 0, limit);
        this._offsets = {
          start,
          end,
          factor: 1 / (start + 1 + end)
        };
      }
      _generate() {
        const adapter = this._adapter;
        const min = this.min;
        const max = this.max;
        const options = this.options;
        const timeOpts = options.time;
        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
        const stepSize = valueOrDefault(options.ticks.stepSize, 1);
        const weekday = minor === "week" ? timeOpts.isoWeekday : false;
        const hasWeekday = isNumber(weekday) || weekday === true;
        const ticks = {};
        let first = min;
        let time, count;
        if (hasWeekday) {
          first = +adapter.startOf(first, "isoWeek", weekday);
        }
        first = +adapter.startOf(first, hasWeekday ? "day" : minor);
        if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
          throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
        }
        const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
        for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
          addTick(ticks, time, timestamps);
        }
        if (time === max || options.bounds === "ticks" || count === 1) {
          addTick(ticks, time, timestamps);
        }
        return Object.keys(ticks).sort(sorter).map((x) => +x);
      }
      getLabelForValue(value) {
        const adapter = this._adapter;
        const timeOpts = this.options.time;
        if (timeOpts.tooltipFormat) {
          return adapter.format(value, timeOpts.tooltipFormat);
        }
        return adapter.format(value, timeOpts.displayFormats.datetime);
      }
      format(value, format) {
        const options = this.options;
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const fmt = format || formats[unit];
        return this._adapter.format(value, fmt);
      }
      _tickFormatFunction(time, index2, ticks, format) {
        const options = this.options;
        const formatter = options.ticks.callback;
        if (formatter) {
          return callback(formatter, [
            time,
            index2,
            ticks
          ], this);
        }
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const majorUnit = this._majorUnit;
        const minorFormat = unit && formats[unit];
        const majorFormat = majorUnit && formats[majorUnit];
        const tick = ticks[index2];
        const major = majorUnit && majorFormat && tick && tick.major;
        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
      }
      generateTickLabels(ticks) {
        let i2, ilen, tick;
        for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
          tick = ticks[i2];
          tick.label = this._tickFormatFunction(tick.value, i2, ticks);
        }
      }
      getDecimalForValue(value) {
        return value === null ? NaN : (value - this.min) / (this.max - this.min);
      }
      getPixelForValue(value) {
        const offsets = this._offsets;
        const pos = this.getDecimalForValue(value);
        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
      }
      getValueForPixel(pixel) {
        const offsets = this._offsets;
        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return this.min + pos * (this.max - this.min);
      }
      _getLabelSize(label) {
        const ticksOpts = this.options.ticks;
        const tickLabelWidth = this.ctx.measureText(label).width;
        const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
        const cosRotation = Math.cos(angle);
        const sinRotation = Math.sin(angle);
        const tickFontSize = this._resolveTickFontOptions(0).size;
        return {
          w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
          h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
        };
      }
      _getLabelCapacity(exampleTime) {
        const timeOpts = this.options.time;
        const displayFormats = timeOpts.displayFormats;
        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
          exampleTime
        ], this._majorUnit), format);
        const size = this._getLabelSize(exampleLabel);
        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
        return capacity > 0 ? capacity : 1;
      }
      getDataTimestamps() {
        let timestamps = this._cache.data || [];
        let i2, ilen;
        if (timestamps.length) {
          return timestamps;
        }
        const metas = this.getMatchingVisibleMetas();
        if (this._normalized && metas.length) {
          return this._cache.data = metas[0].controller.getAllParsedValues(this);
        }
        for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
          timestamps = timestamps.concat(metas[i2].controller.getAllParsedValues(this));
        }
        return this._cache.data = this.normalize(timestamps);
      }
      getLabelTimestamps() {
        const timestamps = this._cache.labels || [];
        let i2, ilen;
        if (timestamps.length) {
          return timestamps;
        }
        const labels = this.getLabels();
        for (i2 = 0, ilen = labels.length; i2 < ilen; ++i2) {
          timestamps.push(parse(this, labels[i2]));
        }
        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
      }
      normalize(values) {
        return _arrayUnique(values.sort(sorter));
      }
    }
    __publicField(TimeScale, "id", "time");
    __publicField(TimeScale, "defaults", {
      bounds: "data",
      adapters: {},
      time: {
        parser: false,
        unit: false,
        round: false,
        isoWeekday: false,
        minUnit: "millisecond",
        displayFormats: {}
      },
      ticks: {
        source: "auto",
        callback: false,
        major: {
          enabled: false
        }
      }
    });
    function interpolate(table2, val, reverse) {
      let lo = 0;
      let hi = table2.length - 1;
      let prevSource, nextSource, prevTarget, nextTarget;
      if (reverse) {
        if (val >= table2[lo].pos && val <= table2[hi].pos) {
          ({ lo, hi } = _lookupByKey(table2, "pos", val));
        }
        ({ pos: prevSource, time: prevTarget } = table2[lo]);
        ({ pos: nextSource, time: nextTarget } = table2[hi]);
      } else {
        if (val >= table2[lo].time && val <= table2[hi].time) {
          ({ lo, hi } = _lookupByKey(table2, "time", val));
        }
        ({ time: prevSource, pos: prevTarget } = table2[lo]);
        ({ time: nextSource, pos: nextTarget } = table2[hi]);
      }
      const span = nextSource - prevSource;
      return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
    }
    class TimeSeriesScale extends TimeScale {
      constructor(props) {
        super(props);
        this._table = [];
        this._minPos = void 0;
        this._tableRange = void 0;
      }
      initOffsets() {
        const timestamps = this._getTimestampsForTable();
        const table2 = this._table = this.buildLookupTable(timestamps);
        this._minPos = interpolate(table2, this.min);
        this._tableRange = interpolate(table2, this.max) - this._minPos;
        super.initOffsets(timestamps);
      }
      buildLookupTable(timestamps) {
        const { min, max } = this;
        const items = [];
        const table2 = [];
        let i2, ilen, prev, curr, next;
        for (i2 = 0, ilen = timestamps.length; i2 < ilen; ++i2) {
          curr = timestamps[i2];
          if (curr >= min && curr <= max) {
            items.push(curr);
          }
        }
        if (items.length < 2) {
          return [
            {
              time: min,
              pos: 0
            },
            {
              time: max,
              pos: 1
            }
          ];
        }
        for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
          next = items[i2 + 1];
          prev = items[i2 - 1];
          curr = items[i2];
          if (Math.round((next + prev) / 2) !== curr) {
            table2.push({
              time: curr,
              pos: i2 / (ilen - 1)
            });
          }
        }
        return table2;
      }
      _generate() {
        const min = this.min;
        const max = this.max;
        let timestamps = super.getDataTimestamps();
        if (!timestamps.includes(min) || !timestamps.length) {
          timestamps.splice(0, 0, min);
        }
        if (!timestamps.includes(max) || timestamps.length === 1) {
          timestamps.push(max);
        }
        return timestamps.sort((a, b) => a - b);
      }
      _getTimestampsForTable() {
        let timestamps = this._cache.all || [];
        if (timestamps.length) {
          return timestamps;
        }
        const data = this.getDataTimestamps();
        const label = this.getLabelTimestamps();
        if (data.length && label.length) {
          timestamps = this.normalize(data.concat(label));
        } else {
          timestamps = data.length ? data : label;
        }
        timestamps = this._cache.all = timestamps;
        return timestamps;
      }
      getDecimalForValue(value) {
        return (interpolate(this._table, value) - this._minPos) / this._tableRange;
      }
      getValueForPixel(pixel) {
        const offsets = this._offsets;
        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
      }
    }
    __publicField(TimeSeriesScale, "id", "timeseries");
    __publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
    const defaultDatasetIdKey = "label";
    function reforwardRef(ref, value) {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref) {
        ref.current = value;
      }
    }
    function setOptions(chart, nextOptions) {
      const options = chart.options;
      if (options && nextOptions) {
        Object.assign(options, nextOptions);
      }
    }
    function setLabels(currentData, nextLabels) {
      currentData.labels = nextLabels;
    }
    function setDatasets(currentData, nextDatasets, datasetIdKey = defaultDatasetIdKey) {
      const addedDatasets = [];
      currentData.datasets = nextDatasets.map((nextDataset) => {
        const currentDataset = currentData.datasets.find((dataset) => dataset[datasetIdKey] === nextDataset[datasetIdKey]);
        if (!currentDataset || !nextDataset.data || addedDatasets.includes(currentDataset)) {
          return __spreadValues({}, nextDataset);
        }
        addedDatasets.push(currentDataset);
        Object.assign(currentDataset, nextDataset);
        return currentDataset;
      });
    }
    function cloneData(data, datasetIdKey = defaultDatasetIdKey) {
      const nextData = {
        labels: [],
        datasets: []
      };
      setLabels(nextData, data.labels);
      setDatasets(nextData, data.datasets, datasetIdKey);
      return nextData;
    }
    function ChartComponent(props, ref) {
      const _a2 = props, { height = 150, width = 300, redraw = false, datasetIdKey, type, data, options, plugins = [], fallbackContent, updateMode } = _a2, canvasProps = __objRest(_a2, ["height", "width", "redraw", "datasetIdKey", "type", "data", "options", "plugins", "fallbackContent", "updateMode"]);
      const canvasRef = reactExports.useRef(null);
      const chartRef = reactExports.useRef(null);
      const renderChart = () => {
        if (!canvasRef.current) return;
        chartRef.current = new Chart$1(canvasRef.current, {
          type,
          data: cloneData(data, datasetIdKey),
          options: options && __spreadValues({}, options),
          plugins
        });
        reforwardRef(ref, chartRef.current);
      };
      const destroyChart = () => {
        reforwardRef(ref, null);
        if (chartRef.current) {
          chartRef.current.destroy();
          chartRef.current = null;
        }
      };
      reactExports.useEffect(() => {
        if (!redraw && chartRef.current && options) {
          setOptions(chartRef.current, options);
        }
      }, [
        redraw,
        options
      ]);
      reactExports.useEffect(() => {
        if (!redraw && chartRef.current) {
          setLabels(chartRef.current.config.data, data.labels);
        }
      }, [
        redraw,
        data.labels
      ]);
      reactExports.useEffect(() => {
        if (!redraw && chartRef.current && data.datasets) {
          setDatasets(chartRef.current.config.data, data.datasets, datasetIdKey);
        }
      }, [
        redraw,
        data.datasets
      ]);
      reactExports.useEffect(() => {
        if (!chartRef.current) return;
        if (redraw) {
          destroyChart();
          setTimeout(renderChart);
        } else {
          chartRef.current.update(updateMode);
        }
      }, [
        redraw,
        options,
        data.labels,
        data.datasets,
        updateMode
      ]);
      reactExports.useEffect(() => {
        if (!chartRef.current) return;
        destroyChart();
        setTimeout(renderChart);
      }, [
        type
      ]);
      reactExports.useEffect(() => {
        renderChart();
        return () => destroyChart();
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("canvas", __spreadProps(__spreadValues({
        ref: canvasRef,
        role: "img",
        height,
        width
      }, canvasProps), {
        children: fallbackContent
      }));
    }
    const Chart = /* @__PURE__ */ reactExports.forwardRef(ChartComponent);
    function createTypedChart(type, registerables) {
      Chart$1.register(registerables);
      return /* @__PURE__ */ reactExports.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Chart, __spreadProps(__spreadValues({}, props), {
        ref,
        type
      })));
    }
    const Line$1 = /* @__PURE__ */ createTypedChart("line", LineController);
    function useMediaQuery(query) {
      const [matches, setMatches] = reactExports.useState(() => {
        return window.matchMedia(query).matches;
      });
      reactExports.useEffect(() => {
        const media = window.matchMedia(query);
        const listener = (event) => {
          setMatches(event.matches);
        };
        listener({ matches: media.matches });
        media.addEventListener("change", listener);
        return () => media.removeEventListener("change", listener);
      }, [query]);
      return matches;
    }
    const container$3 = "UsagePage-module__container___nCAFc";
    const header = "UsagePage-module__header___HxnC8";
    const pageTitle$3 = "UsagePage-module__pageTitle___70rs5";
    const errorBox = "UsagePage-module__errorBox___gB8Rj";
    const hint = "UsagePage-module__hint___pUQ06";
    const loadingOverlay = "UsagePage-module__loadingOverlay___BuX9V";
    const loadingOverlayContent = "UsagePage-module__loadingOverlayContent___3vf0S";
    const loadingOverlayText = "UsagePage-module__loadingOverlayText___64YIy";
    const statsGrid = "UsagePage-module__statsGrid___Q0sW-";
    const statCard = "UsagePage-module__statCard___iCndn";
    const statValue = "UsagePage-module__statValue___duHNu";
    const statCardHeader = "UsagePage-module__statCardHeader___IbBKW";
    const statLabelGroup = "UsagePage-module__statLabelGroup___SMxKl";
    const statIconBadge = "UsagePage-module__statIconBadge___bPCTx";
    const statLabel = "UsagePage-module__statLabel___V2mir";
    const statMetaRow = "UsagePage-module__statMetaRow___VB7gR";
    const statMetaItem = "UsagePage-module__statMetaItem___YIXw2";
    const statMetaDot = "UsagePage-module__statMetaDot___daNGF";
    const statSubtle = "UsagePage-module__statSubtle___yXU7t";
    const statTrend = "UsagePage-module__statTrend___ra06-";
    const statTrendPlaceholder = "UsagePage-module__statTrendPlaceholder___oRADx";
    const sparkline = "UsagePage-module__sparkline___1tqGF";
    const apiList = "UsagePage-module__apiList___2kChf";
    const apiItem = "UsagePage-module__apiItem___cyn0u";
    const apiHeader = "UsagePage-module__apiHeader___tT8FK";
    const apiInfo = "UsagePage-module__apiInfo___OFEK-";
    const apiEndpoint = "UsagePage-module__apiEndpoint___J38DV";
    const apiStats = "UsagePage-module__apiStats___blw7G";
    const apiBadge = "UsagePage-module__apiBadge___OAqI7";
    const expandIcon = "UsagePage-module__expandIcon___5FU6h";
    const apiModels = "UsagePage-module__apiModels___eZNUp";
    const modelRow = "UsagePage-module__modelRow___ZKhXO";
    const modelName$1 = "UsagePage-module__modelName___mlOFW";
    const modelStat = "UsagePage-module__modelStat___9behg";
    const tableWrapper = "UsagePage-module__tableWrapper___Sax8l";
    const table = "UsagePage-module__table___-sWaI";
    const modelCell = "UsagePage-module__modelCell___0d7fk";
    const pricingSection = "UsagePage-module__pricingSection___jk8kk";
    const priceForm = "UsagePage-module__priceForm___OJwRe";
    const formRow = "UsagePage-module__formRow___sHXY2";
    const formField = "UsagePage-module__formField___Vf4b-";
    const select = "UsagePage-module__select___ZAWx-";
    const pricesList = "UsagePage-module__pricesList___ys67C";
    const pricesTitle = "UsagePage-module__pricesTitle___CJRmb";
    const pricesGrid = "UsagePage-module__pricesGrid___rCyGv";
    const priceItem = "UsagePage-module__priceItem___I0JbD";
    const priceInfo = "UsagePage-module__priceInfo___TteL5";
    const priceModel = "UsagePage-module__priceModel___GvFG8";
    const priceMeta = "UsagePage-module__priceMeta___V2rEi";
    const priceActions = "UsagePage-module__priceActions___2BFSQ";
    const chartWrapper = "UsagePage-module__chartWrapper___lAIqa";
    const chartLegend = "UsagePage-module__chartLegend___OA6vI";
    const legendItem = "UsagePage-module__legendItem___g2pb0";
    const legendDot = "UsagePage-module__legendDot___Ehp8J";
    const legendLabel = "UsagePage-module__legendLabel___pjtGV";
    const chartArea = "UsagePage-module__chartArea___ZykTT";
    const chartScroller = "UsagePage-module__chartScroller___AtIi0";
    const chartCanvas = "UsagePage-module__chartCanvas___NYz9z";
    const periodButtons = "UsagePage-module__periodButtons___MD8jm";
    const chartsGrid = "UsagePage-module__chartsGrid___k56wO";
    const detailsGrid = "UsagePage-module__detailsGrid___zSOOI";
    const chartLineHeader = "UsagePage-module__chartLineHeader___xPk4F";
    const chartLineList = "UsagePage-module__chartLineList___Le-PV";
    const chartLineItem = "UsagePage-module__chartLineItem___p7NYT";
    const chartLineLabel = "UsagePage-module__chartLineLabel___jA5Ww";
    const chartLineCount = "UsagePage-module__chartLineCount___yVkE2";
    const chartLineHint = "UsagePage-module__chartLineHint___v7FGv";
    const styles$3 = {
      container: container$3,
      header,
      pageTitle: pageTitle$3,
      errorBox,
      hint,
      loadingOverlay,
      loadingOverlayContent,
      loadingOverlayText,
      statsGrid,
      statCard,
      statValue,
      statCardHeader,
      statLabelGroup,
      statIconBadge,
      statLabel,
      statMetaRow,
      statMetaItem,
      statMetaDot,
      statSubtle,
      statTrend,
      statTrendPlaceholder,
      sparkline,
      apiList,
      apiItem,
      apiHeader,
      apiInfo,
      apiEndpoint,
      apiStats,
      apiBadge,
      expandIcon,
      apiModels,
      modelRow,
      modelName: modelName$1,
      modelStat,
      tableWrapper,
      table,
      modelCell,
      pricingSection,
      priceForm,
      formRow,
      formField,
      select,
      pricesList,
      pricesTitle,
      pricesGrid,
      priceItem,
      priceInfo,
      priceModel,
      priceMeta,
      priceActions,
      chartWrapper,
      chartLegend,
      legendItem,
      legendDot,
      legendLabel,
      chartArea,
      chartScroller,
      chartCanvas,
      periodButtons,
      chartsGrid,
      detailsGrid,
      chartLineHeader,
      chartLineList,
      chartLineItem,
      chartLineLabel,
      chartLineCount,
      chartLineHint
    };
    Chart$1.register(
      CategoryScale,
      LinearScale,
      PointElement,
      LineElement,
      plugin_title,
      plugin_tooltip,
      plugin_legend,
      index
    );
    function UsagePage() {
      var _a2, _b, _c, _d, _e;
      const { t: t2 } = useTranslation();
      const isMobile = useMediaQuery("(max-width: 768px)");
      const theme2 = useThemeStore((state) => state.theme);
      const isDark = theme2 === "dark";
      const [usage, setUsage] = reactExports.useState(null);
      const [loading, setLoading] = reactExports.useState(true);
      const [error2, setError] = reactExports.useState("");
      const [modelPrices, setModelPrices] = reactExports.useState({});
      const [selectedModel, setSelectedModel] = reactExports.useState("");
      const [promptPrice, setPromptPrice] = reactExports.useState("");
      const [completionPrice, setCompletionPrice] = reactExports.useState("");
      const [cachePrice, setCachePrice] = reactExports.useState("");
      const [expandedApis, setExpandedApis] = reactExports.useState(/* @__PURE__ */ new Set());
      const [requestsPeriod, setRequestsPeriod] = reactExports.useState("day");
      const [tokensPeriod, setTokensPeriod] = reactExports.useState("day");
      const [chartLines, setChartLines] = reactExports.useState(["all"]);
      const MAX_CHART_LINES = 9;
      const loadUsage = reactExports.useCallback(() => __async(null, null, function* () {
        var _a3;
        setLoading(true);
        setError("");
        try {
          const data = yield usageApi.getUsage();
          const payload = (_a3 = data == null ? void 0 : data.usage) != null ? _a3 : data;
          setUsage(payload);
        } catch (err) {
          const message2 = err instanceof Error ? err.message : t2("usage_stats.loading_error");
          setError(message2);
        } finally {
          setLoading(false);
        }
      }), [t2]);
      reactExports.useEffect(() => {
        loadUsage();
        setModelPrices(loadModelPrices());
      }, [loadUsage]);
      const tokenBreakdown = usage ? calculateTokenBreakdown(usage) : { cachedTokens: 0, reasoningTokens: 0 };
      const rateStats = usage ? calculateRecentPerMinuteRates(30, usage) : { rpm: 0, tpm: 0, requestCount: 0, tokenCount: 0 };
      const totalCost = usage ? calculateTotalCost(usage, modelPrices) : 0;
      const modelNames = usage ? getModelNamesFromUsage(usage) : [];
      const apiStats2 = usage ? getApiStats(usage, modelPrices) : [];
      const modelStats = usage ? getModelStats(usage, modelPrices) : [];
      const hasPrices = Object.keys(modelPrices).length > 0;
      const requestsChartData = reactExports.useMemo(() => {
        if (!usage) return { labels: [], datasets: [] };
        return buildChartData(usage, requestsPeriod, "requests", chartLines);
      }, [usage, requestsPeriod, chartLines]);
      const tokensChartData = reactExports.useMemo(() => {
        if (!usage) return { labels: [], datasets: [] };
        return buildChartData(usage, tokensPeriod, "tokens", chartLines);
      }, [usage, tokensPeriod, chartLines]);
      const sparklineOptions = reactExports.useMemo(
        () => ({
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, tooltip: { enabled: false } },
          scales: { x: { display: false }, y: { display: false } },
          elements: { line: { tension: 0.45 }, point: { radius: 0 } }
        }),
        []
      );
      const buildLastHourSeries = reactExports.useCallback(
        (metric) => {
          if (!usage) return { labels: [], data: [] };
          const details = collectUsageDetails(usage);
          if (!details.length) return { labels: [], data: [] };
          const windowMinutes = 60;
          const now = Date.now();
          const windowStart = now - windowMinutes * 60 * 1e3;
          const buckets = new Array(windowMinutes).fill(0);
          details.forEach((detail) => {
            const timestamp2 = Date.parse(detail.timestamp);
            if (Number.isNaN(timestamp2) || timestamp2 < windowStart) {
              return;
            }
            const minuteIndex = Math.min(
              windowMinutes - 1,
              Math.floor((timestamp2 - windowStart) / 6e4)
            );
            const increment = metric === "tokens" ? extractTotalTokens(detail) : 1;
            buckets[minuteIndex] += increment;
          });
          const labels = buckets.map((_, idx) => {
            const date = new Date(windowStart + (idx + 1) * 6e4);
            const h = date.getHours().toString().padStart(2, "0");
            const m = date.getMinutes().toString().padStart(2, "0");
            return `${h}:${m}`;
          });
          return { labels, data: buckets };
        },
        [usage]
      );
      const buildSparkline = reactExports.useCallback(
        (series, color2, backgroundColor) => {
          var _a3;
          if (loading || !((_a3 = series == null ? void 0 : series.data) == null ? void 0 : _a3.length)) {
            return null;
          }
          const sliceStart = Math.max(series.data.length - 60, 0);
          const labels = series.labels.slice(sliceStart);
          const points = series.data.slice(sliceStart);
          return {
            data: {
              labels,
              datasets: [
                {
                  data: points,
                  borderColor: color2,
                  backgroundColor,
                  fill: true,
                  tension: 0.45,
                  pointRadius: 0,
                  borderWidth: 2
                }
              ]
            }
          };
        },
        [loading]
      );
      const requestsSparkline = reactExports.useMemo(
        () => buildSparkline(buildLastHourSeries("requests"), "#3b82f6", "rgba(59, 130, 246, 0.18)"),
        [buildLastHourSeries, buildSparkline]
      );
      const tokensSparkline = reactExports.useMemo(
        () => buildSparkline(buildLastHourSeries("tokens"), "#8b5cf6", "rgba(139, 92, 246, 0.18)"),
        [buildLastHourSeries, buildSparkline]
      );
      const rpmSparkline = reactExports.useMemo(
        () => buildSparkline(buildLastHourSeries("requests"), "#22c55e", "rgba(34, 197, 94, 0.18)"),
        [buildLastHourSeries, buildSparkline]
      );
      const tpmSparkline = reactExports.useMemo(
        () => buildSparkline(buildLastHourSeries("tokens"), "#f97316", "rgba(249, 115, 22, 0.18)"),
        [buildLastHourSeries, buildSparkline]
      );
      const costSparkline = reactExports.useMemo(
        () => buildSparkline(buildLastHourSeries("tokens"), "#f59e0b", "rgba(245, 158, 11, 0.18)"),
        [buildLastHourSeries, buildSparkline]
      );
      const buildChartOptions = reactExports.useCallback(
        (period, labels) => {
          const pointRadius = isMobile && period === "hour" ? 0 : isMobile ? 2 : 4;
          const tickFontSize = isMobile ? 10 : 12;
          const maxTickLabelCount = isMobile ? period === "hour" ? 8 : 6 : period === "hour" ? 12 : 10;
          const gridColor = isDark ? "rgba(255, 255, 255, 0.06)" : "rgba(17, 24, 39, 0.06)";
          const axisBorderColor = isDark ? "rgba(255, 255, 255, 0.10)" : "rgba(17, 24, 39, 0.10)";
          const tickColor = isDark ? "rgba(255, 255, 255, 0.72)" : "rgba(17, 24, 39, 0.72)";
          const tooltipBg = isDark ? "rgba(17, 24, 39, 0.92)" : "rgba(255, 255, 255, 0.98)";
          const tooltipTitle = isDark ? "#ffffff" : "#111827";
          const tooltipBody = isDark ? "rgba(255, 255, 255, 0.86)" : "#374151";
          const tooltipBorder = isDark ? "rgba(255, 255, 255, 0.10)" : "rgba(17, 24, 39, 0.10)";
          return {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: "index",
              intersect: false
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                backgroundColor: tooltipBg,
                titleColor: tooltipTitle,
                bodyColor: tooltipBody,
                borderColor: tooltipBorder,
                borderWidth: 1,
                padding: 10,
                displayColors: true,
                usePointStyle: true
              }
            },
            scales: {
              x: {
                grid: {
                  color: gridColor,
                  drawTicks: false
                },
                border: {
                  color: axisBorderColor
                },
                ticks: {
                  color: tickColor,
                  font: { size: tickFontSize },
                  maxRotation: isMobile ? 0 : 45,
                  minRotation: isMobile ? 0 : 0,
                  autoSkip: true,
                  maxTicksLimit: maxTickLabelCount,
                  callback: (value) => {
                    const index2 = typeof value === "number" ? value : Number(value);
                    const raw = Number.isFinite(index2) && labels[index2] ? labels[index2] : typeof value === "string" ? value : "";
                    if (period === "hour") {
                      const [md, time] = raw.split(" ");
                      if (!time) return raw;
                      if (time.startsWith("00:")) {
                        return md ? [md, time] : time;
                      }
                      return time;
                    }
                    if (isMobile) {
                      const parts = raw.split("-");
                      if (parts.length === 3) {
                        return `${parts[1]}-${parts[2]}`;
                      }
                    }
                    return raw;
                  }
                }
              },
              y: {
                beginAtZero: true,
                grid: {
                  color: gridColor
                },
                border: {
                  color: axisBorderColor
                },
                ticks: {
                  color: tickColor,
                  font: { size: tickFontSize }
                }
              }
            },
            elements: {
              line: {
                tension: 0.35,
                borderWidth: isMobile ? 1.5 : 2
              },
              point: {
                borderWidth: 2,
                radius: pointRadius,
                hoverRadius: 4
              }
            }
          };
        },
        [isDark, isMobile]
      );
      const requestsChartOptions = reactExports.useMemo(
        () => buildChartOptions(requestsPeriod, requestsChartData.labels),
        [buildChartOptions, requestsPeriod, requestsChartData.labels]
      );
      const tokensChartOptions = reactExports.useMemo(
        () => buildChartOptions(tokensPeriod, tokensChartData.labels),
        [buildChartOptions, tokensPeriod, tokensChartData.labels]
      );
      const getHourChartMinWidth = reactExports.useCallback(
        (labelCount) => {
          if (!isMobile || labelCount <= 0) return void 0;
          const perPoint = 56;
          const minWidth = Math.min(labelCount * perPoint, 3e3);
          return `${minWidth}px`;
        },
        [isMobile]
      );
      const handleAddChartLine = () => {
        if (chartLines.length >= MAX_CHART_LINES) return;
        const unusedModel = modelNames.find((m) => !chartLines.includes(m));
        if (unusedModel) {
          setChartLines([...chartLines, unusedModel]);
        } else {
          setChartLines([...chartLines, "all"]);
        }
      };
      const handleRemoveChartLine = (index2) => {
        if (chartLines.length <= 1) return;
        const newLines = [...chartLines];
        newLines.splice(index2, 1);
        setChartLines(newLines);
      };
      const handleChartLineChange = (index2, value) => {
        const newLines = [...chartLines];
        newLines[index2] = value;
        setChartLines(newLines);
      };
      const handleSavePrice = () => {
        if (!selectedModel) return;
        const prompt = parseFloat(promptPrice) || 0;
        const completion = parseFloat(completionPrice) || 0;
        const cache = cachePrice.trim() === "" ? prompt : parseFloat(cachePrice) || 0;
        const newPrices = __spreadProps(__spreadValues({}, modelPrices), { [selectedModel]: { prompt, completion, cache } });
        setModelPrices(newPrices);
        saveModelPrices(newPrices);
        setSelectedModel("");
        setPromptPrice("");
        setCompletionPrice("");
        setCachePrice("");
      };
      const handleDeletePrice = (model) => {
        const newPrices = __spreadValues({}, modelPrices);
        delete newPrices[model];
        setModelPrices(newPrices);
        saveModelPrices(newPrices);
      };
      const handleEditPrice = (model) => {
        var _a3, _b2, _c2;
        const price = modelPrices[model];
        setSelectedModel(model);
        setPromptPrice(((_a3 = price == null ? void 0 : price.prompt) == null ? void 0 : _a3.toString()) || "");
        setCompletionPrice(((_b2 = price == null ? void 0 : price.completion) == null ? void 0 : _b2.toString()) || "");
        setCachePrice(((_c2 = price == null ? void 0 : price.cache) == null ? void 0 : _c2.toString()) || "");
      };
      const toggleApiExpand = (endpoint) => {
        setExpandedApis((prev) => {
          const newSet = new Set(prev);
          if (newSet.has(endpoint)) {
            newSet.delete(endpoint);
          } else {
            newSet.add(endpoint);
          }
          return newSet;
        });
      };
      const statsCards = [
        {
          key: "requests",
          label: t2("usage_stats.total_requests"),
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconSatellite, { size: 16 }),
          accent: "#3b82f6",
          accentSoft: "rgba(59, 130, 246, 0.18)",
          accentBorder: "rgba(59, 130, 246, 0.35)",
          value: loading ? "-" : ((_a2 = usage == null ? void 0 : usage.total_requests) != null ? _a2 : 0).toLocaleString(),
          meta: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$3.statMetaItem, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.statMetaDot, style: { backgroundColor: "#10b981" } }),
              t2("usage_stats.success_requests"),
              ": ",
              loading ? "-" : (_b = usage == null ? void 0 : usage.success_count) != null ? _b : 0
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$3.statMetaItem, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.statMetaDot, style: { backgroundColor: "#ef4444" } }),
              t2("usage_stats.failed_requests"),
              ": ",
              loading ? "-" : (_c = usage == null ? void 0 : usage.failure_count) != null ? _c : 0
            ] })
          ] }),
          trend: requestsSparkline
        },
        {
          key: "tokens",
          label: t2("usage_stats.total_tokens"),
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconDiamond, { size: 16 }),
          accent: "#8b5cf6",
          accentSoft: "rgba(139, 92, 246, 0.18)",
          accentBorder: "rgba(139, 92, 246, 0.35)",
          value: loading ? "-" : formatTokensInMillions((_d = usage == null ? void 0 : usage.total_tokens) != null ? _d : 0),
          meta: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$3.statMetaItem, children: [
              t2("usage_stats.cached_tokens"),
              ": ",
              loading ? "-" : formatTokensInMillions(tokenBreakdown.cachedTokens)
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$3.statMetaItem, children: [
              t2("usage_stats.reasoning_tokens"),
              ": ",
              loading ? "-" : formatTokensInMillions(tokenBreakdown.reasoningTokens)
            ] })
          ] }),
          trend: tokensSparkline
        },
        {
          key: "rpm",
          label: t2("usage_stats.rpm_30m"),
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconTimer, { size: 16 }),
          accent: "#22c55e",
          accentSoft: "rgba(34, 197, 94, 0.18)",
          accentBorder: "rgba(34, 197, 94, 0.32)",
          value: loading ? "-" : formatPerMinuteValue(rateStats.rpm),
          meta: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$3.statMetaItem, children: [
            t2("usage_stats.total_requests"),
            ": ",
            loading ? "-" : rateStats.requestCount.toLocaleString()
          ] }),
          trend: rpmSparkline
        },
        {
          key: "tpm",
          label: t2("usage_stats.tpm_30m"),
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconTrendingUp, { size: 16 }),
          accent: "#f97316",
          accentSoft: "rgba(249, 115, 22, 0.18)",
          accentBorder: "rgba(249, 115, 22, 0.32)",
          value: loading ? "-" : formatPerMinuteValue(rateStats.tpm),
          meta: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$3.statMetaItem, children: [
            t2("usage_stats.total_tokens"),
            ": ",
            loading ? "-" : formatTokensInMillions(rateStats.tokenCount)
          ] }),
          trend: tpmSparkline
        },
        {
          key: "cost",
          label: t2("usage_stats.total_cost"),
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconDollarSign, { size: 16 }),
          accent: "#f59e0b",
          accentSoft: "rgba(245, 158, 11, 0.18)",
          accentBorder: "rgba(245, 158, 11, 0.32)",
          value: loading ? "-" : hasPrices ? formatUsd(totalCost) : "--",
          meta: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$3.statMetaItem, children: [
              t2("usage_stats.total_tokens"),
              ": ",
              loading ? "-" : formatTokensInMillions((_e = usage == null ? void 0 : usage.total_tokens) != null ? _e : 0)
            ] }),
            !hasPrices && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${styles$3.statMetaItem} ${styles$3.statSubtle}`, children: t2("usage_stats.cost_need_price") })
          ] }),
          trend: hasPrices ? costSparkline : null
        }
      ];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.container, children: [
        loading && !usage && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.loadingOverlay, "aria-busy": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.loadingOverlayContent, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: 28 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.loadingOverlayText, children: t2("common.loading") })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.header, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$3.pageTitle, children: t2("usage_stats.title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "secondary",
              size: "sm",
              onClick: loadUsage,
              disabled: loading,
              children: loading ? t2("common.loading") : t2("usage_stats.refresh")
            }
          )
        ] }),
        error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.errorBox, children: error2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.statsGrid, children: statsCards.map((card) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: styles$3.statCard,
            style: {
              "--accent": card.accent,
              "--accent-soft": card.accentSoft,
              "--accent-border": card.accentBorder
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.statCardHeader, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.statLabelGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.statLabel, children: card.label }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.statIconBadge, children: card.icon })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.statValue, children: card.value }),
              card.meta && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.statMetaRow, children: card.meta }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.statTrend, children: card.trend ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line$1, { className: styles$3.sparkline, data: card.trend.data, options: sparklineOptions }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.statTrendPlaceholder }) })
            ]
          },
          card.key
        )) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Card,
          {
            title: t2("usage_stats.chart_line_actions_label"),
            extra: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.chartLineHeader, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$3.chartLineCount, children: [
                chartLines.length,
                "/",
                MAX_CHART_LINES
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "secondary",
                  size: "sm",
                  onClick: handleAddChartLine,
                  disabled: chartLines.length >= MAX_CHART_LINES,
                  children: t2("usage_stats.chart_line_add")
                }
              )
            ] }),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.chartLineList, children: chartLines.map((line, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.chartLineItem, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.chartLineLabel, children: t2(`usage_stats.chart_line_label_${index2 + 1}`) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "select",
                  {
                    value: line,
                    onChange: (e) => handleChartLineChange(index2, e.target.value),
                    className: styles$3.select,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "all", children: t2("usage_stats.chart_line_all") }),
                      modelNames.map((name2) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: name2, children: name2 }, name2))
                    ]
                  }
                ),
                chartLines.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "danger",
                    size: "sm",
                    onClick: () => handleRemoveChartLine(index2),
                    children: t2("usage_stats.chart_line_delete")
                  }
                )
              ] }, index2)) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$3.chartLineHint, children: t2("usage_stats.chart_line_hint") })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.chartsGrid, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Card,
            {
              title: t2("usage_stats.requests_trend"),
              extra: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.periodButtons, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: requestsPeriod === "hour" ? "primary" : "secondary",
                    size: "sm",
                    onClick: () => setRequestsPeriod("hour"),
                    children: t2("usage_stats.by_hour")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: requestsPeriod === "day" ? "primary" : "secondary",
                    size: "sm",
                    onClick: () => setRequestsPeriod("day"),
                    children: t2("usage_stats.by_day")
                  }
                )
              ] }),
              children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.hint, children: t2("common.loading") }) : requestsChartData.labels.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.chartWrapper, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.chartLegend, "aria-label": "Chart legend", children: requestsChartData.datasets.map((dataset, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: styles$3.legendItem,
                    title: dataset.label,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.legendDot, style: { backgroundColor: dataset.borderColor } }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.legendLabel, children: dataset.label })
                    ]
                  },
                  `${dataset.label}-${index2}`
                )) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.chartArea, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.chartScroller, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: styles$3.chartCanvas,
                    style: requestsPeriod === "hour" ? { minWidth: getHourChartMinWidth(requestsChartData.labels.length) } : void 0,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line$1, { data: requestsChartData, options: requestsChartOptions })
                  }
                ) }) })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.hint, children: t2("usage_stats.no_data") })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Card,
            {
              title: t2("usage_stats.tokens_trend"),
              extra: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.periodButtons, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: tokensPeriod === "hour" ? "primary" : "secondary",
                    size: "sm",
                    onClick: () => setTokensPeriod("hour"),
                    children: t2("usage_stats.by_hour")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: tokensPeriod === "day" ? "primary" : "secondary",
                    size: "sm",
                    onClick: () => setTokensPeriod("day"),
                    children: t2("usage_stats.by_day")
                  }
                )
              ] }),
              children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.hint, children: t2("common.loading") }) : tokensChartData.labels.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.chartWrapper, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.chartLegend, "aria-label": "Chart legend", children: tokensChartData.datasets.map((dataset, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: styles$3.legendItem,
                    title: dataset.label,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.legendDot, style: { backgroundColor: dataset.borderColor } }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.legendLabel, children: dataset.label })
                    ]
                  },
                  `${dataset.label}-${index2}`
                )) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.chartArea, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.chartScroller, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: styles$3.chartCanvas,
                    style: tokensPeriod === "hour" ? { minWidth: getHourChartMinWidth(tokensChartData.labels.length) } : void 0,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line$1, { data: tokensChartData, options: tokensChartOptions })
                  }
                ) }) })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.hint, children: t2("usage_stats.no_data") })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.detailsGrid, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { title: t2("usage_stats.api_details"), children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.hint, children: t2("common.loading") }) : apiStats2.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.apiList, children: apiStats2.map((api) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.apiItem, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: styles$3.apiHeader,
                onClick: () => toggleApiExpand(api.endpoint),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.apiInfo, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.apiEndpoint, children: api.endpoint }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.apiStats, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$3.apiBadge, children: [
                        t2("usage_stats.requests_count"),
                        ": ",
                        api.totalRequests
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$3.apiBadge, children: [
                        "Tokens: ",
                        formatTokensInMillions(api.totalTokens)
                      ] }),
                      hasPrices && api.totalCost > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$3.apiBadge, children: [
                        t2("usage_stats.total_cost"),
                        ": ",
                        formatUsd(api.totalCost)
                      ] })
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.expandIcon, children: expandedApis.has(api.endpoint) ? "" : "" })
                ]
              }
            ),
            expandedApis.has(api.endpoint) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.apiModels, children: Object.entries(api.models).map(([model, stats2]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.modelRow, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.modelName, children: model }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$3.modelStat, children: [
                stats2.requests,
                " ",
                t2("usage_stats.requests_count")
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.modelStat, children: formatTokensInMillions(stats2.tokens) })
            ] }, model)) })
          ] }, api.endpoint)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.hint, children: t2("usage_stats.no_data") }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { title: t2("usage_stats.models"), children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.hint, children: t2("common.loading") }) : modelStats.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.tableWrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: styles$3.table, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("usage_stats.model_name") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("usage_stats.requests_count") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("usage_stats.tokens_count") }),
              hasPrices && /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("usage_stats.total_cost") })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: modelStats.map((stat) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: styles$3.modelCell, children: stat.model }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: stat.requests.toLocaleString() }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: formatTokensInMillions(stat.tokens) }),
              hasPrices && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: stat.cost > 0 ? formatUsd(stat.cost) : "--" })
            ] }, stat.model)) })
          ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.hint, children: t2("usage_stats.no_data") }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { title: t2("usage_stats.model_price_settings"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.pricingSection, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.priceForm, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.formRow, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.formField, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("usage_stats.model_name") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "select",
                {
                  value: selectedModel,
                  onChange: (e) => {
                    setSelectedModel(e.target.value);
                    const price = modelPrices[e.target.value];
                    if (price) {
                      setPromptPrice(price.prompt.toString());
                      setCompletionPrice(price.completion.toString());
                      setCachePrice(price.cache.toString());
                    } else {
                      setPromptPrice("");
                      setCompletionPrice("");
                      setCachePrice("");
                    }
                  },
                  className: styles$3.select,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: t2("usage_stats.model_price_select_placeholder") }),
                    modelNames.map((name2) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: name2, children: name2 }, name2))
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.formField, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { children: [
                t2("usage_stats.model_price_prompt"),
                " ($/1M)"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  type: "number",
                  value: promptPrice,
                  onChange: (e) => setPromptPrice(e.target.value),
                  placeholder: "0.00",
                  step: "0.0001"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.formField, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { children: [
                t2("usage_stats.model_price_completion"),
                " ($/1M)"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  type: "number",
                  value: completionPrice,
                  onChange: (e) => setCompletionPrice(e.target.value),
                  placeholder: "0.00",
                  step: "0.0001"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.formField, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { children: [
                t2("usage_stats.model_price_cache"),
                " ($/1M)"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  type: "number",
                  value: cachePrice,
                  onChange: (e) => setCachePrice(e.target.value),
                  placeholder: "0.00",
                  step: "0.0001"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "primary",
                onClick: handleSavePrice,
                disabled: !selectedModel,
                children: t2("common.save")
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.pricesList, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: styles$3.pricesTitle, children: t2("usage_stats.saved_prices") }),
            Object.keys(modelPrices).length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.pricesGrid, children: Object.entries(modelPrices).map(([model, price]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.priceItem, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.priceInfo, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.priceModel, children: model }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.priceMeta, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                    t2("usage_stats.model_price_prompt"),
                    ": $",
                    price.prompt.toFixed(4),
                    "/1M"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                    t2("usage_stats.model_price_completion"),
                    ": $",
                    price.completion.toFixed(4),
                    "/1M"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                    t2("usage_stats.model_price_cache"),
                    ": $",
                    price.cache.toFixed(4),
                    "/1M"
                  ] })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.priceActions, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "secondary",
                    size: "sm",
                    onClick: () => handleEditPrice(model),
                    children: t2("common.edit")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "danger",
                    size: "sm",
                    onClick: () => handleDeletePrice(model),
                    children: t2("common.delete")
                  }
                )
              ] })
            ] }, model)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.hint, children: t2("usage_stats.model_price_empty") })
          ] })
        ] }) })
      ] });
    }
    function _extends() {
      return _extends = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r in t2) ({}).hasOwnProperty.call(t2, r) && (n[r] = t2[r]);
        }
        return n;
      }, _extends.apply(null, arguments);
    }
    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r) return {};
      var t2 = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t2[n] = r[n];
      }
      return t2;
    }
    let rangeFrom = [], rangeTo = [];
    (() => {
      let numbers2 = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
      for (let i2 = 0, n = 0; i2 < numbers2.length; i2++)
        (i2 % 2 ? rangeTo : rangeFrom).push(n = n + numbers2[i2]);
    })();
    function isExtendingChar(code2) {
      if (code2 < 768) return false;
      for (let from2 = 0, to2 = rangeFrom.length; ; ) {
        let mid = from2 + to2 >> 1;
        if (code2 < rangeFrom[mid]) to2 = mid;
        else if (code2 >= rangeTo[mid]) from2 = mid + 1;
        else return true;
        if (from2 == to2) return false;
      }
    }
    function isRegionalIndicator(code2) {
      return code2 >= 127462 && code2 <= 127487;
    }
    const ZWJ = 8205;
    function findClusterBreak$1(str, pos, forward = true, includeExtending = true) {
      return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
    }
    function nextClusterBreak(str, pos, includeExtending) {
      if (pos == str.length) return pos;
      if (pos && surrogateLow$1(str.charCodeAt(pos)) && surrogateHigh$1(str.charCodeAt(pos - 1))) pos--;
      let prev = codePointAt$1(str, pos);
      pos += codePointSize$1(prev);
      while (pos < str.length) {
        let next = codePointAt$1(str, pos);
        if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
          pos += codePointSize$1(next);
          prev = next;
        } else if (isRegionalIndicator(next)) {
          let countBefore = 0, i2 = pos - 2;
          while (i2 >= 0 && isRegionalIndicator(codePointAt$1(str, i2))) {
            countBefore++;
            i2 -= 2;
          }
          if (countBefore % 2 == 0) break;
          else pos += 2;
        } else {
          break;
        }
      }
      return pos;
    }
    function prevClusterBreak(str, pos, includeExtending) {
      while (pos > 0) {
        let found = nextClusterBreak(str, pos - 2, includeExtending);
        if (found < pos) return found;
        pos--;
      }
      return 0;
    }
    function codePointAt$1(str, pos) {
      let code0 = str.charCodeAt(pos);
      if (!surrogateHigh$1(code0) || pos + 1 == str.length) return code0;
      let code1 = str.charCodeAt(pos + 1);
      if (!surrogateLow$1(code1)) return code0;
      return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
    }
    function surrogateLow$1(ch) {
      return ch >= 56320 && ch < 57344;
    }
    function surrogateHigh$1(ch) {
      return ch >= 55296 && ch < 56320;
    }
    function codePointSize$1(code2) {
      return code2 < 65536 ? 1 : 2;
    }
    class Text {
      /**
      Get the line description around the given position.
      */
      lineAt(pos) {
        if (pos < 0 || pos > this.length)
          throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
        return this.lineInner(pos, false, 1, 0);
      }
      /**
      Get the description for the given (1-based) line number.
      */
      line(n) {
        if (n < 1 || n > this.lines)
          throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
        return this.lineInner(n, true, 1, 0);
      }
      /**
      Replace a range of the text with the given content.
      */
      replace(from2, to2, text) {
        [from2, to2] = clip(this, from2, to2);
        let parts = [];
        this.decompose(
          0,
          from2,
          parts,
          2
          /* Open.To */
        );
        if (text.length)
          text.decompose(
            0,
            text.length,
            parts,
            1 | 2
            /* Open.To */
          );
        this.decompose(
          to2,
          this.length,
          parts,
          1
          /* Open.From */
        );
        return TextNode.from(parts, this.length - (to2 - from2) + text.length);
      }
      /**
      Append another document to this one.
      */
      append(other) {
        return this.replace(this.length, this.length, other);
      }
      /**
      Retrieve the text between the given points.
      */
      slice(from2, to2 = this.length) {
        [from2, to2] = clip(this, from2, to2);
        let parts = [];
        this.decompose(from2, to2, parts, 0);
        return TextNode.from(parts, to2 - from2);
      }
      /**
      Test whether this text is equal to another instance.
      */
      eq(other) {
        if (other == this)
          return true;
        if (other.length != this.length || other.lines != this.lines)
          return false;
        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
        let a = new RawTextCursor(this), b = new RawTextCursor(other);
        for (let skip2 = start, pos = start; ; ) {
          a.next(skip2);
          b.next(skip2);
          skip2 = 0;
          if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
            return false;
          pos += a.value.length;
          if (a.done || pos >= end)
            return true;
        }
      }
      /**
      Iterate over the text. When `dir` is `-1`, iteration happens
      from end to start. This will return lines and the breaks between
      them as separate strings.
      */
      iter(dir = 1) {
        return new RawTextCursor(this, dir);
      }
      /**
      Iterate over a range of the text. When `from` > `to`, the
      iterator will run in reverse.
      */
      iterRange(from2, to2 = this.length) {
        return new PartialTextCursor(this, from2, to2);
      }
      /**
      Return a cursor that iterates over the given range of lines,
      _without_ returning the line breaks between, and yielding empty
      strings for empty lines.
      
      When `from` and `to` are given, they should be 1-based line numbers.
      */
      iterLines(from2, to2) {
        let inner;
        if (from2 == null) {
          inner = this.iter();
        } else {
          if (to2 == null)
            to2 = this.lines + 1;
          let start = this.line(from2).from;
          inner = this.iterRange(start, Math.max(start, to2 == this.lines + 1 ? this.length : to2 <= 1 ? 0 : this.line(to2 - 1).to));
        }
        return new LineCursor(inner);
      }
      /**
      Return the document as a string, using newline characters to
      separate lines.
      */
      toString() {
        return this.sliceString(0);
      }
      /**
      Convert the document to an array of lines (which can be
      deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
      */
      toJSON() {
        let lines = [];
        this.flatten(lines);
        return lines;
      }
      /**
      @internal
      */
      constructor() {
      }
      /**
      Create a `Text` instance for the given array of lines.
      */
      static of(text) {
        if (text.length == 0)
          throw new RangeError("A document must have at least one line");
        if (text.length == 1 && !text[0])
          return Text.empty;
        return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
      }
    }
    class TextLeaf extends Text {
      constructor(text, length = textLength(text)) {
        super();
        this.text = text;
        this.length = length;
      }
      get lines() {
        return this.text.length;
      }
      get children() {
        return null;
      }
      lineInner(target, isLine, line, offset) {
        for (let i2 = 0; ; i2++) {
          let string2 = this.text[i2], end = offset + string2.length;
          if ((isLine ? line : end) >= target)
            return new Line(offset, end, line, string2);
          offset = end + 1;
          line++;
        }
      }
      decompose(from2, to2, target, open) {
        let text = from2 <= 0 && to2 >= this.length ? this : new TextLeaf(sliceText(this.text, from2, to2), Math.min(to2, this.length) - Math.max(0, from2));
        if (open & 1) {
          let prev = target.pop();
          let joined = appendText(text.text, prev.text.slice(), 0, text.length);
          if (joined.length <= 32) {
            target.push(new TextLeaf(joined, prev.length + text.length));
          } else {
            let mid = joined.length >> 1;
            target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
          }
        } else {
          target.push(text);
        }
      }
      replace(from2, to2, text) {
        if (!(text instanceof TextLeaf))
          return super.replace(from2, to2, text);
        [from2, to2] = clip(this, from2, to2);
        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from2)), to2);
        let newLen = this.length + text.length - (to2 - from2);
        if (lines.length <= 32)
          return new TextLeaf(lines, newLen);
        return TextNode.from(TextLeaf.split(lines, []), newLen);
      }
      sliceString(from2, to2 = this.length, lineSep = "\n") {
        [from2, to2] = clip(this, from2, to2);
        let result = "";
        for (let pos = 0, i2 = 0; pos <= to2 && i2 < this.text.length; i2++) {
          let line = this.text[i2], end = pos + line.length;
          if (pos > from2 && i2)
            result += lineSep;
          if (from2 < end && to2 > pos)
            result += line.slice(Math.max(0, from2 - pos), to2 - pos);
          pos = end + 1;
        }
        return result;
      }
      flatten(target) {
        for (let line of this.text)
          target.push(line);
      }
      scanIdentical() {
        return 0;
      }
      static split(text, target) {
        let part = [], len = -1;
        for (let line of text) {
          part.push(line);
          len += line.length + 1;
          if (part.length == 32) {
            target.push(new TextLeaf(part, len));
            part = [];
            len = -1;
          }
        }
        if (len > -1)
          target.push(new TextLeaf(part, len));
        return target;
      }
    }
    class TextNode extends Text {
      constructor(children, length) {
        super();
        this.children = children;
        this.length = length;
        this.lines = 0;
        for (let child of children)
          this.lines += child.lines;
      }
      lineInner(target, isLine, line, offset) {
        for (let i2 = 0; ; i2++) {
          let child = this.children[i2], end = offset + child.length, endLine = line + child.lines - 1;
          if ((isLine ? endLine : end) >= target)
            return child.lineInner(target, isLine, line, offset);
          offset = end + 1;
          line = endLine + 1;
        }
      }
      decompose(from2, to2, target, open) {
        for (let i2 = 0, pos = 0; pos <= to2 && i2 < this.children.length; i2++) {
          let child = this.children[i2], end = pos + child.length;
          if (from2 <= end && to2 >= pos) {
            let childOpen = open & ((pos <= from2 ? 1 : 0) | (end >= to2 ? 2 : 0));
            if (pos >= from2 && end <= to2 && !childOpen)
              target.push(child);
            else
              child.decompose(from2 - pos, to2 - pos, target, childOpen);
          }
          pos = end + 1;
        }
      }
      replace(from2, to2, text) {
        [from2, to2] = clip(this, from2, to2);
        if (text.lines < this.lines)
          for (let i2 = 0, pos = 0; i2 < this.children.length; i2++) {
            let child = this.children[i2], end = pos + child.length;
            if (from2 >= pos && to2 <= end) {
              let updated = child.replace(from2 - pos, to2 - pos, text);
              let totalLines = this.lines - child.lines + updated.lines;
              if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
                let copy2 = this.children.slice();
                copy2[i2] = updated;
                return new TextNode(copy2, this.length - (to2 - from2) + text.length);
              }
              return super.replace(pos, end, updated);
            }
            pos = end + 1;
          }
        return super.replace(from2, to2, text);
      }
      sliceString(from2, to2 = this.length, lineSep = "\n") {
        [from2, to2] = clip(this, from2, to2);
        let result = "";
        for (let i2 = 0, pos = 0; i2 < this.children.length && pos <= to2; i2++) {
          let child = this.children[i2], end = pos + child.length;
          if (pos > from2 && i2)
            result += lineSep;
          if (from2 < end && to2 > pos)
            result += child.sliceString(from2 - pos, to2 - pos, lineSep);
          pos = end + 1;
        }
        return result;
      }
      flatten(target) {
        for (let child of this.children)
          child.flatten(target);
      }
      scanIdentical(other, dir) {
        if (!(other instanceof TextNode))
          return 0;
        let length = 0;
        let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
        for (; ; iA += dir, iB += dir) {
          if (iA == eA || iB == eB)
            return length;
          let chA = this.children[iA], chB = other.children[iB];
          if (chA != chB)
            return length + chA.scanIdentical(chB, dir);
          length += chA.length + 1;
        }
      }
      static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
        let lines = 0;
        for (let ch of children)
          lines += ch.lines;
        if (lines < 32) {
          let flat = [];
          for (let ch of children)
            ch.flatten(flat);
          return new TextLeaf(flat, length);
        }
        let chunk = Math.max(
          32,
          lines >> 5
          /* Tree.BranchShift */
        ), maxChunk = chunk << 1, minChunk = chunk >> 1;
        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
        function add2(child) {
          let last;
          if (child.lines > maxChunk && child instanceof TextNode) {
            for (let node of child.children)
              add2(node);
          } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
            flush();
            chunked.push(child);
          } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
            currentLines += child.lines;
            currentLen += child.length + 1;
            currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
          } else {
            if (currentLines + child.lines > chunk)
              flush();
            currentLines += child.lines;
            currentLen += child.length + 1;
            currentChunk.push(child);
          }
        }
        function flush() {
          if (currentLines == 0)
            return;
          chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
          currentLen = -1;
          currentLines = currentChunk.length = 0;
        }
        for (let child of children)
          add2(child);
        flush();
        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
      }
    }
    Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
    function textLength(text) {
      let length = -1;
      for (let line of text)
        length += line.length + 1;
      return length;
    }
    function appendText(text, target, from2 = 0, to2 = 1e9) {
      for (let pos = 0, i2 = 0, first = true; i2 < text.length && pos <= to2; i2++) {
        let line = text[i2], end = pos + line.length;
        if (end >= from2) {
          if (end > to2)
            line = line.slice(0, to2 - pos);
          if (pos < from2)
            line = line.slice(from2 - pos);
          if (first) {
            target[target.length - 1] += line;
            first = false;
          } else
            target.push(line);
        }
        pos = end + 1;
      }
      return target;
    }
    function sliceText(text, from2, to2) {
      return appendText(text, [""], from2, to2);
    }
    class RawTextCursor {
      constructor(text, dir = 1) {
        this.dir = dir;
        this.done = false;
        this.lineBreak = false;
        this.value = "";
        this.nodes = [text];
        this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
      }
      nextInner(skip2, dir) {
        this.done = this.lineBreak = false;
        for (; ; ) {
          let last = this.nodes.length - 1;
          let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
          let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
          if (offset == (dir > 0 ? size : 0)) {
            if (last == 0) {
              this.done = true;
              this.value = "";
              return this;
            }
            if (dir > 0)
              this.offsets[last - 1]++;
            this.nodes.pop();
            this.offsets.pop();
          } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
            this.offsets[last] += dir;
            if (skip2 == 0) {
              this.lineBreak = true;
              this.value = "\n";
              return this;
            }
            skip2--;
          } else if (top2 instanceof TextLeaf) {
            let next = top2.text[offset + (dir < 0 ? -1 : 0)];
            this.offsets[last] += dir;
            if (next.length > Math.max(0, skip2)) {
              this.value = skip2 == 0 ? next : dir > 0 ? next.slice(skip2) : next.slice(0, next.length - skip2);
              return this;
            }
            skip2 -= next.length;
          } else {
            let next = top2.children[offset + (dir < 0 ? -1 : 0)];
            if (skip2 > next.length) {
              skip2 -= next.length;
              this.offsets[last] += dir;
            } else {
              if (dir < 0)
                this.offsets[last]--;
              this.nodes.push(next);
              this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
            }
          }
        }
      }
      next(skip2 = 0) {
        if (skip2 < 0) {
          this.nextInner(-skip2, -this.dir);
          skip2 = this.value.length;
        }
        return this.nextInner(skip2, this.dir);
      }
    }
    class PartialTextCursor {
      constructor(text, start, end) {
        this.value = "";
        this.done = false;
        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
        this.pos = start > end ? text.length : 0;
        this.from = Math.min(start, end);
        this.to = Math.max(start, end);
      }
      nextInner(skip2, dir) {
        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
          this.value = "";
          this.done = true;
          return this;
        }
        skip2 += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
        if (skip2 > limit)
          skip2 = limit;
        limit -= skip2;
        let { value } = this.cursor.next(skip2);
        this.pos += (value.length + skip2) * dir;
        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
        this.done = !this.value;
        return this;
      }
      next(skip2 = 0) {
        if (skip2 < 0)
          skip2 = Math.max(skip2, this.from - this.pos);
        else if (skip2 > 0)
          skip2 = Math.min(skip2, this.to - this.pos);
        return this.nextInner(skip2, this.cursor.dir);
      }
      get lineBreak() {
        return this.cursor.lineBreak && this.value != "";
      }
    }
    class LineCursor {
      constructor(inner) {
        this.inner = inner;
        this.afterBreak = true;
        this.value = "";
        this.done = false;
      }
      next(skip2 = 0) {
        let { done, lineBreak, value } = this.inner.next(skip2);
        if (done && this.afterBreak) {
          this.value = "";
          this.afterBreak = false;
        } else if (done) {
          this.done = true;
          this.value = "";
        } else if (lineBreak) {
          if (this.afterBreak) {
            this.value = "";
          } else {
            this.afterBreak = true;
            this.next();
          }
        } else {
          this.value = value;
          this.afterBreak = false;
        }
        return this;
      }
      get lineBreak() {
        return false;
      }
    }
    if (typeof Symbol != "undefined") {
      Text.prototype[Symbol.iterator] = function() {
        return this.iter();
      };
      RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
        return this;
      };
    }
    class Line {
      /**
      @internal
      */
      constructor(from2, to2, number2, text) {
        this.from = from2;
        this.to = to2;
        this.number = number2;
        this.text = text;
      }
      /**
      The length of the line (not including any line break after it).
      */
      get length() {
        return this.to - this.from;
      }
    }
    function clip(text, from2, to2) {
      from2 = Math.max(0, Math.min(text.length, from2));
      return [from2, Math.max(from2, Math.min(text.length, to2))];
    }
    function findClusterBreak(str, pos, forward = true, includeExtending = true) {
      return findClusterBreak$1(str, pos, forward, includeExtending);
    }
    function surrogateLow(ch) {
      return ch >= 56320 && ch < 57344;
    }
    function surrogateHigh(ch) {
      return ch >= 55296 && ch < 56320;
    }
    function codePointAt(str, pos) {
      let code0 = str.charCodeAt(pos);
      if (!surrogateHigh(code0) || pos + 1 == str.length)
        return code0;
      let code1 = str.charCodeAt(pos + 1);
      if (!surrogateLow(code1))
        return code0;
      return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
    }
    function fromCodePoint(code2) {
      if (code2 <= 65535)
        return String.fromCharCode(code2);
      code2 -= 65536;
      return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
    }
    function codePointSize(code2) {
      return code2 < 65536 ? 1 : 2;
    }
    const DefaultSplit = /\r\n?|\n/;
    var MapMode = /* @__PURE__ */ (function(MapMode2) {
      MapMode2[MapMode2["Simple"] = 0] = "Simple";
      MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
      MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
      MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
      return MapMode2;
    })(MapMode || (MapMode = {}));
    class ChangeDesc {
      // Sections are encoded as pairs of integers. The first is the
      // length in the current document, and the second is -1 for
      // unaffected sections, and the length of the replacement content
      // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
      // 0), and a replacement two positive numbers.
      /**
      @internal
      */
      constructor(sections) {
        this.sections = sections;
      }
      /**
      The length of the document before the change.
      */
      get length() {
        let result = 0;
        for (let i2 = 0; i2 < this.sections.length; i2 += 2)
          result += this.sections[i2];
        return result;
      }
      /**
      The length of the document after the change.
      */
      get newLength() {
        let result = 0;
        for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
          let ins = this.sections[i2 + 1];
          result += ins < 0 ? this.sections[i2] : ins;
        }
        return result;
      }
      /**
      False when there are actual changes in this set.
      */
      get empty() {
        return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
      }
      /**
      Iterate over the unchanged parts left by these changes. `posA`
      provides the position of the range in the old document, `posB`
      the new position in the changed document.
      */
      iterGaps(f) {
        for (let i2 = 0, posA = 0, posB = 0; i2 < this.sections.length; ) {
          let len = this.sections[i2++], ins = this.sections[i2++];
          if (ins < 0) {
            f(posA, posB, len);
            posB += len;
          } else {
            posB += ins;
          }
          posA += len;
        }
      }
      /**
      Iterate over the ranges changed by these changes. (See
      [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
      variant that also provides you with the inserted text.)
      `fromA`/`toA` provides the extent of the change in the starting
      document, `fromB`/`toB` the extent of the replacement in the
      changed document.
      
      When `individual` is true, adjacent changes (which are kept
      separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
      reported separately.
      */
      iterChangedRanges(f, individual = false) {
        iterChanges(this, f, individual);
      }
      /**
      Get a description of the inverted form of these changes.
      */
      get invertedDesc() {
        let sections = [];
        for (let i2 = 0; i2 < this.sections.length; ) {
          let len = this.sections[i2++], ins = this.sections[i2++];
          if (ins < 0)
            sections.push(len, ins);
          else
            sections.push(ins, len);
        }
        return new ChangeDesc(sections);
      }
      /**
      Compute the combined effect of applying another set of changes
      after this one. The length of the document after this set should
      match the length before `other`.
      */
      composeDesc(other) {
        return this.empty ? other : other.empty ? this : composeSets(this, other);
      }
      /**
      Map this description, which should start with the same document
      as `other`, over another set of changes, so that it can be
      applied after it. When `before` is true, map as if the changes
      in `this` happened before the ones in `other`.
      */
      mapDesc(other, before = false) {
        return other.empty ? this : mapSet(this, other, before);
      }
      mapPos(pos, assoc = -1, mode = MapMode.Simple) {
        let posA = 0, posB = 0;
        for (let i2 = 0; i2 < this.sections.length; ) {
          let len = this.sections[i2++], ins = this.sections[i2++], endA = posA + len;
          if (ins < 0) {
            if (endA > pos)
              return posB + (pos - posA);
            posB += len;
          } else {
            if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
              return null;
            if (endA > pos || endA == pos && assoc < 0 && !len)
              return pos == posA || assoc < 0 ? posB : posB + ins;
            posB += ins;
          }
          posA = endA;
        }
        if (pos > posA)
          throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
        return posB;
      }
      /**
      Check whether these changes touch a given range. When one of the
      changes entirely covers the range, the string `"cover"` is
      returned.
      */
      touchesRange(from2, to2 = from2) {
        for (let i2 = 0, pos = 0; i2 < this.sections.length && pos <= to2; ) {
          let len = this.sections[i2++], ins = this.sections[i2++], end = pos + len;
          if (ins >= 0 && pos <= to2 && end >= from2)
            return pos < from2 && end > to2 ? "cover" : true;
          pos = end;
        }
        return false;
      }
      /**
      @internal
      */
      toString() {
        let result = "";
        for (let i2 = 0; i2 < this.sections.length; ) {
          let len = this.sections[i2++], ins = this.sections[i2++];
          result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
        }
        return result;
      }
      /**
      Serialize this change desc to a JSON-representable value.
      */
      toJSON() {
        return this.sections;
      }
      /**
      Create a change desc from its JSON representation (as produced
      by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
      */
      static fromJSON(json) {
        if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number"))
          throw new RangeError("Invalid JSON representation of ChangeDesc");
        return new ChangeDesc(json);
      }
      /**
      @internal
      */
      static create(sections) {
        return new ChangeDesc(sections);
      }
    }
    class ChangeSet extends ChangeDesc {
      constructor(sections, inserted) {
        super(sections);
        this.inserted = inserted;
      }
      /**
      Apply the changes to a document, returning the modified
      document.
      */
      apply(doc2) {
        if (this.length != doc2.length)
          throw new RangeError("Applying change set to a document with the wrong length");
        iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
        return doc2;
      }
      mapDesc(other, before = false) {
        return mapSet(this, other, before, true);
      }
      /**
      Given the document as it existed _before_ the changes, return a
      change set that represents the inverse of this set, which could
      be used to go from the document created by the changes back to
      the document as it existed before the changes.
      */
      invert(doc2) {
        let sections = this.sections.slice(), inserted = [];
        for (let i2 = 0, pos = 0; i2 < sections.length; i2 += 2) {
          let len = sections[i2], ins = sections[i2 + 1];
          if (ins >= 0) {
            sections[i2] = ins;
            sections[i2 + 1] = len;
            let index2 = i2 >> 1;
            while (inserted.length < index2)
              inserted.push(Text.empty);
            inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
          }
          pos += len;
        }
        return new ChangeSet(sections, inserted);
      }
      /**
      Combine two subsequent change sets into a single set. `other`
      must start in the document produced by `this`. If `this` goes
      `docA`  `docB` and `other` represents `docB`  `docC`, the
      returned value will represent the change `docA`  `docC`.
      */
      compose(other) {
        return this.empty ? other : other.empty ? this : composeSets(this, other, true);
      }
      /**
      Given another change set starting in the same document, maps this
      change set over the other, producing a new change set that can be
      applied to the document produced by applying `other`. When
      `before` is `true`, order changes as if `this` comes before
      `other`, otherwise (the default) treat `other` as coming first.
      
      Given two changes `A` and `B`, `A.compose(B.map(A))` and
      `B.compose(A.map(B, true))` will produce the same document. This
      provides a basic form of [operational
      transformation](https://en.wikipedia.org/wiki/Operational_transformation),
      and can be used for collaborative editing.
      */
      map(other, before = false) {
        return other.empty ? this : mapSet(this, other, before, true);
      }
      /**
      Iterate over the changed ranges in the document, calling `f` for
      each, with the range in the original document (`fromA`-`toA`)
      and the range that replaces it in the new document
      (`fromB`-`toB`).
      
      When `individual` is true, adjacent changes are reported
      separately.
      */
      iterChanges(f, individual = false) {
        iterChanges(this, f, individual);
      }
      /**
      Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
      set.
      */
      get desc() {
        return ChangeDesc.create(this.sections);
      }
      /**
      @internal
      */
      filter(ranges) {
        let resultSections = [], resultInserted = [], filteredSections = [];
        let iter = new SectionIter(this);
        done: for (let i2 = 0, pos = 0; ; ) {
          let next = i2 == ranges.length ? 1e9 : ranges[i2++];
          while (pos < next || pos == next && iter.len == 0) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, next - pos);
            addSection(filteredSections, len, -1);
            let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
            addSection(resultSections, len, ins);
            if (ins > 0)
              addInsert(resultInserted, resultSections, iter.text);
            iter.forward(len);
            pos += len;
          }
          let end = ranges[i2++];
          while (pos < end) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, end - pos);
            addSection(resultSections, len, -1);
            addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
            iter.forward(len);
            pos += len;
          }
        }
        return {
          changes: new ChangeSet(resultSections, resultInserted),
          filtered: ChangeDesc.create(filteredSections)
        };
      }
      /**
      Serialize this change set to a JSON-representable value.
      */
      toJSON() {
        let parts = [];
        for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
          let len = this.sections[i2], ins = this.sections[i2 + 1];
          if (ins < 0)
            parts.push(len);
          else if (ins == 0)
            parts.push([len]);
          else
            parts.push([len].concat(this.inserted[i2 >> 1].toJSON()));
        }
        return parts;
      }
      /**
      Create a change set for the given changes, for a document of the
      given length, using `lineSep` as line separator.
      */
      static of(changes, length, lineSep) {
        let sections = [], inserted = [], pos = 0;
        let total = null;
        function flush(force = false) {
          if (!force && !sections.length)
            return;
          if (pos < length)
            addSection(sections, length - pos, -1);
          let set2 = new ChangeSet(sections, inserted);
          total = total ? total.compose(set2.map(total)) : set2;
          sections = [];
          inserted = [];
          pos = 0;
        }
        function process2(spec) {
          if (Array.isArray(spec)) {
            for (let sub of spec)
              process2(sub);
          } else if (spec instanceof ChangeSet) {
            if (spec.length != length)
              throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
            flush();
            total = total ? total.compose(spec.map(total)) : spec;
          } else {
            let { from: from2, to: to2 = from2, insert: insert2 } = spec;
            if (from2 > to2 || from2 < 0 || to2 > length)
              throw new RangeError(`Invalid change range ${from2} to ${to2} (in doc of length ${length})`);
            let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
            let insLen = insText.length;
            if (from2 == to2 && insLen == 0)
              return;
            if (from2 < pos)
              flush();
            if (from2 > pos)
              addSection(sections, from2 - pos, -1);
            addSection(sections, to2 - from2, insLen);
            addInsert(inserted, sections, insText);
            pos = to2;
          }
        }
        process2(changes);
        flush(!total);
        return total;
      }
      /**
      Create an empty changeset of the given length.
      */
      static empty(length) {
        return new ChangeSet(length ? [length, -1] : [], []);
      }
      /**
      Create a changeset from its JSON representation (as produced by
      [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
      */
      static fromJSON(json) {
        if (!Array.isArray(json))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        let sections = [], inserted = [];
        for (let i2 = 0; i2 < json.length; i2++) {
          let part = json[i2];
          if (typeof part == "number") {
            sections.push(part, -1);
          } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i3) => i3 && typeof e != "string")) {
            throw new RangeError("Invalid JSON representation of ChangeSet");
          } else if (part.length == 1) {
            sections.push(part[0], 0);
          } else {
            while (inserted.length < i2)
              inserted.push(Text.empty);
            inserted[i2] = Text.of(part.slice(1));
            sections.push(part[0], inserted[i2].length);
          }
        }
        return new ChangeSet(sections, inserted);
      }
      /**
      @internal
      */
      static createSet(sections, inserted) {
        return new ChangeSet(sections, inserted);
      }
    }
    function addSection(sections, len, ins, forceJoin = false) {
      if (len == 0 && ins <= 0)
        return;
      let last = sections.length - 2;
      if (last >= 0 && ins <= 0 && ins == sections[last + 1])
        sections[last] += len;
      else if (last >= 0 && len == 0 && sections[last] == 0)
        sections[last + 1] += ins;
      else if (forceJoin) {
        sections[last] += len;
        sections[last + 1] += ins;
      } else
        sections.push(len, ins);
    }
    function addInsert(values, sections, value) {
      if (value.length == 0)
        return;
      let index2 = sections.length - 2 >> 1;
      if (index2 < values.length) {
        values[values.length - 1] = values[values.length - 1].append(value);
      } else {
        while (values.length < index2)
          values.push(Text.empty);
        values.push(value);
      }
    }
    function iterChanges(desc, f, individual) {
      let inserted = desc.inserted;
      for (let posA = 0, posB = 0, i2 = 0; i2 < desc.sections.length; ) {
        let len = desc.sections[i2++], ins = desc.sections[i2++];
        if (ins < 0) {
          posA += len;
          posB += len;
        } else {
          let endA = posA, endB = posB, text = Text.empty;
          for (; ; ) {
            endA += len;
            endB += ins;
            if (ins && inserted)
              text = text.append(inserted[i2 - 2 >> 1]);
            if (individual || i2 == desc.sections.length || desc.sections[i2 + 1] < 0)
              break;
            len = desc.sections[i2++];
            ins = desc.sections[i2++];
          }
          f(posA, endA, posB, endB, text);
          posA = endA;
          posB = endB;
        }
      }
    }
    function mapSet(setA, setB, before, mkSet = false) {
      let sections = [], insert2 = mkSet ? [] : null;
      let a = new SectionIter(setA), b = new SectionIter(setB);
      for (let inserted = -1; ; ) {
        if (a.done && b.len || b.done && a.len) {
          throw new Error("Mismatched change set lengths");
        } else if (a.ins == -1 && b.ins == -1) {
          let len = Math.min(a.len, b.len);
          addSection(sections, len, -1);
          a.forward(len);
          b.forward(len);
        } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
          let len = b.len;
          addSection(sections, b.ins, -1);
          while (len) {
            let piece = Math.min(a.len, len);
            if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
              addSection(sections, 0, a.ins);
              if (insert2)
                addInsert(insert2, sections, a.text);
              inserted = a.i;
            }
            a.forward(piece);
            len -= piece;
          }
          b.next();
        } else if (a.ins >= 0) {
          let len = 0, left = a.len;
          while (left) {
            if (b.ins == -1) {
              let piece = Math.min(left, b.len);
              len += piece;
              left -= piece;
              b.forward(piece);
            } else if (b.ins == 0 && b.len < left) {
              left -= b.len;
              b.next();
            } else {
              break;
            }
          }
          addSection(sections, len, inserted < a.i ? a.ins : 0);
          if (insert2 && inserted < a.i)
            addInsert(insert2, sections, a.text);
          inserted = a.i;
          a.forward(a.len - left);
        } else if (a.done && b.done) {
          return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
        } else {
          throw new Error("Mismatched change set lengths");
        }
      }
    }
    function composeSets(setA, setB, mkSet = false) {
      let sections = [];
      let insert2 = mkSet ? [] : null;
      let a = new SectionIter(setA), b = new SectionIter(setB);
      for (let open = false; ; ) {
        if (a.done && b.done) {
          return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
        } else if (a.ins == 0) {
          addSection(sections, a.len, 0, open);
          a.next();
        } else if (b.len == 0 && !b.done) {
          addSection(sections, 0, b.ins, open);
          if (insert2)
            addInsert(insert2, sections, b.text);
          b.next();
        } else if (a.done || b.done) {
          throw new Error("Mismatched change set lengths");
        } else {
          let len = Math.min(a.len2, b.len), sectionLen = sections.length;
          if (a.ins == -1) {
            let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
            addSection(sections, len, insB, open);
            if (insert2 && insB)
              addInsert(insert2, sections, b.text);
          } else if (b.ins == -1) {
            addSection(sections, a.off ? 0 : a.len, len, open);
            if (insert2)
              addInsert(insert2, sections, a.textBit(len));
          } else {
            addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
            if (insert2 && !b.off)
              addInsert(insert2, sections, b.text);
          }
          open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
          a.forward2(len);
          b.forward(len);
        }
      }
    }
    class SectionIter {
      constructor(set2) {
        this.set = set2;
        this.i = 0;
        this.next();
      }
      next() {
        let { sections } = this.set;
        if (this.i < sections.length) {
          this.len = sections[this.i++];
          this.ins = sections[this.i++];
        } else {
          this.len = 0;
          this.ins = -2;
        }
        this.off = 0;
      }
      get done() {
        return this.ins == -2;
      }
      get len2() {
        return this.ins < 0 ? this.len : this.ins;
      }
      get text() {
        let { inserted } = this.set, index2 = this.i - 2 >> 1;
        return index2 >= inserted.length ? Text.empty : inserted[index2];
      }
      textBit(len) {
        let { inserted } = this.set, index2 = this.i - 2 >> 1;
        return index2 >= inserted.length && !len ? Text.empty : inserted[index2].slice(this.off, len == null ? void 0 : this.off + len);
      }
      forward(len) {
        if (len == this.len)
          this.next();
        else {
          this.len -= len;
          this.off += len;
        }
      }
      forward2(len) {
        if (this.ins == -1)
          this.forward(len);
        else if (len == this.ins)
          this.next();
        else {
          this.ins -= len;
          this.off += len;
        }
      }
    }
    class SelectionRange {
      constructor(from2, to2, flags) {
        this.from = from2;
        this.to = to2;
        this.flags = flags;
      }
      /**
      The anchor of the rangethe side that doesn't move when you
      extend it.
      */
      get anchor() {
        return this.flags & 32 ? this.to : this.from;
      }
      /**
      The head of the range, which is moved when the range is
      [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
      */
      get head() {
        return this.flags & 32 ? this.from : this.to;
      }
      /**
      True when `anchor` and `head` are at the same position.
      */
      get empty() {
        return this.from == this.to;
      }
      /**
      If this is a cursor that is explicitly associated with the
      character on one of its sides, this returns the side. -1 means
      the character before its position, 1 the character after, and 0
      means no association.
      */
      get assoc() {
        return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
      }
      /**
      The bidirectional text level associated with this cursor, if
      any.
      */
      get bidiLevel() {
        let level = this.flags & 7;
        return level == 7 ? null : level;
      }
      /**
      The goal column (stored vertical offset) associated with a
      cursor. This is used to preserve the vertical position when
      [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
      lines of different length.
      */
      get goalColumn() {
        let value = this.flags >> 6;
        return value == 16777215 ? void 0 : value;
      }
      /**
      Map this range through a change, producing a valid range in the
      updated document.
      */
      map(change, assoc = -1) {
        let from2, to2;
        if (this.empty) {
          from2 = to2 = change.mapPos(this.from, assoc);
        } else {
          from2 = change.mapPos(this.from, 1);
          to2 = change.mapPos(this.to, -1);
        }
        return from2 == this.from && to2 == this.to ? this : new SelectionRange(from2, to2, this.flags);
      }
      /**
      Extend this range to cover at least `from` to `to`.
      */
      extend(from2, to2 = from2) {
        if (from2 <= this.anchor && to2 >= this.anchor)
          return EditorSelection.range(from2, to2);
        let head = Math.abs(from2 - this.anchor) > Math.abs(to2 - this.anchor) ? from2 : to2;
        return EditorSelection.range(this.anchor, head);
      }
      /**
      Compare this range to another range.
      */
      eq(other, includeAssoc = false) {
        return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
      }
      /**
      Return a JSON-serializable object representing the range.
      */
      toJSON() {
        return { anchor: this.anchor, head: this.head };
      }
      /**
      Convert a JSON representation of a range to a `SelectionRange`
      instance.
      */
      static fromJSON(json) {
        if (!json || typeof json.anchor != "number" || typeof json.head != "number")
          throw new RangeError("Invalid JSON representation for SelectionRange");
        return EditorSelection.range(json.anchor, json.head);
      }
      /**
      @internal
      */
      static create(from2, to2, flags) {
        return new SelectionRange(from2, to2, flags);
      }
    }
    class EditorSelection {
      constructor(ranges, mainIndex) {
        this.ranges = ranges;
        this.mainIndex = mainIndex;
      }
      /**
      Map a selection through a change. Used to adjust the selection
      position for changes.
      */
      map(change, assoc = -1) {
        if (change.empty)
          return this;
        return EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
      }
      /**
      Compare this selection to another selection. By default, ranges
      are compared only by position. When `includeAssoc` is true,
      cursor ranges must also have the same
      [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
      */
      eq(other, includeAssoc = false) {
        if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
          return false;
        for (let i2 = 0; i2 < this.ranges.length; i2++)
          if (!this.ranges[i2].eq(other.ranges[i2], includeAssoc))
            return false;
        return true;
      }
      /**
      Get the primary selection range. Usually, you should make sure
      your code applies to _all_ ranges, by using methods like
      [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
      */
      get main() {
        return this.ranges[this.mainIndex];
      }
      /**
      Make sure the selection only has one range. Returns a selection
      holding only the main range from this selection.
      */
      asSingle() {
        return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
      }
      /**
      Extend this selection with an extra range.
      */
      addRange(range, main = true) {
        return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
      }
      /**
      Replace a given range with another range, and then normalize the
      selection to merge and sort ranges if necessary.
      */
      replaceRange(range, which = this.mainIndex) {
        let ranges = this.ranges.slice();
        ranges[which] = range;
        return EditorSelection.create(ranges, this.mainIndex);
      }
      /**
      Convert this selection to an object that can be serialized to
      JSON.
      */
      toJSON() {
        return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
      }
      /**
      Create a selection from a JSON representation.
      */
      static fromJSON(json) {
        if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
          throw new RangeError("Invalid JSON representation for EditorSelection");
        return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
      }
      /**
      Create a selection holding a single range.
      */
      static single(anchor, head = anchor) {
        return new EditorSelection([EditorSelection.range(anchor, head)], 0);
      }
      /**
      Sort and merge the given set of ranges, creating a valid
      selection.
      */
      static create(ranges, mainIndex = 0) {
        if (ranges.length == 0)
          throw new RangeError("A selection needs at least one range");
        for (let pos = 0, i2 = 0; i2 < ranges.length; i2++) {
          let range = ranges[i2];
          if (range.empty ? range.from <= pos : range.from < pos)
            return EditorSelection.normalized(ranges.slice(), mainIndex);
          pos = range.to;
        }
        return new EditorSelection(ranges, mainIndex);
      }
      /**
      Create a cursor selection range at the given position. You can
      safely ignore the optional arguments in most situations.
      */
      static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
      }
      /**
      Create a selection range.
      */
      static range(anchor, head, goalColumn, bidiLevel) {
        let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
        return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
      }
      /**
      @internal
      */
      static normalized(ranges, mainIndex = 0) {
        let main = ranges[mainIndex];
        ranges.sort((a, b) => a.from - b.from);
        mainIndex = ranges.indexOf(main);
        for (let i2 = 1; i2 < ranges.length; i2++) {
          let range = ranges[i2], prev = ranges[i2 - 1];
          if (range.empty ? range.from <= prev.to : range.from < prev.to) {
            let from2 = prev.from, to2 = Math.max(range.to, prev.to);
            if (i2 <= mainIndex)
              mainIndex--;
            ranges.splice(--i2, 2, range.anchor > range.head ? EditorSelection.range(to2, from2) : EditorSelection.range(from2, to2));
          }
        }
        return new EditorSelection(ranges, mainIndex);
      }
    }
    function checkSelection(selection2, docLength) {
      for (let range of selection2.ranges)
        if (range.to > docLength)
          throw new RangeError("Selection points outside of document");
    }
    let nextID = 0;
    class Facet {
      constructor(combine, compareInput, compare2, isStatic, enables) {
        this.combine = combine;
        this.compareInput = compareInput;
        this.compare = compare2;
        this.isStatic = isStatic;
        this.id = nextID++;
        this.default = combine([]);
        this.extensions = typeof enables == "function" ? enables(this) : enables;
      }
      /**
      Returns a facet reader for this facet, which can be used to
      [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
      */
      get reader() {
        return this;
      }
      /**
      Define a new facet.
      */
      static define(config2 = {}) {
        return new Facet(config2.combine || ((a) => a), config2.compareInput || ((a, b) => a === b), config2.compare || (!config2.combine ? sameArray$1 : (a, b) => a === b), !!config2.static, config2.enables);
      }
      /**
      Returns an extension that adds the given value to this facet.
      */
      of(value) {
        return new FacetProvider([], this, 0, value);
      }
      /**
      Create an extension that computes a value for the facet from a
      state. You must take care to declare the parts of the state that
      this value depends on, since your function is only called again
      for a new state when one of those parts changed.
      
      In cases where your value depends only on a single field, you'll
      want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
      */
      compute(deps, get2) {
        if (this.isStatic)
          throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 1, get2);
      }
      /**
      Create an extension that computes zero or more values for this
      facet from a state.
      */
      computeN(deps, get2) {
        if (this.isStatic)
          throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 2, get2);
      }
      from(field, get2) {
        if (!get2)
          get2 = (x) => x;
        return this.compute([field], (state) => get2(state.field(field)));
      }
    }
    function sameArray$1(a, b) {
      return a == b || a.length == b.length && a.every((e, i2) => e === b[i2]);
    }
    class FacetProvider {
      constructor(dependencies, facet, type, value) {
        this.dependencies = dependencies;
        this.facet = facet;
        this.type = type;
        this.value = value;
        this.id = nextID++;
      }
      dynamicSlot(addresses) {
        var _a2;
        let getter = this.value;
        let compare2 = this.facet.compareInput;
        let id2 = this.id, idx = addresses[id2] >> 1, multi = this.type == 2;
        let depDoc = false, depSel = false, depAddrs = [];
        for (let dep of this.dependencies) {
          if (dep == "doc")
            depDoc = true;
          else if (dep == "selection")
            depSel = true;
          else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
            depAddrs.push(addresses[dep.id]);
        }
        return {
          create(state) {
            state.values[idx] = getter(state);
            return 1;
          },
          update(state, tr) {
            if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
              let newVal = getter(state);
              if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
                state.values[idx] = newVal;
                return 1;
              }
            }
            return 0;
          },
          reconfigure: (state, oldState) => {
            let newVal, oldAddr = oldState.config.address[id2];
            if (oldAddr != null) {
              let oldVal = getAddr(oldState, oldAddr);
              if (this.dependencies.every((dep) => {
                return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
              }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
                state.values[idx] = oldVal;
                return 0;
              }
            } else {
              newVal = getter(state);
            }
            state.values[idx] = newVal;
            return 1;
          }
        };
      }
    }
    function compareArray(a, b, compare2) {
      if (a.length != b.length)
        return false;
      for (let i2 = 0; i2 < a.length; i2++)
        if (!compare2(a[i2], b[i2]))
          return false;
      return true;
    }
    function ensureAll(state, addrs) {
      let changed = false;
      for (let addr of addrs)
        if (ensureAddr(state, addr) & 1)
          changed = true;
      return changed;
    }
    function dynamicFacetSlot(addresses, facet, providers) {
      let providerAddrs = providers.map((p) => addresses[p.id]);
      let providerTypes = providers.map((p) => p.type);
      let dynamic = providerAddrs.filter((p) => !(p & 1));
      let idx = addresses[facet.id] >> 1;
      function get2(state) {
        let values = [];
        for (let i2 = 0; i2 < providerAddrs.length; i2++) {
          let value = getAddr(state, providerAddrs[i2]);
          if (providerTypes[i2] == 2)
            for (let val of value)
              values.push(val);
          else
            values.push(value);
        }
        return facet.combine(values);
      }
      return {
        create(state) {
          for (let addr of providerAddrs)
            ensureAddr(state, addr);
          state.values[idx] = get2(state);
          return 1;
        },
        update(state, tr) {
          if (!ensureAll(state, dynamic))
            return 0;
          let value = get2(state);
          if (facet.compare(value, state.values[idx]))
            return 0;
          state.values[idx] = value;
          return 1;
        },
        reconfigure(state, oldState) {
          let depChanged = ensureAll(state, providerAddrs);
          let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
          if (oldProviders && !depChanged && sameArray$1(providers, oldProviders)) {
            state.values[idx] = oldValue;
            return 0;
          }
          let value = get2(state);
          if (facet.compare(value, oldValue)) {
            state.values[idx] = oldValue;
            return 0;
          }
          state.values[idx] = value;
          return 1;
        }
      };
    }
    const initField = /* @__PURE__ */ Facet.define({ static: true });
    class StateField {
      constructor(id2, createF, updateF, compareF, spec) {
        this.id = id2;
        this.createF = createF;
        this.updateF = updateF;
        this.compareF = compareF;
        this.spec = spec;
        this.provides = void 0;
      }
      /**
      Define a state field.
      */
      static define(config2) {
        let field = new StateField(nextID++, config2.create, config2.update, config2.compare || ((a, b) => a === b), config2);
        if (config2.provide)
          field.provides = config2.provide(field);
        return field;
      }
      create(state) {
        let init = state.facet(initField).find((i2) => i2.field == this);
        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
      }
      /**
      @internal
      */
      slot(addresses) {
        let idx = addresses[this.id] >> 1;
        return {
          create: (state) => {
            state.values[idx] = this.create(state);
            return 1;
          },
          update: (state, tr) => {
            let oldVal = state.values[idx];
            let value = this.updateF(oldVal, tr);
            if (this.compareF(oldVal, value))
              return 0;
            state.values[idx] = value;
            return 1;
          },
          reconfigure: (state, oldState) => {
            let init = state.facet(initField), oldInit = oldState.facet(initField), reInit;
            if ((reInit = init.find((i2) => i2.field == this)) && reInit != oldInit.find((i2) => i2.field == this)) {
              state.values[idx] = reInit.create(state);
              return 1;
            }
            if (oldState.config.address[this.id] != null) {
              state.values[idx] = oldState.field(this);
              return 0;
            }
            state.values[idx] = this.create(state);
            return 1;
          }
        };
      }
      /**
      Returns an extension that enables this field and overrides the
      way it is initialized. Can be useful when you need to provide a
      non-default starting value for the field.
      */
      init(create2) {
        return [this, initField.of({ field: this, create: create2 })];
      }
      /**
      State field instances can be used as
      [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
      given state.
      */
      get extension() {
        return this;
      }
    }
    const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
    function prec(value) {
      return (ext) => new PrecExtension(ext, value);
    }
    const Prec = {
      /**
      The highest precedence level, for extensions that should end up
      near the start of the precedence ordering.
      */
      highest: /* @__PURE__ */ prec(Prec_.highest),
      /**
      A higher-than-default precedence, for extensions that should
      come before those with default precedence.
      */
      high: /* @__PURE__ */ prec(Prec_.high),
      /**
      The default precedence, which is also used for extensions
      without an explicit precedence.
      */
      default: /* @__PURE__ */ prec(Prec_.default),
      /**
      A lower-than-default precedence.
      */
      low: /* @__PURE__ */ prec(Prec_.low),
      /**
      The lowest precedence level. Meant for things that should end up
      near the end of the extension order.
      */
      lowest: /* @__PURE__ */ prec(Prec_.lowest)
    };
    class PrecExtension {
      constructor(inner, prec2) {
        this.inner = inner;
        this.prec = prec2;
      }
    }
    class Compartment {
      /**
      Create an instance of this compartment to add to your [state
      configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
      */
      of(ext) {
        return new CompartmentInstance(this, ext);
      }
      /**
      Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
      reconfigures this compartment.
      */
      reconfigure(content2) {
        return Compartment.reconfigure.of({ compartment: this, extension: content2 });
      }
      /**
      Get the current content of the compartment in the state, or
      `undefined` if it isn't present.
      */
      get(state) {
        return state.config.compartments.get(this);
      }
    }
    class CompartmentInstance {
      constructor(compartment, inner) {
        this.compartment = compartment;
        this.inner = inner;
      }
    }
    class Configuration {
      constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
        this.base = base2;
        this.compartments = compartments;
        this.dynamicSlots = dynamicSlots;
        this.address = address;
        this.staticValues = staticValues;
        this.facets = facets;
        this.statusTemplate = [];
        while (this.statusTemplate.length < dynamicSlots.length)
          this.statusTemplate.push(
            0
            /* SlotStatus.Unresolved */
          );
      }
      staticFacet(facet) {
        let addr = this.address[facet.id];
        return addr == null ? facet.default : this.staticValues[addr >> 1];
      }
      static resolve(base2, compartments, oldState) {
        let fields = [];
        let facets = /* @__PURE__ */ Object.create(null);
        let newCompartments = /* @__PURE__ */ new Map();
        for (let ext of flatten(base2, compartments, newCompartments)) {
          if (ext instanceof StateField)
            fields.push(ext);
          else
            (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
        }
        let address = /* @__PURE__ */ Object.create(null);
        let staticValues = [];
        let dynamicSlots = [];
        for (let field of fields) {
          address[field.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a) => field.slot(a));
        }
        let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
        for (let id2 in facets) {
          let providers = facets[id2], facet = providers[0].facet;
          let oldProviders = oldFacets && oldFacets[id2] || [];
          if (providers.every(
            (p) => p.type == 0
            /* Provider.Static */
          )) {
            address[facet.id] = staticValues.length << 1 | 1;
            if (sameArray$1(oldProviders, providers)) {
              staticValues.push(oldState.facet(facet));
            } else {
              let value = facet.combine(providers.map((p) => p.value));
              staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
            }
          } else {
            for (let p of providers) {
              if (p.type == 0) {
                address[p.id] = staticValues.length << 1 | 1;
                staticValues.push(p.value);
              } else {
                address[p.id] = dynamicSlots.length << 1;
                dynamicSlots.push((a) => p.dynamicSlot(a));
              }
            }
            address[facet.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
          }
        }
        let dynamic = dynamicSlots.map((f) => f(address));
        return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
      }
    }
    function flatten(extension, compartments, newCompartments) {
      let result = [[], [], [], [], []];
      let seen = /* @__PURE__ */ new Map();
      function inner(ext, prec2) {
        let known = seen.get(ext);
        if (known != null) {
          if (known <= prec2)
            return;
          let found = result[known].indexOf(ext);
          if (found > -1)
            result[known].splice(found, 1);
          if (ext instanceof CompartmentInstance)
            newCompartments.delete(ext.compartment);
        }
        seen.set(ext, prec2);
        if (Array.isArray(ext)) {
          for (let e of ext)
            inner(e, prec2);
        } else if (ext instanceof CompartmentInstance) {
          if (newCompartments.has(ext.compartment))
            throw new RangeError(`Duplicate use of compartment in extensions`);
          let content2 = compartments.get(ext.compartment) || ext.inner;
          newCompartments.set(ext.compartment, content2);
          inner(content2, prec2);
        } else if (ext instanceof PrecExtension) {
          inner(ext.inner, ext.prec);
        } else if (ext instanceof StateField) {
          result[prec2].push(ext);
          if (ext.provides)
            inner(ext.provides, prec2);
        } else if (ext instanceof FacetProvider) {
          result[prec2].push(ext);
          if (ext.facet.extensions)
            inner(ext.facet.extensions, Prec_.default);
        } else {
          let content2 = ext.extension;
          if (!content2)
            throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
          inner(content2, prec2);
        }
      }
      inner(extension, Prec_.default);
      return result.reduce((a, b) => a.concat(b));
    }
    function ensureAddr(state, addr) {
      if (addr & 1)
        return 2;
      let idx = addr >> 1;
      let status2 = state.status[idx];
      if (status2 == 4)
        throw new Error("Cyclic dependency between fields and/or facets");
      if (status2 & 2)
        return status2;
      state.status[idx] = 4;
      let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
      return state.status[idx] = 2 | changed;
    }
    function getAddr(state, addr) {
      return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
    }
    const languageData = /* @__PURE__ */ Facet.define();
    const allowMultipleSelections = /* @__PURE__ */ Facet.define({
      combine: (values) => values.some((v) => v),
      static: true
    });
    const lineSeparator = /* @__PURE__ */ Facet.define({
      combine: (values) => values.length ? values[0] : void 0,
      static: true
    });
    const changeFilter = /* @__PURE__ */ Facet.define();
    const transactionFilter = /* @__PURE__ */ Facet.define();
    const transactionExtender = /* @__PURE__ */ Facet.define();
    const readOnly = /* @__PURE__ */ Facet.define({
      combine: (values) => values.length ? values[0] : false
    });
    class Annotation {
      /**
      @internal
      */
      constructor(type, value) {
        this.type = type;
        this.value = value;
      }
      /**
      Define a new type of annotation.
      */
      static define() {
        return new AnnotationType();
      }
    }
    class AnnotationType {
      /**
      Create an instance of this annotation.
      */
      of(value) {
        return new Annotation(this, value);
      }
    }
    class StateEffectType {
      /**
      @internal
      */
      constructor(map2) {
        this.map = map2;
      }
      /**
      Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
      type.
      */
      of(value) {
        return new StateEffect(this, value);
      }
    }
    class StateEffect {
      /**
      @internal
      */
      constructor(type, value) {
        this.type = type;
        this.value = value;
      }
      /**
      Map this effect through a position mapping. Will return
      `undefined` when that ends up deleting the effect.
      */
      map(mapping) {
        let mapped = this.type.map(this.value, mapping);
        return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
      }
      /**
      Tells you whether this effect object is of a given
      [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
      */
      is(type) {
        return this.type == type;
      }
      /**
      Define a new effect type. The type parameter indicates the type
      of values that his effect holds. It should be a type that
      doesn't include `undefined`, since that is used in
      [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
      removed.
      */
      static define(spec = {}) {
        return new StateEffectType(spec.map || ((v) => v));
      }
      /**
      Map an array of effects through a change set.
      */
      static mapEffects(effects2, mapping) {
        if (!effects2.length)
          return effects2;
        let result = [];
        for (let effect of effects2) {
          let mapped = effect.map(mapping);
          if (mapped)
            result.push(mapped);
        }
        return result;
      }
    }
    StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
    StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
    class Transaction {
      constructor(startState, changes, selection2, effects2, annotations, scrollIntoView2) {
        this.startState = startState;
        this.changes = changes;
        this.selection = selection2;
        this.effects = effects2;
        this.annotations = annotations;
        this.scrollIntoView = scrollIntoView2;
        this._doc = null;
        this._state = null;
        if (selection2)
          checkSelection(selection2, changes.newLength);
        if (!annotations.some((a) => a.type == Transaction.time))
          this.annotations = annotations.concat(Transaction.time.of(Date.now()));
      }
      /**
      @internal
      */
      static create(startState, changes, selection2, effects2, annotations, scrollIntoView2) {
        return new Transaction(startState, changes, selection2, effects2, annotations, scrollIntoView2);
      }
      /**
      The new document produced by the transaction. Contrary to
      [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
      force the entire new state to be computed right away, so it is
      recommended that [transaction
      filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
      when they need to look at the new document.
      */
      get newDoc() {
        return this._doc || (this._doc = this.changes.apply(this.startState.doc));
      }
      /**
      The new selection produced by the transaction. If
      [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
      this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
      current selection through the changes made by the transaction.
      */
      get newSelection() {
        return this.selection || this.startState.selection.map(this.changes);
      }
      /**
      The new state created by the transaction. Computed on demand
      (but retained for subsequent access), so it is recommended not to
      access it in [transaction
      filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
      */
      get state() {
        if (!this._state)
          this.startState.applyTransaction(this);
        return this._state;
      }
      /**
      Get the value of the given annotation type, if any.
      */
      annotation(type) {
        for (let ann of this.annotations)
          if (ann.type == type)
            return ann.value;
        return void 0;
      }
      /**
      Indicates whether the transaction changed the document.
      */
      get docChanged() {
        return !this.changes.empty;
      }
      /**
      Indicates whether this transaction reconfigures the state
      (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
      with a top-level configuration
      [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
      */
      get reconfigured() {
        return this.startState.config != this.state.config;
      }
      /**
      Returns true if the transaction has a [user
      event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
      or more specific than `event`. For example, if the transaction
      has `"select.pointer"` as user event, `"select"` and
      `"select.pointer"` will match it.
      */
      isUserEvent(event) {
        let e = this.annotation(Transaction.userEvent);
        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
      }
    }
    Transaction.time = /* @__PURE__ */ Annotation.define();
    Transaction.userEvent = /* @__PURE__ */ Annotation.define();
    Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
    Transaction.remote = /* @__PURE__ */ Annotation.define();
    function joinRanges(a, b) {
      let result = [];
      for (let iA = 0, iB = 0; ; ) {
        let from2, to2;
        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
          from2 = a[iA++];
          to2 = a[iA++];
        } else if (iB < b.length) {
          from2 = b[iB++];
          to2 = b[iB++];
        } else
          return result;
        if (!result.length || result[result.length - 1] < from2)
          result.push(from2, to2);
        else if (result[result.length - 1] < to2)
          result[result.length - 1] = to2;
      }
    }
    function mergeTransaction(a, b, sequential) {
      var _a2;
      let mapForA, mapForB, changes;
      if (sequential) {
        mapForA = b.changes;
        mapForB = ChangeSet.empty(b.changes.length);
        changes = a.changes.compose(b.changes);
      } else {
        mapForA = b.changes.map(a.changes);
        mapForB = a.changes.mapDesc(b.changes, true);
        changes = a.changes.compose(mapForA);
      }
      return {
        changes,
        selection: b.selection ? b.selection.map(mapForB) : (_a2 = a.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
        scrollIntoView: a.scrollIntoView || b.scrollIntoView
      };
    }
    function resolveTransactionInner(state, spec, docSize) {
      let sel = spec.selection, annotations = asArray$1(spec.annotations);
      if (spec.userEvent)
        annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
      return {
        changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
        effects: asArray$1(spec.effects),
        annotations,
        scrollIntoView: !!spec.scrollIntoView
      };
    }
    function resolveTransaction(state, specs, filter) {
      let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
      if (specs.length && specs[0].filter === false)
        filter = false;
      for (let i2 = 1; i2 < specs.length; i2++) {
        if (specs[i2].filter === false)
          filter = false;
        let seq = !!specs[i2].sequential;
        s = mergeTransaction(s, resolveTransactionInner(state, specs[i2], seq ? s.changes.newLength : state.doc.length), seq);
      }
      let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
      return extendTransaction(filter ? filterTransaction(tr) : tr);
    }
    function filterTransaction(tr) {
      let state = tr.startState;
      let result = true;
      for (let filter of state.facet(changeFilter)) {
        let value = filter(tr);
        if (value === false) {
          result = false;
          break;
        }
        if (Array.isArray(value))
          result = result === true ? value : joinRanges(result, value);
      }
      if (result !== true) {
        let changes, back;
        if (result === false) {
          back = tr.changes.invertedDesc;
          changes = ChangeSet.empty(state.doc.length);
        } else {
          let filtered = tr.changes.filter(result);
          changes = filtered.changes;
          back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
        }
        tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
      }
      let filters2 = state.facet(transactionFilter);
      for (let i2 = filters2.length - 1; i2 >= 0; i2--) {
        let filtered = filters2[i2](tr);
        if (filtered instanceof Transaction)
          tr = filtered;
        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
          tr = filtered[0];
        else
          tr = resolveTransaction(state, asArray$1(filtered), false);
      }
      return tr;
    }
    function extendTransaction(tr) {
      let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
      for (let i2 = extenders.length - 1; i2 >= 0; i2--) {
        let extension = extenders[i2](tr);
        if (extension && Object.keys(extension).length)
          spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
      }
      return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
    }
    const none$2 = [];
    function asArray$1(value) {
      return value == null ? none$2 : Array.isArray(value) ? value : [value];
    }
    var CharCategory = /* @__PURE__ */ (function(CharCategory2) {
      CharCategory2[CharCategory2["Word"] = 0] = "Word";
      CharCategory2[CharCategory2["Space"] = 1] = "Space";
      CharCategory2[CharCategory2["Other"] = 2] = "Other";
      return CharCategory2;
    })(CharCategory || (CharCategory = {}));
    const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    let wordChar;
    try {
      wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
    } catch (_) {
    }
    function hasWordChar(str) {
      if (wordChar)
        return wordChar.test(str);
      for (let i2 = 0; i2 < str.length; i2++) {
        let ch = str[i2];
        if (/\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
          return true;
      }
      return false;
    }
    function makeCategorizer(wordChars) {
      return (char) => {
        if (!/\S/.test(char))
          return CharCategory.Space;
        if (hasWordChar(char))
          return CharCategory.Word;
        for (let i2 = 0; i2 < wordChars.length; i2++)
          if (char.indexOf(wordChars[i2]) > -1)
            return CharCategory.Word;
        return CharCategory.Other;
      };
    }
    class EditorState {
      constructor(config2, doc2, selection2, values, computeSlot, tr) {
        this.config = config2;
        this.doc = doc2;
        this.selection = selection2;
        this.values = values;
        this.status = config2.statusTemplate.slice();
        this.computeSlot = computeSlot;
        if (tr)
          tr._state = this;
        for (let i2 = 0; i2 < this.config.dynamicSlots.length; i2++)
          ensureAddr(this, i2 << 1);
        this.computeSlot = null;
      }
      field(field, require2 = true) {
        let addr = this.config.address[field.id];
        if (addr == null) {
          if (require2)
            throw new RangeError("Field is not present in this state");
          return void 0;
        }
        ensureAddr(this, addr);
        return getAddr(this, addr);
      }
      /**
      Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
      state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
      can be passed. Unless
      [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
      [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
      are assumed to start in the _current_ document (not the document
      produced by previous specs), and its
      [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
      [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
      to the document created by its _own_ changes. The resulting
      transaction contains the combined effect of all the different
      specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
      specs take precedence over earlier ones.
      */
      update(...specs) {
        return resolveTransaction(this, specs, true);
      }
      /**
      @internal
      */
      applyTransaction(tr) {
        let conf = this.config, { base: base2, compartments } = conf;
        for (let effect of tr.effects) {
          if (effect.is(Compartment.reconfigure)) {
            if (conf) {
              compartments = /* @__PURE__ */ new Map();
              conf.compartments.forEach((val, key) => compartments.set(key, val));
              conf = null;
            }
            compartments.set(effect.value.compartment, effect.value.extension);
          } else if (effect.is(StateEffect.reconfigure)) {
            conf = null;
            base2 = effect.value;
          } else if (effect.is(StateEffect.appendConfig)) {
            conf = null;
            base2 = asArray$1(base2).concat(effect.value);
          }
        }
        let startValues;
        if (!conf) {
          conf = Configuration.resolve(base2, compartments, this);
          let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
          startValues = intermediateState.values;
        } else {
          startValues = tr.startState.values.slice();
        }
        let selection2 = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
        new EditorState(conf, tr.newDoc, selection2, startValues, (state, slot) => slot.update(state, tr), tr);
      }
      /**
      Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
      replaces every selection range with the given content.
      */
      replaceSelection(text) {
        if (typeof text == "string")
          text = this.toText(text);
        return this.changeByRange((range) => ({
          changes: { from: range.from, to: range.to, insert: text },
          range: EditorSelection.cursor(range.from + text.length)
        }));
      }
      /**
      Create a set of changes and a new selection by running the given
      function for each range in the active selection. The function
      can return an optional set of changes (in the coordinate space
      of the start document), plus an updated range (in the coordinate
      space of the document produced by the call's own changes). This
      method will merge all the changes and ranges into a single
      changeset and selection, and return it as a [transaction
      spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
      [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
      */
      changeByRange(f) {
        let sel = this.selection;
        let result1 = f(sel.ranges[0]);
        let changes = this.changes(result1.changes), ranges = [result1.range];
        let effects2 = asArray$1(result1.effects);
        for (let i2 = 1; i2 < sel.ranges.length; i2++) {
          let result = f(sel.ranges[i2]);
          let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
          for (let j = 0; j < i2; j++)
            ranges[j] = ranges[j].map(newMapped);
          let mapBy = changes.mapDesc(newChanges, true);
          ranges.push(result.range.map(mapBy));
          changes = changes.compose(newMapped);
          effects2 = StateEffect.mapEffects(effects2, newMapped).concat(StateEffect.mapEffects(asArray$1(result.effects), mapBy));
        }
        return {
          changes,
          selection: EditorSelection.create(ranges, sel.mainIndex),
          effects: effects2
        };
      }
      /**
      Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
      description, taking the state's document length and line
      separator into account.
      */
      changes(spec = []) {
        if (spec instanceof ChangeSet)
          return spec;
        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
      }
      /**
      Using the state's [line
      separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
      [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
      */
      toText(string2) {
        return Text.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
      }
      /**
      Return the given range of the document as a string.
      */
      sliceDoc(from2 = 0, to2 = this.doc.length) {
        return this.doc.sliceString(from2, to2, this.lineBreak);
      }
      /**
      Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
      */
      facet(facet) {
        let addr = this.config.address[facet.id];
        if (addr == null)
          return facet.default;
        ensureAddr(this, addr);
        return getAddr(this, addr);
      }
      /**
      Convert this state to a JSON-serializable object. When custom
      fields should be serialized, you can pass them in as an object
      mapping property names (in the resulting object, which should
      not use `doc` or `selection`) to fields.
      */
      toJSON(fields) {
        let result = {
          doc: this.sliceDoc(),
          selection: this.selection.toJSON()
        };
        if (fields)
          for (let prop in fields) {
            let value = fields[prop];
            if (value instanceof StateField && this.config.address[value.id] != null)
              result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
          }
        return result;
      }
      /**
      Deserialize a state from its JSON representation. When custom
      fields should be deserialized, pass the same object you passed
      to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
      third argument.
      */
      static fromJSON(json, config2 = {}, fields) {
        if (!json || typeof json.doc != "string")
          throw new RangeError("Invalid JSON representation for EditorState");
        let fieldInit = [];
        if (fields)
          for (let prop in fields) {
            if (Object.prototype.hasOwnProperty.call(json, prop)) {
              let field = fields[prop], value = json[prop];
              fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
            }
          }
        return EditorState.create({
          doc: json.doc,
          selection: EditorSelection.fromJSON(json.selection),
          extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
        });
      }
      /**
      Create a new state. You'll usually only need this when
      initializing an editorupdated states are created by applying
      transactions.
      */
      static create(config2 = {}) {
        let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
        let doc2 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
        let selection2 = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
        checkSelection(selection2, doc2.length);
        if (!configuration.staticFacet(allowMultipleSelections))
          selection2 = selection2.asSingle();
        return new EditorState(configuration, doc2, selection2, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
      }
      /**
      The size (in columns) of a tab in the document, determined by
      the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
      */
      get tabSize() {
        return this.facet(EditorState.tabSize);
      }
      /**
      Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
      string for this state.
      */
      get lineBreak() {
        return this.facet(EditorState.lineSeparator) || "\n";
      }
      /**
      Returns true when the editor is
      [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
      */
      get readOnly() {
        return this.facet(readOnly);
      }
      /**
      Look up a translation for the given phrase (via the
      [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
      original string if no translation is found.
      
      If additional arguments are passed, they will be inserted in
      place of markers like `$1` (for the first value) and `$2`, etc.
      A single `$` is equivalent to `$1`, and `$$` will produce a
      literal dollar sign.
      */
      phrase(phrase2, ...insert2) {
        for (let map2 of this.facet(EditorState.phrases))
          if (Object.prototype.hasOwnProperty.call(map2, phrase2)) {
            phrase2 = map2[phrase2];
            break;
          }
        if (insert2.length)
          phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m, i2) => {
            if (i2 == "$")
              return "$";
            let n = +(i2 || 1);
            return !n || n > insert2.length ? m : insert2[n - 1];
          });
        return phrase2;
      }
      /**
      Find the values for a given language data field, provided by the
      the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
      
      Examples of language data fields are...
      
      - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
        comment syntax.
      - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
        for providing language-specific completion sources.
      - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
        characters that should be considered part of words in this
        language.
      - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
        bracket closing behavior.
      */
      languageDataAt(name2, pos, side = -1) {
        let values = [];
        for (let provider of this.facet(languageData)) {
          for (let result of provider(this, pos, side)) {
            if (Object.prototype.hasOwnProperty.call(result, name2))
              values.push(result[name2]);
          }
        }
        return values;
      }
      /**
      Return a function that can categorize strings (expected to
      represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
      into one of:
      
       - Word (contains an alphanumeric character or a character
         explicitly listed in the local language's `"wordChars"`
         language data, which should be a string)
       - Space (contains only whitespace)
       - Other (anything else)
      */
      charCategorizer(at) {
        return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
      }
      /**
      Find the word at the given position, meaning the range
      containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
      around it. If no word characters are adjacent to the position,
      this returns null.
      */
      wordAt(pos) {
        let { text, from: from2, length } = this.doc.lineAt(pos);
        let cat = this.charCategorizer(pos);
        let start = pos - from2, end = pos - from2;
        while (start > 0) {
          let prev = findClusterBreak(text, start, false);
          if (cat(text.slice(prev, start)) != CharCategory.Word)
            break;
          start = prev;
        }
        while (end < length) {
          let next = findClusterBreak(text, end);
          if (cat(text.slice(end, next)) != CharCategory.Word)
            break;
          end = next;
        }
        return start == end ? null : EditorSelection.range(start + from2, end + from2);
      }
    }
    EditorState.allowMultipleSelections = allowMultipleSelections;
    EditorState.tabSize = /* @__PURE__ */ Facet.define({
      combine: (values) => values.length ? values[0] : 4
    });
    EditorState.lineSeparator = lineSeparator;
    EditorState.readOnly = readOnly;
    EditorState.phrases = /* @__PURE__ */ Facet.define({
      compare(a, b) {
        let kA = Object.keys(a), kB = Object.keys(b);
        return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
      }
    });
    EditorState.languageData = languageData;
    EditorState.changeFilter = changeFilter;
    EditorState.transactionFilter = transactionFilter;
    EditorState.transactionExtender = transactionExtender;
    Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
    function combineConfig(configs, defaults2, combine = {}) {
      let result = {};
      for (let config2 of configs)
        for (let key of Object.keys(config2)) {
          let value = config2[key], current = result[key];
          if (current === void 0)
            result[key] = value;
          else if (current === value || value === void 0) ;
          else if (Object.hasOwnProperty.call(combine, key))
            result[key] = combine[key](current, value);
          else
            throw new Error("Config merge conflict for field " + key);
        }
      for (let key in defaults2)
        if (result[key] === void 0)
          result[key] = defaults2[key];
      return result;
    }
    class RangeValue {
      /**
      Compare this value with another value. Used when comparing
      rangesets. The default implementation compares by identity.
      Unless you are only creating a fixed number of unique instances
      of your value type, it is a good idea to implement this
      properly.
      */
      eq(other) {
        return this == other;
      }
      /**
      Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
      */
      range(from2, to2 = from2) {
        return Range$1.create(from2, to2, this);
      }
    }
    RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
    RangeValue.prototype.point = false;
    RangeValue.prototype.mapMode = MapMode.TrackDel;
    let Range$1 = class Range2 {
      constructor(from2, to2, value) {
        this.from = from2;
        this.to = to2;
        this.value = value;
      }
      /**
      @internal
      */
      static create(from2, to2, value) {
        return new Range2(from2, to2, value);
      }
    };
    function cmpRange(a, b) {
      return a.from - b.from || a.value.startSide - b.value.startSide;
    }
    class Chunk {
      constructor(from2, to2, value, maxPoint) {
        this.from = from2;
        this.to = to2;
        this.value = value;
        this.maxPoint = maxPoint;
      }
      get length() {
        return this.to[this.to.length - 1];
      }
      // Find the index of the given position and side. Use the ranges'
      // `from` pos when `end == false`, `to` when `end == true`.
      findIndex(pos, side, end, startAt = 0) {
        let arr = end ? this.to : this.from;
        for (let lo = startAt, hi = arr.length; ; ) {
          if (lo == hi)
            return lo;
          let mid = lo + hi >> 1;
          let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
          if (mid == lo)
            return diff >= 0 ? lo : hi;
          if (diff >= 0)
            hi = mid;
          else
            lo = mid + 1;
        }
      }
      between(offset, from2, to2, f) {
        for (let i2 = this.findIndex(from2, -1e9, true), e = this.findIndex(to2, 1e9, false, i2); i2 < e; i2++)
          if (f(this.from[i2] + offset, this.to[i2] + offset, this.value[i2]) === false)
            return false;
      }
      map(offset, changes) {
        let value = [], from2 = [], to2 = [], newPos = -1, maxPoint = -1;
        for (let i2 = 0; i2 < this.value.length; i2++) {
          let val = this.value[i2], curFrom = this.from[i2] + offset, curTo = this.to[i2] + offset, newFrom, newTo;
          if (curFrom == curTo) {
            let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
            if (mapped == null)
              continue;
            newFrom = newTo = mapped;
            if (val.startSide != val.endSide) {
              newTo = changes.mapPos(curFrom, val.endSide);
              if (newTo < newFrom)
                continue;
            }
          } else {
            newFrom = changes.mapPos(curFrom, val.startSide);
            newTo = changes.mapPos(curTo, val.endSide);
            if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
              continue;
          }
          if ((newTo - newFrom || val.endSide - val.startSide) < 0)
            continue;
          if (newPos < 0)
            newPos = newFrom;
          if (val.point)
            maxPoint = Math.max(maxPoint, newTo - newFrom);
          value.push(val);
          from2.push(newFrom - newPos);
          to2.push(newTo - newPos);
        }
        return { mapped: value.length ? new Chunk(from2, to2, value, maxPoint) : null, pos: newPos };
      }
    }
    class RangeSet {
      constructor(chunkPos, chunk, nextLayer, maxPoint) {
        this.chunkPos = chunkPos;
        this.chunk = chunk;
        this.nextLayer = nextLayer;
        this.maxPoint = maxPoint;
      }
      /**
      @internal
      */
      static create(chunkPos, chunk, nextLayer, maxPoint) {
        return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
      }
      /**
      @internal
      */
      get length() {
        let last = this.chunk.length - 1;
        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
      }
      /**
      The number of ranges in the set.
      */
      get size() {
        if (this.isEmpty)
          return 0;
        let size = this.nextLayer.size;
        for (let chunk of this.chunk)
          size += chunk.value.length;
        return size;
      }
      /**
      @internal
      */
      chunkEnd(index2) {
        return this.chunkPos[index2] + this.chunk[index2].length;
      }
      /**
      Update the range set, optionally adding new ranges or filtering
      out existing ones.
      
      (Note: The type parameter is just there as a kludge to work
      around TypeScript variance issues that prevented `RangeSet<X>`
      from being a subtype of `RangeSet<Y>` when `X` is a subtype of
      `Y`.)
      */
      update(updateSpec) {
        let { add: add2 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
        let filter = updateSpec.filter;
        if (add2.length == 0 && !filter)
          return this;
        if (sort)
          add2 = add2.slice().sort(cmpRange);
        if (this.isEmpty)
          return add2.length ? RangeSet.of(add2) : this;
        let cur2 = new LayerCursor(this, null, -1).goto(0), i2 = 0, spill = [];
        let builder = new RangeSetBuilder();
        while (cur2.value || i2 < add2.length) {
          if (i2 < add2.length && (cur2.from - add2[i2].from || cur2.startSide - add2[i2].value.startSide) >= 0) {
            let range = add2[i2++];
            if (!builder.addInner(range.from, range.to, range.value))
              spill.push(range);
          } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i2 == add2.length || this.chunkEnd(cur2.chunkIndex) < add2[i2].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
            cur2.nextChunk();
          } else {
            if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
              if (!builder.addInner(cur2.from, cur2.to, cur2.value))
                spill.push(Range$1.create(cur2.from, cur2.to, cur2.value));
            }
            cur2.next();
          }
        }
        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
      }
      /**
      Map this range set through a set of changes, return the new set.
      */
      map(changes) {
        if (changes.empty || this.isEmpty)
          return this;
        let chunks = [], chunkPos = [], maxPoint = -1;
        for (let i2 = 0; i2 < this.chunk.length; i2++) {
          let start = this.chunkPos[i2], chunk = this.chunk[i2];
          let touch = changes.touchesRange(start, start + chunk.length);
          if (touch === false) {
            maxPoint = Math.max(maxPoint, chunk.maxPoint);
            chunks.push(chunk);
            chunkPos.push(changes.mapPos(start));
          } else if (touch === true) {
            let { mapped, pos } = chunk.map(start, changes);
            if (mapped) {
              maxPoint = Math.max(maxPoint, mapped.maxPoint);
              chunks.push(mapped);
              chunkPos.push(pos);
            }
          }
        }
        let next = this.nextLayer.map(changes);
        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
      }
      /**
      Iterate over the ranges that touch the region `from` to `to`,
      calling `f` for each. There is no guarantee that the ranges will
      be reported in any specific order. When the callback returns
      `false`, iteration stops.
      */
      between(from2, to2, f) {
        if (this.isEmpty)
          return;
        for (let i2 = 0; i2 < this.chunk.length; i2++) {
          let start = this.chunkPos[i2], chunk = this.chunk[i2];
          if (to2 >= start && from2 <= start + chunk.length && chunk.between(start, from2 - start, to2 - start, f) === false)
            return;
        }
        this.nextLayer.between(from2, to2, f);
      }
      /**
      Iterate over the ranges in this set, in order, including all
      ranges that end at or after `from`.
      */
      iter(from2 = 0) {
        return HeapCursor.from([this]).goto(from2);
      }
      /**
      @internal
      */
      get isEmpty() {
        return this.nextLayer == this;
      }
      /**
      Iterate over the ranges in a collection of sets, in order,
      starting from `from`.
      */
      static iter(sets, from2 = 0) {
        return HeapCursor.from(sets).goto(from2);
      }
      /**
      Iterate over two groups of sets, calling methods on `comparator`
      to notify it of possible differences.
      */
      static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
        let a = oldSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
        let b = newSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
        let sharedChunks = findSharedChunks(a, b, textDiff);
        let sideA = new SpanCursor(a, sharedChunks, minPointSize);
        let sideB = new SpanCursor(b, sharedChunks, minPointSize);
        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
        if (textDiff.empty && textDiff.length == 0)
          compare(sideA, 0, sideB, 0, 0, comparator);
      }
      /**
      Compare the contents of two groups of range sets, returning true
      if they are equivalent in the given range.
      */
      static eq(oldSets, newSets, from2 = 0, to2) {
        if (to2 == null)
          to2 = 1e9 - 1;
        let a = oldSets.filter((set2) => !set2.isEmpty && newSets.indexOf(set2) < 0);
        let b = newSets.filter((set2) => !set2.isEmpty && oldSets.indexOf(set2) < 0);
        if (a.length != b.length)
          return false;
        if (!a.length)
          return true;
        let sharedChunks = findSharedChunks(a, b);
        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from2), sideB = new SpanCursor(b, sharedChunks, 0).goto(from2);
        for (; ; ) {
          if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
            return false;
          if (sideA.to > to2)
            return true;
          sideA.next();
          sideB.next();
        }
      }
      /**
      Iterate over a group of range sets at the same time, notifying
      the iterator about the ranges covering every given piece of
      content. Returns the open count (see
      [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
      of the iteration.
      */
      static spans(sets, from2, to2, iterator2, minPointSize = -1) {
        let cursor2 = new SpanCursor(sets, null, minPointSize).goto(from2), pos = from2;
        let openRanges = cursor2.openStart;
        for (; ; ) {
          let curTo = Math.min(cursor2.to, to2);
          if (cursor2.point) {
            let active = cursor2.activeForPoint(cursor2.to);
            let openCount = cursor2.pointFrom < from2 ? active.length + 1 : cursor2.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
            iterator2.point(pos, curTo, cursor2.point, active, openCount, cursor2.pointRank);
            openRanges = Math.min(cursor2.openEnd(curTo), active.length);
          } else if (curTo > pos) {
            iterator2.span(pos, curTo, cursor2.active, openRanges);
            openRanges = cursor2.openEnd(curTo);
          }
          if (cursor2.to > to2)
            return openRanges + (cursor2.point && cursor2.to > to2 ? 1 : 0);
          pos = cursor2.to;
          cursor2.next();
        }
      }
      /**
      Create a range set for the given range or array of ranges. By
      default, this expects the ranges to be _sorted_ (by start
      position and, if two start at the same position,
      `value.startSide`). You can pass `true` as second argument to
      cause the method to sort them.
      */
      static of(ranges, sort = false) {
        let build = new RangeSetBuilder();
        for (let range of ranges instanceof Range$1 ? [ranges] : sort ? lazySort(ranges) : ranges)
          build.add(range.from, range.to, range.value);
        return build.finish();
      }
      /**
      Join an array of range sets into a single set.
      */
      static join(sets) {
        if (!sets.length)
          return RangeSet.empty;
        let result = sets[sets.length - 1];
        for (let i2 = sets.length - 2; i2 >= 0; i2--) {
          for (let layer2 = sets[i2]; layer2 != RangeSet.empty; layer2 = layer2.nextLayer)
            result = new RangeSet(layer2.chunkPos, layer2.chunk, result, Math.max(layer2.maxPoint, result.maxPoint));
        }
        return result;
      }
    }
    RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
    function lazySort(ranges) {
      if (ranges.length > 1)
        for (let prev = ranges[0], i2 = 1; i2 < ranges.length; i2++) {
          let cur2 = ranges[i2];
          if (cmpRange(prev, cur2) > 0)
            return ranges.slice().sort(cmpRange);
          prev = cur2;
        }
      return ranges;
    }
    RangeSet.empty.nextLayer = RangeSet.empty;
    class RangeSetBuilder {
      finishChunk(newArrays) {
        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
        this.chunkPos.push(this.chunkStart);
        this.chunkStart = -1;
        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
        this.maxPoint = -1;
        if (newArrays) {
          this.from = [];
          this.to = [];
          this.value = [];
        }
      }
      /**
      Create an empty builder.
      */
      constructor() {
        this.chunks = [];
        this.chunkPos = [];
        this.chunkStart = -1;
        this.last = null;
        this.lastFrom = -1e9;
        this.lastTo = -1e9;
        this.from = [];
        this.to = [];
        this.value = [];
        this.maxPoint = -1;
        this.setMaxPoint = -1;
        this.nextLayer = null;
      }
      /**
      Add a range. Ranges should be added in sorted (by `from` and
      `value.startSide`) order.
      */
      add(from2, to2, value) {
        if (!this.addInner(from2, to2, value))
          (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from2, to2, value);
      }
      /**
      @internal
      */
      addInner(from2, to2, value) {
        let diff = from2 - this.lastTo || value.startSide - this.last.endSide;
        if (diff <= 0 && (from2 - this.lastFrom || value.startSide - this.last.startSide) < 0)
          throw new Error("Ranges must be added sorted by `from` position and `startSide`");
        if (diff < 0)
          return false;
        if (this.from.length == 250)
          this.finishChunk(true);
        if (this.chunkStart < 0)
          this.chunkStart = from2;
        this.from.push(from2 - this.chunkStart);
        this.to.push(to2 - this.chunkStart);
        this.last = value;
        this.lastFrom = from2;
        this.lastTo = to2;
        this.value.push(value);
        if (value.point)
          this.maxPoint = Math.max(this.maxPoint, to2 - from2);
        return true;
      }
      /**
      @internal
      */
      addChunk(from2, chunk) {
        if ((from2 - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
          return false;
        if (this.from.length)
          this.finishChunk(true);
        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
        this.chunks.push(chunk);
        this.chunkPos.push(from2);
        let last = chunk.value.length - 1;
        this.last = chunk.value[last];
        this.lastFrom = chunk.from[last] + from2;
        this.lastTo = chunk.to[last] + from2;
        return true;
      }
      /**
      Finish the range set. Returns the new set. The builder can't be
      used anymore after this has been called.
      */
      finish() {
        return this.finishInner(RangeSet.empty);
      }
      /**
      @internal
      */
      finishInner(next) {
        if (this.from.length)
          this.finishChunk(false);
        if (this.chunks.length == 0)
          return next;
        let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
        this.from = null;
        return result;
      }
    }
    function findSharedChunks(a, b, textDiff) {
      let inA = /* @__PURE__ */ new Map();
      for (let set2 of a)
        for (let i2 = 0; i2 < set2.chunk.length; i2++)
          if (set2.chunk[i2].maxPoint <= 0)
            inA.set(set2.chunk[i2], set2.chunkPos[i2]);
      let shared = /* @__PURE__ */ new Set();
      for (let set2 of b)
        for (let i2 = 0; i2 < set2.chunk.length; i2++) {
          let known = inA.get(set2.chunk[i2]);
          if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set2.chunkPos[i2] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set2.chunk[i2].length)))
            shared.add(set2.chunk[i2]);
        }
      return shared;
    }
    class LayerCursor {
      constructor(layer2, skip2, minPoint, rank = 0) {
        this.layer = layer2;
        this.skip = skip2;
        this.minPoint = minPoint;
        this.rank = rank;
      }
      get startSide() {
        return this.value ? this.value.startSide : 0;
      }
      get endSide() {
        return this.value ? this.value.endSide : 0;
      }
      goto(pos, side = -1e9) {
        this.chunkIndex = this.rangeIndex = 0;
        this.gotoInner(pos, side, false);
        return this;
      }
      gotoInner(pos, side, forward) {
        while (this.chunkIndex < this.layer.chunk.length) {
          let next = this.layer.chunk[this.chunkIndex];
          if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
            break;
          this.chunkIndex++;
          forward = false;
        }
        if (this.chunkIndex < this.layer.chunk.length) {
          let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
          if (!forward || this.rangeIndex < rangeIndex)
            this.setRangeIndex(rangeIndex);
        }
        this.next();
      }
      forward(pos, side) {
        if ((this.to - pos || this.endSide - side) < 0)
          this.gotoInner(pos, side, true);
      }
      next() {
        for (; ; ) {
          if (this.chunkIndex == this.layer.chunk.length) {
            this.from = this.to = 1e9;
            this.value = null;
            break;
          } else {
            let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
            let from2 = chunkPos + chunk.from[this.rangeIndex];
            this.from = from2;
            this.to = chunkPos + chunk.to[this.rangeIndex];
            this.value = chunk.value[this.rangeIndex];
            this.setRangeIndex(this.rangeIndex + 1);
            if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
              break;
          }
        }
      }
      setRangeIndex(index2) {
        if (index2 == this.layer.chunk[this.chunkIndex].value.length) {
          this.chunkIndex++;
          if (this.skip) {
            while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
              this.chunkIndex++;
          }
          this.rangeIndex = 0;
        } else {
          this.rangeIndex = index2;
        }
      }
      nextChunk() {
        this.chunkIndex++;
        this.rangeIndex = 0;
        this.next();
      }
      compare(other) {
        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
      }
    }
    class HeapCursor {
      constructor(heap) {
        this.heap = heap;
      }
      static from(sets, skip2 = null, minPoint = -1) {
        let heap = [];
        for (let i2 = 0; i2 < sets.length; i2++) {
          for (let cur2 = sets[i2]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
            if (cur2.maxPoint >= minPoint)
              heap.push(new LayerCursor(cur2, skip2, minPoint, i2));
          }
        }
        return heap.length == 1 ? heap[0] : new HeapCursor(heap);
      }
      get startSide() {
        return this.value ? this.value.startSide : 0;
      }
      goto(pos, side = -1e9) {
        for (let cur2 of this.heap)
          cur2.goto(pos, side);
        for (let i2 = this.heap.length >> 1; i2 >= 0; i2--)
          heapBubble(this.heap, i2);
        this.next();
        return this;
      }
      forward(pos, side) {
        for (let cur2 of this.heap)
          cur2.forward(pos, side);
        for (let i2 = this.heap.length >> 1; i2 >= 0; i2--)
          heapBubble(this.heap, i2);
        if ((this.to - pos || this.value.endSide - side) < 0)
          this.next();
      }
      next() {
        if (this.heap.length == 0) {
          this.from = this.to = 1e9;
          this.value = null;
          this.rank = -1;
        } else {
          let top2 = this.heap[0];
          this.from = top2.from;
          this.to = top2.to;
          this.value = top2.value;
          this.rank = top2.rank;
          if (top2.value)
            top2.next();
          heapBubble(this.heap, 0);
        }
      }
    }
    function heapBubble(heap, index2) {
      for (let cur2 = heap[index2]; ; ) {
        let childIndex = (index2 << 1) + 1;
        if (childIndex >= heap.length)
          break;
        let child = heap[childIndex];
        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
          child = heap[childIndex + 1];
          childIndex++;
        }
        if (cur2.compare(child) < 0)
          break;
        heap[childIndex] = cur2;
        heap[index2] = child;
        index2 = childIndex;
      }
    }
    class SpanCursor {
      constructor(sets, skip2, minPoint) {
        this.minPoint = minPoint;
        this.active = [];
        this.activeTo = [];
        this.activeRank = [];
        this.minActive = -1;
        this.point = null;
        this.pointFrom = 0;
        this.pointRank = 0;
        this.to = -1e9;
        this.endSide = 0;
        this.openStart = -1;
        this.cursor = HeapCursor.from(sets, skip2, minPoint);
      }
      goto(pos, side = -1e9) {
        this.cursor.goto(pos, side);
        this.active.length = this.activeTo.length = this.activeRank.length = 0;
        this.minActive = -1;
        this.to = pos;
        this.endSide = side;
        this.openStart = -1;
        this.next();
        return this;
      }
      forward(pos, side) {
        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
          this.removeActive(this.minActive);
        this.cursor.forward(pos, side);
      }
      removeActive(index2) {
        remove(this.active, index2);
        remove(this.activeTo, index2);
        remove(this.activeRank, index2);
        this.minActive = findMinIndex(this.active, this.activeTo);
      }
      addActive(trackOpen) {
        let i2 = 0, { value, to: to2, rank } = this.cursor;
        while (i2 < this.activeRank.length && (rank - this.activeRank[i2] || to2 - this.activeTo[i2]) > 0)
          i2++;
        insert(this.active, i2, value);
        insert(this.activeTo, i2, to2);
        insert(this.activeRank, i2, rank);
        if (trackOpen)
          insert(trackOpen, i2, this.cursor.from);
        this.minActive = findMinIndex(this.active, this.activeTo);
      }
      // After calling this, if `this.point` != null, the next range is a
      // point. Otherwise, it's a regular range, covered by `this.active`.
      next() {
        let from2 = this.to, wasPoint = this.point;
        this.point = null;
        let trackOpen = this.openStart < 0 ? [] : null;
        for (; ; ) {
          let a = this.minActive;
          if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
            if (this.activeTo[a] > from2) {
              this.to = this.activeTo[a];
              this.endSide = this.active[a].endSide;
              break;
            }
            this.removeActive(a);
            if (trackOpen)
              remove(trackOpen, a);
          } else if (!this.cursor.value) {
            this.to = this.endSide = 1e9;
            break;
          } else if (this.cursor.from > from2) {
            this.to = this.cursor.from;
            this.endSide = this.cursor.startSide;
            break;
          } else {
            let nextVal = this.cursor.value;
            if (!nextVal.point) {
              this.addActive(trackOpen);
              this.cursor.next();
            } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
              this.cursor.next();
            } else {
              this.point = nextVal;
              this.pointFrom = this.cursor.from;
              this.pointRank = this.cursor.rank;
              this.to = this.cursor.to;
              this.endSide = nextVal.endSide;
              this.cursor.next();
              this.forward(this.to, this.endSide);
              break;
            }
          }
        }
        if (trackOpen) {
          this.openStart = 0;
          for (let i2 = trackOpen.length - 1; i2 >= 0 && trackOpen[i2] < from2; i2--)
            this.openStart++;
        }
      }
      activeForPoint(to2) {
        if (!this.active.length)
          return this.active;
        let active = [];
        for (let i2 = this.active.length - 1; i2 >= 0; i2--) {
          if (this.activeRank[i2] < this.pointRank)
            break;
          if (this.activeTo[i2] > to2 || this.activeTo[i2] == to2 && this.active[i2].endSide >= this.point.endSide)
            active.push(this.active[i2]);
        }
        return active.reverse();
      }
      openEnd(to2) {
        let open = 0;
        for (let i2 = this.activeTo.length - 1; i2 >= 0 && this.activeTo[i2] > to2; i2--)
          open++;
        return open;
      }
    }
    function compare(a, startA, b, startB, length, comparator) {
      a.goto(startA);
      b.goto(startB);
      let endB = startB + length;
      let pos = startB, dPos = startB - startA;
      for (; ; ) {
        let dEnd = a.to + dPos - b.to, diff = dEnd || a.endSide - b.endSide;
        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
        if (a.point || b.point) {
          if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))
            comparator.comparePoint(pos, clipEnd, a.point, b.point);
        } else {
          if (clipEnd > pos && !sameValues(a.active, b.active))
            comparator.compareRange(pos, clipEnd, a.active, b.active);
        }
        if (end > endB)
          break;
        if ((dEnd || a.openEnd != b.openEnd) && comparator.boundChange)
          comparator.boundChange(end);
        pos = end;
        if (diff <= 0)
          a.next();
        if (diff >= 0)
          b.next();
      }
    }
    function sameValues(a, b) {
      if (a.length != b.length)
        return false;
      for (let i2 = 0; i2 < a.length; i2++)
        if (a[i2] != b[i2] && !a[i2].eq(b[i2]))
          return false;
      return true;
    }
    function remove(array, index2) {
      for (let i2 = index2, e = array.length - 1; i2 < e; i2++)
        array[i2] = array[i2 + 1];
      array.pop();
    }
    function insert(array, index2, value) {
      for (let i2 = array.length - 1; i2 >= index2; i2--)
        array[i2 + 1] = array[i2];
      array[index2] = value;
    }
    function findMinIndex(value, array) {
      let found = -1, foundPos = 1e9;
      for (let i2 = 0; i2 < array.length; i2++)
        if ((array[i2] - foundPos || value[i2].endSide - value[found].endSide) < 0) {
          found = i2;
          foundPos = array[i2];
        }
      return found;
    }
    function countColumn(string2, tabSize, to2 = string2.length) {
      let n = 0;
      for (let i2 = 0; i2 < to2 && i2 < string2.length; ) {
        if (string2.charCodeAt(i2) == 9) {
          n += tabSize - n % tabSize;
          i2++;
        } else {
          n++;
          i2 = findClusterBreak(string2, i2);
        }
      }
      return n;
    }
    function findColumn$1(string2, col, tabSize, strict) {
      for (let i2 = 0, n = 0; ; ) {
        if (n >= col)
          return i2;
        if (i2 == string2.length)
          break;
        n += string2.charCodeAt(i2) == 9 ? tabSize - n % tabSize : 1;
        i2 = findClusterBreak(string2, i2);
      }
      return strict === true ? -1 : string2.length;
    }
    const C = "";
    const COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
    const SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
    const top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
    class StyleModule {
      // :: (Object<Style>, ?{finish: ?(string)  string})
      // Create a style module from the given spec.
      //
      // When `finish` is given, it is called on regular (non-`@`)
      // selectors (after `&` expansion) to compute the final selector.
      constructor(spec, options) {
        this.rules = [];
        let { finish } = options || {};
        function splitSelector(selector) {
          return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
        }
        function render(selectors, spec2, target, isKeyframes) {
          let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
          if (isAt && spec2 == null) return target.push(selectors[0] + ";");
          for (let prop in spec2) {
            let value = spec2[prop];
            if (/&/.test(prop)) {
              render(
                prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),
                value,
                target
              );
            } else if (value && typeof value == "object") {
              if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
              render(splitSelector(prop), value, local, keyframes);
            } else if (value != null) {
              local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
            }
          }
          if (local.length || keyframes) {
            target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
          }
        }
        for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);
      }
      // :: ()  string
      // Returns a string containing the module's CSS rules.
      getRules() {
        return this.rules.join("\n");
      }
      // :: ()  string
      // Generate a new unique CSS class name.
      static newName() {
        let id2 = top[COUNT] || 1;
        top[COUNT] = id2 + 1;
        return C + id2.toString(36);
      }
      // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
      //
      // Mount the given set of modules in the given DOM root, which ensures
      // that the CSS rules defined by the module are available in that
      // context.
      //
      // Rules are only added to the document once per root.
      //
      // Rule order will follow the order of the modules, so that rules from
      // modules later in the array take precedence of those from earlier
      // modules. If you call this function multiple times for the same root
      // in a way that changes the order of already mounted modules, the old
      // order will be changed.
      //
      // If a Content Security Policy nonce is provided, it is added to
      // the `<style>` tag generated by the library.
      static mount(root, modules, options) {
        let set2 = root[SET], nonce = options && options.nonce;
        if (!set2) set2 = new StyleSet(root, nonce);
        else if (nonce) set2.setNonce(nonce);
        set2.mount(Array.isArray(modules) ? modules : [modules], root);
      }
    }
    let adoptedSet = /* @__PURE__ */ new Map();
    class StyleSet {
      constructor(root, nonce) {
        let doc2 = root.ownerDocument || root, win = doc2.defaultView;
        if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
          let adopted = adoptedSet.get(doc2);
          if (adopted) return root[SET] = adopted;
          this.sheet = new win.CSSStyleSheet();
          adoptedSet.set(doc2, this);
        } else {
          this.styleTag = doc2.createElement("style");
          if (nonce) this.styleTag.setAttribute("nonce", nonce);
        }
        this.modules = [];
        root[SET] = this;
      }
      mount(modules, root) {
        let sheet = this.sheet;
        let pos = 0, j = 0;
        for (let i2 = 0; i2 < modules.length; i2++) {
          let mod = modules[i2], index2 = this.modules.indexOf(mod);
          if (index2 < j && index2 > -1) {
            this.modules.splice(index2, 1);
            j--;
            index2 = -1;
          }
          if (index2 == -1) {
            this.modules.splice(j++, 0, mod);
            if (sheet) for (let k = 0; k < mod.rules.length; k++)
              sheet.insertRule(mod.rules[k], pos++);
          } else {
            while (j < index2) pos += this.modules[j++].rules.length;
            pos += mod.rules.length;
            j++;
          }
        }
        if (sheet) {
          if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)
            root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];
        } else {
          let text = "";
          for (let i2 = 0; i2 < this.modules.length; i2++)
            text += this.modules[i2].getRules() + "\n";
          this.styleTag.textContent = text;
          let target = root.head || root;
          if (this.styleTag.parentNode != target)
            target.insertBefore(this.styleTag, target.firstChild);
        }
      }
      setNonce(nonce) {
        if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
          this.styleTag.setAttribute("nonce", nonce);
      }
    }
    var base = {
      8: "Backspace",
      9: "Tab",
      10: "Enter",
      12: "NumLock",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      44: "PrintScreen",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Meta",
      92: "Meta",
      106: "*",
      107: "+",
      108: ",",
      109: "-",
      110: ".",
      111: "/",
      144: "NumLock",
      145: "ScrollLock",
      160: "Shift",
      161: "Shift",
      162: "Control",
      163: "Control",
      164: "Alt",
      165: "Alt",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'"
    };
    var shift = {
      48: ")",
      49: "!",
      50: "@",
      51: "#",
      52: "$",
      53: "%",
      54: "^",
      55: "&",
      56: "*",
      57: "(",
      59: ":",
      61: "+",
      173: "_",
      186: ":",
      187: "+",
      188: "<",
      189: "_",
      190: ">",
      191: "?",
      192: "~",
      219: "{",
      220: "|",
      221: "}",
      222: '"'
    };
    var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
    var ie$1 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
    for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;
    for (var i = 65; i <= 90; i++) {
      base[i] = String.fromCharCode(i + 32);
      shift[i] = String.fromCharCode(i);
    }
    for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
    function keyName(event) {
      var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie$1 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
      var name2 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
      if (name2 == "Esc") name2 = "Escape";
      if (name2 == "Del") name2 = "Delete";
      if (name2 == "Left") name2 = "ArrowLeft";
      if (name2 == "Up") name2 = "ArrowUp";
      if (name2 == "Right") name2 = "ArrowRight";
      if (name2 == "Down") name2 = "ArrowDown";
      return name2;
    }
    function crelt() {
      var elt = arguments[0];
      if (typeof elt == "string") elt = document.createElement(elt);
      var i2 = 1, next = arguments[1];
      if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
        for (var name2 in next) if (Object.prototype.hasOwnProperty.call(next, name2)) {
          var value = next[name2];
          if (typeof value == "string") elt.setAttribute(name2, value);
          else if (value != null) elt[name2] = value;
        }
        i2++;
      }
      for (; i2 < arguments.length; i2++) add(elt, arguments[i2]);
      return elt;
    }
    function add(elt, child) {
      if (typeof child == "string") {
        elt.appendChild(document.createTextNode(child));
      } else if (child == null) ;
      else if (child.nodeType != null) {
        elt.appendChild(child);
      } else if (Array.isArray(child)) {
        for (var i2 = 0; i2 < child.length; i2++) add(elt, child[i2]);
      } else {
        throw new RangeError("Unsupported child node: " + child);
      }
    }
    let nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
    let doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
    const ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
    const ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
    const ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
    const ie = !!(ie_upto10 || ie_11up || ie_edge);
    const gecko = !ie && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
    const chrome = !ie && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
    const webkit = "webkitFontSmoothing" in doc.documentElement.style;
    const safari = !ie && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
    const ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
    var browser = {
      mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
      windows: /* @__PURE__ */ /Win/.test(nav.platform),
      linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
      ie,
      ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
      gecko,
      gecko_version: gecko ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
      chrome: !!chrome,
      chrome_version: chrome ? +chrome[1] : 0,
      ios,
      android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
      webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
      safari,
      safari_version: safari ? +(/* @__PURE__ */ /\bVersion\/(\d+(\.\d+)?)/.exec(nav.userAgent) || [0, 0])[1] : 0,
      tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
    };
    function getSelection(root) {
      let target;
      if (root.nodeType == 11) {
        target = root.getSelection ? root : root.ownerDocument;
      } else {
        target = root;
      }
      return target.getSelection();
    }
    function contains(dom, node) {
      return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
    }
    function hasSelection(dom, selection2) {
      if (!selection2.anchorNode)
        return false;
      try {
        return contains(dom, selection2.anchorNode);
      } catch (_) {
        return false;
      }
    }
    function clientRectsFor(dom) {
      if (dom.nodeType == 3)
        return textRange(dom, 0, dom.nodeValue.length).getClientRects();
      else if (dom.nodeType == 1)
        return dom.getClientRects();
      else
        return [];
    }
    function isEquivalentPosition(node, off, targetNode, targetOff) {
      return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
    }
    function domIndex(node) {
      for (var index2 = 0; ; index2++) {
        node = node.previousSibling;
        if (!node)
          return index2;
      }
    }
    function isBlockElement(node) {
      return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
    }
    function scanFor(node, off, targetNode, targetOff, dir) {
      for (; ; ) {
        if (node == targetNode && off == targetOff)
          return true;
        if (off == (dir < 0 ? 0 : maxOffset(node))) {
          if (node.nodeName == "DIV")
            return false;
          let parent = node.parentNode;
          if (!parent || parent.nodeType != 1)
            return false;
          off = domIndex(node) + (dir < 0 ? 0 : 1);
          node = parent;
        } else if (node.nodeType == 1) {
          node = node.childNodes[off + (dir < 0 ? -1 : 0)];
          if (node.nodeType == 1 && node.contentEditable == "false")
            return false;
          off = dir < 0 ? maxOffset(node) : 0;
        } else {
          return false;
        }
      }
    }
    function maxOffset(node) {
      return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
    }
    function flattenRect(rect, left) {
      let x = left ? rect.left : rect.right;
      return { left: x, right: x, top: rect.top, bottom: rect.bottom };
    }
    function windowRect(win) {
      let vp = win.visualViewport;
      if (vp)
        return {
          left: 0,
          right: vp.width,
          top: 0,
          bottom: vp.height
        };
      return {
        left: 0,
        right: win.innerWidth,
        top: 0,
        bottom: win.innerHeight
      };
    }
    function getScale(elt, rect) {
      let scaleX = rect.width / elt.offsetWidth;
      let scaleY = rect.height / elt.offsetHeight;
      if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1)
        scaleX = 1;
      if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1)
        scaleY = 1;
      return { scaleX, scaleY };
    }
    function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
      let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
      for (let cur2 = dom, stop = false; cur2 && !stop; ) {
        if (cur2.nodeType == 1) {
          let bounding, top2 = cur2 == doc2.body;
          let scaleX = 1, scaleY = 1;
          if (top2) {
            bounding = windowRect(win);
          } else {
            if (/^(fixed|sticky)$/.test(getComputedStyle(cur2).position))
              stop = true;
            if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
              cur2 = cur2.assignedSlot || cur2.parentNode;
              continue;
            }
            let rect2 = cur2.getBoundingClientRect();
            ({ scaleX, scaleY } = getScale(cur2, rect2));
            bounding = {
              left: rect2.left,
              right: rect2.left + cur2.clientWidth * scaleX,
              top: rect2.top,
              bottom: rect2.top + cur2.clientHeight * scaleY
            };
          }
          let moveX = 0, moveY = 0;
          if (y == "nearest") {
            if (rect.top < bounding.top) {
              moveY = rect.top - (bounding.top + yMargin);
              if (side > 0 && rect.bottom > bounding.bottom + moveY)
                moveY = rect.bottom - bounding.bottom + yMargin;
            } else if (rect.bottom > bounding.bottom) {
              moveY = rect.bottom - bounding.bottom + yMargin;
              if (side < 0 && rect.top - moveY < bounding.top)
                moveY = rect.top - (bounding.top + yMargin);
            }
          } else {
            let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
            let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
            moveY = targetTop - bounding.top;
          }
          if (x == "nearest") {
            if (rect.left < bounding.left) {
              moveX = rect.left - (bounding.left + xMargin);
              if (side > 0 && rect.right > bounding.right + moveX)
                moveX = rect.right - bounding.right + xMargin;
            } else if (rect.right > bounding.right) {
              moveX = rect.right - bounding.right + xMargin;
              if (side < 0 && rect.left < bounding.left + moveX)
                moveX = rect.left - (bounding.left + xMargin);
            }
          } else {
            let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
            moveX = targetLeft - bounding.left;
          }
          if (moveX || moveY) {
            if (top2) {
              win.scrollBy(moveX, moveY);
            } else {
              let movedX = 0, movedY = 0;
              if (moveY) {
                let start = cur2.scrollTop;
                cur2.scrollTop += moveY / scaleY;
                movedY = (cur2.scrollTop - start) * scaleY;
              }
              if (moveX) {
                let start = cur2.scrollLeft;
                cur2.scrollLeft += moveX / scaleX;
                movedX = (cur2.scrollLeft - start) * scaleX;
              }
              rect = {
                left: rect.left - movedX,
                top: rect.top - movedY,
                right: rect.right - movedX,
                bottom: rect.bottom - movedY
              };
              if (movedX && Math.abs(movedX - moveX) < 1)
                x = "nearest";
              if (movedY && Math.abs(movedY - moveY) < 1)
                y = "nearest";
            }
          }
          if (top2)
            break;
          if (rect.top < bounding.top || rect.bottom > bounding.bottom || rect.left < bounding.left || rect.right > bounding.right)
            rect = {
              left: Math.max(rect.left, bounding.left),
              right: Math.min(rect.right, bounding.right),
              top: Math.max(rect.top, bounding.top),
              bottom: Math.min(rect.bottom, bounding.bottom)
            };
          cur2 = cur2.assignedSlot || cur2.parentNode;
        } else if (cur2.nodeType == 11) {
          cur2 = cur2.host;
        } else {
          break;
        }
      }
    }
    function scrollableParents(dom) {
      let doc2 = dom.ownerDocument, x, y;
      for (let cur2 = dom.parentNode; cur2; ) {
        if (cur2 == doc2.body || x && y) {
          break;
        } else if (cur2.nodeType == 1) {
          if (!y && cur2.scrollHeight > cur2.clientHeight)
            y = cur2;
          if (!x && cur2.scrollWidth > cur2.clientWidth)
            x = cur2;
          cur2 = cur2.assignedSlot || cur2.parentNode;
        } else if (cur2.nodeType == 11) {
          cur2 = cur2.host;
        } else {
          break;
        }
      }
      return { x, y };
    }
    class DOMSelectionState {
      constructor() {
        this.anchorNode = null;
        this.anchorOffset = 0;
        this.focusNode = null;
        this.focusOffset = 0;
      }
      eq(domSel) {
        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
      }
      setRange(range) {
        let { anchorNode, focusNode } = range;
        this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
      }
      set(anchorNode, anchorOffset, focusNode, focusOffset) {
        this.anchorNode = anchorNode;
        this.anchorOffset = anchorOffset;
        this.focusNode = focusNode;
        this.focusOffset = focusOffset;
      }
    }
    let preventScrollSupported = null;
    if (browser.safari && browser.safari_version >= 26)
      preventScrollSupported = false;
    function focusPreventScroll(dom) {
      if (dom.setActive)
        return dom.setActive();
      if (preventScrollSupported)
        return dom.focus(preventScrollSupported);
      let stack = [];
      for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
        stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
        if (cur2 == cur2.ownerDocument)
          break;
      }
      dom.focus(preventScrollSupported == null ? {
        get preventScroll() {
          preventScrollSupported = { preventScroll: true };
          return true;
        }
      } : void 0);
      if (!preventScrollSupported) {
        preventScrollSupported = false;
        for (let i2 = 0; i2 < stack.length; ) {
          let elt = stack[i2++], top2 = stack[i2++], left = stack[i2++];
          if (elt.scrollTop != top2)
            elt.scrollTop = top2;
          if (elt.scrollLeft != left)
            elt.scrollLeft = left;
        }
      }
    }
    let scratchRange;
    function textRange(node, from2, to2 = from2) {
      let range = scratchRange || (scratchRange = document.createRange());
      range.setEnd(node, to2);
      range.setStart(node, from2);
      return range;
    }
    function dispatchKey(elt, name2, code2, mods) {
      let options = { key: name2, code: name2, keyCode: code2, which: code2, cancelable: true };
      if (mods)
        ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);
      let down = new KeyboardEvent("keydown", options);
      down.synthetic = true;
      elt.dispatchEvent(down);
      let up = new KeyboardEvent("keyup", options);
      up.synthetic = true;
      elt.dispatchEvent(up);
      return down.defaultPrevented || up.defaultPrevented;
    }
    function getRoot(node) {
      while (node) {
        if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
          return node;
        node = node.assignedSlot || node.parentNode;
      }
      return null;
    }
    function clearAttributes(node) {
      while (node.attributes.length)
        node.removeAttributeNode(node.attributes[0]);
    }
    function atElementStart(doc2, selection2) {
      let node = selection2.focusNode, offset = selection2.focusOffset;
      if (!node || selection2.anchorNode != node || selection2.anchorOffset != offset)
        return false;
      offset = Math.min(offset, maxOffset(node));
      for (; ; ) {
        if (offset) {
          if (node.nodeType != 1)
            return false;
          let prev = node.childNodes[offset - 1];
          if (prev.contentEditable == "false")
            offset--;
          else {
            node = prev;
            offset = maxOffset(node);
          }
        } else if (node == doc2) {
          return true;
        } else {
          offset = domIndex(node);
          node = node.parentNode;
        }
      }
    }
    function isScrolledToBottom(elt) {
      return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
    }
    function textNodeBefore(startNode, startOffset) {
      for (let node = startNode, offset = startOffset; ; ) {
        if (node.nodeType == 3 && offset > 0) {
          return { node, offset };
        } else if (node.nodeType == 1 && offset > 0) {
          if (node.contentEditable == "false")
            return null;
          node = node.childNodes[offset - 1];
          offset = maxOffset(node);
        } else if (node.parentNode && !isBlockElement(node)) {
          offset = domIndex(node);
          node = node.parentNode;
        } else {
          return null;
        }
      }
    }
    function textNodeAfter(startNode, startOffset) {
      for (let node = startNode, offset = startOffset; ; ) {
        if (node.nodeType == 3 && offset < node.nodeValue.length) {
          return { node, offset };
        } else if (node.nodeType == 1 && offset < node.childNodes.length) {
          if (node.contentEditable == "false")
            return null;
          node = node.childNodes[offset];
          offset = 0;
        } else if (node.parentNode && !isBlockElement(node)) {
          offset = domIndex(node) + 1;
          node = node.parentNode;
        } else {
          return null;
        }
      }
    }
    class DOMPos {
      constructor(node, offset, precise = true) {
        this.node = node;
        this.offset = offset;
        this.precise = precise;
      }
      static before(dom, precise) {
        return new DOMPos(dom.parentNode, domIndex(dom), precise);
      }
      static after(dom, precise) {
        return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
      }
    }
    const noChildren = [];
    class ContentView {
      constructor() {
        this.parent = null;
        this.dom = null;
        this.flags = 2;
      }
      get overrideDOMText() {
        return null;
      }
      get posAtStart() {
        return this.parent ? this.parent.posBefore(this) : 0;
      }
      get posAtEnd() {
        return this.posAtStart + this.length;
      }
      posBefore(view) {
        let pos = this.posAtStart;
        for (let child of this.children) {
          if (child == view)
            return pos;
          pos += child.length + child.breakAfter;
        }
        throw new RangeError("Invalid child in posBefore");
      }
      posAfter(view) {
        return this.posBefore(view) + view.length;
      }
      sync(view, track) {
        if (this.flags & 2) {
          let parent = this.dom;
          let prev = null, next;
          for (let child of this.children) {
            if (child.flags & 7) {
              if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
                let contentView = ContentView.get(next);
                if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                  child.reuseDOM(next);
              }
              child.sync(view, track);
              child.flags &= -8;
            }
            next = prev ? prev.nextSibling : parent.firstChild;
            if (track && !track.written && track.node == parent && next != child.dom)
              track.written = true;
            if (child.dom.parentNode == parent) {
              while (next && next != child.dom)
                next = rm$1(next);
            } else {
              parent.insertBefore(child.dom, next);
            }
            prev = child.dom;
          }
          next = prev ? prev.nextSibling : parent.firstChild;
          if (next && track && track.node == parent)
            track.written = true;
          while (next)
            next = rm$1(next);
        } else if (this.flags & 1) {
          for (let child of this.children)
            if (child.flags & 7) {
              child.sync(view, track);
              child.flags &= -8;
            }
        }
      }
      reuseDOM(_dom) {
      }
      localPosFromDOM(node, offset) {
        let after;
        if (node == this.dom) {
          after = this.dom.childNodes[offset];
        } else {
          let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
          for (; ; ) {
            let parent = node.parentNode;
            if (parent == this.dom)
              break;
            if (bias == 0 && parent.firstChild != parent.lastChild) {
              if (node == parent.firstChild)
                bias = -1;
              else
                bias = 1;
            }
            node = parent;
          }
          if (bias < 0)
            after = node;
          else
            after = node.nextSibling;
        }
        if (after == this.dom.firstChild)
          return 0;
        while (after && !ContentView.get(after))
          after = after.nextSibling;
        if (!after)
          return this.length;
        for (let i2 = 0, pos = 0; ; i2++) {
          let child = this.children[i2];
          if (child.dom == after)
            return pos;
          pos += child.length + child.breakAfter;
        }
      }
      domBoundsAround(from2, to2, offset = 0) {
        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
        for (let i2 = 0, pos = offset, prevEnd = offset; i2 < this.children.length; i2++) {
          let child = this.children[i2], end = pos + child.length;
          if (pos < from2 && end > to2)
            return child.domBoundsAround(from2, to2, pos);
          if (end >= from2 && fromI == -1) {
            fromI = i2;
            fromStart = pos;
          }
          if (pos > to2 && child.dom.parentNode == this.dom) {
            toI = i2;
            toEnd = prevEnd;
            break;
          }
          prevEnd = end;
          pos = end + child.breakAfter;
        }
        return {
          from: fromStart,
          to: toEnd < 0 ? offset + this.length : toEnd,
          startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
          endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
        };
      }
      markDirty(andParent = false) {
        this.flags |= 2;
        this.markParentsDirty(andParent);
      }
      markParentsDirty(childList) {
        for (let parent = this.parent; parent; parent = parent.parent) {
          if (childList)
            parent.flags |= 2;
          if (parent.flags & 1)
            return;
          parent.flags |= 1;
          childList = false;
        }
      }
      setParent(parent) {
        if (this.parent != parent) {
          this.parent = parent;
          if (this.flags & 7)
            this.markParentsDirty(true);
        }
      }
      setDOM(dom) {
        if (this.dom == dom)
          return;
        if (this.dom)
          this.dom.cmView = null;
        this.dom = dom;
        dom.cmView = this;
      }
      get rootView() {
        for (let v = this; ; ) {
          let parent = v.parent;
          if (!parent)
            return v;
          v = parent;
        }
      }
      replaceChildren(from2, to2, children = noChildren) {
        this.markDirty();
        for (let i2 = from2; i2 < to2; i2++) {
          let child = this.children[i2];
          if (child.parent == this && children.indexOf(child) < 0)
            child.destroy();
        }
        if (children.length < 250)
          this.children.splice(from2, to2 - from2, ...children);
        else
          this.children = [].concat(this.children.slice(0, from2), children, this.children.slice(to2));
        for (let i2 = 0; i2 < children.length; i2++)
          children[i2].setParent(this);
      }
      ignoreMutation(_rec) {
        return false;
      }
      ignoreEvent(_event) {
        return false;
      }
      childCursor(pos = this.length) {
        return new ChildCursor(this.children, pos, this.children.length);
      }
      childPos(pos, bias = 1) {
        return this.childCursor().findPos(pos, bias);
      }
      toString() {
        let name2 = this.constructor.name.replace("View", "");
        return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
      }
      static get(node) {
        return node.cmView;
      }
      get isEditable() {
        return true;
      }
      get isWidget() {
        return false;
      }
      get isHidden() {
        return false;
      }
      merge(from2, to2, source2, hasStart, openStart, openEnd) {
        return false;
      }
      become(other) {
        return false;
      }
      canReuseDOM(other) {
        return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
      }
      // When this is a zero-length view with a side, this should return a
      // number <= 0 to indicate it is before its position, or a
      // number > 0 when after its position.
      getSide() {
        return 0;
      }
      destroy() {
        for (let child of this.children)
          if (child.parent == this)
            child.destroy();
        this.parent = null;
      }
    }
    ContentView.prototype.breakAfter = 0;
    function rm$1(dom) {
      let next = dom.nextSibling;
      dom.parentNode.removeChild(dom);
      return next;
    }
    class ChildCursor {
      constructor(children, pos, i2) {
        this.children = children;
        this.pos = pos;
        this.i = i2;
        this.off = 0;
      }
      findPos(pos, bias = 1) {
        for (; ; ) {
          if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
            this.off = pos - this.pos;
            return this;
          }
          let next = this.children[--this.i];
          this.pos -= next.length + next.breakAfter;
        }
      }
    }
    function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
      let { children } = parent;
      let before = children.length ? children[fromI] : null;
      let last = insert2.length ? insert2[insert2.length - 1] : null;
      let breakAtEnd = last ? last.breakAfter : breakAtStart;
      if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last : null, fromOff == 0, openStart, openEnd))
        return;
      if (toI < children.length) {
        let after = children[toI];
        if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {
          if (fromI == toI) {
            after = after.split(toOff);
            toOff = 0;
          }
          if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
            insert2[insert2.length - 1] = after;
          } else {
            if (toOff || after.children.length && !after.children[0].length)
              after.merge(0, toOff, null, false, 0, openEnd);
            insert2.push(after);
          }
        } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
          if (last)
            last.breakAfter = 1;
          else
            breakAtStart = 1;
        }
        toI++;
      }
      if (before) {
        before.breakAfter = breakAtStart;
        if (fromOff > 0) {
          if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
            before.breakAfter = insert2.shift().breakAfter;
          } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
            before.merge(fromOff, before.length, null, false, openStart, 0);
          }
          fromI++;
        }
      }
      while (fromI < toI && insert2.length) {
        if (children[toI - 1].become(insert2[insert2.length - 1])) {
          toI--;
          insert2.pop();
          openEnd = insert2.length ? 0 : openStart;
        } else if (children[fromI].become(insert2[0])) {
          fromI++;
          insert2.shift();
          openStart = insert2.length ? 0 : openEnd;
        } else {
          break;
        }
      }
      if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
        fromI--;
      if (fromI < toI || insert2.length)
        parent.replaceChildren(fromI, toI, insert2);
    }
    function mergeChildrenInto(parent, from2, to2, insert2, openStart, openEnd) {
      let cur2 = parent.childCursor();
      let { i: toI, off: toOff } = cur2.findPos(to2, 1);
      let { i: fromI, off: fromOff } = cur2.findPos(from2, -1);
      let dLen = from2 - to2;
      for (let view of insert2)
        dLen += view.length;
      parent.length += dLen;
      replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
    }
    const MaxJoinLen = 256;
    class TextView extends ContentView {
      constructor(text) {
        super();
        this.text = text;
      }
      get length() {
        return this.text.length;
      }
      createDOM(textDOM) {
        this.setDOM(textDOM || document.createTextNode(this.text));
      }
      sync(view, track) {
        if (!this.dom)
          this.createDOM();
        if (this.dom.nodeValue != this.text) {
          if (track && track.node == this.dom)
            track.written = true;
          this.dom.nodeValue = this.text;
        }
      }
      reuseDOM(dom) {
        if (dom.nodeType == 3)
          this.createDOM(dom);
      }
      merge(from2, to2, source2) {
        if (this.flags & 8 || source2 && (!(source2 instanceof TextView) || this.length - (to2 - from2) + source2.length > MaxJoinLen || source2.flags & 8))
          return false;
        this.text = this.text.slice(0, from2) + (source2 ? source2.text : "") + this.text.slice(to2);
        this.markDirty();
        return true;
      }
      split(from2) {
        let result = new TextView(this.text.slice(from2));
        this.text = this.text.slice(0, from2);
        this.markDirty();
        result.flags |= this.flags & 8;
        return result;
      }
      localPosFromDOM(node, offset) {
        return node == this.dom ? offset : offset ? this.text.length : 0;
      }
      domAtPos(pos) {
        return new DOMPos(this.dom, pos);
      }
      domBoundsAround(_from, _to, offset) {
        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
      }
      coordsAt(pos, side) {
        return textCoords(this.dom, pos, side);
      }
    }
    class MarkView extends ContentView {
      constructor(mark, children = [], length = 0) {
        super();
        this.mark = mark;
        this.children = children;
        this.length = length;
        for (let ch of children)
          ch.setParent(this);
      }
      setAttrs(dom) {
        clearAttributes(dom);
        if (this.mark.class)
          dom.className = this.mark.class;
        if (this.mark.attrs)
          for (let name2 in this.mark.attrs)
            dom.setAttribute(name2, this.mark.attrs[name2]);
        return dom;
      }
      canReuseDOM(other) {
        return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
      }
      reuseDOM(node) {
        if (node.nodeName == this.mark.tagName.toUpperCase()) {
          this.setDOM(node);
          this.flags |= 4 | 2;
        }
      }
      sync(view, track) {
        if (!this.dom)
          this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
        else if (this.flags & 4)
          this.setAttrs(this.dom);
        super.sync(view, track);
      }
      merge(from2, to2, source2, _hasStart, openStart, openEnd) {
        if (source2 && (!(source2 instanceof MarkView && source2.mark.eq(this.mark)) || from2 && openStart <= 0 || to2 < this.length && openEnd <= 0))
          return false;
        mergeChildrenInto(this, from2, to2, source2 ? source2.children.slice() : [], openStart - 1, openEnd - 1);
        this.markDirty();
        return true;
      }
      split(from2) {
        let result = [], off = 0, detachFrom = -1, i2 = 0;
        for (let elt of this.children) {
          let end = off + elt.length;
          if (end > from2)
            result.push(off < from2 ? elt.split(from2 - off) : elt);
          if (detachFrom < 0 && off >= from2)
            detachFrom = i2;
          off = end;
          i2++;
        }
        let length = this.length - from2;
        this.length = from2;
        if (detachFrom > -1) {
          this.children.length = detachFrom;
          this.markDirty();
        }
        return new MarkView(this.mark, result, length);
      }
      domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
      }
      coordsAt(pos, side) {
        return coordsInChildren(this, pos, side);
      }
    }
    function textCoords(text, pos, side) {
      let length = text.nodeValue.length;
      if (pos > length)
        pos = length;
      let from2 = pos, to2 = pos, flatten2 = 0;
      if (pos == 0 && side < 0 || pos == length && side >= 0) {
        if (!(browser.chrome || browser.gecko)) {
          if (pos) {
            from2--;
            flatten2 = 1;
          } else if (to2 < length) {
            to2++;
            flatten2 = -1;
          }
        }
      } else {
        if (side < 0)
          from2--;
        else if (to2 < length)
          to2++;
      }
      let rects = textRange(text, from2, to2).getClientRects();
      if (!rects.length)
        return null;
      let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
      if (browser.safari && !flatten2 && rect.width == 0)
        rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
      return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
    }
    class WidgetView extends ContentView {
      static create(widget, length, side) {
        return new WidgetView(widget, length, side);
      }
      constructor(widget, length, side) {
        super();
        this.widget = widget;
        this.length = length;
        this.side = side;
        this.prevWidget = null;
      }
      split(from2) {
        let result = WidgetView.create(this.widget, this.length - from2, this.side);
        this.length -= from2;
        return result;
      }
      sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
          if (this.dom && this.prevWidget)
            this.prevWidget.destroy(this.dom);
          this.prevWidget = null;
          this.setDOM(this.widget.toDOM(view));
          if (!this.widget.editable)
            this.dom.contentEditable = "false";
        }
      }
      getSide() {
        return this.side;
      }
      merge(from2, to2, source2, hasStart, openStart, openEnd) {
        if (source2 && (!(source2 instanceof WidgetView) || !this.widget.compare(source2.widget) || from2 > 0 && openStart <= 0 || to2 < this.length && openEnd <= 0))
          return false;
        this.length = from2 + (source2 ? source2.length : 0) + (this.length - to2);
        return true;
      }
      become(other) {
        if (other instanceof WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
          if (!this.widget.compare(other.widget))
            this.markDirty(true);
          if (this.dom && !this.prevWidget)
            this.prevWidget = this.widget;
          this.widget = other.widget;
          this.length = other.length;
          return true;
        }
        return false;
      }
      ignoreMutation() {
        return true;
      }
      ignoreEvent(event) {
        return this.widget.ignoreEvent(event);
      }
      get overrideDOMText() {
        if (this.length == 0)
          return Text.empty;
        let top2 = this;
        while (top2.parent)
          top2 = top2.parent;
        let { view } = top2, text = view && view.state.doc, start = this.posAtStart;
        return text ? text.slice(start, start + this.length) : Text.empty;
      }
      domAtPos(pos) {
        return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
      }
      domBoundsAround() {
        return null;
      }
      coordsAt(pos, side) {
        let custom = this.widget.coordsAt(this.dom, pos, side);
        if (custom)
          return custom;
        let rects = this.dom.getClientRects(), rect = null;
        if (!rects.length)
          return null;
        let fromBack = this.side ? this.side < 0 : pos > 0;
        for (let i2 = fromBack ? rects.length - 1 : 0; ; i2 += fromBack ? -1 : 1) {
          rect = rects[i2];
          if (pos > 0 ? i2 == 0 : i2 == rects.length - 1 || rect.top < rect.bottom)
            break;
        }
        return flattenRect(rect, !fromBack);
      }
      get isEditable() {
        return false;
      }
      get isWidget() {
        return true;
      }
      get isHidden() {
        return this.widget.isHidden;
      }
      destroy() {
        super.destroy();
        if (this.dom)
          this.widget.destroy(this.dom);
      }
    }
    class WidgetBufferView extends ContentView {
      constructor(side) {
        super();
        this.side = side;
      }
      get length() {
        return 0;
      }
      merge() {
        return false;
      }
      become(other) {
        return other instanceof WidgetBufferView && other.side == this.side;
      }
      split() {
        return new WidgetBufferView(this.side);
      }
      sync() {
        if (!this.dom) {
          let dom = document.createElement("img");
          dom.className = "cm-widgetBuffer";
          dom.setAttribute("aria-hidden", "true");
          this.setDOM(dom);
        }
      }
      getSide() {
        return this.side;
      }
      domAtPos(pos) {
        return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
      }
      localPosFromDOM() {
        return 0;
      }
      domBoundsAround() {
        return null;
      }
      coordsAt(pos) {
        return this.dom.getBoundingClientRect();
      }
      get overrideDOMText() {
        return Text.empty;
      }
      get isHidden() {
        return true;
      }
    }
    TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
    function inlineDOMAtPos(parent, pos) {
      let dom = parent.dom, { children } = parent, i2 = 0;
      for (let off = 0; i2 < children.length; i2++) {
        let child = children[i2], end = off + child.length;
        if (end == off && child.getSide() <= 0)
          continue;
        if (pos > off && pos < end && child.dom.parentNode == dom)
          return child.domAtPos(pos - off);
        if (pos <= off)
          break;
        off = end;
      }
      for (let j = i2; j > 0; j--) {
        let prev = children[j - 1];
        if (prev.dom.parentNode == dom)
          return prev.domAtPos(prev.length);
      }
      for (let j = i2; j < children.length; j++) {
        let next = children[j];
        if (next.dom.parentNode == dom)
          return next.domAtPos(0);
      }
      return new DOMPos(dom, 0);
    }
    function joinInlineInto(parent, view, open) {
      let last, { children } = parent;
      if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
        joinInlineInto(last, view.children[0], open - 1);
      } else {
        children.push(view);
        view.setParent(parent);
      }
      parent.length += view.length;
    }
    function coordsInChildren(view, pos, side) {
      let before = null, beforePos = -1, after = null, afterPos = -1;
      function scan(view2, pos2) {
        for (let i2 = 0, off = 0; i2 < view2.children.length && off <= pos2; i2++) {
          let child = view2.children[i2], end = off + child.length;
          if (end >= pos2) {
            if (child.children.length) {
              scan(child, pos2 - off);
            } else if ((!after || after.isHidden && (side > 0 || onSameLine(after, child))) && (end > pos2 || off == end && child.getSide() > 0)) {
              after = child;
              afterPos = pos2 - off;
            } else if (off < pos2 || off == end && child.getSide() < 0 && !child.isHidden) {
              before = child;
              beforePos = pos2 - off;
            }
          }
          off = end;
        }
      }
      scan(view, pos);
      let target = (side < 0 ? before : after) || before || after;
      if (target)
        return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
      return fallbackRect(view);
    }
    function fallbackRect(view) {
      let last = view.dom.lastChild;
      if (!last)
        return view.dom.getBoundingClientRect();
      let rects = clientRectsFor(last);
      return rects[rects.length - 1] || null;
    }
    function onSameLine(a, b) {
      let posA = a.coordsAt(0, 1), posB = b.coordsAt(0, 1);
      return posA && posB && posB.top < posA.bottom;
    }
    function combineAttrs(source2, target) {
      for (let name2 in source2) {
        if (name2 == "class" && target.class)
          target.class += " " + source2.class;
        else if (name2 == "style" && target.style)
          target.style += ";" + source2.style;
        else
          target[name2] = source2[name2];
      }
      return target;
    }
    const noAttrs$1 = /* @__PURE__ */ Object.create(null);
    function attrsEq(a, b, ignore) {
      if (a == b)
        return true;
      if (!a)
        a = noAttrs$1;
      if (!b)
        b = noAttrs$1;
      let keysA = Object.keys(a), keysB = Object.keys(b);
      if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
        return false;
      for (let key of keysA) {
        if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key]))
          return false;
      }
      return true;
    }
    function updateAttrs(dom, prev, attrs) {
      let changed = false;
      if (prev) {
        for (let name2 in prev)
          if (!(attrs && name2 in attrs)) {
            changed = true;
            if (name2 == "style")
              dom.style.cssText = "";
            else
              dom.removeAttribute(name2);
          }
      }
      if (attrs) {
        for (let name2 in attrs)
          if (!(prev && prev[name2] == attrs[name2])) {
            changed = true;
            if (name2 == "style")
              dom.style.cssText = attrs[name2];
            else
              dom.setAttribute(name2, attrs[name2]);
          }
      }
      return changed;
    }
    function getAttrs(dom) {
      let attrs = /* @__PURE__ */ Object.create(null);
      for (let i2 = 0; i2 < dom.attributes.length; i2++) {
        let attr = dom.attributes[i2];
        attrs[attr.name] = attr.value;
      }
      return attrs;
    }
    class WidgetType {
      /**
      Compare this instance to another instance of the same type.
      (TypeScript can't express this, but only instances of the same
      specific class will be passed to this method.) This is used to
      avoid redrawing widgets when they are replaced by a new
      decoration of the same type. The default implementation just
      returns `false`, which will cause new instances of the widget to
      always be redrawn.
      */
      eq(widget) {
        return false;
      }
      /**
      Update a DOM element created by a widget of the same type (but
      different, non-`eq` content) to reflect this widget. May return
      true to indicate that it could update, false to indicate it
      couldn't (in which case the widget will be redrawn). The default
      implementation just returns false.
      */
      updateDOM(dom, view) {
        return false;
      }
      /**
      @internal
      */
      compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
      }
      /**
      The estimated height this widget will have, to be used when
      estimating the height of content that hasn't been drawn. May
      return -1 to indicate you don't know. The default implementation
      returns -1.
      */
      get estimatedHeight() {
        return -1;
      }
      /**
      For inline widgets that are displayed inline (as opposed to
      `inline-block`) and introduce line breaks (through `<br>` tags
      or textual newlines), this must indicate the amount of line
      breaks they introduce. Defaults to 0.
      */
      get lineBreaks() {
        return 0;
      }
      /**
      Can be used to configure which kinds of events inside the widget
      should be ignored by the editor. The default is to ignore all
      events.
      */
      ignoreEvent(event) {
        return true;
      }
      /**
      Override the way screen coordinates for positions at/in the
      widget are found. `pos` will be the offset into the widget, and
      `side` the side of the position that is being queriedless than
      zero for before, greater than zero for after, and zero for
      directly at that position.
      */
      coordsAt(dom, pos, side) {
        return null;
      }
      /**
      @internal
      */
      get isHidden() {
        return false;
      }
      /**
      @internal
      */
      get editable() {
        return false;
      }
      /**
      This is called when the an instance of the widget is removed
      from the editor view.
      */
      destroy(dom) {
      }
    }
    var BlockType = /* @__PURE__ */ (function(BlockType2) {
      BlockType2[BlockType2["Text"] = 0] = "Text";
      BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
      BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
      BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
      return BlockType2;
    })(BlockType || (BlockType = {}));
    class Decoration extends RangeValue {
      constructor(startSide, endSide, widget, spec) {
        super();
        this.startSide = startSide;
        this.endSide = endSide;
        this.widget = widget;
        this.spec = spec;
      }
      /**
      @internal
      */
      get heightRelevant() {
        return false;
      }
      /**
      Create a mark decoration, which influences the styling of the
      content in its range. Nested mark decorations will cause nested
      DOM elements to be created. Nesting order is determined by
      precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
      the higher-precedence decorations creating the inner DOM nodes.
      Such elements are split on line boundaries and on the boundaries
      of lower-precedence decorations.
      */
      static mark(spec) {
        return new MarkDecoration(spec);
      }
      /**
      Create a widget decoration, which displays a DOM element at the
      given position.
      */
      static widget(spec) {
        let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
        side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
        return new PointDecoration(spec, side, side, block, spec.widget || null, false);
      }
      /**
      Create a replace decoration which replaces the given range with
      a widget, or simply hides it.
      */
      static replace(spec) {
        let block = !!spec.block, startSide, endSide;
        if (spec.isBlockGap) {
          startSide = -5e8;
          endSide = 4e8;
        } else {
          let { start, end } = getInclusive(spec, block);
          startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
          endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
        }
        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
      }
      /**
      Create a line decoration, which can add DOM attributes to the
      line starting at the given position.
      */
      static line(spec) {
        return new LineDecoration(spec);
      }
      /**
      Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
      decorated range or ranges. If the ranges aren't already sorted,
      pass `true` for `sort` to make the library sort them for you.
      */
      static set(of, sort = false) {
        return RangeSet.of(of, sort);
      }
      /**
      @internal
      */
      hasHeight() {
        return this.widget ? this.widget.estimatedHeight > -1 : false;
      }
    }
    Decoration.none = RangeSet.empty;
    class MarkDecoration extends Decoration {
      constructor(spec) {
        let { start, end } = getInclusive(spec);
        super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
        this.tagName = spec.tagName || "span";
        this.class = spec.class || "";
        this.attrs = spec.attributes || null;
      }
      eq(other) {
        var _a2, _b;
        return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && (this.class || ((_a2 = this.attrs) === null || _a2 === void 0 ? void 0 : _a2.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, "class");
      }
      range(from2, to2 = from2) {
        if (from2 >= to2)
          throw new RangeError("Mark decorations may not be empty");
        return super.range(from2, to2);
      }
    }
    MarkDecoration.prototype.point = false;
    class LineDecoration extends Decoration {
      constructor(spec) {
        super(-2e8, -2e8, null, spec);
      }
      eq(other) {
        return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
      }
      range(from2, to2 = from2) {
        if (to2 != from2)
          throw new RangeError("Line decoration ranges must be zero-length");
        return super.range(from2, to2);
      }
    }
    LineDecoration.prototype.mapMode = MapMode.TrackBefore;
    LineDecoration.prototype.point = true;
    class PointDecoration extends Decoration {
      constructor(spec, startSide, endSide, block, widget, isReplace) {
        super(startSide, endSide, widget, spec);
        this.block = block;
        this.isReplace = isReplace;
        this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
      }
      // Only relevant when this.block == true
      get type() {
        return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
      }
      get heightRelevant() {
        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
      }
      eq(other) {
        return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
      }
      range(from2, to2 = from2) {
        if (this.isReplace && (from2 > to2 || from2 == to2 && this.startSide > 0 && this.endSide <= 0))
          throw new RangeError("Invalid range for replacement decoration");
        if (!this.isReplace && to2 != from2)
          throw new RangeError("Widget decorations can only have zero-length ranges");
        return super.range(from2, to2);
      }
    }
    PointDecoration.prototype.point = true;
    function getInclusive(spec, block = false) {
      let { inclusiveStart: start, inclusiveEnd: end } = spec;
      if (start == null)
        start = spec.inclusive;
      if (end == null)
        end = spec.inclusive;
      return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
    }
    function widgetsEq(a, b) {
      return a == b || !!(a && b && a.compare(b));
    }
    function addRange(from2, to2, ranges, margin = 0) {
      let last = ranges.length - 1;
      if (last >= 0 && ranges[last] + margin >= from2)
        ranges[last] = Math.max(ranges[last], to2);
      else
        ranges.push(from2, to2);
    }
    class LineView extends ContentView {
      constructor() {
        super(...arguments);
        this.children = [];
        this.length = 0;
        this.prevAttrs = void 0;
        this.attrs = null;
        this.breakAfter = 0;
      }
      // Consumes source
      merge(from2, to2, source2, hasStart, openStart, openEnd) {
        if (source2) {
          if (!(source2 instanceof LineView))
            return false;
          if (!this.dom)
            source2.transferDOM(this);
        }
        if (hasStart)
          this.setDeco(source2 ? source2.attrs : null);
        mergeChildrenInto(this, from2, to2, source2 ? source2.children.slice() : [], openStart, openEnd);
        return true;
      }
      split(at) {
        let end = new LineView();
        end.breakAfter = this.breakAfter;
        if (this.length == 0)
          return end;
        let { i: i2, off } = this.childPos(at);
        if (off) {
          end.append(this.children[i2].split(off), 0);
          this.children[i2].merge(off, this.children[i2].length, null, false, 0, 0);
          i2++;
        }
        for (let j = i2; j < this.children.length; j++)
          end.append(this.children[j], 0);
        while (i2 > 0 && this.children[i2 - 1].length == 0)
          this.children[--i2].destroy();
        this.children.length = i2;
        this.markDirty();
        this.length = at;
        return end;
      }
      transferDOM(other) {
        if (!this.dom)
          return;
        this.markDirty();
        other.setDOM(this.dom);
        other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
        this.prevAttrs = void 0;
        this.dom = null;
      }
      setDeco(attrs) {
        if (!attrsEq(this.attrs, attrs)) {
          if (this.dom) {
            this.prevAttrs = this.attrs;
            this.markDirty();
          }
          this.attrs = attrs;
        }
      }
      append(child, openStart) {
        joinInlineInto(this, child, openStart);
      }
      // Only called when building a line view in ContentBuilder
      addLineDeco(deco) {
        let attrs = deco.spec.attributes, cls = deco.spec.class;
        if (attrs)
          this.attrs = combineAttrs(attrs, this.attrs || {});
        if (cls)
          this.attrs = combineAttrs({ class: cls }, this.attrs || {});
      }
      domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
      }
      reuseDOM(node) {
        if (node.nodeName == "DIV") {
          this.setDOM(node);
          this.flags |= 4 | 2;
        }
      }
      sync(view, track) {
        var _a2;
        if (!this.dom) {
          this.setDOM(document.createElement("div"));
          this.dom.className = "cm-line";
          this.prevAttrs = this.attrs ? null : void 0;
        } else if (this.flags & 4) {
          clearAttributes(this.dom);
          this.dom.className = "cm-line";
          this.prevAttrs = this.attrs ? null : void 0;
        }
        if (this.prevAttrs !== void 0) {
          updateAttrs(this.dom, this.prevAttrs, this.attrs);
          this.dom.classList.add("cm-line");
          this.prevAttrs = void 0;
        }
        super.sync(view, track);
        let last = this.dom.lastChild;
        while (last && ContentView.get(last) instanceof MarkView)
          last = last.lastChild;
        if (!last || !this.length || last.nodeName != "BR" && ((_a2 = ContentView.get(last)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
          let hack = document.createElement("BR");
          hack.cmIgnore = true;
          this.dom.appendChild(hack);
        }
      }
      measureTextSize() {
        if (this.children.length == 0 || this.length > 20)
          return null;
        let totalWidth = 0, textHeight;
        for (let child of this.children) {
          if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
            return null;
          let rects = clientRectsFor(child.dom);
          if (rects.length != 1)
            return null;
          totalWidth += rects[0].width;
          textHeight = rects[0].height;
        }
        return !totalWidth ? null : {
          lineHeight: this.dom.getBoundingClientRect().height,
          charWidth: totalWidth / this.length,
          textHeight
        };
      }
      coordsAt(pos, side) {
        let rect = coordsInChildren(this, pos, side);
        if (!this.children.length && rect && this.parent) {
          let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
          if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
            let dist2 = (height - heightOracle.textHeight) / 2;
            return { top: rect.top + dist2, bottom: rect.bottom - dist2, left: rect.left, right: rect.left };
          }
        }
        return rect;
      }
      become(other) {
        return other instanceof LineView && this.children.length == 0 && other.children.length == 0 && attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;
      }
      covers() {
        return true;
      }
      static find(docView, pos) {
        for (let i2 = 0, off = 0; i2 < docView.children.length; i2++) {
          let block = docView.children[i2], end = off + block.length;
          if (end >= pos) {
            if (block instanceof LineView)
              return block;
            if (end > pos)
              break;
          }
          off = end + block.breakAfter;
        }
        return null;
      }
    }
    class BlockWidgetView extends ContentView {
      constructor(widget, length, deco) {
        super();
        this.widget = widget;
        this.length = length;
        this.deco = deco;
        this.breakAfter = 0;
        this.prevWidget = null;
      }
      merge(from2, to2, source2, _takeDeco, openStart, openEnd) {
        if (source2 && (!(source2 instanceof BlockWidgetView) || !this.widget.compare(source2.widget) || from2 > 0 && openStart <= 0 || to2 < this.length && openEnd <= 0))
          return false;
        this.length = from2 + (source2 ? source2.length : 0) + (this.length - to2);
        return true;
      }
      domAtPos(pos) {
        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
      }
      split(at) {
        let len = this.length - at;
        this.length = at;
        let end = new BlockWidgetView(this.widget, len, this.deco);
        end.breakAfter = this.breakAfter;
        return end;
      }
      get children() {
        return noChildren;
      }
      sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
          if (this.dom && this.prevWidget)
            this.prevWidget.destroy(this.dom);
          this.prevWidget = null;
          this.setDOM(this.widget.toDOM(view));
          if (!this.widget.editable)
            this.dom.contentEditable = "false";
        }
      }
      get overrideDOMText() {
        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
      }
      domBoundsAround() {
        return null;
      }
      become(other) {
        if (other instanceof BlockWidgetView && other.widget.constructor == this.widget.constructor) {
          if (!other.widget.compare(this.widget))
            this.markDirty(true);
          if (this.dom && !this.prevWidget)
            this.prevWidget = this.widget;
          this.widget = other.widget;
          this.length = other.length;
          this.deco = other.deco;
          this.breakAfter = other.breakAfter;
          return true;
        }
        return false;
      }
      ignoreMutation() {
        return true;
      }
      ignoreEvent(event) {
        return this.widget.ignoreEvent(event);
      }
      get isEditable() {
        return false;
      }
      get isWidget() {
        return true;
      }
      coordsAt(pos, side) {
        let custom = this.widget.coordsAt(this.dom, pos, side);
        if (custom)
          return custom;
        if (this.widget instanceof BlockGapWidget)
          return null;
        return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
      }
      destroy() {
        super.destroy();
        if (this.dom)
          this.widget.destroy(this.dom);
      }
      covers(side) {
        let { startSide, endSide } = this.deco;
        return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
      }
    }
    class BlockGapWidget extends WidgetType {
      constructor(height) {
        super();
        this.height = height;
      }
      toDOM() {
        let elt = document.createElement("div");
        elt.className = "cm-gap";
        this.updateDOM(elt);
        return elt;
      }
      eq(other) {
        return other.height == this.height;
      }
      updateDOM(elt) {
        elt.style.height = this.height + "px";
        return true;
      }
      get editable() {
        return true;
      }
      get estimatedHeight() {
        return this.height;
      }
      ignoreEvent() {
        return false;
      }
    }
    class ContentBuilder {
      constructor(doc2, pos, end, disallowBlockEffectsFor) {
        this.doc = doc2;
        this.pos = pos;
        this.end = end;
        this.disallowBlockEffectsFor = disallowBlockEffectsFor;
        this.content = [];
        this.curLine = null;
        this.breakAtStart = 0;
        this.pendingBuffer = 0;
        this.bufferMarks = [];
        this.atCursorPos = true;
        this.openStart = -1;
        this.openEnd = -1;
        this.text = "";
        this.textOff = 0;
        this.cursor = doc2.iter();
        this.skip = pos;
      }
      posCovered() {
        if (this.content.length == 0)
          return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
        let last = this.content[this.content.length - 1];
        return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);
      }
      getLine() {
        if (!this.curLine) {
          this.content.push(this.curLine = new LineView());
          this.atCursorPos = true;
        }
        return this.curLine;
      }
      flushBuffer(active = this.bufferMarks) {
        if (this.pendingBuffer) {
          this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
          this.pendingBuffer = 0;
        }
      }
      addBlockWidget(view) {
        this.flushBuffer();
        this.curLine = null;
        this.content.push(view);
      }
      finish(openEnd) {
        if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
          this.flushBuffer();
        else
          this.pendingBuffer = 0;
        if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
          this.getLine();
      }
      buildText(length, active, openStart) {
        while (length > 0) {
          if (this.textOff == this.text.length) {
            let { value, lineBreak, done } = this.cursor.next(this.skip);
            this.skip = 0;
            if (done)
              throw new Error("Ran out of text content when drawing inline views");
            if (lineBreak) {
              if (!this.posCovered())
                this.getLine();
              if (this.content.length)
                this.content[this.content.length - 1].breakAfter = 1;
              else
                this.breakAtStart = 1;
              this.flushBuffer();
              this.curLine = null;
              this.atCursorPos = true;
              length--;
              continue;
            } else {
              this.text = value;
              this.textOff = 0;
            }
          }
          let remaining = Math.min(this.text.length - this.textOff, length);
          let take = Math.min(
            remaining,
            512
            /* T.Chunk */
          );
          this.flushBuffer(active.slice(active.length - openStart));
          this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
          this.atCursorPos = true;
          this.textOff += take;
          length -= take;
          openStart = remaining <= take ? 0 : active.length;
        }
      }
      span(from2, to2, active, openStart) {
        this.buildText(to2 - from2, active, openStart);
        this.pos = to2;
        if (this.openStart < 0)
          this.openStart = openStart;
      }
      point(from2, to2, deco, active, openStart, index2) {
        if (this.disallowBlockEffectsFor[index2] && deco instanceof PointDecoration) {
          if (deco.block)
            throw new RangeError("Block decorations may not be specified via plugins");
          if (to2 > this.doc.lineAt(this.pos).to)
            throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
        }
        let len = to2 - from2;
        if (deco instanceof PointDecoration) {
          if (deco.block) {
            if (deco.startSide > 0 && !this.posCovered())
              this.getLine();
            this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
          } else {
            let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
            let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from2 < to2 || deco.startSide > 0);
            let cursorAfter = !view.isEditable && (from2 < to2 || openStart > active.length || deco.startSide <= 0);
            let line = this.getLine();
            if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable)
              this.pendingBuffer = 0;
            this.flushBuffer(active);
            if (cursorBefore) {
              line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
              openStart = active.length + Math.max(0, openStart - active.length);
            }
            line.append(wrapMarks(view, active), openStart);
            this.atCursorPos = cursorAfter;
            this.pendingBuffer = !cursorAfter ? 0 : from2 < to2 || openStart > active.length ? 1 : 2;
            if (this.pendingBuffer)
              this.bufferMarks = active.slice();
          }
        } else if (this.doc.lineAt(this.pos).from == this.pos) {
          this.getLine().addLineDeco(deco);
        }
        if (len) {
          if (this.textOff + len <= this.text.length) {
            this.textOff += len;
          } else {
            this.skip += len - (this.text.length - this.textOff);
            this.text = "";
            this.textOff = 0;
          }
          this.pos = to2;
        }
        if (this.openStart < 0)
          this.openStart = openStart;
      }
      static build(text, from2, to2, decorations2, dynamicDecorationMap) {
        let builder = new ContentBuilder(text, from2, to2, dynamicDecorationMap);
        builder.openEnd = RangeSet.spans(decorations2, from2, to2, builder);
        if (builder.openStart < 0)
          builder.openStart = builder.openEnd;
        builder.finish(builder.openEnd);
        return builder;
      }
    }
    function wrapMarks(view, active) {
      for (let mark of active)
        view = new MarkView(mark, [view], view.length);
      return view;
    }
    class NullWidget extends WidgetType {
      constructor(tag) {
        super();
        this.tag = tag;
      }
      eq(other) {
        return other.tag == this.tag;
      }
      toDOM() {
        return document.createElement(this.tag);
      }
      updateDOM(elt) {
        return elt.nodeName.toLowerCase() == this.tag;
      }
      get isHidden() {
        return true;
      }
    }
    NullWidget.inline = /* @__PURE__ */ new NullWidget("span");
    NullWidget.block = /* @__PURE__ */ new NullWidget("div");
    var Direction = /* @__PURE__ */ (function(Direction2) {
      Direction2[Direction2["LTR"] = 0] = "LTR";
      Direction2[Direction2["RTL"] = 1] = "RTL";
      return Direction2;
    })(Direction || (Direction = {}));
    const LTR = Direction.LTR, RTL = Direction.RTL;
    function dec(str) {
      let result = [];
      for (let i2 = 0; i2 < str.length; i2++)
        result.push(1 << +str[i2]);
      return result;
    }
    const LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
    const ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
    const Brackets = /* @__PURE__ */ Object.create(null), BracketStack = [];
    for (let p of ["()", "[]", "{}"]) {
      let l = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
      Brackets[l] = r;
      Brackets[r] = -l;
    }
    function charType(ch) {
      return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8204 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : 1;
    }
    const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
    class BidiSpan {
      /**
      The direction of this span.
      */
      get dir() {
        return this.level % 2 ? RTL : LTR;
      }
      /**
      @internal
      */
      constructor(from2, to2, level) {
        this.from = from2;
        this.to = to2;
        this.level = level;
      }
      /**
      @internal
      */
      side(end, dir) {
        return this.dir == dir == end ? this.to : this.from;
      }
      /**
      @internal
      */
      forward(forward, dir) {
        return forward == (this.dir == dir);
      }
      /**
      @internal
      */
      static find(order, index2, level, assoc) {
        let maybe = -1;
        for (let i2 = 0; i2 < order.length; i2++) {
          let span = order[i2];
          if (span.from <= index2 && span.to >= index2) {
            if (span.level == level)
              return i2;
            if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index2 : span.to > index2 : order[maybe].level > span.level))
              maybe = i2;
          }
        }
        if (maybe < 0)
          throw new RangeError("Index out of range");
        return maybe;
      }
    }
    function isolatesEq(a, b) {
      if (a.length != b.length)
        return false;
      for (let i2 = 0; i2 < a.length; i2++) {
        let iA = a[i2], iB = b[i2];
        if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
          return false;
      }
      return true;
    }
    const types = [];
    function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
      for (let iI = 0; iI <= isolates.length; iI++) {
        let from2 = iI ? isolates[iI - 1].to : rFrom, to2 = iI < isolates.length ? isolates[iI].from : rTo;
        let prevType = iI ? 256 : outerType;
        for (let i2 = from2, prev = prevType, prevStrong = prevType; i2 < to2; i2++) {
          let type = charType(line.charCodeAt(i2));
          if (type == 512)
            type = prev;
          else if (type == 8 && prevStrong == 4)
            type = 16;
          types[i2] = type == 4 ? 2 : type;
          if (type & 7)
            prevStrong = type;
          prev = type;
        }
        for (let i2 = from2, prev = prevType, prevStrong = prevType; i2 < to2; i2++) {
          let type = types[i2];
          if (type == 128) {
            if (i2 < to2 - 1 && prev == types[i2 + 1] && prev & 24)
              type = types[i2] = prev;
            else
              types[i2] = 256;
          } else if (type == 64) {
            let end = i2 + 1;
            while (end < to2 && types[end] == 64)
              end++;
            let replace2 = i2 && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
            for (let j = i2; j < end; j++)
              types[j] = replace2;
            i2 = end - 1;
          } else if (type == 8 && prevStrong == 1) {
            types[i2] = 1;
          }
          prev = type;
          if (type & 7)
            prevStrong = type;
        }
      }
    }
    function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
      let oppositeType = outerType == 1 ? 2 : 1;
      for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
        let from2 = iI ? isolates[iI - 1].to : rFrom, to2 = iI < isolates.length ? isolates[iI].from : rTo;
        for (let i2 = from2, ch, br, type; i2 < to2; i2++) {
          if (br = Brackets[ch = line.charCodeAt(i2)]) {
            if (br < 0) {
              for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                if (BracketStack[sJ + 1] == -br) {
                  let flags = BracketStack[sJ + 2];
                  let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
                  if (type2)
                    types[i2] = types[BracketStack[sJ]] = type2;
                  sI = sJ;
                  break;
                }
              }
            } else if (BracketStack.length == 189) {
              break;
            } else {
              BracketStack[sI++] = i2;
              BracketStack[sI++] = ch;
              BracketStack[sI++] = context;
            }
          } else if ((type = types[i2]) == 2 || type == 1) {
            let embed = type == outerType;
            context = embed ? 0 : 1;
            for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
              let cur2 = BracketStack[sJ + 2];
              if (cur2 & 2)
                break;
              if (embed) {
                BracketStack[sJ + 2] |= 2;
              } else {
                if (cur2 & 4)
                  break;
                BracketStack[sJ + 2] |= 4;
              }
            }
          }
        }
      }
    }
    function processNeutrals(rFrom, rTo, isolates, outerType) {
      for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
        let from2 = iI ? isolates[iI - 1].to : rFrom, to2 = iI < isolates.length ? isolates[iI].from : rTo;
        for (let i2 = from2; i2 < to2; ) {
          let type = types[i2];
          if (type == 256) {
            let end = i2 + 1;
            for (; ; ) {
              if (end == to2) {
                if (iI == isolates.length)
                  break;
                end = isolates[iI++].to;
                to2 = iI < isolates.length ? isolates[iI].from : rTo;
              } else if (types[end] == 256) {
                end++;
              } else {
                break;
              }
            }
            let beforeL = prev == 1;
            let afterL = (end < rTo ? types[end] : outerType) == 1;
            let replace2 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
            for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i2; ) {
              if (j == fromJ) {
                j = isolates[--jI].from;
                fromJ = jI ? isolates[jI - 1].to : rFrom;
              }
              types[--j] = replace2;
            }
            i2 = end;
          } else {
            prev = type;
            i2++;
          }
        }
      }
    }
    function emitSpans(line, from2, to2, level, baseLevel, isolates, order) {
      let ourType = level % 2 ? 2 : 1;
      if (level % 2 == baseLevel % 2) {
        for (let iCh = from2, iI = 0; iCh < to2; ) {
          let sameDir = true, isNum = false;
          if (iI == isolates.length || iCh < isolates[iI].from) {
            let next = types[iCh];
            if (next != ourType) {
              sameDir = false;
              isNum = next == 16;
            }
          }
          let recurse = !sameDir && ourType == 1 ? [] : null;
          let localLevel = sameDir ? level : level + 1;
          let iScan = iCh;
          run: for (; ; ) {
            if (iI < isolates.length && iScan == isolates[iI].from) {
              if (isNum)
                break run;
              let iso = isolates[iI];
              if (!sameDir)
                for (let upto = iso.to, jI = iI + 1; ; ) {
                  if (upto == to2)
                    break run;
                  if (jI < isolates.length && isolates[jI].from == upto)
                    upto = isolates[jI++].to;
                  else if (types[upto] == ourType)
                    break run;
                  else
                    break;
                }
              iI++;
              if (recurse) {
                recurse.push(iso);
              } else {
                if (iso.from > iCh)
                  order.push(new BidiSpan(iCh, iso.from, localLevel));
                let dirSwap = iso.direction == LTR != !(localLevel % 2);
                computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                iCh = iso.to;
              }
              iScan = iso.to;
            } else if (iScan == to2 || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
              break;
            } else {
              iScan++;
            }
          }
          if (recurse)
            emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
          else if (iCh < iScan)
            order.push(new BidiSpan(iCh, iScan, localLevel));
          iCh = iScan;
        }
      } else {
        for (let iCh = to2, iI = isolates.length; iCh > from2; ) {
          let sameDir = true, isNum = false;
          if (!iI || iCh > isolates[iI - 1].to) {
            let next = types[iCh - 1];
            if (next != ourType) {
              sameDir = false;
              isNum = next == 16;
            }
          }
          let recurse = !sameDir && ourType == 1 ? [] : null;
          let localLevel = sameDir ? level : level + 1;
          let iScan = iCh;
          run: for (; ; ) {
            if (iI && iScan == isolates[iI - 1].to) {
              if (isNum)
                break run;
              let iso = isolates[--iI];
              if (!sameDir)
                for (let upto = iso.from, jI = iI; ; ) {
                  if (upto == from2)
                    break run;
                  if (jI && isolates[jI - 1].to == upto)
                    upto = isolates[--jI].from;
                  else if (types[upto - 1] == ourType)
                    break run;
                  else
                    break;
                }
              if (recurse) {
                recurse.push(iso);
              } else {
                if (iso.to < iCh)
                  order.push(new BidiSpan(iso.to, iCh, localLevel));
                let dirSwap = iso.direction == LTR != !(localLevel % 2);
                computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                iCh = iso.from;
              }
              iScan = iso.from;
            } else if (iScan == from2 || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
              break;
            } else {
              iScan--;
            }
          }
          if (recurse)
            emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
          else if (iScan < iCh)
            order.push(new BidiSpan(iScan, iCh, localLevel));
          iCh = iScan;
        }
      }
    }
    function computeSectionOrder(line, level, baseLevel, isolates, from2, to2, order) {
      let outerType = level % 2 ? 2 : 1;
      computeCharTypes(line, from2, to2, isolates, outerType);
      processBracketPairs(line, from2, to2, isolates, outerType);
      processNeutrals(from2, to2, isolates, outerType);
      emitSpans(line, from2, to2, level, baseLevel, isolates, order);
    }
    function computeOrder(line, direction, isolates) {
      if (!line)
        return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
      if (direction == LTR && !isolates.length && !BidiRE.test(line))
        return trivialOrder(line.length);
      if (isolates.length)
        while (line.length > types.length)
          types[types.length] = 256;
      let order = [], level = direction == LTR ? 0 : 1;
      computeSectionOrder(line, level, level, isolates, 0, line.length, order);
      return order;
    }
    function trivialOrder(length) {
      return [new BidiSpan(0, length, 0)];
    }
    let movedOver = "";
    function moveVisually(line, order, dir, start, forward) {
      var _a2;
      let startIndex = start.head - line.from;
      let spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
      let span = order[spanI], spanEnd = span.side(forward, dir);
      if (startIndex == spanEnd) {
        let nextI = spanI += forward ? 1 : -1;
        if (nextI < 0 || nextI >= order.length)
          return null;
        span = order[spanI = nextI];
        startIndex = span.side(!forward, dir);
        spanEnd = span.side(forward, dir);
      }
      let nextIndex = findClusterBreak(line.text, startIndex, span.forward(forward, dir));
      if (nextIndex < span.from || nextIndex > span.to)
        nextIndex = spanEnd;
      movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
      let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
      if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
        return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
      return EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
    }
    function autoDirection(text, from2, to2) {
      for (let i2 = from2; i2 < to2; i2++) {
        let type = charType(text.charCodeAt(i2));
        if (type == 1)
          return LTR;
        if (type == 2 || type == 4)
          return RTL;
      }
      return LTR;
    }
    const clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
    const dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
    const mouseSelectionStyle = /* @__PURE__ */ Facet.define();
    const exceptionSink = /* @__PURE__ */ Facet.define();
    const updateListener = /* @__PURE__ */ Facet.define();
    const inputHandler$1 = /* @__PURE__ */ Facet.define();
    const focusChangeEffect = /* @__PURE__ */ Facet.define();
    const clipboardInputFilter = /* @__PURE__ */ Facet.define();
    const clipboardOutputFilter = /* @__PURE__ */ Facet.define();
    const perLineTextDirection = /* @__PURE__ */ Facet.define({
      combine: (values) => values.some((x) => x)
    });
    const nativeSelectionHidden = /* @__PURE__ */ Facet.define({
      combine: (values) => values.some((x) => x)
    });
    const scrollHandler = /* @__PURE__ */ Facet.define();
    class ScrollTarget {
      constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
        this.range = range;
        this.y = y;
        this.x = x;
        this.yMargin = yMargin;
        this.xMargin = xMargin;
        this.isSnapshot = isSnapshot;
      }
      map(changes) {
        return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
      }
      clip(state) {
        return this.range.to <= state.doc.length ? this : new ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
      }
    }
    const scrollIntoView$1 = /* @__PURE__ */ StateEffect.define({ map: (t2, ch) => t2.map(ch) });
    const setEditContextFormatting = /* @__PURE__ */ StateEffect.define();
    function logException(state, exception, context) {
      let handler = state.facet(exceptionSink);
      if (handler.length)
        handler[0](exception);
      else if (window.onerror && window.onerror(String(exception), context, void 0, void 0, exception)) ;
      else if (context)
        console.error(context + ":", exception);
      else
        console.error(exception);
    }
    const editable = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : true });
    let nextPluginID = 0;
    const viewPlugin = /* @__PURE__ */ Facet.define({
      combine(plugins) {
        return plugins.filter((p, i2) => {
          for (let j = 0; j < i2; j++)
            if (plugins[j].plugin == p.plugin)
              return false;
          return true;
        });
      }
    });
    class ViewPlugin {
      constructor(id2, create2, domEventHandlers, domEventObservers, buildExtensions) {
        this.id = id2;
        this.create = create2;
        this.domEventHandlers = domEventHandlers;
        this.domEventObservers = domEventObservers;
        this.baseExtensions = buildExtensions(this);
        this.extension = this.baseExtensions.concat(viewPlugin.of({ plugin: this, arg: void 0 }));
      }
      /**
      Create an extension for this plugin with the given argument.
      */
      of(arg) {
        return this.baseExtensions.concat(viewPlugin.of({ plugin: this, arg }));
      }
      /**
      Define a plugin from a constructor function that creates the
      plugin's value, given an editor view.
      */
      static define(create2, spec) {
        const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
        return new ViewPlugin(nextPluginID++, create2, eventHandlers, eventObservers, (plugin) => {
          let ext = [];
          if (deco)
            ext.push(decorations.of((view) => {
              let pluginInst = view.plugin(plugin);
              return pluginInst ? deco(pluginInst) : Decoration.none;
            }));
          if (provide)
            ext.push(provide(plugin));
          return ext;
        });
      }
      /**
      Create a plugin for a class whose constructor takes a single
      editor view as argument.
      */
      static fromClass(cls, spec) {
        return ViewPlugin.define((view, arg) => new cls(view, arg), spec);
      }
    }
    class PluginInstance {
      constructor(spec) {
        this.spec = spec;
        this.mustUpdate = null;
        this.value = null;
      }
      get plugin() {
        return this.spec && this.spec.plugin;
      }
      update(view) {
        if (!this.value) {
          if (this.spec) {
            try {
              this.value = this.spec.plugin.create(view, this.spec.arg);
            } catch (e) {
              logException(view.state, e, "CodeMirror plugin crashed");
              this.deactivate();
            }
          }
        } else if (this.mustUpdate) {
          let update = this.mustUpdate;
          this.mustUpdate = null;
          if (this.value.update) {
            try {
              this.value.update(update);
            } catch (e) {
              logException(update.state, e, "CodeMirror plugin crashed");
              if (this.value.destroy)
                try {
                  this.value.destroy();
                } catch (_) {
                }
              this.deactivate();
            }
          }
        }
        return this;
      }
      destroy(view) {
        var _a2;
        if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
          try {
            this.value.destroy();
          } catch (e) {
            logException(view.state, e, "CodeMirror plugin crashed");
          }
        }
      }
      deactivate() {
        this.spec = this.value = null;
      }
    }
    const editorAttributes = /* @__PURE__ */ Facet.define();
    const contentAttributes = /* @__PURE__ */ Facet.define();
    const decorations = /* @__PURE__ */ Facet.define();
    const outerDecorations = /* @__PURE__ */ Facet.define();
    const atomicRanges = /* @__PURE__ */ Facet.define();
    const bidiIsolatedRanges = /* @__PURE__ */ Facet.define();
    function getIsolatedRanges(view, line) {
      let isolates = view.state.facet(bidiIsolatedRanges);
      if (!isolates.length)
        return isolates;
      let sets = isolates.map((i2) => i2 instanceof Function ? i2(view) : i2);
      let result = [];
      RangeSet.spans(sets, line.from, line.to, {
        point() {
        },
        span(fromDoc, toDoc, active, open) {
          let from2 = fromDoc - line.from, to2 = toDoc - line.from;
          let level = result;
          for (let i2 = active.length - 1; i2 >= 0; i2--, open--) {
            let direction = active[i2].spec.bidiIsolate, update;
            if (direction == null)
              direction = autoDirection(line.text, from2, to2);
            if (open > 0 && level.length && (update = level[level.length - 1]).to == from2 && update.direction == direction) {
              update.to = to2;
              level = update.inner;
            } else {
              let add2 = { from: from2, to: to2, direction, inner: [] };
              level.push(add2);
              level = add2.inner;
            }
          }
        }
      });
      return result;
    }
    const scrollMargins = /* @__PURE__ */ Facet.define();
    function getScrollMargins(view) {
      let left = 0, right = 0, top2 = 0, bottom = 0;
      for (let source2 of view.state.facet(scrollMargins)) {
        let m = source2(view);
        if (m) {
          if (m.left != null)
            left = Math.max(left, m.left);
          if (m.right != null)
            right = Math.max(right, m.right);
          if (m.top != null)
            top2 = Math.max(top2, m.top);
          if (m.bottom != null)
            bottom = Math.max(bottom, m.bottom);
        }
      }
      return { left, right, top: top2, bottom };
    }
    const styleModule = /* @__PURE__ */ Facet.define();
    class ChangedRange {
      constructor(fromA, toA, fromB, toB) {
        this.fromA = fromA;
        this.toA = toA;
        this.fromB = fromB;
        this.toB = toB;
      }
      join(other) {
        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
      }
      addToSet(set2) {
        let i2 = set2.length, me = this;
        for (; i2 > 0; i2--) {
          let range = set2[i2 - 1];
          if (range.fromA > me.toA)
            continue;
          if (range.toA < me.fromA)
            break;
          me = me.join(range);
          set2.splice(i2 - 1, 1);
        }
        set2.splice(i2, 0, me);
        return set2;
      }
      static extendWithRanges(diff, ranges) {
        if (ranges.length == 0)
          return diff;
        let result = [];
        for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
          let next = dI == diff.length ? null : diff[dI], off = posA - posB;
          let end = next ? next.fromB : 1e9;
          while (rI < ranges.length && ranges[rI] < end) {
            let from2 = ranges[rI], to2 = ranges[rI + 1];
            let fromB = Math.max(posB, from2), toB = Math.min(end, to2);
            if (fromB <= toB)
              new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
            if (to2 > end)
              break;
            else
              rI += 2;
          }
          if (!next)
            return result;
          new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
          posA = next.toA;
          posB = next.toB;
        }
      }
    }
    class ViewUpdate {
      constructor(view, state, transactions) {
        this.view = view;
        this.state = state;
        this.transactions = transactions;
        this.flags = 0;
        this.startState = view.state;
        this.changes = ChangeSet.empty(this.startState.doc.length);
        for (let tr of transactions)
          this.changes = this.changes.compose(tr.changes);
        let changedRanges = [];
        this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
        this.changedRanges = changedRanges;
      }
      /**
      @internal
      */
      static create(view, state, transactions) {
        return new ViewUpdate(view, state, transactions);
      }
      /**
      Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
      [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
      update.
      */
      get viewportChanged() {
        return (this.flags & 4) > 0;
      }
      /**
      Returns true when
      [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
      and the viewport change is not just the result of mapping it in
      response to document changes.
      */
      get viewportMoved() {
        return (this.flags & 8) > 0;
      }
      /**
      Indicates whether the height of a block element in the editor
      changed in this update.
      */
      get heightChanged() {
        return (this.flags & 2) > 0;
      }
      /**
      Returns true when the document was modified or the size of the
      editor, or elements within the editor, changed.
      */
      get geometryChanged() {
        return this.docChanged || (this.flags & (16 | 2)) > 0;
      }
      /**
      True when this update indicates a focus change.
      */
      get focusChanged() {
        return (this.flags & 1) > 0;
      }
      /**
      Whether the document changed in this update.
      */
      get docChanged() {
        return !this.changes.empty;
      }
      /**
      Whether the selection was explicitly set in this update.
      */
      get selectionSet() {
        return this.transactions.some((tr) => tr.selection);
      }
      /**
      @internal
      */
      get empty() {
        return this.flags == 0 && this.transactions.length == 0;
      }
    }
    class DocView extends ContentView {
      get length() {
        return this.view.state.doc.length;
      }
      constructor(view) {
        super();
        this.view = view;
        this.decorations = [];
        this.dynamicDecorationMap = [false];
        this.domChanged = null;
        this.hasComposition = null;
        this.markedForComposition = /* @__PURE__ */ new Set();
        this.editContextFormatting = Decoration.none;
        this.lastCompositionAfterCursor = false;
        this.minWidth = 0;
        this.minWidthFrom = 0;
        this.minWidthTo = 0;
        this.impreciseAnchor = null;
        this.impreciseHead = null;
        this.forceSelection = false;
        this.lastUpdate = Date.now();
        this.setDOM(view.contentDOM);
        this.children = [new LineView()];
        this.children[0].setParent(this);
        this.updateDeco();
        this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
      }
      // Update the document view to a given state.
      update(update) {
        var _a2;
        let changedRanges = update.changedRanges;
        if (this.minWidth > 0 && changedRanges.length) {
          if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
            this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
          } else {
            this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
            this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
          }
        }
        this.updateEditContextFormatting(update);
        let readCompositionAt = -1;
        if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
          if ((_a2 = this.domChanged) === null || _a2 === void 0 ? void 0 : _a2.newSel)
            readCompositionAt = this.domChanged.newSel.head;
          else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
            readCompositionAt = update.state.selection.main.head;
        }
        let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
        this.domChanged = null;
        if (this.hasComposition) {
          this.markedForComposition.clear();
          let { from: from2, to: to2 } = this.hasComposition;
          changedRanges = new ChangedRange(from2, to2, update.changes.mapPos(from2, -1), update.changes.mapPos(to2, 1)).addToSet(changedRanges.slice());
        }
        this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
        if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines)
          this.forceSelection = true;
        let prevDeco = this.decorations, deco = this.updateDeco();
        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
        if (!(this.flags & 7) && changedRanges.length == 0) {
          return false;
        } else {
          this.updateInner(changedRanges, update.startState.doc.length, composition);
          if (update.transactions.length)
            this.lastUpdate = Date.now();
          return true;
        }
      }
      // Used by update and the constructor do perform the actual DOM
      // update
      updateInner(changes, oldLength, composition) {
        this.view.viewState.mustMeasureContent = true;
        this.updateChildren(changes, oldLength, composition);
        let { observer } = this.view;
        observer.ignore(() => {
          this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
          this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
          let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
          this.sync(this.view, track);
          this.flags &= -8;
          if (track && (track.written || observer.selectionRange.focusNode != track.node))
            this.forceSelection = true;
          this.dom.style.height = "";
        });
        this.markedForComposition.forEach(
          (cView) => cView.flags &= -9
          /* ViewFlag.Composition */
        );
        let gaps = [];
        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
          for (let child of this.children)
            if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
              gaps.push(child.dom);
        }
        observer.updateGaps(gaps);
      }
      updateChildren(changes, oldLength, composition) {
        let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
        let cursor2 = this.childCursor(oldLength);
        for (let i2 = ranges.length - 1; ; i2--) {
          let next = i2 >= 0 ? ranges[i2] : null;
          if (!next)
            break;
          let { fromA, toA, fromB, toB } = next, content2, breakAtStart, openStart, openEnd;
          if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
            let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
            let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
            breakAtStart = before.breakAtStart;
            openStart = before.openStart;
            openEnd = after.openEnd;
            let compLine = this.compositionView(composition);
            if (after.breakAtStart) {
              compLine.breakAfter = 1;
            } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
              compLine.breakAfter = after.content[0].breakAfter;
              after.content.shift();
            }
            if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
              before.content.pop();
            }
            content2 = before.content.concat(compLine).concat(after.content);
          } else {
            ({ content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
          }
          let { i: toI, off: toOff } = cursor2.findPos(toA, 1);
          let { i: fromI, off: fromOff } = cursor2.findPos(fromA, -1);
          replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
        }
        if (composition)
          this.fixCompositionDOM(composition);
      }
      updateEditContextFormatting(update) {
        this.editContextFormatting = this.editContextFormatting.map(update.changes);
        for (let tr of update.transactions)
          for (let effect of tr.effects)
            if (effect.is(setEditContextFormatting)) {
              this.editContextFormatting = effect.value;
            }
      }
      compositionView(composition) {
        let cur2 = new TextView(composition.text.nodeValue);
        cur2.flags |= 8;
        for (let { deco } of composition.marks)
          cur2 = new MarkView(deco, [cur2], cur2.length);
        let line = new LineView();
        line.append(cur2, 0);
        return line;
      }
      fixCompositionDOM(composition) {
        let fix = (dom, cView2) => {
          cView2.flags |= 8 | (cView2.children.some(
            (c) => c.flags & 7
            /* ViewFlag.Dirty */
          ) ? 1 : 0);
          this.markedForComposition.add(cView2);
          let prev = ContentView.get(dom);
          if (prev && prev != cView2)
            prev.dom = null;
          cView2.setDOM(dom);
        };
        let pos = this.childPos(composition.range.fromB, 1);
        let cView = this.children[pos.i];
        fix(composition.line, cView);
        for (let i2 = composition.marks.length - 1; i2 >= -1; i2--) {
          pos = cView.childPos(pos.off, 1);
          cView = cView.children[pos.i];
          fix(i2 >= 0 ? composition.marks[i2].node : composition.text, cView);
        }
      }
      // Sync the DOM selection to this.state.selection
      updateSelection(mustRead = false, fromPointer = false) {
        if (mustRead || !this.view.observer.selectionRange.focusNode)
          this.view.observer.readSelectionRange();
        let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
        let selectionNotFocus = !focused && !(this.view.state.facet(editable) || this.dom.tabIndex > -1) && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
        if (!(focused || fromPointer || selectionNotFocus))
          return;
        let force = this.forceSelection;
        this.forceSelection = false;
        let main = this.view.state.selection.main;
        let anchor = this.moveToLine(this.domAtPos(main.anchor));
        let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
        if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
          let dummy = document.createTextNode("");
          this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
          anchor = head = new DOMPos(dummy, 0);
          force = true;
        }
        let domSel = this.view.observer.selectionRange;
        if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
          this.view.observer.ignore(() => {
            if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
              this.dom.blur();
              this.dom.focus({ preventScroll: true });
            }
            let rawSel = getSelection(this.view.root);
            if (!rawSel) ;
            else if (main.empty) {
              if (browser.gecko) {
                let nextTo = nextToUneditable(anchor.node, anchor.offset);
                if (nextTo && nextTo != (1 | 2)) {
                  let text = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
                  if (text)
                    anchor = new DOMPos(text.node, text.offset);
                }
              }
              rawSel.collapse(anchor.node, anchor.offset);
              if (main.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
                rawSel.caretBidiLevel = main.bidiLevel;
            } else if (rawSel.extend) {
              rawSel.collapse(anchor.node, anchor.offset);
              try {
                rawSel.extend(head.node, head.offset);
              } catch (_) {
              }
            } else {
              let range = document.createRange();
              if (main.anchor > main.head)
                [anchor, head] = [head, anchor];
              range.setEnd(head.node, head.offset);
              range.setStart(anchor.node, anchor.offset);
              rawSel.removeAllRanges();
              rawSel.addRange(range);
            }
            if (selectionNotFocus && this.view.root.activeElement == this.dom) {
              this.dom.blur();
              if (activeElt)
                activeElt.focus();
            }
          });
          this.view.observer.setSelectionRange(anchor, head);
        }
        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
      }
      // If a zero-length widget is inserted next to the cursor during
      // composition, avoid moving it across it and disrupting the
      // composition.
      suppressWidgetCursorChange(sel, cursor2) {
        return this.hasComposition && cursor2.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor2.head;
      }
      enforceCursorAssoc() {
        if (this.hasComposition)
          return;
        let { view } = this, cursor2 = view.state.selection.main;
        let sel = getSelection(view.root);
        let { anchorNode, anchorOffset } = view.observer.selectionRange;
        if (!sel || !cursor2.empty || !cursor2.assoc || !sel.modify)
          return;
        let line = LineView.find(this, cursor2.head);
        if (!line)
          return;
        let lineStart = line.posAtStart;
        if (cursor2.head == lineStart || cursor2.head == lineStart + line.length)
          return;
        let before = this.coordsAt(cursor2.head, -1), after = this.coordsAt(cursor2.head, 1);
        if (!before || !after || before.bottom > after.top)
          return;
        let dom = this.domAtPos(cursor2.head + cursor2.assoc);
        sel.collapse(dom.node, dom.offset);
        sel.modify("move", cursor2.assoc < 0 ? "forward" : "backward", "lineboundary");
        view.observer.readSelectionRange();
        let newRange = view.observer.selectionRange;
        if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor2.from)
          sel.collapse(anchorNode, anchorOffset);
      }
      // If a position is in/near a block widget, move it to a nearby text
      // line, since we don't want the cursor inside a block widget.
      moveToLine(pos) {
        let dom = this.dom, newPos;
        if (pos.node != dom)
          return pos;
        for (let i2 = pos.offset; !newPos && i2 < dom.childNodes.length; i2++) {
          let view = ContentView.get(dom.childNodes[i2]);
          if (view instanceof LineView)
            newPos = view.domAtPos(0);
        }
        for (let i2 = pos.offset - 1; !newPos && i2 >= 0; i2--) {
          let view = ContentView.get(dom.childNodes[i2]);
          if (view instanceof LineView)
            newPos = view.domAtPos(view.length);
        }
        return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
      }
      nearest(dom) {
        for (let cur2 = dom; cur2; ) {
          let domView = ContentView.get(cur2);
          if (domView && domView.rootView == this)
            return domView;
          cur2 = cur2.parentNode;
        }
        return null;
      }
      posFromDOM(node, offset) {
        let view = this.nearest(node);
        if (!view)
          throw new RangeError("Trying to find position for a DOM position outside of the document");
        return view.localPosFromDOM(node, offset) + view.posAtStart;
      }
      domAtPos(pos) {
        let { i: i2, off } = this.childCursor().findPos(pos, -1);
        for (; i2 < this.children.length - 1; ) {
          let child = this.children[i2];
          if (off < child.length || child instanceof LineView)
            break;
          i2++;
          off = 0;
        }
        return this.children[i2].domAtPos(off);
      }
      coordsAt(pos, side) {
        let best = null, bestPos = 0;
        for (let off = this.length, i2 = this.children.length - 1; i2 >= 0; i2--) {
          let child = this.children[i2], end = off - child.breakAfter, start = end - child.length;
          if (end < pos)
            break;
          if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
            best = child;
            bestPos = start;
          } else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
            if (child.deco.startSide < 0)
              break;
            else if (i2)
              best = null;
          }
          off = start;
        }
        return best ? best.coordsAt(pos - bestPos, side) : null;
      }
      coordsForChar(pos) {
        let { i: i2, off } = this.childPos(pos, 1), child = this.children[i2];
        if (!(child instanceof LineView))
          return null;
        while (child.children.length) {
          let { i: i3, off: childOff } = child.childPos(off, 1);
          for (; ; i3++) {
            if (i3 == child.children.length)
              return null;
            if ((child = child.children[i3]).length)
              break;
          }
          off = childOff;
        }
        if (!(child instanceof TextView))
          return null;
        let end = findClusterBreak(child.text, off);
        if (end == off)
          return null;
        let rects = textRange(child.dom, off, end).getClientRects();
        for (let i3 = 0; i3 < rects.length; i3++) {
          let rect = rects[i3];
          if (i3 == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
            return rect;
        }
        return null;
      }
      measureVisibleLineHeights(viewport) {
        let result = [], { from: from2, to: to2 } = viewport;
        let contentWidth = this.view.contentDOM.clientWidth;
        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
        let widest = -1, ltr = this.view.textDirection == Direction.LTR;
        for (let pos = 0, i2 = 0; i2 < this.children.length; i2++) {
          let child = this.children[i2], end = pos + child.length;
          if (end > to2)
            break;
          if (pos >= from2) {
            let childRect = child.dom.getBoundingClientRect();
            result.push(childRect.height);
            if (isWider) {
              let last = child.dom.lastChild;
              let rects = last ? clientRectsFor(last) : [];
              if (rects.length) {
                let rect = rects[rects.length - 1];
                let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
                if (width > widest) {
                  widest = width;
                  this.minWidth = contentWidth;
                  this.minWidthFrom = pos;
                  this.minWidthTo = end;
                }
              }
            }
          }
          pos = end + child.breakAfter;
        }
        return result;
      }
      textDirectionAt(pos) {
        let { i: i2 } = this.childPos(pos, 1);
        return getComputedStyle(this.children[i2].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
      }
      measureTextSize() {
        for (let child of this.children) {
          if (child instanceof LineView) {
            let measure = child.measureTextSize();
            if (measure)
              return measure;
          }
        }
        let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
        dummy.className = "cm-line";
        dummy.style.width = "99999px";
        dummy.style.position = "absolute";
        dummy.textContent = "abc def ghi jkl mno pqr stu";
        this.view.observer.ignore(() => {
          this.dom.appendChild(dummy);
          let rect = clientRectsFor(dummy.firstChild)[0];
          lineHeight = dummy.getBoundingClientRect().height;
          charWidth = rect ? rect.width / 27 : 7;
          textHeight = rect ? rect.height : lineHeight;
          dummy.remove();
        });
        return { lineHeight, charWidth, textHeight };
      }
      childCursor(pos = this.length) {
        let i2 = this.children.length;
        if (i2)
          pos -= this.children[--i2].length;
        return new ChildCursor(this.children, pos, i2);
      }
      computeBlockGapDeco() {
        let deco = [], vs = this.view.viewState;
        for (let pos = 0, i2 = 0; ; i2++) {
          let next = i2 == vs.viewports.length ? null : vs.viewports[i2];
          let end = next ? next.from - 1 : this.length;
          if (end > pos) {
            let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
            deco.push(Decoration.replace({
              widget: new BlockGapWidget(height),
              block: true,
              inclusive: true,
              isBlockGap: true
            }).range(pos, end));
          }
          if (!next)
            break;
          pos = next.to + 1;
        }
        return Decoration.set(deco);
      }
      updateDeco() {
        let i2 = 1;
        let allDeco = this.view.state.facet(decorations).map((d) => {
          let dynamic = this.dynamicDecorationMap[i2++] = typeof d == "function";
          return dynamic ? d(this.view) : d;
        });
        let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i3) => {
          let dynamic = typeof d == "function";
          if (dynamic)
            dynamicOuter = true;
          return dynamic ? d(this.view) : d;
        });
        if (outerDeco.length) {
          this.dynamicDecorationMap[i2++] = dynamicOuter;
          allDeco.push(RangeSet.join(outerDeco));
        }
        this.decorations = [
          this.editContextFormatting,
          ...allDeco,
          this.computeBlockGapDeco(),
          this.view.viewState.lineGapDeco
        ];
        while (i2 < this.decorations.length)
          this.dynamicDecorationMap[i2++] = false;
        return this.decorations;
      }
      scrollIntoView(target) {
        if (target.isSnapshot) {
          let ref = this.view.viewState.lineBlockAt(target.range.head);
          this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
          this.view.scrollDOM.scrollLeft = target.xMargin;
          return;
        }
        for (let handler of this.view.state.facet(scrollHandler)) {
          try {
            if (handler(this.view, target.range, target))
              return true;
          } catch (e) {
            logException(this.view.state, e, "scroll handler");
          }
        }
        let { range } = target;
        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
        if (!rect)
          return;
        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
          rect = {
            left: Math.min(rect.left, other.left),
            top: Math.min(rect.top, other.top),
            right: Math.max(rect.right, other.right),
            bottom: Math.max(rect.bottom, other.bottom)
          };
        let margins = getScrollMargins(this.view);
        let targetRect = {
          left: rect.left - margins.left,
          top: rect.top - margins.top,
          right: rect.right + margins.right,
          bottom: rect.bottom + margins.bottom
        };
        let { offsetWidth, offsetHeight } = this.view.scrollDOM;
        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
      }
      lineHasWidget(pos) {
        let { i: i2 } = this.childCursor().findPos(pos);
        if (i2 == this.children.length)
          return false;
        let scan = (child) => child instanceof WidgetView || child.children.some(scan);
        return scan(this.children[i2]);
      }
    }
    function betweenUneditable(pos) {
      return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
    }
    function findCompositionNode(view, headPos) {
      let sel = view.observer.selectionRange;
      if (!sel.focusNode)
        return null;
      let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
      let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
      let textNode = textBefore || textAfter;
      if (textAfter && textBefore && textAfter.node != textBefore.node) {
        let descAfter = ContentView.get(textAfter.node);
        if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
          textNode = textAfter;
        } else if (view.docView.lastCompositionAfterCursor) {
          let descBefore = ContentView.get(textBefore.node);
          if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue))
            textNode = textAfter;
        }
      }
      view.docView.lastCompositionAfterCursor = textNode != textBefore;
      if (!textNode)
        return null;
      let from2 = headPos - textNode.offset;
      return { from: from2, to: from2 + textNode.node.nodeValue.length, node: textNode.node };
    }
    function findCompositionRange(view, changes, headPos) {
      let found = findCompositionNode(view, headPos);
      if (!found)
        return null;
      let { node: textNode, from: from2, to: to2 } = found, text = textNode.nodeValue;
      if (/[\n\r]/.test(text))
        return null;
      if (view.state.doc.sliceString(found.from, found.to) != text)
        return null;
      let inv = changes.invertedDesc;
      let range = new ChangedRange(inv.mapPos(from2), inv.mapPos(to2), from2, to2);
      let marks = [];
      for (let parent = textNode.parentNode; ; parent = parent.parentNode) {
        let parentView = ContentView.get(parent);
        if (parentView instanceof MarkView)
          marks.push({ node: parent, deco: parentView.mark });
        else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
          return { range, text: textNode, marks, line: parent };
        else if (parent != view.contentDOM)
          marks.push({ node: parent, deco: new MarkDecoration({
            inclusive: true,
            attributes: getAttrs(parent),
            tagName: parent.tagName.toLowerCase()
          }) });
        else
          return null;
      }
    }
    function nextToUneditable(node, offset) {
      if (node.nodeType != 1)
        return 0;
      return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
    }
    let DecorationComparator$1 = class DecorationComparator {
      constructor() {
        this.changes = [];
      }
      compareRange(from2, to2) {
        addRange(from2, to2, this.changes);
      }
      comparePoint(from2, to2) {
        addRange(from2, to2, this.changes);
      }
      boundChange(pos) {
        addRange(pos, pos, this.changes);
      }
    };
    function findChangedDeco(a, b, diff) {
      let comp = new DecorationComparator$1();
      RangeSet.compare(a, b, diff, comp);
      return comp.changes;
    }
    function inUneditable(node, inside2) {
      for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
        if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
          return true;
        }
      }
      return false;
    }
    function touchesComposition(changes, composition) {
      let touched = false;
      if (composition)
        changes.iterChangedRanges((from2, to2) => {
          if (from2 < composition.to && to2 > composition.from)
            touched = true;
        });
      return touched;
    }
    function groupAt(state, pos, bias = 1) {
      let categorize = state.charCategorizer(pos);
      let line = state.doc.lineAt(pos), linePos = pos - line.from;
      if (line.length == 0)
        return EditorSelection.cursor(pos);
      if (linePos == 0)
        bias = 1;
      else if (linePos == line.length)
        bias = -1;
      let from2 = linePos, to2 = linePos;
      if (bias < 0)
        from2 = findClusterBreak(line.text, linePos, false);
      else
        to2 = findClusterBreak(line.text, linePos);
      let cat = categorize(line.text.slice(from2, to2));
      while (from2 > 0) {
        let prev = findClusterBreak(line.text, from2, false);
        if (categorize(line.text.slice(prev, from2)) != cat)
          break;
        from2 = prev;
      }
      while (to2 < line.length) {
        let next = findClusterBreak(line.text, to2);
        if (categorize(line.text.slice(to2, next)) != cat)
          break;
        to2 = next;
      }
      return EditorSelection.range(from2 + line.from, to2 + line.from);
    }
    function getdx(x, rect) {
      return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
    }
    function getdy(y, rect) {
      return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
    }
    function yOverlap(a, b) {
      return a.top < b.bottom - 1 && a.bottom > b.top + 1;
    }
    function upTop(rect, top2) {
      return top2 < rect.top ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
    }
    function upBot(rect, bottom) {
      return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
    }
    function domPosAtCoords(parent, x, y) {
      let closest, closestRect, closestX, closestY, closestOverlap = false;
      let above, below, aboveRect, belowRect;
      for (let child = parent.firstChild; child; child = child.nextSibling) {
        let rects = clientRectsFor(child);
        for (let i2 = 0; i2 < rects.length; i2++) {
          let rect = rects[i2];
          if (closestRect && yOverlap(closestRect, rect))
            rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
          let dx = getdx(x, rect), dy = getdy(y, rect);
          if (dx == 0 && dy == 0)
            return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
          if (!closest || closestY > dy || closestY == dy && closestX > dx) {
            closest = child;
            closestRect = rect;
            closestX = dx;
            closestY = dy;
            closestOverlap = !dx ? true : x < rect.left ? i2 > 0 : i2 < rects.length - 1;
          }
          if (dx == 0) {
            if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
              above = child;
              aboveRect = rect;
            } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
              below = child;
              belowRect = rect;
            }
          } else if (aboveRect && yOverlap(aboveRect, rect)) {
            aboveRect = upBot(aboveRect, rect.bottom);
          } else if (belowRect && yOverlap(belowRect, rect)) {
            belowRect = upTop(belowRect, rect.top);
          }
        }
      }
      if (aboveRect && aboveRect.bottom >= y) {
        closest = above;
        closestRect = aboveRect;
      } else if (belowRect && belowRect.top <= y) {
        closest = below;
        closestRect = belowRect;
      }
      if (!closest)
        return { node: parent, offset: 0 };
      let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
      if (closest.nodeType == 3)
        return domPosInText(closest, clipX, y);
      if (closestOverlap && closest.contentEditable != "false")
        return domPosAtCoords(closest, clipX, y);
      let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
      return { node: parent, offset };
    }
    function domPosInText(node, x, y) {
      let len = node.nodeValue.length;
      let closestOffset = -1, closestDY = 1e9, generalSide = 0;
      for (let i2 = 0; i2 < len; i2++) {
        let rects = textRange(node, i2, i2 + 1).getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (rect.top == rect.bottom)
            continue;
          if (!generalSide)
            generalSide = x - rect.left;
          let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
          if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
            let right = x >= (rect.left + rect.right) / 2, after = right;
            if (browser.chrome || browser.gecko) {
              let rectBefore = textRange(node, i2).getBoundingClientRect();
              if (Math.abs(rectBefore.left - rect.right) < 0.1)
                after = !right;
            }
            if (dy <= 0)
              return { node, offset: i2 + (after ? 1 : 0) };
            closestOffset = i2 + (after ? 1 : 0);
            closestDY = dy;
          }
        }
      }
      return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
    }
    function posAtCoords(view, coords, precise, bias = -1) {
      var _a2, _b;
      let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
      let block, { docHeight } = view.viewState;
      let { x, y } = coords, yOffset = y - docTop;
      if (yOffset < 0)
        return 0;
      if (yOffset > docHeight)
        return view.state.doc.length;
      for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
        block = view.elementAtHeight(yOffset);
        if (block.type == BlockType.Text)
          break;
        for (; ; ) {
          yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
          if (yOffset >= 0 && yOffset <= docHeight)
            break;
          if (bounced)
            return precise ? null : 0;
          bounced = true;
          bias = -bias;
        }
      }
      y = docTop + yOffset;
      let lineStart = block.from;
      if (lineStart < view.viewport.from)
        return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
      if (lineStart > view.viewport.to)
        return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
      let doc2 = view.dom.ownerDocument;
      let root = view.root.elementFromPoint ? view.root : doc2;
      let element = root.elementFromPoint(x, y);
      if (element && !view.contentDOM.contains(element))
        element = null;
      if (!element) {
        x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
        element = root.elementFromPoint(x, y);
        if (element && !view.contentDOM.contains(element))
          element = null;
      }
      let node, offset = -1;
      if (element && ((_a2 = view.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
        if (doc2.caretPositionFromPoint) {
          let pos = doc2.caretPositionFromPoint(x, y);
          if (pos)
            ({ offsetNode: node, offset } = pos);
        } else if (doc2.caretRangeFromPoint) {
          let range = doc2.caretRangeFromPoint(x, y);
          if (range)
            ({ startContainer: node, startOffset: offset } = range);
        }
        if (node && (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x)))
          node = void 0;
        if (node)
          offset = Math.min(maxOffset(node), offset);
      }
      if (!node || !view.docView.dom.contains(node)) {
        let line = LineView.find(view.docView, lineStart);
        if (!line)
          return yOffset > block.top + block.height / 2 ? block.to : block.from;
        ({ node, offset } = domPosAtCoords(line.dom, x, y));
      }
      let nearest = view.docView.nearest(node);
      if (!nearest)
        return null;
      if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
        let rect = nearest.dom.getBoundingClientRect();
        return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
      } else {
        return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
      }
    }
    function posAtCoordsImprecise(view, contentRect, block, x, y) {
      let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
      if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
        let textHeight = view.viewState.heightOracle.textHeight;
        let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
        into += line * view.viewState.heightOracle.lineLength;
      }
      let content2 = view.state.sliceDoc(block.from, block.to);
      return block.from + findColumn$1(content2, into, view.state.tabSize);
    }
    function isEndOfLineBefore(node, offset, x) {
      let len, scan = node;
      if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
        return false;
      for (; ; ) {
        let next = scan.nextSibling;
        if (next) {
          if (next.nodeName == "BR")
            break;
          return false;
        } else {
          let parent = scan.parentNode;
          if (!parent || parent.nodeName == "DIV")
            break;
          scan = parent;
        }
      }
      return textRange(node, len - 1, len).getBoundingClientRect().right > x;
    }
    function isSuspiciousSafariCaretResult(node, offset, x) {
      return isEndOfLineBefore(node, offset, x);
    }
    function isSuspiciousChromeCaretResult(node, offset, x) {
      if (offset != 0)
        return isEndOfLineBefore(node, offset, x);
      for (let cur2 = node; ; ) {
        let parent = cur2.parentNode;
        if (!parent || parent.nodeType != 1 || parent.firstChild != cur2)
          return false;
        if (parent.classList.contains("cm-line"))
          break;
        cur2 = parent;
      }
      let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
      return x - rect.left > 5;
    }
    function blockAt(view, pos, side) {
      let line = view.lineBlockAt(pos);
      if (Array.isArray(line.type)) {
        let best;
        for (let l of line.type) {
          if (l.from > pos)
            break;
          if (l.to < pos)
            continue;
          if (l.from < pos && l.to > pos)
            return l;
          if (!best || l.type == BlockType.Text && (best.type != l.type || (side < 0 ? l.from < pos : l.to > pos)))
            best = l;
        }
        return best || line;
      }
      return line;
    }
    function moveToLineBoundary(view, start, forward, includeWrap) {
      let line = blockAt(view, start.head, start.assoc || -1);
      let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
      if (coords) {
        let editorRect = view.dom.getBoundingClientRect();
        let direction = view.textDirectionAt(line.from);
        let pos = view.posAtCoords({
          x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
          y: (coords.top + coords.bottom) / 2
        });
        if (pos != null)
          return EditorSelection.cursor(pos, forward ? -1 : 1);
      }
      return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
    }
    function moveByChar(view, start, forward, by) {
      let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
      let direction = view.textDirectionAt(line.from);
      for (let cur2 = start, check = null; ; ) {
        let next = moveVisually(line, spans, direction, cur2, forward), char = movedOver;
        if (!next) {
          if (line.number == (forward ? view.state.doc.lines : 1))
            return cur2;
          char = "\n";
          line = view.state.doc.line(line.number + (forward ? 1 : -1));
          spans = view.bidiSpans(line);
          next = view.visualLineSide(line, !forward);
        }
        if (!check) {
          if (!by)
            return next;
          check = by(char);
        } else if (!check(char)) {
          return cur2;
        }
        cur2 = next;
      }
    }
    function byGroup(view, pos, start) {
      let categorize = view.state.charCategorizer(pos);
      let cat = categorize(start);
      return (next) => {
        let nextCat = categorize(next);
        if (cat == CharCategory.Space)
          cat = nextCat;
        return cat == nextCat;
      };
    }
    function moveVertically(view, start, forward, distance) {
      let startPos = start.head, dir = forward ? 1 : -1;
      if (startPos == (forward ? view.state.doc.length : 0))
        return EditorSelection.cursor(startPos, start.assoc);
      let goal = start.goalColumn, startY;
      let rect = view.contentDOM.getBoundingClientRect();
      let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
      if (startCoords) {
        if (goal == null)
          goal = startCoords.left - rect.left;
        startY = dir < 0 ? startCoords.top : startCoords.bottom;
      } else {
        let line = view.viewState.lineBlockAt(startPos);
        if (goal == null)
          goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
        startY = (dir < 0 ? line.top : line.bottom) + docTop;
      }
      let resolvedGoal = rect.left + goal;
      let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
      for (let extra = 0; ; extra += 10) {
        let curY = startY + (dist2 + extra) * dir;
        let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
        if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
          let charRect = view.docView.coordsForChar(pos);
          let assoc = !charRect || curY < charRect.top ? -1 : 1;
          return EditorSelection.cursor(pos, assoc, void 0, goal);
        }
      }
    }
    function skipAtomicRanges(atoms, pos, bias) {
      for (; ; ) {
        let moved = 0;
        for (let set2 of atoms) {
          set2.between(pos - 1, pos + 1, (from2, to2, value) => {
            if (pos > from2 && pos < to2) {
              let side = moved || bias || (pos - from2 < to2 - pos ? -1 : 1);
              pos = side < 0 ? from2 : to2;
              moved = side;
            }
          });
        }
        if (!moved)
          return pos;
      }
    }
    function skipAtomsForSelection(atoms, sel) {
      let ranges = null;
      for (let i2 = 0; i2 < sel.ranges.length; i2++) {
        let range = sel.ranges[i2], updated = null;
        if (range.empty) {
          let pos = skipAtomicRanges(atoms, range.from, 0);
          if (pos != range.from)
            updated = EditorSelection.cursor(pos, -1);
        } else {
          let from2 = skipAtomicRanges(atoms, range.from, -1);
          let to2 = skipAtomicRanges(atoms, range.to, 1);
          if (from2 != range.from || to2 != range.to)
            updated = EditorSelection.range(range.from == range.anchor ? from2 : to2, range.from == range.head ? from2 : to2);
        }
        if (updated) {
          if (!ranges)
            ranges = sel.ranges.slice();
          ranges[i2] = updated;
        }
      }
      return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
    }
    function skipAtoms(view, oldPos, pos) {
      let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f) => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
      return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
    }
    const LineBreakPlaceholder = "";
    class DOMReader {
      constructor(points, state) {
        this.points = points;
        this.text = "";
        this.lineSeparator = state.facet(EditorState.lineSeparator);
      }
      append(text) {
        this.text += text;
      }
      lineBreak() {
        this.text += LineBreakPlaceholder;
      }
      readRange(start, end) {
        if (!start)
          return this;
        let parent = start.parentNode;
        for (let cur2 = start; ; ) {
          this.findPointBefore(parent, cur2);
          let oldLen = this.text.length;
          this.readNode(cur2);
          let next = cur2.nextSibling;
          if (next == end)
            break;
          let view = ContentView.get(cur2), nextView = ContentView.get(next);
          if ((view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || cur2.cmIgnore) && this.text.length > oldLen) && !isEmptyToEnd(next, end))
            this.lineBreak();
          cur2 = next;
        }
        this.findPointBefore(parent, end);
        return this;
      }
      readTextNode(node) {
        let text = node.nodeValue;
        for (let point of this.points)
          if (point.node == node)
            point.pos = this.text.length + Math.min(point.offset, text.length);
        for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
          let nextBreak = -1, breakSize = 1, m;
          if (this.lineSeparator) {
            nextBreak = text.indexOf(this.lineSeparator, off);
            breakSize = this.lineSeparator.length;
          } else if (m = re.exec(text)) {
            nextBreak = m.index;
            breakSize = m[0].length;
          }
          this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
          if (nextBreak < 0)
            break;
          this.lineBreak();
          if (breakSize > 1) {
            for (let point of this.points)
              if (point.node == node && point.pos > this.text.length)
                point.pos -= breakSize - 1;
          }
          off = nextBreak + breakSize;
        }
      }
      readNode(node) {
        if (node.cmIgnore)
          return;
        let view = ContentView.get(node);
        let fromView = view && view.overrideDOMText;
        if (fromView != null) {
          this.findPointInside(node, fromView.length);
          for (let i2 = fromView.iter(); !i2.next().done; ) {
            if (i2.lineBreak)
              this.lineBreak();
            else
              this.append(i2.value);
          }
        } else if (node.nodeType == 3) {
          this.readTextNode(node);
        } else if (node.nodeName == "BR") {
          if (node.nextSibling)
            this.lineBreak();
        } else if (node.nodeType == 1) {
          this.readRange(node.firstChild, null);
        }
      }
      findPointBefore(node, next) {
        for (let point of this.points)
          if (point.node == node && node.childNodes[point.offset] == next)
            point.pos = this.text.length;
      }
      findPointInside(node, length) {
        for (let point of this.points)
          if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
            point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
      }
    }
    function isAtEnd(parent, node, offset) {
      for (; ; ) {
        if (!node || offset < maxOffset(node))
          return false;
        if (node == parent)
          return true;
        offset = domIndex(node) + 1;
        node = node.parentNode;
      }
    }
    function isEmptyToEnd(node, end) {
      let widgets;
      for (; ; node = node.nextSibling) {
        if (node == end || !node)
          break;
        let view = ContentView.get(node);
        if (!((view === null || view === void 0 ? void 0 : view.isWidget) || node.cmIgnore))
          return false;
        if (view)
          (widgets || (widgets = [])).push(view);
      }
      if (widgets)
        for (let w of widgets) {
          let override = w.overrideDOMText;
          if (override === null || override === void 0 ? void 0 : override.length)
            return false;
        }
      return true;
    }
    class DOMPoint {
      constructor(node, offset) {
        this.node = node;
        this.offset = offset;
        this.pos = -1;
      }
    }
    class DOMChange {
      constructor(view, start, end, typeOver) {
        this.typeOver = typeOver;
        this.bounds = null;
        this.text = "";
        this.domChanged = start > -1;
        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
        if (view.state.readOnly && start > -1) {
          this.newSel = null;
        } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
          let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
          let reader = new DOMReader(selPoints, view.state);
          reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
          this.text = reader.text;
          this.newSel = selectionFromPoints(selPoints, this.bounds.from);
        } else {
          let domSel = view.observer.selectionRange;
          let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
          let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
          let vp = view.viewport;
          if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {
            let from2 = Math.min(head, anchor), to2 = Math.max(head, anchor);
            let offFrom = vp.from - from2, offTo = vp.to - to2;
            if ((offFrom == 0 || offFrom == 1 || from2 == 0) && (offTo == 0 || offTo == -1 || to2 == view.state.doc.length)) {
              head = 0;
              anchor = view.state.doc.length;
            }
          }
          if (view.inputState.composing > -1 && view.state.selection.ranges.length > 1)
            this.newSel = view.state.selection.replaceRange(EditorSelection.range(anchor, head));
          else
            this.newSel = EditorSelection.single(anchor, head);
        }
      }
    }
    function applyDOMChange(view, domChange) {
      let change;
      let { newSel } = domChange, sel = view.state.selection.main;
      let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
      if (domChange.bounds) {
        let { from: from2, to: to2 } = domChange.bounds;
        let preferredPos = sel.from, preferredSide = null;
        if (lastKey === 8 || browser.android && domChange.text.length < to2 - from2) {
          preferredPos = sel.to;
          preferredSide = "end";
        }
        let diff = findDiff(view.state.doc.sliceString(from2, to2, LineBreakPlaceholder), domChange.text, preferredPos - from2, preferredSide);
        if (diff) {
          if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
            diff.toB--;
          change = {
            from: from2 + diff.from,
            to: from2 + diff.toA,
            insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
          };
        }
      } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
        newSel = null;
      }
      if (!change && !newSel)
        return false;
      if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
        change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
      } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
        if (newSel && change.insert.length == 2)
          newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
        change = { from: change.from, to: change.to, insert: Text.of([change.insert.toString().replace(".", " ")]) };
      } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
        change = {
          from: sel.from,
          to: sel.to,
          insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
        };
      } else if (view.state.doc.lineAt(sel.from).to < sel.to && view.docView.lineHasWidget(sel.to) && view.inputState.insertingTextAt > Date.now() - 50) {
        change = {
          from: sel.from,
          to: sel.to,
          insert: view.state.toText(view.inputState.insertingText)
        };
      } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
        if (newSel)
          newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
        change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
      }
      if (change) {
        return applyDOMChangeInner(view, change, newSel, lastKey);
      } else if (newSel && !newSel.main.eq(sel)) {
        let scrollIntoView2 = false, userEvent = "select";
        if (view.inputState.lastSelectionTime > Date.now() - 50) {
          if (view.inputState.lastSelectionOrigin == "select")
            scrollIntoView2 = true;
          userEvent = view.inputState.lastSelectionOrigin;
          if (userEvent == "select.pointer")
            newSel = skipAtomsForSelection(view.state.facet(atomicRanges).map((f) => f(view)), newSel);
        }
        view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView2, userEvent });
        return true;
      } else {
        return false;
      }
    }
    function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
      if (browser.ios && view.inputState.flushIOSKey(change))
        return true;
      let sel = view.state.selection.main;
      if (browser.android && (change.to == sel.to && // GBoard will sometimes remove a space it just inserted
      // after a completion when you press enter
      (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
        return true;
      let text = change.insert.toString();
      if (view.inputState.composing >= 0)
        view.inputState.composing++;
      let defaultTr;
      let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
      if (!view.state.facet(inputHandler$1).some((h) => h(view, change.from, change.to, text, defaultInsert)))
        view.dispatch(defaultInsert());
      return true;
    }
    function applyDefaultInsert(view, change, newSel) {
      let tr, startState = view.state, sel = startState.selection.main, inAtomic = -1;
      if (change.from == change.to && change.from < sel.from || change.from > sel.to) {
        let side = change.from < sel.from ? -1 : 1, pos = side < 0 ? sel.from : sel.to;
        let moved = skipAtomicRanges(startState.facet(atomicRanges).map((f) => f(view)), pos, side);
        if (change.from == moved)
          inAtomic = moved;
      }
      if (inAtomic > -1) {
        tr = {
          changes: change,
          selection: EditorSelection.cursor(change.from + change.insert.length, -1)
        };
      } else if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
      } else {
        let changes = startState.changes(change);
        let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
        if (startState.selection.ranges.length > 1 && (view.inputState.composing >= 0 || view.inputState.compositionPendingChange) && change.to <= sel.to + 10 && change.to >= sel.to - 10) {
          let replaced = view.state.sliceDoc(change.from, change.to);
          let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
          if (composition) {
            let dLen = change.insert.length - (change.to - change.from);
            compositionRange = { from: composition.from, to: composition.to - dLen };
          } else {
            compositionRange = view.state.doc.lineAt(sel.head);
          }
          let offset = sel.to - change.to;
          tr = startState.changeByRange((range) => {
            if (range.from == sel.from && range.to == sel.to)
              return { changes, range: mainSel || range.map(changes) };
            let to2 = range.to - offset, from2 = to2 - replaced.length;
            if (view.state.sliceDoc(from2, to2) != replaced || // Unfortunately, there's no way to make multiple
            // changes in the same node work without aborting
            // composition, so cursors in the composition range are
            // ignored.
            to2 >= compositionRange.from && from2 <= compositionRange.to)
              return { range };
            let rangeChanges = startState.changes({ from: from2, to: to2, insert: change.insert }), selOff = range.to - sel.to;
            return {
              changes: rangeChanges,
              range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
            };
          });
        } else {
          tr = {
            changes,
            selection: mainSel && startState.selection.replaceRange(mainSel)
          };
        }
      }
      let userEvent = "input.type";
      if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
        view.inputState.compositionPendingChange = false;
        userEvent += ".compose";
        if (view.inputState.compositionFirstChange) {
          userEvent += ".start";
          view.inputState.compositionFirstChange = false;
        }
      }
      return startState.update(tr, { userEvent, scrollIntoView: true });
    }
    function findDiff(a, b, preferredPos, preferredSide) {
      let minLen = Math.min(a.length, b.length);
      let from2 = 0;
      while (from2 < minLen && a.charCodeAt(from2) == b.charCodeAt(from2))
        from2++;
      if (from2 == minLen && a.length == b.length)
        return null;
      let toA = a.length, toB = b.length;
      while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
        toA--;
        toB--;
      }
      if (preferredSide == "end") {
        let adjust = Math.max(0, from2 - Math.min(toA, toB));
        preferredPos -= toA + adjust - from2;
      }
      if (toA < from2 && a.length < b.length) {
        let move = preferredPos <= from2 && preferredPos >= toA ? from2 - preferredPos : 0;
        from2 -= move;
        toB = from2 + (toB - toA);
        toA = from2;
      } else if (toB < from2) {
        let move = preferredPos <= from2 && preferredPos >= toB ? from2 - preferredPos : 0;
        from2 -= move;
        toA = from2 + (toA - toB);
        toB = from2;
      }
      return { from: from2, toA, toB };
    }
    function selectionPoints(view) {
      let result = [];
      if (view.root.activeElement != view.contentDOM)
        return result;
      let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
      if (anchorNode) {
        result.push(new DOMPoint(anchorNode, anchorOffset));
        if (focusNode != anchorNode || focusOffset != anchorOffset)
          result.push(new DOMPoint(focusNode, focusOffset));
      }
      return result;
    }
    function selectionFromPoints(points, base2) {
      if (points.length == 0)
        return null;
      let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
      return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
    }
    class InputState {
      setSelectionOrigin(origin2) {
        this.lastSelectionOrigin = origin2;
        this.lastSelectionTime = Date.now();
      }
      constructor(view) {
        this.view = view;
        this.lastKeyCode = 0;
        this.lastKeyTime = 0;
        this.lastTouchTime = 0;
        this.lastFocusTime = 0;
        this.lastScrollTop = 0;
        this.lastScrollLeft = 0;
        this.pendingIOSKey = void 0;
        this.tabFocusMode = -1;
        this.lastSelectionOrigin = null;
        this.lastSelectionTime = 0;
        this.lastContextMenu = 0;
        this.scrollHandlers = [];
        this.handlers = /* @__PURE__ */ Object.create(null);
        this.composing = -1;
        this.compositionFirstChange = null;
        this.compositionEndedAt = 0;
        this.compositionPendingKey = false;
        this.compositionPendingChange = false;
        this.insertingText = "";
        this.insertingTextAt = 0;
        this.mouseSelection = null;
        this.draggedContent = null;
        this.handleEvent = this.handleEvent.bind(this);
        this.notifiedFocused = view.hasFocus;
        if (browser.safari)
          view.contentDOM.addEventListener("input", () => null);
        if (browser.gecko)
          firefoxCopyCutHack(view.contentDOM.ownerDocument);
      }
      handleEvent(event) {
        if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
          return;
        if (event.type == "keydown" && this.keydown(event))
          return;
        if (this.view.updateState != 0)
          Promise.resolve().then(() => this.runHandlers(event.type, event));
        else
          this.runHandlers(event.type, event);
      }
      runHandlers(type, event) {
        let handlers2 = this.handlers[type];
        if (handlers2) {
          for (let observer of handlers2.observers)
            observer(this.view, event);
          for (let handler of handlers2.handlers) {
            if (event.defaultPrevented)
              break;
            if (handler(this.view, event)) {
              event.preventDefault();
              break;
            }
          }
        }
      }
      ensureHandlers(plugins) {
        let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
        for (let type in handlers2)
          if (type != "scroll") {
            let passive = !handlers2[type].handlers.length;
            let exists = prev[type];
            if (exists && passive != !exists.handlers.length) {
              dom.removeEventListener(type, this.handleEvent);
              exists = null;
            }
            if (!exists)
              dom.addEventListener(type, this.handleEvent, { passive });
          }
        for (let type in prev)
          if (type != "scroll" && !handlers2[type])
            dom.removeEventListener(type, this.handleEvent);
        this.handlers = handlers2;
      }
      keydown(event) {
        this.lastKeyCode = event.keyCode;
        this.lastKeyTime = Date.now();
        if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
          return true;
        if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
          this.tabFocusMode = -1;
        if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
          this.view.observer.delayAndroidKey(event.key, event.keyCode);
          return true;
        }
        let pending;
        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
          this.pendingIOSKey = pending || event;
          setTimeout(() => this.flushIOSKey(), 250);
          return true;
        }
        if (event.keyCode != 229)
          this.view.observer.forceFlush();
        return false;
      }
      flushIOSKey(change) {
        let key = this.pendingIOSKey;
        if (!key)
          return false;
        if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
          return false;
        this.pendingIOSKey = void 0;
        return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : void 0);
      }
      ignoreDuringComposition(event) {
        if (!/^key/.test(event.type) || event.synthetic)
          return false;
        if (this.composing > 0)
          return true;
        if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
          this.compositionPendingKey = false;
          return true;
        }
        return false;
      }
      startMouseSelection(mouseSelection) {
        if (this.mouseSelection)
          this.mouseSelection.destroy();
        this.mouseSelection = mouseSelection;
      }
      update(update) {
        this.view.observer.update(update);
        if (this.mouseSelection)
          this.mouseSelection.update(update);
        if (this.draggedContent && update.docChanged)
          this.draggedContent = this.draggedContent.map(update.changes);
        if (update.transactions.length)
          this.lastKeyCode = this.lastSelectionTime = 0;
      }
      destroy() {
        if (this.mouseSelection)
          this.mouseSelection.destroy();
      }
    }
    function bindHandler(plugin, handler) {
      return (view, event) => {
        try {
          return handler.call(plugin, event, view);
        } catch (e) {
          logException(view.state, e);
        }
      };
    }
    function computeHandlers(plugins) {
      let result = /* @__PURE__ */ Object.create(null);
      function record(type) {
        return result[type] || (result[type] = { observers: [], handlers: [] });
      }
      for (let plugin of plugins) {
        let spec = plugin.spec, handlers2 = spec && spec.plugin.domEventHandlers, observers2 = spec && spec.plugin.domEventObservers;
        if (handlers2)
          for (let type in handlers2) {
            let f = handlers2[type];
            if (f)
              record(type).handlers.push(bindHandler(plugin.value, f));
          }
        if (observers2)
          for (let type in observers2) {
            let f = observers2[type];
            if (f)
              record(type).observers.push(bindHandler(plugin.value, f));
          }
      }
      for (let type in handlers)
        record(type).handlers.push(handlers[type]);
      for (let type in observers)
        record(type).observers.push(observers[type]);
      return result;
    }
    const PendingKeys = [
      { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
      { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
      { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
      { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
    ];
    const EmacsyPendingKeys = "dthko";
    const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
    const dragScrollMargin = 6;
    function dragScrollSpeed(dist2) {
      return Math.max(0, dist2) * 0.7 + 8;
    }
    function dist(a, b) {
      return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
    }
    class MouseSelection {
      constructor(view, startEvent, style, mustSelect) {
        this.view = view;
        this.startEvent = startEvent;
        this.style = style;
        this.mustSelect = mustSelect;
        this.scrollSpeed = { x: 0, y: 0 };
        this.scrolling = -1;
        this.lastEvent = startEvent;
        this.scrollParents = scrollableParents(view.contentDOM);
        this.atoms = view.state.facet(atomicRanges).map((f) => f(view));
        let doc2 = view.contentDOM.ownerDocument;
        doc2.addEventListener("mousemove", this.move = this.move.bind(this));
        doc2.addEventListener("mouseup", this.up = this.up.bind(this));
        this.extend = startEvent.shiftKey;
        this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
      }
      start(event) {
        if (this.dragging === false)
          this.select(event);
      }
      move(event) {
        if (event.buttons == 0)
          return this.destroy();
        if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
          return;
        this.select(this.lastEvent = event);
        let sx = 0, sy = 0;
        let left = 0, top2 = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;
        if (this.scrollParents.x)
          ({ left, right } = this.scrollParents.x.getBoundingClientRect());
        if (this.scrollParents.y)
          ({ top: top2, bottom } = this.scrollParents.y.getBoundingClientRect());
        let margins = getScrollMargins(this.view);
        if (event.clientX - margins.left <= left + dragScrollMargin)
          sx = -dragScrollSpeed(left - event.clientX);
        else if (event.clientX + margins.right >= right - dragScrollMargin)
          sx = dragScrollSpeed(event.clientX - right);
        if (event.clientY - margins.top <= top2 + dragScrollMargin)
          sy = -dragScrollSpeed(top2 - event.clientY);
        else if (event.clientY + margins.bottom >= bottom - dragScrollMargin)
          sy = dragScrollSpeed(event.clientY - bottom);
        this.setScrollSpeed(sx, sy);
      }
      up(event) {
        if (this.dragging == null)
          this.select(this.lastEvent);
        if (!this.dragging)
          event.preventDefault();
        this.destroy();
      }
      destroy() {
        this.setScrollSpeed(0, 0);
        let doc2 = this.view.contentDOM.ownerDocument;
        doc2.removeEventListener("mousemove", this.move);
        doc2.removeEventListener("mouseup", this.up);
        this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
      }
      setScrollSpeed(sx, sy) {
        this.scrollSpeed = { x: sx, y: sy };
        if (sx || sy) {
          if (this.scrolling < 0)
            this.scrolling = setInterval(() => this.scroll(), 50);
        } else if (this.scrolling > -1) {
          clearInterval(this.scrolling);
          this.scrolling = -1;
        }
      }
      scroll() {
        let { x, y } = this.scrollSpeed;
        if (x && this.scrollParents.x) {
          this.scrollParents.x.scrollLeft += x;
          x = 0;
        }
        if (y && this.scrollParents.y) {
          this.scrollParents.y.scrollTop += y;
          y = 0;
        }
        if (x || y)
          this.view.win.scrollBy(x, y);
        if (this.dragging === false)
          this.select(this.lastEvent);
      }
      select(event) {
        let { view } = this, selection2 = skipAtomsForSelection(this.atoms, this.style.get(event, this.extend, this.multiple));
        if (this.mustSelect || !selection2.eq(view.state.selection, this.dragging === false))
          this.view.dispatch({
            selection: selection2,
            userEvent: "select.pointer"
          });
        this.mustSelect = false;
      }
      update(update) {
        if (update.transactions.some((tr) => tr.isUserEvent("input.type")))
          this.destroy();
        else if (this.style.update(update))
          setTimeout(() => this.select(this.lastEvent), 20);
      }
    }
    function addsSelectionRange(view, event) {
      let facet = view.state.facet(clickAddsSelectionRange);
      return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
    }
    function dragMovesSelection(view, event) {
      let facet = view.state.facet(dragMovesSelection$1);
      return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
    }
    function isInPrimarySelection(view, event) {
      let { main } = view.state.selection;
      if (main.empty)
        return false;
      let sel = getSelection(view.root);
      if (!sel || sel.rangeCount == 0)
        return true;
      let rects = sel.getRangeAt(0).getClientRects();
      for (let i2 = 0; i2 < rects.length; i2++) {
        let rect = rects[i2];
        if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
          return true;
      }
      return false;
    }
    function eventBelongsToEditor(view, event) {
      if (!event.bubbles)
        return true;
      if (event.defaultPrevented)
        return false;
      for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
        if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
          return false;
      return true;
    }
    const handlers = /* @__PURE__ */ Object.create(null);
    const observers = /* @__PURE__ */ Object.create(null);
    const brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
    function capturePaste(view) {
      let parent = view.dom.parentNode;
      if (!parent)
        return;
      let target = parent.appendChild(document.createElement("textarea"));
      target.style.cssText = "position: fixed; left: -10000px; top: 10px";
      target.focus();
      setTimeout(() => {
        view.focus();
        target.remove();
        doPaste(view, target.value);
      }, 50);
    }
    function textFilter(state, facet, text) {
      for (let filter of state.facet(facet))
        text = filter(text, state);
      return text;
    }
    function doPaste(view, input) {
      input = textFilter(view.state, clipboardInputFilter, input);
      let { state } = view, changes, i2 = 1, text = state.toText(input);
      let byLine = text.lines == state.selection.ranges.length;
      let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text.toString();
      if (linewise) {
        let lastLine = -1;
        changes = state.changeByRange((range) => {
          let line = state.doc.lineAt(range.from);
          if (line.from == lastLine)
            return { range };
          lastLine = line.from;
          let insert2 = state.toText((byLine ? text.line(i2++).text : input) + state.lineBreak);
          return {
            changes: { from: line.from, insert: insert2 },
            range: EditorSelection.cursor(range.from + insert2.length)
          };
        });
      } else if (byLine) {
        changes = state.changeByRange((range) => {
          let line = text.line(i2++);
          return {
            changes: { from: range.from, to: range.to, insert: line.text },
            range: EditorSelection.cursor(range.from + line.length)
          };
        });
      } else {
        changes = state.replaceSelection(text);
      }
      view.dispatch(changes, {
        userEvent: "input.paste",
        scrollIntoView: true
      });
    }
    observers.scroll = (view) => {
      view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
      view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
    };
    handlers.keydown = (view, event) => {
      view.inputState.setSelectionOrigin("select");
      if (event.keyCode == 27 && view.inputState.tabFocusMode != 0)
        view.inputState.tabFocusMode = Date.now() + 2e3;
      return false;
    };
    observers.touchstart = (view, e) => {
      view.inputState.lastTouchTime = Date.now();
      view.inputState.setSelectionOrigin("select.pointer");
    };
    observers.touchmove = (view) => {
      view.inputState.setSelectionOrigin("select.pointer");
    };
    handlers.mousedown = (view, event) => {
      view.observer.flush();
      if (view.inputState.lastTouchTime > Date.now() - 2e3)
        return false;
      let style = null;
      for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
        style = makeStyle(view, event);
        if (style)
          break;
      }
      if (!style && event.button == 0)
        style = basicMouseSelection(view, event);
      if (style) {
        let mustFocus = !view.hasFocus;
        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
        if (mustFocus)
          view.observer.ignore(() => {
            focusPreventScroll(view.contentDOM);
            let active = view.root.activeElement;
            if (active && !active.contains(view.contentDOM))
              active.blur();
          });
        let mouseSel = view.inputState.mouseSelection;
        if (mouseSel) {
          mouseSel.start(event);
          return mouseSel.dragging === false;
        }
      } else {
        view.inputState.setSelectionOrigin("select.pointer");
      }
      return false;
    };
    function rangeForClick(view, pos, bias, type) {
      if (type == 1) {
        return EditorSelection.cursor(pos, bias);
      } else if (type == 2) {
        return groupAt(view.state, pos, bias);
      } else {
        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
        let from2 = visual ? visual.posAtStart : line.from, to2 = visual ? visual.posAtEnd : line.to;
        if (to2 < view.state.doc.length && to2 == line.to)
          to2++;
        return EditorSelection.range(from2, to2);
      }
    }
    let inside = (x, y, rect) => y >= rect.top && y <= rect.bottom && x >= rect.left && x <= rect.right;
    function findPositionSide(view, pos, x, y) {
      let line = LineView.find(view.docView, pos);
      if (!line)
        return 1;
      let off = pos - line.posAtStart;
      if (off == 0)
        return 1;
      if (off == line.length)
        return -1;
      let before = line.coordsAt(off, -1);
      if (before && inside(x, y, before))
        return -1;
      let after = line.coordsAt(off, 1);
      if (after && inside(x, y, after))
        return 1;
      return before && before.bottom >= y ? -1 : 1;
    }
    function queryPos(view, event) {
      let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
      return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
    }
    const BadMouseDetail = browser.ie && browser.ie_version <= 11;
    let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;
    function getClickType(event) {
      if (!BadMouseDetail)
        return event.detail;
      let last = lastMouseDown, lastTime = lastMouseDownTime;
      lastMouseDown = event;
      lastMouseDownTime = Date.now();
      return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
    }
    function basicMouseSelection(view, event) {
      let start = queryPos(view, event), type = getClickType(event);
      let startSel = view.state.selection;
      return {
        update(update) {
          if (update.docChanged) {
            start.pos = update.changes.mapPos(start.pos);
            startSel = startSel.map(update.changes);
          }
        },
        get(event2, extend2, multiple) {
          let cur2 = queryPos(view, event2), removed;
          let range = rangeForClick(view, cur2.pos, cur2.bias, type);
          if (start.pos != cur2.pos && !extend2) {
            let startRange = rangeForClick(view, start.pos, start.bias, type);
            let from2 = Math.min(startRange.from, range.from), to2 = Math.max(startRange.to, range.to);
            range = from2 < range.from ? EditorSelection.range(from2, to2) : EditorSelection.range(to2, from2);
          }
          if (extend2)
            return startSel.replaceRange(startSel.main.extend(range.from, range.to));
          else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur2.pos)))
            return removed;
          else if (multiple)
            return startSel.addRange(range);
          else
            return EditorSelection.create([range]);
        }
      };
    }
    function removeRangeAround(sel, pos) {
      for (let i2 = 0; i2 < sel.ranges.length; i2++) {
        let { from: from2, to: to2 } = sel.ranges[i2];
        if (from2 <= pos && to2 >= pos)
          return EditorSelection.create(sel.ranges.slice(0, i2).concat(sel.ranges.slice(i2 + 1)), sel.mainIndex == i2 ? 0 : sel.mainIndex - (sel.mainIndex > i2 ? 1 : 0));
      }
      return null;
    }
    handlers.dragstart = (view, event) => {
      let { selection: { main: range } } = view.state;
      if (event.target.draggable) {
        let cView = view.docView.nearest(event.target);
        if (cView && cView.isWidget) {
          let from2 = cView.posAtStart, to2 = from2 + cView.length;
          if (from2 >= range.to || to2 <= range.from)
            range = EditorSelection.range(from2, to2);
        }
      }
      let { inputState } = view;
      if (inputState.mouseSelection)
        inputState.mouseSelection.dragging = true;
      inputState.draggedContent = range;
      if (event.dataTransfer) {
        event.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));
        event.dataTransfer.effectAllowed = "copyMove";
      }
      return false;
    };
    handlers.dragend = (view) => {
      view.inputState.draggedContent = null;
      return false;
    };
    function dropText(view, event, text, direct) {
      text = textFilter(view.state, clipboardInputFilter, text);
      if (!text)
        return;
      let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
      let { draggedContent } = view.inputState;
      let del = direct && draggedContent && dragMovesSelection(view, event) ? { from: draggedContent.from, to: draggedContent.to } : null;
      let ins = { from: dropPos, insert: text };
      let changes = view.state.changes(del ? [del, ins] : ins);
      view.focus();
      view.dispatch({
        changes,
        selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
        userEvent: del ? "move.drop" : "input.drop"
      });
      view.inputState.draggedContent = null;
    }
    handlers.drop = (view, event) => {
      if (!event.dataTransfer)
        return false;
      if (view.state.readOnly)
        return true;
      let files = event.dataTransfer.files;
      if (files && files.length) {
        let text = Array(files.length), read = 0;
        let finishFile = () => {
          if (++read == files.length)
            dropText(view, event, text.filter((s) => s != null).join(view.state.lineBreak), false);
        };
        for (let i2 = 0; i2 < files.length; i2++) {
          let reader = new FileReader();
          reader.onerror = finishFile;
          reader.onload = () => {
            if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
              text[i2] = reader.result;
            finishFile();
          };
          reader.readAsText(files[i2]);
        }
        return true;
      } else {
        let text = event.dataTransfer.getData("Text");
        if (text) {
          dropText(view, event, text, true);
          return true;
        }
      }
      return false;
    };
    handlers.paste = (view, event) => {
      if (view.state.readOnly)
        return true;
      view.observer.flush();
      let data = brokenClipboardAPI ? null : event.clipboardData;
      if (data) {
        doPaste(view, data.getData("text/plain") || data.getData("text/uri-list"));
        return true;
      } else {
        capturePaste(view);
        return false;
      }
    };
    function captureCopy(view, text) {
      let parent = view.dom.parentNode;
      if (!parent)
        return;
      let target = parent.appendChild(document.createElement("textarea"));
      target.style.cssText = "position: fixed; left: -10000px; top: 10px";
      target.value = text;
      target.focus();
      target.selectionEnd = text.length;
      target.selectionStart = 0;
      setTimeout(() => {
        target.remove();
        view.focus();
      }, 50);
    }
    function copiedRange(state) {
      let content2 = [], ranges = [], linewise = false;
      for (let range of state.selection.ranges)
        if (!range.empty) {
          content2.push(state.sliceDoc(range.from, range.to));
          ranges.push(range);
        }
      if (!content2.length) {
        let upto = -1;
        for (let { from: from2 } of state.selection.ranges) {
          let line = state.doc.lineAt(from2);
          if (line.number > upto) {
            content2.push(line.text);
            ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
          }
          upto = line.number;
        }
        linewise = true;
      }
      return { text: textFilter(state, clipboardOutputFilter, content2.join(state.lineBreak)), ranges, linewise };
    }
    let lastLinewiseCopy = null;
    handlers.copy = handlers.cut = (view, event) => {
      let { text, ranges, linewise } = copiedRange(view.state);
      if (!text && !linewise)
        return false;
      lastLinewiseCopy = linewise ? text : null;
      if (event.type == "cut" && !view.state.readOnly)
        view.dispatch({
          changes: ranges,
          scrollIntoView: true,
          userEvent: "delete.cut"
        });
      let data = brokenClipboardAPI ? null : event.clipboardData;
      if (data) {
        data.clearData();
        data.setData("text/plain", text);
        return true;
      } else {
        captureCopy(view, text);
        return false;
      }
    };
    const isFocusChange = /* @__PURE__ */ Annotation.define();
    function focusChangeTransaction(state, focus) {
      let effects2 = [];
      for (let getEffect of state.facet(focusChangeEffect)) {
        let effect = getEffect(state, focus);
        if (effect)
          effects2.push(effect);
      }
      return effects2.length ? state.update({ effects: effects2, annotations: isFocusChange.of(true) }) : null;
    }
    function updateForFocusChange(view) {
      setTimeout(() => {
        let focus = view.hasFocus;
        if (focus != view.inputState.notifiedFocused) {
          let tr = focusChangeTransaction(view.state, focus);
          if (tr)
            view.dispatch(tr);
          else
            view.update([]);
        }
      }, 10);
    }
    observers.focus = (view) => {
      view.inputState.lastFocusTime = Date.now();
      if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
        view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
      }
      updateForFocusChange(view);
    };
    observers.blur = (view) => {
      view.observer.clearSelectionRange();
      updateForFocusChange(view);
    };
    observers.compositionstart = observers.compositionupdate = (view) => {
      if (view.observer.editContext)
        return;
      if (view.inputState.compositionFirstChange == null)
        view.inputState.compositionFirstChange = true;
      if (view.inputState.composing < 0) {
        view.inputState.composing = 0;
      }
    };
    observers.compositionend = (view) => {
      if (view.observer.editContext)
        return;
      view.inputState.composing = -1;
      view.inputState.compositionEndedAt = Date.now();
      view.inputState.compositionPendingKey = true;
      view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
      view.inputState.compositionFirstChange = null;
      if (browser.chrome && browser.android) {
        view.observer.flushSoon();
      } else if (view.inputState.compositionPendingChange) {
        Promise.resolve().then(() => view.observer.flush());
      } else {
        setTimeout(() => {
          if (view.inputState.composing < 0 && view.docView.hasComposition)
            view.update([]);
        }, 50);
      }
    };
    observers.contextmenu = (view) => {
      view.inputState.lastContextMenu = Date.now();
    };
    handlers.beforeinput = (view, event) => {
      var _a2, _b;
      if (event.inputType == "insertText" || event.inputType == "insertCompositionText") {
        view.inputState.insertingText = event.data;
        view.inputState.insertingTextAt = Date.now();
      }
      if (event.inputType == "insertReplacementText" && view.observer.editContext) {
        let text = (_a2 = event.dataTransfer) === null || _a2 === void 0 ? void 0 : _a2.getData("text/plain"), ranges = event.getTargetRanges();
        if (text && ranges.length) {
          let r = ranges[0];
          let from2 = view.posAtDOM(r.startContainer, r.startOffset), to2 = view.posAtDOM(r.endContainer, r.endOffset);
          applyDOMChangeInner(view, { from: from2, to: to2, insert: view.state.toText(text) }, null);
          return true;
        }
      }
      let pending;
      if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
        view.observer.delayAndroidKey(pending.key, pending.keyCode);
        if (pending.key == "Backspace" || pending.key == "Delete") {
          let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
          setTimeout(() => {
            var _a3;
            if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
              view.contentDOM.blur();
              view.focus();
            }
          }, 100);
        }
      }
      if (browser.ios && event.inputType == "deleteContentForward") {
        view.observer.flushSoon();
      }
      if (browser.safari && event.inputType == "insertText" && view.inputState.composing >= 0) {
        setTimeout(() => observers.compositionend(view, event), 20);
      }
      return false;
    };
    const appliedFirefoxHack = /* @__PURE__ */ new Set();
    function firefoxCopyCutHack(doc2) {
      if (!appliedFirefoxHack.has(doc2)) {
        appliedFirefoxHack.add(doc2);
        doc2.addEventListener("copy", () => {
        });
        doc2.addEventListener("cut", () => {
        });
      }
    }
    const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
    let heightChangeFlag = false;
    function clearHeightChangeFlag() {
      heightChangeFlag = false;
    }
    class HeightOracle {
      constructor(lineWrapping) {
        this.lineWrapping = lineWrapping;
        this.doc = Text.empty;
        this.heightSamples = {};
        this.lineHeight = 14;
        this.charWidth = 7;
        this.textHeight = 14;
        this.lineLength = 30;
      }
      heightForGap(from2, to2) {
        let lines = this.doc.lineAt(to2).number - this.doc.lineAt(from2).number + 1;
        if (this.lineWrapping)
          lines += Math.max(0, Math.ceil((to2 - from2 - lines * this.lineLength * 0.5) / this.lineLength));
        return this.lineHeight * lines;
      }
      heightForLine(length) {
        if (!this.lineWrapping)
          return this.lineHeight;
        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / Math.max(1, this.lineLength - 5)));
        return lines * this.lineHeight;
      }
      setDoc(doc2) {
        this.doc = doc2;
        return this;
      }
      mustRefreshForWrapping(whiteSpace) {
        return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
      }
      mustRefreshForHeights(lineHeights) {
        let newHeight = false;
        for (let i2 = 0; i2 < lineHeights.length; i2++) {
          let h = lineHeights[i2];
          if (h < 0) {
            i2++;
          } else if (!this.heightSamples[Math.floor(h * 10)]) {
            newHeight = true;
            this.heightSamples[Math.floor(h * 10)] = true;
          }
        }
        return newHeight;
      }
      refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
        this.lineWrapping = lineWrapping;
        this.lineHeight = lineHeight;
        this.charWidth = charWidth;
        this.textHeight = textHeight;
        this.lineLength = lineLength;
        if (changed) {
          this.heightSamples = {};
          for (let i2 = 0; i2 < knownHeights.length; i2++) {
            let h = knownHeights[i2];
            if (h < 0)
              i2++;
            else
              this.heightSamples[Math.floor(h * 10)] = true;
          }
        }
        return changed;
      }
    }
    class MeasuredHeights {
      constructor(from2, heights) {
        this.from = from2;
        this.heights = heights;
        this.index = 0;
      }
      get more() {
        return this.index < this.heights.length;
      }
    }
    class BlockInfo {
      /**
      @internal
      */
      constructor(from2, length, top2, height, _content) {
        this.from = from2;
        this.length = length;
        this.top = top2;
        this.height = height;
        this._content = _content;
      }
      /**
      The type of element this is. When querying lines, this may be
      an array of all the blocks that make up the line.
      */
      get type() {
        return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
      }
      /**
      The end of the element as a document position.
      */
      get to() {
        return this.from + this.length;
      }
      /**
      The bottom position of the element.
      */
      get bottom() {
        return this.top + this.height;
      }
      /**
      If this is a widget block, this will return the widget
      associated with it.
      */
      get widget() {
        return this._content instanceof PointDecoration ? this._content.widget : null;
      }
      /**
      If this is a textblock, this holds the number of line breaks
      that appear in widgets inside the block.
      */
      get widgetLineBreaks() {
        return typeof this._content == "number" ? this._content : 0;
      }
      /**
      @internal
      */
      join(other) {
        let content2 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content2);
      }
    }
    var QueryType$1 = /* @__PURE__ */ (function(QueryType2) {
      QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
      QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
      QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
      return QueryType2;
    })(QueryType$1 || (QueryType$1 = {}));
    const Epsilon = 1e-3;
    class HeightMap {
      constructor(length, height, flags = 2) {
        this.length = length;
        this.height = height;
        this.flags = flags;
      }
      get outdated() {
        return (this.flags & 2) > 0;
      }
      set outdated(value) {
        this.flags = (value ? 2 : 0) | this.flags & -3;
      }
      setHeight(height) {
        if (this.height != height) {
          if (Math.abs(this.height - height) > Epsilon)
            heightChangeFlag = true;
          this.height = height;
        }
      }
      // Base case is to replace a leaf node, which simply builds a tree
      // from the new nodes and returns that (HeightMapBranch and
      // HeightMapGap override this to actually use from/to)
      replace(_from, _to, nodes) {
        return HeightMap.of(nodes);
      }
      // Again, these are base cases, and are overridden for branch and gap nodes.
      decomposeLeft(_to, result) {
        result.push(this);
      }
      decomposeRight(_from, result) {
        result.push(this);
      }
      applyChanges(decorations2, oldDoc, oracle, changes) {
        let me = this, doc2 = oracle.doc;
        for (let i2 = changes.length - 1; i2 >= 0; i2--) {
          let { fromA, toA, fromB, toB } = changes[i2];
          let start = me.lineAt(fromA, QueryType$1.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
          let end = start.to >= toA ? start : me.lineAt(toA, QueryType$1.ByPosNoHeight, oracle, 0, 0);
          toB += end.to - toA;
          toA = end.to;
          while (i2 > 0 && start.from <= changes[i2 - 1].toA) {
            fromA = changes[i2 - 1].fromA;
            fromB = changes[i2 - 1].fromB;
            i2--;
            if (fromA < start.from)
              start = me.lineAt(fromA, QueryType$1.ByPosNoHeight, oracle, 0, 0);
          }
          fromB += start.from - fromA;
          fromA = start.from;
          let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
          me = replace(me, me.replace(fromA, toA, nodes));
        }
        return me.updateHeight(oracle, 0);
      }
      static empty() {
        return new HeightMapText(0, 0);
      }
      // nodes uses null values to indicate the position of line breaks.
      // There are never line breaks at the start or end of the array, or
      // two line breaks next to each other, and the array isn't allowed
      // to be empty (same restrictions as return value from the builder).
      static of(nodes) {
        if (nodes.length == 1)
          return nodes[0];
        let i2 = 0, j = nodes.length, before = 0, after = 0;
        for (; ; ) {
          if (i2 == j) {
            if (before > after * 2) {
              let split = nodes[i2 - 1];
              if (split.break)
                nodes.splice(--i2, 1, split.left, null, split.right);
              else
                nodes.splice(--i2, 1, split.left, split.right);
              j += 1 + split.break;
              before -= split.size;
            } else if (after > before * 2) {
              let split = nodes[j];
              if (split.break)
                nodes.splice(j, 1, split.left, null, split.right);
              else
                nodes.splice(j, 1, split.left, split.right);
              j += 2 + split.break;
              after -= split.size;
            } else {
              break;
            }
          } else if (before < after) {
            let next = nodes[i2++];
            if (next)
              before += next.size;
          } else {
            let next = nodes[--j];
            if (next)
              after += next.size;
          }
        }
        let brk = 0;
        if (nodes[i2 - 1] == null) {
          brk = 1;
          i2--;
        } else if (nodes[i2] == null) {
          brk = 1;
          j++;
        }
        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i2)), brk, HeightMap.of(nodes.slice(j)));
      }
    }
    function replace(old, val) {
      if (old == val)
        return old;
      if (old.constructor != val.constructor)
        heightChangeFlag = true;
      return val;
    }
    HeightMap.prototype.size = 1;
    class HeightMapBlock extends HeightMap {
      constructor(length, height, deco) {
        super(length, height);
        this.deco = deco;
      }
      blockAt(_height, _oracle, top2, offset) {
        return new BlockInfo(offset, this.length, top2, this.height, this.deco || 0);
      }
      lineAt(_value, _type, oracle, top2, offset) {
        return this.blockAt(0, oracle, top2, offset);
      }
      forEachLine(from2, to2, oracle, top2, offset, f) {
        if (from2 <= offset + this.length && to2 >= offset)
          f(this.blockAt(0, oracle, top2, offset));
      }
      updateHeight(oracle, offset = 0, _force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
          this.setHeight(measured.heights[measured.index++]);
        this.outdated = false;
        return this;
      }
      toString() {
        return `block(${this.length})`;
      }
    }
    class HeightMapText extends HeightMapBlock {
      constructor(length, height) {
        super(length, height, null);
        this.collapsed = 0;
        this.widgetHeight = 0;
        this.breaks = 0;
      }
      blockAt(_height, _oracle, top2, offset) {
        return new BlockInfo(offset, this.length, top2, this.height, this.breaks);
      }
      replace(_from, _to, nodes) {
        let node = nodes[0];
        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
          if (node instanceof HeightMapGap)
            node = new HeightMapText(node.length, this.height);
          else
            node.height = this.height;
          if (!this.outdated)
            node.outdated = false;
          return node;
        } else {
          return HeightMap.of(nodes);
        }
      }
      updateHeight(oracle, offset = 0, force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
          this.setHeight(measured.heights[measured.index++]);
        else if (force || this.outdated)
          this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
        this.outdated = false;
        return this;
      }
      toString() {
        return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
      }
    }
    class HeightMapGap extends HeightMap {
      constructor(length) {
        super(length, 0);
      }
      heightMetrics(oracle, offset) {
        let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
        let lines = lastLine - firstLine + 1;
        let perLine, perChar = 0;
        if (oracle.lineWrapping) {
          let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
          perLine = totalPerLine / lines;
          if (this.length > lines + 1)
            perChar = (this.height - totalPerLine) / (this.length - lines - 1);
        } else {
          perLine = this.height / lines;
        }
        return { firstLine, lastLine, perLine, perChar };
      }
      blockAt(height, oracle, top2, offset) {
        let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        if (oracle.lineWrapping) {
          let guess = offset + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length));
          let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
          let lineTop = Math.max(top2, height - lineHeight / 2);
          return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
        } else {
          let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
          let { from: from2, length } = oracle.doc.line(firstLine + line);
          return new BlockInfo(from2, length, top2 + perLine * line, perLine, 0);
        }
      }
      lineAt(value, type, oracle, top2, offset) {
        if (type == QueryType$1.ByHeight)
          return this.blockAt(value, oracle, top2, offset);
        if (type == QueryType$1.ByPosNoHeight) {
          let { from: from2, to: to2 } = oracle.doc.lineAt(value);
          return new BlockInfo(from2, to2 - from2, 0, 0, 0);
        }
        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
        let linesAbove = line.number - firstLine;
        let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
        return new BlockInfo(line.from, line.length, Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)), lineHeight, 0);
      }
      forEachLine(from2, to2, oracle, top2, offset, f) {
        from2 = Math.max(from2, offset);
        to2 = Math.min(to2, offset + this.length);
        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        for (let pos = from2, lineTop = top2; pos <= to2; ) {
          let line = oracle.doc.lineAt(pos);
          if (pos == from2) {
            let linesAbove = line.number - firstLine;
            lineTop += perLine * linesAbove + perChar * (from2 - offset - linesAbove);
          }
          let lineHeight = perLine + perChar * line.length;
          f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
          lineTop += lineHeight;
          pos = line.to + 1;
        }
      }
      replace(from2, to2, nodes) {
        let after = this.length - to2;
        if (after > 0) {
          let last = nodes[nodes.length - 1];
          if (last instanceof HeightMapGap)
            nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
          else
            nodes.push(null, new HeightMapGap(after - 1));
        }
        if (from2 > 0) {
          let first = nodes[0];
          if (first instanceof HeightMapGap)
            nodes[0] = new HeightMapGap(from2 + first.length);
          else
            nodes.unshift(new HeightMapGap(from2 - 1), null);
        }
        return HeightMap.of(nodes);
      }
      decomposeLeft(to2, result) {
        result.push(new HeightMapGap(to2 - 1), null);
      }
      decomposeRight(from2, result) {
        result.push(null, new HeightMapGap(this.length - from2 - 1));
      }
      updateHeight(oracle, offset = 0, force = false, measured) {
        let end = offset + this.length;
        if (measured && measured.from <= offset + this.length && measured.more) {
          let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
          if (measured.from > offset)
            nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
          while (pos <= end && measured.more) {
            let len = oracle.doc.lineAt(pos).length;
            if (nodes.length)
              nodes.push(null);
            let height = measured.heights[measured.index++];
            if (singleHeight == -1)
              singleHeight = height;
            else if (Math.abs(height - singleHeight) >= Epsilon)
              singleHeight = -2;
            let line = new HeightMapText(len, height);
            line.outdated = false;
            nodes.push(line);
            pos += len + 1;
          }
          if (pos <= end)
            nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
          let result = HeightMap.of(nodes);
          if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
            heightChangeFlag = true;
          return replace(this, result);
        } else if (force || this.outdated) {
          this.setHeight(oracle.heightForGap(offset, offset + this.length));
          this.outdated = false;
        }
        return this;
      }
      toString() {
        return `gap(${this.length})`;
      }
    }
    class HeightMapBranch extends HeightMap {
      constructor(left, brk, right) {
        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
        this.left = left;
        this.right = right;
        this.size = left.size + right.size;
      }
      get break() {
        return this.flags & 1;
      }
      blockAt(height, oracle, top2, offset) {
        let mid = top2 + this.left.height;
        return height < mid ? this.left.blockAt(height, oracle, top2, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
      }
      lineAt(value, type, oracle, top2, offset) {
        let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
        let left = type == QueryType$1.ByHeight ? value < rightTop : value < rightOffset;
        let base2 = left ? this.left.lineAt(value, type, oracle, top2, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
        if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
          return base2;
        let subQuery = type == QueryType$1.ByPosNoHeight ? QueryType$1.ByPosNoHeight : QueryType$1.ByPos;
        if (left)
          return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
        else
          return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset).join(base2);
      }
      forEachLine(from2, to2, oracle, top2, offset, f) {
        let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
        if (this.break) {
          if (from2 < rightOffset)
            this.left.forEachLine(from2, to2, oracle, top2, offset, f);
          if (to2 >= rightOffset)
            this.right.forEachLine(from2, to2, oracle, rightTop, rightOffset, f);
        } else {
          let mid = this.lineAt(rightOffset, QueryType$1.ByPos, oracle, top2, offset);
          if (from2 < mid.from)
            this.left.forEachLine(from2, mid.from - 1, oracle, top2, offset, f);
          if (mid.to >= from2 && mid.from <= to2)
            f(mid);
          if (to2 > mid.to)
            this.right.forEachLine(mid.to + 1, to2, oracle, rightTop, rightOffset, f);
        }
      }
      replace(from2, to2, nodes) {
        let rightStart = this.left.length + this.break;
        if (to2 < rightStart)
          return this.balanced(this.left.replace(from2, to2, nodes), this.right);
        if (from2 > this.left.length)
          return this.balanced(this.left, this.right.replace(from2 - rightStart, to2 - rightStart, nodes));
        let result = [];
        if (from2 > 0)
          this.decomposeLeft(from2, result);
        let left = result.length;
        for (let node of nodes)
          result.push(node);
        if (from2 > 0)
          mergeGaps(result, left - 1);
        if (to2 < this.length) {
          let right = result.length;
          this.decomposeRight(to2, result);
          mergeGaps(result, right);
        }
        return HeightMap.of(result);
      }
      decomposeLeft(to2, result) {
        let left = this.left.length;
        if (to2 <= left)
          return this.left.decomposeLeft(to2, result);
        result.push(this.left);
        if (this.break) {
          left++;
          if (to2 >= left)
            result.push(null);
        }
        if (to2 > left)
          this.right.decomposeLeft(to2 - left, result);
      }
      decomposeRight(from2, result) {
        let left = this.left.length, right = left + this.break;
        if (from2 >= right)
          return this.right.decomposeRight(from2 - right, result);
        if (from2 < left)
          this.left.decomposeRight(from2, result);
        if (this.break && from2 < right)
          result.push(null);
        result.push(this.right);
      }
      balanced(left, right) {
        if (left.size > 2 * right.size || right.size > 2 * left.size)
          return HeightMap.of(this.break ? [left, null, right] : [left, right]);
        this.left = replace(this.left, left);
        this.right = replace(this.right, right);
        this.setHeight(left.height + right.height);
        this.outdated = left.outdated || right.outdated;
        this.size = left.size + right.size;
        this.length = left.length + this.break + right.length;
        return this;
      }
      updateHeight(oracle, offset = 0, force = false, measured) {
        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
        if (measured && measured.from <= offset + left.length && measured.more)
          rebalance = left = left.updateHeight(oracle, offset, force, measured);
        else
          left.updateHeight(oracle, offset, force);
        if (measured && measured.from <= rightStart + right.length && measured.more)
          rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
        else
          right.updateHeight(oracle, rightStart, force);
        if (rebalance)
          return this.balanced(left, right);
        this.height = this.left.height + this.right.height;
        this.outdated = false;
        return this;
      }
      toString() {
        return this.left + (this.break ? " " : "-") + this.right;
      }
    }
    function mergeGaps(nodes, around) {
      let before, after;
      if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
        nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
    }
    const relevantWidgetHeight = 5;
    class NodeBuilder {
      constructor(pos, oracle) {
        this.pos = pos;
        this.oracle = oracle;
        this.nodes = [];
        this.lineStart = -1;
        this.lineEnd = -1;
        this.covering = null;
        this.writtenTo = pos;
      }
      get isCovered() {
        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
      }
      span(_from, to2) {
        if (this.lineStart > -1) {
          let end = Math.min(to2, this.lineEnd), last = this.nodes[this.nodes.length - 1];
          if (last instanceof HeightMapText)
            last.length += end - this.pos;
          else if (end > this.pos || !this.isCovered)
            this.nodes.push(new HeightMapText(end - this.pos, -1));
          this.writtenTo = end;
          if (to2 > end) {
            this.nodes.push(null);
            this.writtenTo++;
            this.lineStart = -1;
          }
        }
        this.pos = to2;
      }
      point(from2, to2, deco) {
        if (from2 < to2 || deco.heightRelevant) {
          let height = deco.widget ? deco.widget.estimatedHeight : 0;
          let breaks = deco.widget ? deco.widget.lineBreaks : 0;
          if (height < 0)
            height = this.oracle.lineHeight;
          let len = to2 - from2;
          if (deco.block) {
            this.addBlock(new HeightMapBlock(len, height, deco));
          } else if (len || breaks || height >= relevantWidgetHeight) {
            this.addLineDeco(height, breaks, len);
          }
        } else if (to2 > from2) {
          this.span(from2, to2);
        }
        if (this.lineEnd > -1 && this.lineEnd < this.pos)
          this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
      }
      enterLine() {
        if (this.lineStart > -1)
          return;
        let { from: from2, to: to2 } = this.oracle.doc.lineAt(this.pos);
        this.lineStart = from2;
        this.lineEnd = to2;
        if (this.writtenTo < from2) {
          if (this.writtenTo < from2 - 1 || this.nodes[this.nodes.length - 1] == null)
            this.nodes.push(this.blankContent(this.writtenTo, from2 - 1));
          this.nodes.push(null);
        }
        if (this.pos > from2)
          this.nodes.push(new HeightMapText(this.pos - from2, -1));
        this.writtenTo = this.pos;
      }
      blankContent(from2, to2) {
        let gap = new HeightMapGap(to2 - from2);
        if (this.oracle.doc.lineAt(from2).to == to2)
          gap.flags |= 4;
        return gap;
      }
      ensureLine() {
        this.enterLine();
        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
        if (last instanceof HeightMapText)
          return last;
        let line = new HeightMapText(0, -1);
        this.nodes.push(line);
        return line;
      }
      addBlock(block) {
        this.enterLine();
        let deco = block.deco;
        if (deco && deco.startSide > 0 && !this.isCovered)
          this.ensureLine();
        this.nodes.push(block);
        this.writtenTo = this.pos = this.pos + block.length;
        if (deco && deco.endSide > 0)
          this.covering = block;
      }
      addLineDeco(height, breaks, length) {
        let line = this.ensureLine();
        line.length += length;
        line.collapsed += length;
        line.widgetHeight = Math.max(line.widgetHeight, height);
        line.breaks += breaks;
        this.writtenTo = this.pos = this.pos + length;
      }
      finish(from2) {
        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
          this.nodes.push(new HeightMapText(0, -1));
        else if (this.writtenTo < this.pos || last == null)
          this.nodes.push(this.blankContent(this.writtenTo, this.pos));
        let pos = from2;
        for (let node of this.nodes) {
          if (node instanceof HeightMapText)
            node.updateHeight(this.oracle, pos);
          pos += node ? node.length : 1;
        }
        return this.nodes;
      }
      // Always called with a region that on both sides either stretches
      // to a line break or the end of the document.
      // The returned array uses null to indicate line breaks, but never
      // starts or ends in a line break, or has multiple line breaks next
      // to each other.
      static build(oracle, decorations2, from2, to2) {
        let builder = new NodeBuilder(from2, oracle);
        RangeSet.spans(decorations2, from2, to2, builder, 0);
        return builder.finish(from2);
      }
    }
    function heightRelevantDecoChanges(a, b, diff) {
      let comp = new DecorationComparator();
      RangeSet.compare(a, b, diff, comp, 0);
      return comp.changes;
    }
    class DecorationComparator {
      constructor() {
        this.changes = [];
      }
      compareRange() {
      }
      comparePoint(from2, to2, a, b) {
        if (from2 < to2 || a && a.heightRelevant || b && b.heightRelevant)
          addRange(from2, to2, this.changes, 5);
      }
    }
    function visiblePixelRange(dom, paddingTop) {
      let rect = dom.getBoundingClientRect();
      let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
      let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
      let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
      for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
        if (parent.nodeType == 1) {
          let elt = parent;
          let style = window.getComputedStyle(elt);
          if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
            let parentRect = elt.getBoundingClientRect();
            left = Math.max(left, parentRect.left);
            right = Math.min(right, parentRect.right);
            top2 = Math.max(top2, parentRect.top);
            bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
          }
          parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
        } else if (parent.nodeType == 11) {
          parent = parent.host;
        } else {
          break;
        }
      }
      return {
        left: left - rect.left,
        right: Math.max(left, right) - rect.left,
        top: top2 - (rect.top + paddingTop),
        bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
      };
    }
    function inWindow(elt) {
      let rect = elt.getBoundingClientRect(), win = elt.ownerDocument.defaultView || window;
      return rect.left < win.innerWidth && rect.right > 0 && rect.top < win.innerHeight && rect.bottom > 0;
    }
    function fullPixelRange(dom, paddingTop) {
      let rect = dom.getBoundingClientRect();
      return {
        left: 0,
        right: rect.right - rect.left,
        top: paddingTop,
        bottom: rect.bottom - (rect.top + paddingTop)
      };
    }
    class LineGap {
      constructor(from2, to2, size, displaySize) {
        this.from = from2;
        this.to = to2;
        this.size = size;
        this.displaySize = displaySize;
      }
      static same(a, b) {
        if (a.length != b.length)
          return false;
        for (let i2 = 0; i2 < a.length; i2++) {
          let gA = a[i2], gB = b[i2];
          if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
            return false;
        }
        return true;
      }
      draw(viewState, wrapping) {
        return Decoration.replace({
          widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
        }).range(this.from, this.to);
      }
    }
    class LineGapWidget extends WidgetType {
      constructor(size, vertical) {
        super();
        this.size = size;
        this.vertical = vertical;
      }
      eq(other) {
        return other.size == this.size && other.vertical == this.vertical;
      }
      toDOM() {
        let elt = document.createElement("div");
        if (this.vertical) {
          elt.style.height = this.size + "px";
        } else {
          elt.style.width = this.size + "px";
          elt.style.height = "2px";
          elt.style.display = "inline-block";
        }
        return elt;
      }
      get estimatedHeight() {
        return this.vertical ? this.size : -1;
      }
    }
    class ViewState {
      constructor(state) {
        this.state = state;
        this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
        this.inView = true;
        this.paddingTop = 0;
        this.paddingBottom = 0;
        this.contentDOMWidth = 0;
        this.contentDOMHeight = 0;
        this.editorHeight = 0;
        this.editorWidth = 0;
        this.scrollTop = 0;
        this.scrolledToBottom = false;
        this.scaleX = 1;
        this.scaleY = 1;
        this.scrollAnchorPos = 0;
        this.scrollAnchorHeight = -1;
        this.scaler = IdScaler;
        this.scrollTarget = null;
        this.printing = false;
        this.mustMeasureContent = true;
        this.defaultTextDirection = Direction.LTR;
        this.visibleRanges = [];
        this.mustEnforceCursorAssoc = false;
        let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
        this.heightOracle = new HeightOracle(guessWrapping);
        this.stateDeco = state.facet(decorations).filter((d) => typeof d != "function");
        this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
        for (let i2 = 0; i2 < 2; i2++) {
          this.viewport = this.getViewport(0, null);
          if (!this.updateForViewport())
            break;
        }
        this.updateViewportLines();
        this.lineGaps = this.ensureLineGaps([]);
        this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
        this.computeVisibleRanges();
      }
      updateForViewport() {
        let viewports = [this.viewport], { main } = this.state.selection;
        for (let i2 = 0; i2 <= 1; i2++) {
          let pos = i2 ? main.head : main.anchor;
          if (!viewports.some(({ from: from2, to: to2 }) => pos >= from2 && pos <= to2)) {
            let { from: from2, to: to2 } = this.lineBlockAt(pos);
            viewports.push(new Viewport(from2, to2));
          }
        }
        this.viewports = viewports.sort((a, b) => a.from - b.from);
        return this.updateScaler();
      }
      updateScaler() {
        let scaler = this.scaler;
        this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
        return scaler.eq(this.scaler) ? 0 : 2;
      }
      updateViewportLines() {
        this.viewportLines = [];
        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
          this.viewportLines.push(scaleBlock(block, this.scaler));
        });
      }
      update(update, scrollTarget = null) {
        this.state = update.state;
        let prevDeco = this.stateDeco;
        this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
        let contentChanges = update.changedRanges;
        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
        let prevHeight = this.heightMap.height;
        let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
        clearHeightChangeFlag();
        this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
        if (this.heightMap.height != prevHeight || heightChangeFlag)
          update.flags |= 2;
        if (scrollAnchor) {
          this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
          this.scrollAnchorHeight = scrollAnchor.top;
        } else {
          this.scrollAnchorPos = -1;
          this.scrollAnchorHeight = prevHeight;
        }
        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
          viewport = this.getViewport(0, scrollTarget);
        let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
        this.viewport = viewport;
        update.flags |= this.updateForViewport();
        if (viewportChange || !update.changes.empty || update.flags & 2)
          this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
          this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
        update.flags |= this.computeVisibleRanges(update.changes);
        if (scrollTarget)
          this.scrollTarget = scrollTarget;
        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
          this.mustEnforceCursorAssoc = true;
      }
      measure(view) {
        let dom = view.contentDOM, style = window.getComputedStyle(dom);
        let oracle = this.heightOracle;
        let whiteSpace = style.whiteSpace;
        this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
        let domRect = dom.getBoundingClientRect();
        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
        this.contentDOMHeight = domRect.height;
        this.mustMeasureContent = false;
        let result = 0, bias = 0;
        if (domRect.width && domRect.height) {
          let { scaleX, scaleY } = getScale(dom, domRect);
          if (scaleX > 5e-3 && Math.abs(this.scaleX - scaleX) > 5e-3 || scaleY > 5e-3 && Math.abs(this.scaleY - scaleY) > 5e-3) {
            this.scaleX = scaleX;
            this.scaleY = scaleY;
            result |= 16;
            refresh = measureContent = true;
          }
        }
        let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
        let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
          this.paddingTop = paddingTop;
          this.paddingBottom = paddingBottom;
          result |= 16 | 2;
        }
        if (this.editorWidth != view.scrollDOM.clientWidth) {
          if (oracle.lineWrapping)
            measureContent = true;
          this.editorWidth = view.scrollDOM.clientWidth;
          result |= 16;
        }
        let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
        if (this.scrollTop != scrollTop) {
          this.scrollAnchorHeight = -1;
          this.scrollTop = scrollTop;
        }
        this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
        let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
        this.pixelViewport = pixelViewport;
        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
        if (inView != this.inView) {
          this.inView = inView;
          if (inView)
            measureContent = true;
        }
        if (!this.inView && !this.scrollTarget && !inWindow(view.dom))
          return 0;
        let contentWidth = domRect.width;
        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
          this.contentDOMWidth = domRect.width;
          this.editorHeight = view.scrollDOM.clientHeight;
          result |= 16;
        }
        if (measureContent) {
          let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
          if (oracle.mustRefreshForHeights(lineHeights))
            refresh = true;
          if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
            let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
            refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, Math.max(5, contentWidth / charWidth), lineHeights);
            if (refresh) {
              view.docView.minWidth = 0;
              result |= 16;
            }
          }
          if (dTop > 0 && dBottom > 0)
            bias = Math.max(dTop, dBottom);
          else if (dTop < 0 && dBottom < 0)
            bias = Math.min(dTop, dBottom);
          clearHeightChangeFlag();
          for (let vp of this.viewports) {
            let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
            this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
          }
          if (heightChangeFlag)
            result |= 2;
        }
        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
        if (viewportChange) {
          if (result & 2)
            result |= this.updateScaler();
          this.viewport = this.getViewport(bias, this.scrollTarget);
          result |= this.updateForViewport();
        }
        if (result & 2 || viewportChange)
          this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
          this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
        result |= this.computeVisibleRanges();
        if (this.mustEnforceCursorAssoc) {
          this.mustEnforceCursorAssoc = false;
          view.docView.enforceCursorAssoc();
        }
        return result;
      }
      get visibleTop() {
        return this.scaler.fromDOM(this.pixelViewport.top);
      }
      get visibleBottom() {
        return this.scaler.fromDOM(this.pixelViewport.bottom);
      }
      getViewport(bias, scrollTarget) {
        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
        let map2 = this.heightMap, oracle = this.heightOracle;
        let { visibleTop, visibleBottom } = this;
        let viewport = new Viewport(map2.lineAt(visibleTop - marginTop * 1e3, QueryType$1.ByHeight, oracle, 0, 0).from, map2.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType$1.ByHeight, oracle, 0, 0).to);
        if (scrollTarget) {
          let { head } = scrollTarget.range;
          if (head < viewport.from || head > viewport.to) {
            let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
            let block = map2.lineAt(head, QueryType$1.ByPos, oracle, 0, 0), topPos;
            if (scrollTarget.y == "center")
              topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
            else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
              topPos = block.top;
            else
              topPos = block.bottom - viewHeight;
            viewport = new Viewport(map2.lineAt(topPos - 1e3 / 2, QueryType$1.ByHeight, oracle, 0, 0).from, map2.lineAt(topPos + viewHeight + 1e3 / 2, QueryType$1.ByHeight, oracle, 0, 0).to);
          }
        }
        return viewport;
      }
      mapViewport(viewport, changes) {
        let from2 = changes.mapPos(viewport.from, -1), to2 = changes.mapPos(viewport.to, 1);
        return new Viewport(this.heightMap.lineAt(from2, QueryType$1.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to2, QueryType$1.ByPos, this.heightOracle, 0, 0).to);
      }
      // Checks if a given viewport covers the visible part of the
      // document and not too much beyond that.
      viewportIsAppropriate({ from: from2, to: to2 }, bias = 0) {
        if (!this.inView)
          return true;
        let { top: top2 } = this.heightMap.lineAt(from2, QueryType$1.ByPos, this.heightOracle, 0, 0);
        let { bottom } = this.heightMap.lineAt(to2, QueryType$1.ByPos, this.heightOracle, 0, 0);
        let { visibleTop, visibleBottom } = this;
        return (from2 == 0 || top2 <= visibleTop - Math.max(10, Math.min(
          -bias,
          250
          /* VP.MaxCoverMargin */
        ))) && (to2 == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(
          bias,
          250
          /* VP.MaxCoverMargin */
        ))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
      }
      mapLineGaps(gaps, changes) {
        if (!gaps.length || changes.empty)
          return gaps;
        let mapped = [];
        for (let gap of gaps)
          if (!changes.touchesRange(gap.from, gap.to))
            mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
        return mapped;
      }
      // Computes positions in the viewport where the start or end of a
      // line should be hidden, trying to reuse existing line gaps when
      // appropriate to avoid unneccesary redraws.
      // Uses crude character-counting for the positioning and sizing,
      // since actual DOM coordinates aren't always available and
      // predictable. Relies on generous margins (see LG.Margin) to hide
      // the artifacts this might produce from the user.
      ensureLineGaps(current, mayMeasure) {
        let wrapping = this.heightOracle.lineWrapping;
        let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
        if (this.defaultTextDirection != Direction.LTR && !wrapping)
          return [];
        let gaps = [];
        let addGap = (from2, to2, line, structure) => {
          if (to2 - from2 < halfMargin)
            return;
          let sel = this.state.selection.main, avoid = [sel.from];
          if (!sel.empty)
            avoid.push(sel.to);
          for (let pos of avoid) {
            if (pos > from2 && pos < to2) {
              addGap(from2, pos - 10, line, structure);
              addGap(pos + 10, to2, line, structure);
              return;
            }
          }
          let gap = find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from2) < halfMargin && Math.abs(gap2.to - to2) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
          if (!gap) {
            if (to2 < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to2 && r.to >= to2)) {
              let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to2), false, true).head;
              if (lineStart > from2)
                to2 = lineStart;
            }
            let size = this.gapSize(line, from2, to2, structure);
            let displaySize = wrapping || size < 2e6 ? size : 2e6;
            gap = new LineGap(from2, to2, size, displaySize);
          }
          gaps.push(gap);
        };
        let checkLine = (line) => {
          if (line.length < doubleMargin || line.type != BlockType.Text)
            return;
          let structure = lineStructure(line.from, line.to, this.stateDeco);
          if (structure.total < doubleMargin)
            return;
          let target = this.scrollTarget ? this.scrollTarget.range.head : null;
          let viewFrom, viewTo;
          if (wrapping) {
            let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
            let top2, bot;
            if (target != null) {
              let targetFrac = findFraction(structure, target);
              let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
              top2 = targetFrac - spaceFrac;
              bot = targetFrac + spaceFrac;
            } else {
              top2 = (this.visibleTop - line.top - marginHeight) / line.height;
              bot = (this.visibleBottom - line.top + marginHeight) / line.height;
            }
            viewFrom = findPosition(structure, top2);
            viewTo = findPosition(structure, bot);
          } else {
            let totalWidth = structure.total * this.heightOracle.charWidth;
            let marginWidth = margin * this.heightOracle.charWidth;
            let horizOffset = 0;
            if (totalWidth > 2e6)
              for (let old of current) {
                if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left)
                  horizOffset = old.size - old.displaySize;
              }
            let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
            let left, right;
            if (target != null) {
              let targetFrac = findFraction(structure, target);
              let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
              left = targetFrac - spaceFrac;
              right = targetFrac + spaceFrac;
            } else {
              left = (pxLeft - marginWidth) / totalWidth;
              right = (pxRight + marginWidth) / totalWidth;
            }
            viewFrom = findPosition(structure, left);
            viewTo = findPosition(structure, right);
          }
          if (viewFrom > line.from)
            addGap(line.from, viewFrom, line, structure);
          if (viewTo < line.to)
            addGap(viewTo, line.to, line, structure);
        };
        for (let line of this.viewportLines) {
          if (Array.isArray(line.type))
            line.type.forEach(checkLine);
          else
            checkLine(line);
        }
        return gaps;
      }
      gapSize(line, from2, to2, structure) {
        let fraction = findFraction(structure, to2) - findFraction(structure, from2);
        if (this.heightOracle.lineWrapping) {
          return line.height * fraction;
        } else {
          return structure.total * this.heightOracle.charWidth * fraction;
        }
      }
      updateLineGaps(gaps) {
        if (!LineGap.same(gaps, this.lineGaps)) {
          this.lineGaps = gaps;
          this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
        }
      }
      computeVisibleRanges(changes) {
        let deco = this.stateDeco;
        if (this.lineGaps.length)
          deco = deco.concat(this.lineGapDeco);
        let ranges = [];
        RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
          span(from2, to2) {
            ranges.push({ from: from2, to: to2 });
          },
          point() {
          }
        }, 20);
        let changed = 0;
        if (ranges.length != this.visibleRanges.length) {
          changed = 8 | 4;
        } else {
          for (let i2 = 0; i2 < ranges.length && !(changed & 8); i2++) {
            let old = this.visibleRanges[i2], nw = ranges[i2];
            if (old.from != nw.from || old.to != nw.to) {
              changed |= 4;
              if (!(changes && changes.mapPos(old.from, -1) == nw.from && changes.mapPos(old.to, 1) == nw.to))
                changed |= 8;
            }
          }
        }
        this.visibleRanges = ranges;
        return changed;
      }
      lineBlockAt(pos) {
        return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType$1.ByPos, this.heightOracle, 0, 0), this.scaler);
      }
      lineBlockAtHeight(height) {
        return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l) => l.top <= height && l.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType$1.ByHeight, this.heightOracle, 0, 0), this.scaler);
      }
      scrollAnchorAt(scrollTop) {
        let block = this.lineBlockAtHeight(scrollTop + 8);
        return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
      }
      elementAtHeight(height) {
        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
      }
      get docHeight() {
        return this.scaler.toDOM(this.heightMap.height);
      }
      get contentHeight() {
        return this.docHeight + this.paddingTop + this.paddingBottom;
      }
    }
    class Viewport {
      constructor(from2, to2) {
        this.from = from2;
        this.to = to2;
      }
    }
    function lineStructure(from2, to2, stateDeco) {
      let ranges = [], pos = from2, total = 0;
      RangeSet.spans(stateDeco, from2, to2, {
        span() {
        },
        point(from3, to3) {
          if (from3 > pos) {
            ranges.push({ from: pos, to: from3 });
            total += from3 - pos;
          }
          pos = to3;
        }
      }, 20);
      if (pos < to2) {
        ranges.push({ from: pos, to: to2 });
        total += to2 - pos;
      }
      return { total, ranges };
    }
    function findPosition({ total, ranges }, ratio) {
      if (ratio <= 0)
        return ranges[0].from;
      if (ratio >= 1)
        return ranges[ranges.length - 1].to;
      let dist2 = Math.floor(total * ratio);
      for (let i2 = 0; ; i2++) {
        let { from: from2, to: to2 } = ranges[i2], size = to2 - from2;
        if (dist2 <= size)
          return from2 + dist2;
        dist2 -= size;
      }
    }
    function findFraction(structure, pos) {
      let counted = 0;
      for (let { from: from2, to: to2 } of structure.ranges) {
        if (pos <= to2) {
          counted += pos - from2;
          break;
        }
        counted += to2 - from2;
      }
      return counted / structure.total;
    }
    function find(array, f) {
      for (let val of array)
        if (f(val))
          return val;
      return void 0;
    }
    const IdScaler = {
      toDOM(n) {
        return n;
      },
      fromDOM(n) {
        return n;
      },
      scale: 1,
      eq(other) {
        return other == this;
      }
    };
    class BigScaler {
      constructor(oracle, heightMap, viewports) {
        let vpHeight = 0, base2 = 0, domBase = 0;
        this.viewports = viewports.map(({ from: from2, to: to2 }) => {
          let top2 = heightMap.lineAt(from2, QueryType$1.ByPos, oracle, 0, 0).top;
          let bottom = heightMap.lineAt(to2, QueryType$1.ByPos, oracle, 0, 0).bottom;
          vpHeight += bottom - top2;
          return { from: from2, to: to2, top: top2, bottom, domTop: 0, domBottom: 0 };
        });
        this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
        for (let obj of this.viewports) {
          obj.domTop = domBase + (obj.top - base2) * this.scale;
          domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
          base2 = obj.bottom;
        }
      }
      toDOM(n) {
        for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
          let vp = i2 < this.viewports.length ? this.viewports[i2] : null;
          if (!vp || n < vp.top)
            return domBase + (n - base2) * this.scale;
          if (n <= vp.bottom)
            return vp.domTop + (n - vp.top);
          base2 = vp.bottom;
          domBase = vp.domBottom;
        }
      }
      fromDOM(n) {
        for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
          let vp = i2 < this.viewports.length ? this.viewports[i2] : null;
          if (!vp || n < vp.domTop)
            return base2 + (n - domBase) / this.scale;
          if (n <= vp.domBottom)
            return vp.top + (n - vp.domTop);
          base2 = vp.bottom;
          domBase = vp.domBottom;
        }
      }
      eq(other) {
        if (!(other instanceof BigScaler))
          return false;
        return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp, i2) => vp.from == other.viewports[i2].from && vp.to == other.viewports[i2].to);
      }
    }
    function scaleBlock(block, scaler) {
      if (scaler.scale == 1)
        return block;
      let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
      return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b) => scaleBlock(b, scaler)) : block._content);
    }
    const theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
    const darkTheme = /* @__PURE__ */ Facet.define({ combine: (values) => values.indexOf(true) > -1 });
    const baseThemeID = /* @__PURE__ */ StyleModule.newName(), baseLightID = /* @__PURE__ */ StyleModule.newName(), baseDarkID = /* @__PURE__ */ StyleModule.newName();
    const lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
    function buildTheme(main, spec, scopes) {
      return new StyleModule(spec, {
        finish(sel) {
          return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
            if (m == "&")
              return main;
            if (!scopes || !scopes[m])
              throw new RangeError(`Unsupported selector: ${m}`);
            return scopes[m];
          }) : main + " " + sel;
        }
      });
    }
    const baseTheme$1$3 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
      "&": {
        position: "relative !important",
        boxSizing: "border-box",
        "&.cm-focused": {
          // Provide a simple default outline to make sure a focused
          // editor is visually distinct. Can't leave the default behavior
          // because that will apply to the content element, which is
          // inside the scrollable container and doesn't include the
          // gutters. We also can't use an 'auto' outline, since those
          // are, for some reason, drawn behind the element content, which
          // will cause things like the active line background to cover
          // the outline (#297).
          outline: "1px dotted #212121"
        },
        display: "flex !important",
        flexDirection: "column"
      },
      ".cm-scroller": {
        display: "flex !important",
        alignItems: "flex-start !important",
        fontFamily: "monospace",
        lineHeight: 1.4,
        height: "100%",
        overflowX: "auto",
        position: "relative",
        zIndex: 0,
        overflowAnchor: "none"
      },
      ".cm-content": {
        margin: 0,
        flexGrow: 2,
        flexShrink: 0,
        display: "block",
        whiteSpace: "pre",
        wordWrap: "normal",
        // https://github.com/codemirror/dev/issues/456
        boxSizing: "border-box",
        minHeight: "100%",
        padding: "4px 0",
        outline: "none",
        "&[contenteditable=true]": {
          WebkitUserModify: "read-write-plaintext-only"
        }
      },
      ".cm-lineWrapping": {
        whiteSpace_fallback: "pre-wrap",
        // For IE
        whiteSpace: "break-spaces",
        wordBreak: "break-word",
        // For Safari, which doesn't support overflow-wrap: anywhere
        overflowWrap: "anywhere",
        flexShrink: 1
      },
      "&light .cm-content": { caretColor: "black" },
      "&dark .cm-content": { caretColor: "white" },
      ".cm-line": {
        display: "block",
        padding: "0 2px 0 6px"
      },
      ".cm-layer": {
        position: "absolute",
        left: 0,
        top: 0,
        contain: "size style",
        "& > *": {
          position: "absolute"
        }
      },
      "&light .cm-selectionBackground": {
        background: "#d9d9d9"
      },
      "&dark .cm-selectionBackground": {
        background: "#222"
      },
      "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
        background: "#d7d4f0"
      },
      "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
        background: "#233"
      },
      ".cm-cursorLayer": {
        pointerEvents: "none"
      },
      "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
        animation: "steps(1) cm-blink 1.2s infinite"
      },
      // Two animations defined so that we can switch between them to
      // restart the animation without forcing another style
      // recomputation.
      "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
      "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
      ".cm-cursor, .cm-dropCursor": {
        borderLeft: "1.2px solid black",
        marginLeft: "-0.6px",
        pointerEvents: "none"
      },
      ".cm-cursor": {
        display: "none"
      },
      "&dark .cm-cursor": {
        borderLeftColor: "#ddd"
      },
      ".cm-dropCursor": {
        position: "absolute"
      },
      "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
        display: "block"
      },
      ".cm-iso": {
        unicodeBidi: "isolate"
      },
      ".cm-announced": {
        position: "fixed",
        top: "-10000px"
      },
      "@media print": {
        ".cm-announced": { display: "none" }
      },
      "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
      "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
      "&light .cm-specialChar": { color: "red" },
      "&dark .cm-specialChar": { color: "#f78" },
      ".cm-gutters": {
        flexShrink: 0,
        display: "flex",
        height: "100%",
        boxSizing: "border-box",
        zIndex: 200
      },
      ".cm-gutters-before": { insetInlineStart: 0 },
      ".cm-gutters-after": { insetInlineEnd: 0 },
      "&light .cm-gutters": {
        backgroundColor: "#f5f5f5",
        color: "#6c6c6c",
        border: "0px solid #ddd",
        "&.cm-gutters-before": { borderRightWidth: "1px" },
        "&.cm-gutters-after": { borderLeftWidth: "1px" }
      },
      "&dark .cm-gutters": {
        backgroundColor: "#333338",
        color: "#ccc"
      },
      ".cm-gutter": {
        display: "flex !important",
        // Necessary -- prevents margin collapsing
        flexDirection: "column",
        flexShrink: 0,
        boxSizing: "border-box",
        minHeight: "100%",
        overflow: "hidden"
      },
      ".cm-gutterElement": {
        boxSizing: "border-box"
      },
      ".cm-lineNumbers .cm-gutterElement": {
        padding: "0 3px 0 5px",
        minWidth: "20px",
        textAlign: "right",
        whiteSpace: "nowrap"
      },
      "&light .cm-activeLineGutter": {
        backgroundColor: "#e2f2ff"
      },
      "&dark .cm-activeLineGutter": {
        backgroundColor: "#222227"
      },
      ".cm-panels": {
        boxSizing: "border-box",
        position: "sticky",
        left: 0,
        right: 0,
        zIndex: 300
      },
      "&light .cm-panels": {
        backgroundColor: "#f5f5f5",
        color: "black"
      },
      "&light .cm-panels-top": {
        borderBottom: "1px solid #ddd"
      },
      "&light .cm-panels-bottom": {
        borderTop: "1px solid #ddd"
      },
      "&dark .cm-panels": {
        backgroundColor: "#333338",
        color: "white"
      },
      ".cm-dialog": {
        padding: "2px 19px 4px 6px",
        position: "relative",
        "& label": { fontSize: "80%" }
      },
      ".cm-dialog-close": {
        position: "absolute",
        top: "3px",
        right: "4px",
        backgroundColor: "inherit",
        border: "none",
        font: "inherit",
        fontSize: "14px",
        padding: "0"
      },
      ".cm-tab": {
        display: "inline-block",
        overflow: "hidden",
        verticalAlign: "bottom"
      },
      ".cm-widgetBuffer": {
        verticalAlign: "text-top",
        height: "1em",
        width: 0,
        display: "inline"
      },
      ".cm-placeholder": {
        color: "#888",
        display: "inline-block",
        verticalAlign: "top",
        userSelect: "none"
      },
      ".cm-highlightSpace": {
        backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
        backgroundPosition: "center"
      },
      ".cm-highlightTab": {
        backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
        backgroundSize: "auto 100%",
        backgroundPosition: "right 90%",
        backgroundRepeat: "no-repeat"
      },
      ".cm-trailingSpace": {
        backgroundColor: "#ff332255"
      },
      ".cm-button": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        padding: ".2em 1em",
        borderRadius: "1px"
      },
      "&light .cm-button": {
        backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
        border: "1px solid #888",
        "&:active": {
          backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
        }
      },
      "&dark .cm-button": {
        backgroundImage: "linear-gradient(#393939, #111)",
        border: "1px solid #888",
        "&:active": {
          backgroundImage: "linear-gradient(#111, #333)"
        }
      },
      ".cm-textfield": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        border: "1px solid silver",
        padding: ".2em .5em"
      },
      "&light .cm-textfield": {
        backgroundColor: "white"
      },
      "&dark .cm-textfield": {
        border: "1px solid #555",
        backgroundColor: "inherit"
      }
    }, lightDarkIDs);
    const observeOptions = {
      childList: true,
      characterData: true,
      subtree: true,
      attributes: true,
      characterDataOldValue: true
    };
    const useCharData = browser.ie && browser.ie_version <= 11;
    class DOMObserver {
      constructor(view) {
        this.view = view;
        this.active = false;
        this.editContext = null;
        this.selectionRange = new DOMSelectionState();
        this.selectionChanged = false;
        this.delayedFlush = -1;
        this.resizeTimeout = -1;
        this.queue = [];
        this.delayedAndroidKey = null;
        this.flushingAndroidKey = -1;
        this.lastChange = 0;
        this.scrollTargets = [];
        this.intersection = null;
        this.resizeScroll = null;
        this.intersecting = false;
        this.gapIntersection = null;
        this.gaps = [];
        this.printQuery = null;
        this.parentCheck = -1;
        this.dom = view.contentDOM;
        this.observer = new MutationObserver((mutations) => {
          for (let mut of mutations)
            this.queue.push(mut);
          if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
            this.flushSoon();
          else
            this.flush();
        });
        if (window.EditContext && browser.android && view.constructor.EDIT_CONTEXT !== false && // Chrome <126 doesn't support inverted selections in edit context (#1392)
        !(browser.chrome && browser.chrome_version < 126)) {
          this.editContext = new EditContextManager(view);
          if (view.state.facet(editable))
            view.contentDOM.editContext = this.editContext.editContext;
        }
        if (useCharData)
          this.onCharData = (event) => {
            this.queue.push({
              target: event.target,
              type: "characterData",
              oldValue: event.prevValue
            });
            this.flushSoon();
          };
        this.onSelectionChange = this.onSelectionChange.bind(this);
        this.onResize = this.onResize.bind(this);
        this.onPrint = this.onPrint.bind(this);
        this.onScroll = this.onScroll.bind(this);
        if (window.matchMedia)
          this.printQuery = window.matchMedia("print");
        if (typeof ResizeObserver == "function") {
          this.resizeScroll = new ResizeObserver(() => {
            var _a2;
            if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
              this.onResize();
          });
          this.resizeScroll.observe(view.scrollDOM);
        }
        this.addWindowListeners(this.win = view.win);
        this.start();
        if (typeof IntersectionObserver == "function") {
          this.intersection = new IntersectionObserver((entries) => {
            if (this.parentCheck < 0)
              this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
            if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
              this.intersecting = !this.intersecting;
              if (this.intersecting != this.view.inView)
                this.onScrollChanged(document.createEvent("Event"));
            }
          }, { threshold: [0, 1e-3] });
          this.intersection.observe(this.dom);
          this.gapIntersection = new IntersectionObserver((entries) => {
            if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
              this.onScrollChanged(document.createEvent("Event"));
          }, {});
        }
        this.listenForScroll();
        this.readSelectionRange();
      }
      onScrollChanged(e) {
        this.view.inputState.runHandlers("scroll", e);
        if (this.intersecting)
          this.view.measure();
      }
      onScroll(e) {
        if (this.intersecting)
          this.flush(false);
        if (this.editContext)
          this.view.requestMeasure(this.editContext.measureReq);
        this.onScrollChanged(e);
      }
      onResize() {
        if (this.resizeTimeout < 0)
          this.resizeTimeout = setTimeout(() => {
            this.resizeTimeout = -1;
            this.view.requestMeasure();
          }, 50);
      }
      onPrint(event) {
        if ((event.type == "change" || !event.type) && !event.matches)
          return;
        this.view.viewState.printing = true;
        this.view.measure();
        setTimeout(() => {
          this.view.viewState.printing = false;
          this.view.requestMeasure();
        }, 500);
      }
      updateGaps(gaps) {
        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i2) => g != gaps[i2]))) {
          this.gapIntersection.disconnect();
          for (let gap of gaps)
            this.gapIntersection.observe(gap);
          this.gaps = gaps;
        }
      }
      onSelectionChange(event) {
        let wasChanged = this.selectionChanged;
        if (!this.readSelectionRange() || this.delayedAndroidKey)
          return;
        let { view } = this, sel = this.selectionRange;
        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel))
          return;
        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
        if (context && context.ignoreEvent(event)) {
          if (!wasChanged)
            this.selectionChanged = false;
          return;
        }
        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
        sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
          this.flushSoon();
        else
          this.flush(false);
      }
      readSelectionRange() {
        let { view } = this;
        let selection2 = getSelection(view.root);
        if (!selection2)
          return false;
        let range = browser.safari && view.root.nodeType == 11 && view.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection2) || selection2;
        if (!range || this.selectionRange.eq(range))
          return false;
        let local = hasSelection(this.dom, range);
        if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
          this.view.inputState.lastFocusTime = 0;
          view.docView.updateSelection();
          return false;
        }
        this.selectionRange.setRange(range);
        if (local)
          this.selectionChanged = true;
        return true;
      }
      setSelectionRange(anchor, head) {
        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
        this.selectionChanged = false;
      }
      clearSelectionRange() {
        this.selectionRange.set(null, 0, null, 0);
      }
      listenForScroll() {
        this.parentCheck = -1;
        let i2 = 0, changed = null;
        for (let dom = this.dom; dom; ) {
          if (dom.nodeType == 1) {
            if (!changed && i2 < this.scrollTargets.length && this.scrollTargets[i2] == dom)
              i2++;
            else if (!changed)
              changed = this.scrollTargets.slice(0, i2);
            if (changed)
              changed.push(dom);
            dom = dom.assignedSlot || dom.parentNode;
          } else if (dom.nodeType == 11) {
            dom = dom.host;
          } else {
            break;
          }
        }
        if (i2 < this.scrollTargets.length && !changed)
          changed = this.scrollTargets.slice(0, i2);
        if (changed) {
          for (let dom of this.scrollTargets)
            dom.removeEventListener("scroll", this.onScroll);
          for (let dom of this.scrollTargets = changed)
            dom.addEventListener("scroll", this.onScroll);
        }
      }
      ignore(f) {
        if (!this.active)
          return f();
        try {
          this.stop();
          return f();
        } finally {
          this.start();
          this.clear();
        }
      }
      start() {
        if (this.active)
          return;
        this.observer.observe(this.dom, observeOptions);
        if (useCharData)
          this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
        this.active = true;
      }
      stop() {
        if (!this.active)
          return;
        this.active = false;
        this.observer.disconnect();
        if (useCharData)
          this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
      }
      // Throw away any pending changes
      clear() {
        this.processRecords();
        this.queue.length = 0;
        this.selectionChanged = false;
      }
      // Chrome Android, especially in combination with GBoard, not only
      // doesn't reliably fire regular key events, but also often
      // surrounds the effect of enter or backspace with a bunch of
      // composition events that, when interrupted, cause text duplication
      // or other kinds of corruption. This hack makes the editor back off
      // from handling DOM changes for a moment when such a key is
      // detected (via beforeinput or keydown), and then tries to flush
      // them or, if that has no effect, dispatches the given key.
      delayAndroidKey(key, keyCode) {
        var _a2;
        if (!this.delayedAndroidKey) {
          let flush = () => {
            let key2 = this.delayedAndroidKey;
            if (key2) {
              this.clearDelayedAndroidKey();
              this.view.inputState.lastKeyCode = key2.keyCode;
              this.view.inputState.lastKeyTime = Date.now();
              let flushed = this.flush();
              if (!flushed && key2.force)
                dispatchKey(this.dom, key2.key, key2.keyCode);
            }
          };
          this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
        }
        if (!this.delayedAndroidKey || key == "Enter")
          this.delayedAndroidKey = {
            key,
            keyCode,
            // Only run the key handler when no changes are detected if
            // this isn't coming right after another change, in which case
            // it is probably part of a weird chain of updates, and should
            // be ignored if it returns the DOM to its previous state.
            force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
          };
      }
      clearDelayedAndroidKey() {
        this.win.cancelAnimationFrame(this.flushingAndroidKey);
        this.delayedAndroidKey = null;
        this.flushingAndroidKey = -1;
      }
      flushSoon() {
        if (this.delayedFlush < 0)
          this.delayedFlush = this.view.win.requestAnimationFrame(() => {
            this.delayedFlush = -1;
            this.flush();
          });
      }
      forceFlush() {
        if (this.delayedFlush >= 0) {
          this.view.win.cancelAnimationFrame(this.delayedFlush);
          this.delayedFlush = -1;
        }
        this.flush();
      }
      pendingRecords() {
        for (let mut of this.observer.takeRecords())
          this.queue.push(mut);
        return this.queue;
      }
      processRecords() {
        let records = this.pendingRecords();
        if (records.length)
          this.queue = [];
        let from2 = -1, to2 = -1, typeOver = false;
        for (let record of records) {
          let range = this.readMutation(record);
          if (!range)
            continue;
          if (range.typeOver)
            typeOver = true;
          if (from2 == -1) {
            ({ from: from2, to: to2 } = range);
          } else {
            from2 = Math.min(range.from, from2);
            to2 = Math.max(range.to, to2);
          }
        }
        return { from: from2, to: to2, typeOver };
      }
      readChange() {
        let { from: from2, to: to2, typeOver } = this.processRecords();
        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
        if (from2 < 0 && !newSel)
          return null;
        if (from2 > -1)
          this.lastChange = Date.now();
        this.view.inputState.lastFocusTime = 0;
        this.selectionChanged = false;
        let change = new DOMChange(this.view, from2, to2, typeOver);
        this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
        return change;
      }
      // Apply pending changes, if any
      flush(readSelection = true) {
        if (this.delayedFlush >= 0 || this.delayedAndroidKey)
          return false;
        if (readSelection)
          this.readSelectionRange();
        let domChange = this.readChange();
        if (!domChange) {
          this.view.requestMeasure();
          return false;
        }
        let startState = this.view.state;
        let handled = applyDOMChange(this.view, domChange);
        if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main)))
          this.view.update([]);
        return handled;
      }
      readMutation(rec) {
        let cView = this.view.docView.nearest(rec.target);
        if (!cView || cView.ignoreMutation(rec))
          return null;
        cView.markDirty(rec.type == "attributes");
        if (rec.type == "attributes")
          cView.flags |= 4;
        if (rec.type == "childList") {
          let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
          let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
          return {
            from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
            to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
            typeOver: false
          };
        } else if (rec.type == "characterData") {
          return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
        } else {
          return null;
        }
      }
      setWindow(win) {
        if (win != this.win) {
          this.removeWindowListeners(this.win);
          this.win = win;
          this.addWindowListeners(this.win);
        }
      }
      addWindowListeners(win) {
        win.addEventListener("resize", this.onResize);
        if (this.printQuery) {
          if (this.printQuery.addEventListener)
            this.printQuery.addEventListener("change", this.onPrint);
          else
            this.printQuery.addListener(this.onPrint);
        } else
          win.addEventListener("beforeprint", this.onPrint);
        win.addEventListener("scroll", this.onScroll);
        win.document.addEventListener("selectionchange", this.onSelectionChange);
      }
      removeWindowListeners(win) {
        win.removeEventListener("scroll", this.onScroll);
        win.removeEventListener("resize", this.onResize);
        if (this.printQuery) {
          if (this.printQuery.removeEventListener)
            this.printQuery.removeEventListener("change", this.onPrint);
          else
            this.printQuery.removeListener(this.onPrint);
        } else
          win.removeEventListener("beforeprint", this.onPrint);
        win.document.removeEventListener("selectionchange", this.onSelectionChange);
      }
      update(update) {
        if (this.editContext) {
          this.editContext.update(update);
          if (update.startState.facet(editable) != update.state.facet(editable))
            update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
        }
      }
      destroy() {
        var _a2, _b, _c;
        this.stop();
        (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
        for (let dom of this.scrollTargets)
          dom.removeEventListener("scroll", this.onScroll);
        this.removeWindowListeners(this.win);
        clearTimeout(this.parentCheck);
        clearTimeout(this.resizeTimeout);
        this.win.cancelAnimationFrame(this.delayedFlush);
        this.win.cancelAnimationFrame(this.flushingAndroidKey);
        if (this.editContext) {
          this.view.contentDOM.editContext = null;
          this.editContext.destroy();
        }
      }
    }
    function findChild(cView, dom, dir) {
      while (dom) {
        let curView = ContentView.get(dom);
        if (curView && curView.parent == cView)
          return curView;
        let parent = dom.parentNode;
        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
      }
      return null;
    }
    function buildSelectionRangeFromRange(view, range) {
      let anchorNode = range.startContainer, anchorOffset = range.startOffset;
      let focusNode = range.endContainer, focusOffset = range.endOffset;
      let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
      if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
        [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
      return { anchorNode, anchorOffset, focusNode, focusOffset };
    }
    function safariSelectionRangeHack(view, selection2) {
      if (selection2.getComposedRanges) {
        let range = selection2.getComposedRanges(view.root)[0];
        if (range)
          return buildSelectionRangeFromRange(view, range);
      }
      let found = null;
      function read(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        found = event.getTargetRanges()[0];
      }
      view.contentDOM.addEventListener("beforeinput", read, true);
      view.dom.ownerDocument.execCommand("indent");
      view.contentDOM.removeEventListener("beforeinput", read, true);
      return found ? buildSelectionRangeFromRange(view, found) : null;
    }
    class EditContextManager {
      constructor(view) {
        this.from = 0;
        this.to = 0;
        this.pendingContextChange = null;
        this.handlers = /* @__PURE__ */ Object.create(null);
        this.composing = null;
        this.resetRange(view.state);
        let context = this.editContext = new window.EditContext({
          text: view.state.doc.sliceString(this.from, this.to),
          selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
          selectionEnd: this.toContextPos(view.state.selection.main.head)
        });
        this.handlers.textupdate = (e) => {
          let main = view.state.selection.main, { anchor, head } = main;
          let from2 = this.toEditorPos(e.updateRangeStart), to2 = this.toEditorPos(e.updateRangeEnd);
          if (view.inputState.composing >= 0 && !this.composing)
            this.composing = { contextBase: e.updateRangeStart, editorBase: from2, drifted: false };
          let deletes = to2 - from2 > e.text.length;
          if (from2 == this.from && anchor < this.from)
            from2 = anchor;
          else if (to2 == this.to && anchor > this.to)
            to2 = anchor;
          let diff = findDiff(view.state.sliceDoc(from2, to2), e.text, (deletes ? main.from : main.to) - from2, deletes ? "end" : null);
          if (!diff) {
            let newSel = EditorSelection.single(this.toEditorPos(e.selectionStart), this.toEditorPos(e.selectionEnd));
            if (!newSel.main.eq(main))
              view.dispatch({ selection: newSel, userEvent: "select" });
            return;
          }
          let change = {
            from: diff.from + from2,
            to: diff.toA + from2,
            insert: Text.of(e.text.slice(diff.from, diff.toB).split("\n"))
          };
          if ((browser.mac || browser.android) && change.from == head - 1 && /^\. ?$/.test(e.text) && view.contentDOM.getAttribute("autocorrect") == "off")
            change = { from: from2, to: to2, insert: Text.of([e.text.replace(".", " ")]) };
          this.pendingContextChange = change;
          if (!view.state.readOnly) {
            let newLen = this.to - this.from + (change.to - change.from + change.insert.length);
            applyDOMChangeInner(view, change, EditorSelection.single(this.toEditorPos(e.selectionStart, newLen), this.toEditorPos(e.selectionEnd, newLen)));
          }
          if (this.pendingContextChange) {
            this.revertPending(view.state);
            this.setSelection(view.state);
          }
          if (change.from < change.to && !change.insert.length && view.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(context.text.slice(Math.max(0, e.updateRangeStart - 1), Math.min(context.text.length, e.updateRangeStart + 1))))
            this.handlers.compositionend(e);
        };
        this.handlers.characterboundsupdate = (e) => {
          let rects = [], prev = null;
          for (let i2 = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i2 < end; i2++) {
            let rect = view.coordsForChar(i2);
            prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect();
            rects.push(prev);
          }
          context.updateCharacterBounds(e.rangeStart, rects);
        };
        this.handlers.textformatupdate = (e) => {
          let deco = [];
          for (let format of e.getTextFormats()) {
            let lineStyle = format.underlineStyle, thickness = format.underlineThickness;
            if (!/none/i.test(lineStyle) && !/none/i.test(thickness)) {
              let from2 = this.toEditorPos(format.rangeStart), to2 = this.toEditorPos(format.rangeEnd);
              if (from2 < to2) {
                let style = `text-decoration: underline ${/^[a-z]/.test(lineStyle) ? lineStyle + " " : lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${/thin/i.test(thickness) ? 1 : 2}px`;
                deco.push(Decoration.mark({ attributes: { style } }).range(from2, to2));
              }
            }
          }
          view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
        };
        this.handlers.compositionstart = () => {
          if (view.inputState.composing < 0) {
            view.inputState.composing = 0;
            view.inputState.compositionFirstChange = true;
          }
        };
        this.handlers.compositionend = () => {
          view.inputState.composing = -1;
          view.inputState.compositionFirstChange = null;
          if (this.composing) {
            let { drifted } = this.composing;
            this.composing = null;
            if (drifted)
              this.reset(view.state);
          }
        };
        for (let event in this.handlers)
          context.addEventListener(event, this.handlers[event]);
        this.measureReq = { read: (view2) => {
          this.editContext.updateControlBounds(view2.contentDOM.getBoundingClientRect());
          let sel = getSelection(view2.root);
          if (sel && sel.rangeCount)
            this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
        } };
      }
      applyEdits(update) {
        let off = 0, abort = false, pending = this.pendingContextChange;
        update.changes.iterChanges((fromA, toA, _fromB, _toB, insert2) => {
          if (abort)
            return;
          let dLen = insert2.length - (toA - fromA);
          if (pending && toA >= pending.to) {
            if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert2)) {
              pending = this.pendingContextChange = null;
              off += dLen;
              this.to += dLen;
              return;
            } else {
              pending = null;
              this.revertPending(update.state);
            }
          }
          fromA += off;
          toA += off;
          if (toA <= this.from) {
            this.from += dLen;
            this.to += dLen;
          } else if (fromA < this.to) {
            if (fromA < this.from || toA > this.to || this.to - this.from + insert2.length > 3e4) {
              abort = true;
              return;
            }
            this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert2.toString());
            this.to += dLen;
          }
          off += dLen;
        });
        if (pending && !abort)
          this.revertPending(update.state);
        return !abort;
      }
      update(update) {
        let reverted = this.pendingContextChange, startSel = update.startState.selection.main;
        if (this.composing && (this.composing.drifted || !update.changes.touchesRange(startSel.from, startSel.to) && update.transactions.some((tr) => !tr.isUserEvent("input.type") && tr.changes.touchesRange(this.from, this.to)))) {
          this.composing.drifted = true;
          this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);
        } else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
          this.pendingContextChange = null;
          this.reset(update.state);
        } else if (update.docChanged || update.selectionSet || reverted) {
          this.setSelection(update.state);
        }
        if (update.geometryChanged || update.docChanged || update.selectionSet)
          update.view.requestMeasure(this.measureReq);
      }
      resetRange(state) {
        let { head } = state.selection.main;
        this.from = Math.max(
          0,
          head - 1e4
          /* CxVp.Margin */
        );
        this.to = Math.min(
          state.doc.length,
          head + 1e4
          /* CxVp.Margin */
        );
      }
      reset(state) {
        this.resetRange(state);
        this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));
        this.setSelection(state);
      }
      revertPending(state) {
        let pending = this.pendingContextChange;
        this.pendingContextChange = null;
        this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
      }
      setSelection(state) {
        let { main } = state.selection;
        let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
        let end = this.toContextPos(main.head);
        if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)
          this.editContext.updateSelection(start, end);
      }
      rangeIsValid(state) {
        let { head } = state.selection.main;
        return !(this.from > 0 && head - this.from < 500 || this.to < state.doc.length && this.to - head < 500 || this.to - this.from > 1e4 * 3);
      }
      toEditorPos(contextPos, clipLen = this.to - this.from) {
        contextPos = Math.min(contextPos, clipLen);
        let c = this.composing;
        return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;
      }
      toContextPos(editorPos) {
        let c = this.composing;
        return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;
      }
      destroy() {
        for (let event in this.handlers)
          this.editContext.removeEventListener(event, this.handlers[event]);
      }
    }
    class EditorView {
      /**
      The current editor state.
      */
      get state() {
        return this.viewState.state;
      }
      /**
      To be able to display large documents without consuming too much
      memory or overloading the browser, CodeMirror only draws the
      code that is visible (plus a margin around it) to the DOM. This
      property tells you the extent of the current drawn viewport, in
      document positions.
      */
      get viewport() {
        return this.viewState.viewport;
      }
      /**
      When there are, for example, large collapsed ranges in the
      viewport, its size can be a lot bigger than the actual visible
      content. Thus, if you are doing something like styling the
      content in the viewport, it is preferable to only do so for
      these ranges, which are the subset of the viewport that is
      actually drawn.
      */
      get visibleRanges() {
        return this.viewState.visibleRanges;
      }
      /**
      Returns false when the editor is entirely scrolled out of view
      or otherwise hidden.
      */
      get inView() {
        return this.viewState.inView;
      }
      /**
      Indicates whether the user is currently composing text via
      [IME](https://en.wikipedia.org/wiki/Input_method), and at least
      one change has been made in the current composition.
      */
      get composing() {
        return !!this.inputState && this.inputState.composing > 0;
      }
      /**
      Indicates whether the user is currently in composing state. Note
      that on some platforms, like Android, this will be the case a
      lot, since just putting the cursor on a word starts a
      composition there.
      */
      get compositionStarted() {
        return !!this.inputState && this.inputState.composing >= 0;
      }
      /**
      The document or shadow root that the view lives in.
      */
      get root() {
        return this._root;
      }
      /**
      @internal
      */
      get win() {
        return this.dom.ownerDocument.defaultView || window;
      }
      /**
      Construct a new view. You'll want to either provide a `parent`
      option, or put `view.dom` into your document after creating a
      view, so that the user can see the editor.
      */
      constructor(config2 = {}) {
        var _a2;
        this.plugins = [];
        this.pluginMap = /* @__PURE__ */ new Map();
        this.editorAttrs = {};
        this.contentAttrs = {};
        this.bidiCache = [];
        this.destroyed = false;
        this.updateState = 2;
        this.measureScheduled = -1;
        this.measureRequests = [];
        this.contentDOM = document.createElement("div");
        this.scrollDOM = document.createElement("div");
        this.scrollDOM.tabIndex = -1;
        this.scrollDOM.className = "cm-scroller";
        this.scrollDOM.appendChild(this.contentDOM);
        this.announceDOM = document.createElement("div");
        this.announceDOM.className = "cm-announced";
        this.announceDOM.setAttribute("aria-live", "polite");
        this.dom = document.createElement("div");
        this.dom.appendChild(this.announceDOM);
        this.dom.appendChild(this.scrollDOM);
        if (config2.parent)
          config2.parent.appendChild(this.dom);
        let { dispatch } = config2;
        this.dispatchTransactions = config2.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr) => dispatch(tr, this))) || ((trs) => this.update(trs));
        this.dispatch = this.dispatch.bind(this);
        this._root = config2.root || getRoot(config2.parent) || document;
        this.viewState = new ViewState(config2.state || EditorState.create(config2));
        if (config2.scrollTo && config2.scrollTo.is(scrollIntoView$1))
          this.viewState.scrollTarget = config2.scrollTo.value.clip(this.viewState.state);
        this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
        for (let plugin of this.plugins)
          plugin.update(this);
        this.observer = new DOMObserver(this);
        this.inputState = new InputState(this);
        this.inputState.ensureHandlers(this.plugins);
        this.docView = new DocView(this);
        this.mountStyles();
        this.updateAttrs();
        this.updateState = 0;
        this.requestMeasure();
        if ((_a2 = document.fonts) === null || _a2 === void 0 ? void 0 : _a2.ready)
          document.fonts.ready.then(() => this.requestMeasure());
      }
      dispatch(...input) {
        let trs = input.length == 1 && input[0] instanceof Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];
        this.dispatchTransactions(trs, this);
      }
      /**
      Update the view for the given array of transactions. This will
      update the visible document and selection to match the state
      produced by the transactions, and notify view plugins of the
      change. You should usually call
      [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
      as a primitive.
      */
      update(transactions) {
        if (this.updateState != 0)
          throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
        let redrawn = false, attrsChanged = false, update;
        let state = this.state;
        for (let tr of transactions) {
          if (tr.startState != state)
            throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
          state = tr.state;
        }
        if (this.destroyed) {
          this.viewState.state = state;
          return;
        }
        let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
        if (transactions.some((tr) => tr.annotation(isFocusChange))) {
          this.inputState.notifiedFocused = focus;
          focusFlag = 1;
        } else if (focus != this.inputState.notifiedFocused) {
          this.inputState.notifiedFocused = focus;
          dispatchFocus = focusChangeTransaction(state, focus);
          if (!dispatchFocus)
            focusFlag = 1;
        }
        let pendingKey = this.observer.delayedAndroidKey, domChange = null;
        if (pendingKey) {
          this.observer.clearDelayedAndroidKey();
          domChange = this.observer.readChange();
          if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
            domChange = null;
        } else {
          this.observer.clear();
        }
        if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
          return this.setState(state);
        update = ViewUpdate.create(this, state, transactions);
        update.flags |= focusFlag;
        let scrollTarget = this.viewState.scrollTarget;
        try {
          this.updateState = 2;
          for (let tr of transactions) {
            if (scrollTarget)
              scrollTarget = scrollTarget.map(tr.changes);
            if (tr.scrollIntoView) {
              let { main } = tr.state.selection;
              scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
            }
            for (let e of tr.effects)
              if (e.is(scrollIntoView$1))
                scrollTarget = e.value.clip(this.state);
          }
          this.viewState.update(update, scrollTarget);
          this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
          if (!update.empty) {
            this.updatePlugins(update);
            this.inputState.update(update);
          }
          redrawn = this.docView.update(update);
          if (this.state.facet(styleModule) != this.styleModules)
            this.mountStyles();
          attrsChanged = this.updateAttrs();
          this.showAnnouncements(transactions);
          this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
        } finally {
          this.updateState = 0;
        }
        if (update.startState.facet(theme) != update.state.facet(theme))
          this.viewState.mustMeasureContent = true;
        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
          this.requestMeasure();
        if (redrawn)
          this.docViewUpdate();
        if (!update.empty)
          for (let listener of this.state.facet(updateListener)) {
            try {
              listener(update);
            } catch (e) {
              logException(this.state, e, "update listener");
            }
          }
        if (dispatchFocus || domChange)
          Promise.resolve().then(() => {
            if (dispatchFocus && this.state == dispatchFocus.startState)
              this.dispatch(dispatchFocus);
            if (domChange) {
              if (!applyDOMChange(this, domChange) && pendingKey.force)
                dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
            }
          });
      }
      /**
      Reset the view to the given state. (This will cause the entire
      document to be redrawn and all view plugins to be reinitialized,
      so you should probably only use it when the new state isn't
      derived from the old state. Otherwise, use
      [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
      */
      setState(newState) {
        if (this.updateState != 0)
          throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
        if (this.destroyed) {
          this.viewState.state = newState;
          return;
        }
        this.updateState = 2;
        let hadFocus = this.hasFocus;
        try {
          for (let plugin of this.plugins)
            plugin.destroy(this);
          this.viewState = new ViewState(newState);
          this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
          this.pluginMap.clear();
          for (let plugin of this.plugins)
            plugin.update(this);
          this.docView.destroy();
          this.docView = new DocView(this);
          this.inputState.ensureHandlers(this.plugins);
          this.mountStyles();
          this.updateAttrs();
          this.bidiCache = [];
        } finally {
          this.updateState = 0;
        }
        if (hadFocus)
          this.focus();
        this.requestMeasure();
      }
      updatePlugins(update) {
        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
        if (prevSpecs != specs) {
          let newPlugins = [];
          for (let spec of specs) {
            let found = prevSpecs.indexOf(spec);
            if (found < 0) {
              newPlugins.push(new PluginInstance(spec));
            } else {
              let plugin = this.plugins[found];
              plugin.mustUpdate = update;
              newPlugins.push(plugin);
            }
          }
          for (let plugin of this.plugins)
            if (plugin.mustUpdate != update)
              plugin.destroy(this);
          this.plugins = newPlugins;
          this.pluginMap.clear();
        } else {
          for (let p of this.plugins)
            p.mustUpdate = update;
        }
        for (let i2 = 0; i2 < this.plugins.length; i2++)
          this.plugins[i2].update(this);
        if (prevSpecs != specs)
          this.inputState.ensureHandlers(this.plugins);
      }
      docViewUpdate() {
        for (let plugin of this.plugins) {
          let val = plugin.value;
          if (val && val.docViewUpdate) {
            try {
              val.docViewUpdate(this);
            } catch (e) {
              logException(this.state, e, "doc view update listener");
            }
          }
        }
      }
      /**
      @internal
      */
      measure(flush = true) {
        if (this.destroyed)
          return;
        if (this.measureScheduled > -1)
          this.win.cancelAnimationFrame(this.measureScheduled);
        if (this.observer.delayedAndroidKey) {
          this.measureScheduled = -1;
          this.requestMeasure();
          return;
        }
        this.measureScheduled = 0;
        if (flush)
          this.observer.forceFlush();
        let updated = null;
        let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
        let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
        if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
          scrollAnchorHeight = -1;
        this.viewState.scrollAnchorHeight = -1;
        try {
          for (let i2 = 0; ; i2++) {
            if (scrollAnchorHeight < 0) {
              if (isScrolledToBottom(sDOM)) {
                scrollAnchorPos = -1;
                scrollAnchorHeight = this.viewState.heightMap.height;
              } else {
                let block = this.viewState.scrollAnchorAt(scrollTop);
                scrollAnchorPos = block.from;
                scrollAnchorHeight = block.top;
              }
            }
            this.updateState = 1;
            let changed = this.viewState.measure(this);
            if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
              break;
            if (i2 > 5) {
              console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
              break;
            }
            let measuring = [];
            if (!(changed & 4))
              [this.measureRequests, measuring] = [measuring, this.measureRequests];
            let measured = measuring.map((m) => {
              try {
                return m.read(this);
              } catch (e) {
                logException(this.state, e);
                return BadMeasure;
              }
            });
            let update = ViewUpdate.create(this, this.state, []), redrawn = false;
            update.flags |= changed;
            if (!updated)
              updated = update;
            else
              updated.flags |= changed;
            this.updateState = 2;
            if (!update.empty) {
              this.updatePlugins(update);
              this.inputState.update(update);
              this.updateAttrs();
              redrawn = this.docView.update(update);
              if (redrawn)
                this.docViewUpdate();
            }
            for (let i3 = 0; i3 < measuring.length; i3++)
              if (measured[i3] != BadMeasure) {
                try {
                  let m = measuring[i3];
                  if (m.write)
                    m.write(measured[i3], this);
                } catch (e) {
                  logException(this.state, e);
                }
              }
            if (redrawn)
              this.docView.updateSelection(true);
            if (!update.viewportChanged && this.measureRequests.length == 0) {
              if (this.viewState.editorHeight) {
                if (this.viewState.scrollTarget) {
                  this.docView.scrollIntoView(this.viewState.scrollTarget);
                  this.viewState.scrollTarget = null;
                  scrollAnchorHeight = -1;
                  continue;
                } else {
                  let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
                  let diff = newAnchorHeight - scrollAnchorHeight;
                  if (diff > 1 || diff < -1) {
                    scrollTop = scrollTop + diff;
                    sDOM.scrollTop = scrollTop / this.scaleY;
                    scrollAnchorHeight = -1;
                    continue;
                  }
                }
              }
              break;
            }
          }
        } finally {
          this.updateState = 0;
          this.measureScheduled = -1;
        }
        if (updated && !updated.empty)
          for (let listener of this.state.facet(updateListener))
            listener(updated);
      }
      /**
      Get the CSS classes for the currently active editor themes.
      */
      get themeClasses() {
        return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
      }
      updateAttrs() {
        let editorAttrs = attrsFromFacet(this, editorAttributes, {
          class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
        });
        let contentAttrs = {
          spellcheck: "false",
          autocorrect: "off",
          autocapitalize: "off",
          writingsuggestions: "false",
          translate: "no",
          contenteditable: !this.state.facet(editable) ? "false" : "true",
          class: "cm-content",
          style: `${browser.tabSize}: ${this.state.tabSize}`,
          role: "textbox",
          "aria-multiline": "true"
        };
        if (this.state.readOnly)
          contentAttrs["aria-readonly"] = "true";
        attrsFromFacet(this, contentAttributes, contentAttrs);
        let changed = this.observer.ignore(() => {
          let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
          let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
          return changedContent || changedEditor;
        });
        this.editorAttrs = editorAttrs;
        this.contentAttrs = contentAttrs;
        return changed;
      }
      showAnnouncements(trs) {
        let first = true;
        for (let tr of trs)
          for (let effect of tr.effects)
            if (effect.is(EditorView.announce)) {
              if (first)
                this.announceDOM.textContent = "";
              first = false;
              let div = this.announceDOM.appendChild(document.createElement("div"));
              div.textContent = effect.value;
            }
      }
      mountStyles() {
        this.styleModules = this.state.facet(styleModule);
        let nonce = this.state.facet(EditorView.cspNonce);
        StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1$3).reverse(), nonce ? { nonce } : void 0);
      }
      readMeasured() {
        if (this.updateState == 2)
          throw new Error("Reading the editor layout isn't allowed during an update");
        if (this.updateState == 0 && this.measureScheduled > -1)
          this.measure(false);
      }
      /**
      Schedule a layout measurement, optionally providing callbacks to
      do custom DOM measuring followed by a DOM write phase. Using
      this is preferable reading DOM layout directly from, for
      example, an event handler, because it'll make sure measuring and
      drawing done by other components is synchronized, avoiding
      unnecessary DOM layout computations.
      */
      requestMeasure(request) {
        if (this.measureScheduled < 0)
          this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
        if (request) {
          if (this.measureRequests.indexOf(request) > -1)
            return;
          if (request.key != null)
            for (let i2 = 0; i2 < this.measureRequests.length; i2++) {
              if (this.measureRequests[i2].key === request.key) {
                this.measureRequests[i2] = request;
                return;
              }
            }
          this.measureRequests.push(request);
        }
      }
      /**
      Get the value of a specific plugin, if present. Note that
      plugins that crash can be dropped from a view, so even when you
      know you registered a given plugin, it is recommended to check
      the return value of this method.
      */
      plugin(plugin) {
        let known = this.pluginMap.get(plugin);
        if (known === void 0 || known && known.plugin != plugin)
          this.pluginMap.set(plugin, known = this.plugins.find((p) => p.plugin == plugin) || null);
        return known && known.update(this).value;
      }
      /**
      The top position of the document, in screen coordinates. This
      may be negative when the editor is scrolled down. Points
      directly to the top of the first line, not above the padding.
      */
      get documentTop() {
        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
      }
      /**
      Reports the padding above and below the document.
      */
      get documentPadding() {
        return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
      }
      /**
      If the editor is transformed with CSS, this provides the scale
      along the X axis. Otherwise, it will just be 1. Note that
      transforms other than translation and scaling are not supported.
      */
      get scaleX() {
        return this.viewState.scaleX;
      }
      /**
      Provide the CSS transformed scale along the Y axis.
      */
      get scaleY() {
        return this.viewState.scaleY;
      }
      /**
      Find the text line or block widget at the given vertical
      position (which is interpreted as relative to the [top of the
      document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
      */
      elementAtHeight(height) {
        this.readMeasured();
        return this.viewState.elementAtHeight(height);
      }
      /**
      Find the line block (see
      [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
      height, again interpreted relative to the [top of the
      document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
      */
      lineBlockAtHeight(height) {
        this.readMeasured();
        return this.viewState.lineBlockAtHeight(height);
      }
      /**
      Get the extent and vertical position of all [line
      blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
      are relative to the [top of the
      document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
      */
      get viewportLineBlocks() {
        return this.viewState.viewportLines;
      }
      /**
      Find the line block around the given document position. A line
      block is a range delimited on both sides by either a
      non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
      start/end of the document. It will usually just hold a line of
      text, but may be broken into multiple textblocks by block
      widgets.
      */
      lineBlockAt(pos) {
        return this.viewState.lineBlockAt(pos);
      }
      /**
      The editor's total content height.
      */
      get contentHeight() {
        return this.viewState.contentHeight;
      }
      /**
      Move a cursor position by [grapheme
      cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
      the motion is away from the line start, or towards it. In
      bidirectional text, the line is traversed in visual order, using
      the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
      When the start position was the last one on the line, the
      returned position will be across the line break. If there is no
      further line, the original position is returned.
      
      By default, this method moves over a single cluster. The
      optional `by` argument can be used to move across more. It will
      be called with the first cluster as argument, and should return
      a predicate that determines, for each subsequent cluster,
      whether it should also be moved over.
      */
      moveByChar(start, forward, by) {
        return skipAtoms(this, start, moveByChar(this, start, forward, by));
      }
      /**
      Move a cursor position across the next group of either
      [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
      non-whitespace characters.
      */
      moveByGroup(start, forward) {
        return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
      }
      /**
      Get the cursor position visually at the start or end of a line.
      Note that this may differ from the _logical_ position at its
      start or end (which is simply at `line.from`/`line.to`) if text
      at the start or end goes against the line's base text direction.
      */
      visualLineSide(line, end) {
        let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
        let span = order[end ? order.length - 1 : 0];
        return EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
      }
      /**
      Move to the next line boundary in the given direction. If
      `includeWrap` is true, line wrapping is on, and there is a
      further wrap point on the current line, the wrap point will be
      returned. Otherwise this function will return the start or end
      of the line.
      */
      moveToLineBoundary(start, forward, includeWrap = true) {
        return moveToLineBoundary(this, start, forward, includeWrap);
      }
      /**
      Move a cursor position vertically. When `distance` isn't given,
      it defaults to moving to the next line (including wrapped
      lines). Otherwise, `distance` should provide a positive distance
      in pixels.
      
      When `start` has a
      [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
      motion will use that as a target horizontal position. Otherwise,
      the cursor's own horizontal position is used. The returned
      cursor will have its goal column set to whichever column was
      used.
      */
      moveVertically(start, forward, distance) {
        return skipAtoms(this, start, moveVertically(this, start, forward, distance));
      }
      /**
      Find the DOM parent node and offset (child offset if `node` is
      an element, character offset when it is a text node) at the
      given document position.
      
      Note that for positions that aren't currently in
      `visibleRanges`, the resulting DOM position isn't necessarily
      meaningful (it may just point before or after a placeholder
      element).
      */
      domAtPos(pos) {
        return this.docView.domAtPos(pos);
      }
      /**
      Find the document position at the given DOM node. Can be useful
      for associating positions with DOM events. Will raise an error
      when `node` isn't part of the editor content.
      */
      posAtDOM(node, offset = 0) {
        return this.docView.posFromDOM(node, offset);
      }
      posAtCoords(coords, precise = true) {
        this.readMeasured();
        return posAtCoords(this, coords, precise);
      }
      /**
      Get the screen coordinates at the given document position.
      `side` determines whether the coordinates are based on the
      element before (-1) or after (1) the position (if no element is
      available on the given side, the method will transparently use
      another strategy to get reasonable coordinates).
      */
      coordsAtPos(pos, side = 1) {
        this.readMeasured();
        let rect = this.docView.coordsAt(pos, side);
        if (!rect || rect.left == rect.right)
          return rect;
        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
        return flattenRect(rect, span.dir == Direction.LTR == side > 0);
      }
      /**
      Return the rectangle around a given character. If `pos` does not
      point in front of a character that is in the viewport and
      rendered (i.e. not replaced, not a line break), this will return
      null. For space characters that are a line wrap point, this will
      return the position before the line break.
      */
      coordsForChar(pos) {
        this.readMeasured();
        return this.docView.coordsForChar(pos);
      }
      /**
      The default width of a character in the editor. May not
      accurately reflect the width of all characters (given variable
      width fonts or styling of invididual ranges).
      */
      get defaultCharacterWidth() {
        return this.viewState.heightOracle.charWidth;
      }
      /**
      The default height of a line in the editor. May not be accurate
      for all lines.
      */
      get defaultLineHeight() {
        return this.viewState.heightOracle.lineHeight;
      }
      /**
      The text direction
      ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
      CSS property) of the editor's content element.
      */
      get textDirection() {
        return this.viewState.defaultTextDirection;
      }
      /**
      Find the text direction of the block at the given position, as
      assigned by CSS. If
      [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
      isn't enabled, or the given position is outside of the viewport,
      this will always return the same as
      [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
      this may trigger a DOM layout.
      */
      textDirectionAt(pos) {
        let perLine = this.state.facet(perLineTextDirection);
        if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
          return this.textDirection;
        this.readMeasured();
        return this.docView.textDirectionAt(pos);
      }
      /**
      Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
      (as determined by the
      [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
      CSS property of its content element).
      */
      get lineWrapping() {
        return this.viewState.heightOracle.lineWrapping;
      }
      /**
      Returns the bidirectional text structure of the given line
      (which should be in the current document) as an array of span
      objects. The order of these spans matches the [text
      direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
      left-to-right, the leftmost spans come first, otherwise the
      rightmost spans come first.
      */
      bidiSpans(line) {
        if (line.length > MaxBidiLine)
          return trivialOrder(line.length);
        let dir = this.textDirectionAt(line.from), isolates;
        for (let entry of this.bidiCache) {
          if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))
            return entry.order;
        }
        if (!isolates)
          isolates = getIsolatedRanges(this, line);
        let order = computeOrder(line.text, dir, isolates);
        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
        return order;
      }
      /**
      Check whether the editor has focus.
      */
      get hasFocus() {
        var _a2;
        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
      }
      /**
      Put focus on the editor.
      */
      focus() {
        this.observer.ignore(() => {
          focusPreventScroll(this.contentDOM);
          this.docView.updateSelection();
        });
      }
      /**
      Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
      necessary when moving the editor's existing DOM to a new window or shadow root.
      */
      setRoot(root) {
        if (this._root != root) {
          this._root = root;
          this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
          this.mountStyles();
        }
      }
      /**
      Clean up this editor view, removing its element from the
      document, unregistering event handlers, and notifying
      plugins. The view instance can no longer be used after
      calling this.
      */
      destroy() {
        if (this.root.activeElement == this.contentDOM)
          this.contentDOM.blur();
        for (let plugin of this.plugins)
          plugin.destroy(this);
        this.plugins = [];
        this.inputState.destroy();
        this.docView.destroy();
        this.dom.remove();
        this.observer.destroy();
        if (this.measureScheduled > -1)
          this.win.cancelAnimationFrame(this.measureScheduled);
        this.destroyed = true;
      }
      /**
      Returns an effect that can be
      [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
      cause it to scroll the given position or range into view.
      */
      static scrollIntoView(pos, options = {}) {
        return scrollIntoView$1.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
      }
      /**
      Return an effect that resets the editor to its current (at the
      time this method was called) scroll position. Note that this
      only affects the editor's own scrollable element, not parents.
      See also
      [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
      
      The effect should be used with a document identical to the one
      it was created for. Failing to do so is not an error, but may
      not scroll to the expected position. You can
      [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
      */
      scrollSnapshot() {
        let { scrollTop, scrollLeft } = this.scrollDOM;
        let ref = this.viewState.scrollAnchorAt(scrollTop);
        return scrollIntoView$1.of(new ScrollTarget(EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
      }
      /**
      Enable or disable tab-focus mode, which disables key bindings
      for Tab and Shift-Tab, letting the browser's default
      focus-changing behavior go through instead. This is useful to
      prevent trapping keyboard users in your editor.
      
      Without argument, this toggles the mode. With a boolean, it
      enables (true) or disables it (false). Given a number, it
      temporarily enables the mode until that number of milliseconds
      have passed or another non-Tab key is pressed.
      */
      setTabFocusMode(to2) {
        if (to2 == null)
          this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
        else if (typeof to2 == "boolean")
          this.inputState.tabFocusMode = to2 ? 0 : -1;
        else if (this.inputState.tabFocusMode != 0)
          this.inputState.tabFocusMode = Date.now() + to2;
      }
      /**
      Returns an extension that can be used to add DOM event handlers.
      The value should be an object mapping event names to handler
      functions. For any given event, such functions are ordered by
      extension precedence, and the first handler to return true will
      be assumed to have handled that event, and no other handlers or
      built-in behavior will be activated for it. These are registered
      on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
      for `scroll` handlers, which will be called any time the
      editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
      its parent nodes is scrolled.
      */
      static domEventHandlers(handlers2) {
        return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
      }
      /**
      Create an extension that registers DOM event observers. Contrary
      to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
      observers can't be prevented from running by a higher-precedence
      handler returning true. They also don't prevent other handlers
      and observers from running when they return true, and should not
      call `preventDefault`.
      */
      static domEventObservers(observers2) {
        return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
      }
      /**
      Create a theme extension. The first argument can be a
      [`style-mod`](https://github.com/marijnh/style-mod#documentation)
      style spec providing the styles for the theme. These will be
      prefixed with a generated class for the style.
      
      Because the selectors will be prefixed with a scope class, rule
      that directly match the editor's [wrapper
      element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
      addedneed to be explicitly differentiated by adding an `&` to
      the selector for that elementfor example
      `&.cm-focused`.
      
      When `dark` is set to true, the theme will be marked as dark,
      which will cause the `&dark` rules from [base
      themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
      `&light` when a light theme is active).
      */
      static theme(spec, options) {
        let prefix = StyleModule.newName();
        let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
        if (options && options.dark)
          result.push(darkTheme.of(true));
        return result;
      }
      /**
      Create an extension that adds styles to the base theme. Like
      with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
      place of the editor wrapper element when directly targeting
      that. You can also use `&dark` or `&light` instead to only
      target editors with a dark or light theme.
      */
      static baseTheme(spec) {
        return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
      }
      /**
      Retrieve an editor view instance from the view's DOM
      representation.
      */
      static findFromDOM(dom) {
        var _a2;
        let content2 = dom.querySelector(".cm-content");
        let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
        return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
      }
    }
    EditorView.styleModule = styleModule;
    EditorView.inputHandler = inputHandler$1;
    EditorView.clipboardInputFilter = clipboardInputFilter;
    EditorView.clipboardOutputFilter = clipboardOutputFilter;
    EditorView.scrollHandler = scrollHandler;
    EditorView.focusChangeEffect = focusChangeEffect;
    EditorView.perLineTextDirection = perLineTextDirection;
    EditorView.exceptionSink = exceptionSink;
    EditorView.updateListener = updateListener;
    EditorView.editable = editable;
    EditorView.mouseSelectionStyle = mouseSelectionStyle;
    EditorView.dragMovesSelection = dragMovesSelection$1;
    EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
    EditorView.decorations = decorations;
    EditorView.outerDecorations = outerDecorations;
    EditorView.atomicRanges = atomicRanges;
    EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
    EditorView.scrollMargins = scrollMargins;
    EditorView.darkTheme = darkTheme;
    EditorView.cspNonce = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : "" });
    EditorView.contentAttributes = contentAttributes;
    EditorView.editorAttributes = editorAttributes;
    EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
    EditorView.announce = /* @__PURE__ */ StateEffect.define();
    const MaxBidiLine = 4096;
    const BadMeasure = {};
    class CachedOrder {
      constructor(from2, to2, dir, isolates, fresh, order) {
        this.from = from2;
        this.to = to2;
        this.dir = dir;
        this.isolates = isolates;
        this.fresh = fresh;
        this.order = order;
      }
      static update(cache, changes) {
        if (changes.empty && !cache.some((c) => c.fresh))
          return cache;
        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
        for (let i2 = Math.max(0, cache.length - 10); i2 < cache.length; i2++) {
          let entry = cache[i2];
          if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
            result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
        }
        return result;
      }
    }
    function attrsFromFacet(view, facet, base2) {
      for (let sources = view.state.facet(facet), i2 = sources.length - 1; i2 >= 0; i2--) {
        let source2 = sources[i2], value = typeof source2 == "function" ? source2(view) : source2;
        if (value)
          combineAttrs(value, base2);
      }
      return base2;
    }
    const currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
    function normalizeKeyName(name2, platform2) {
      const parts = name2.split(/-(?!$)/);
      let result = parts[parts.length - 1];
      if (result == "Space")
        result = " ";
      let alt, ctrl, shift2, meta2;
      for (let i2 = 0; i2 < parts.length - 1; ++i2) {
        const mod = parts[i2];
        if (/^(cmd|meta|m)$/i.test(mod))
          meta2 = true;
        else if (/^a(lt)?$/i.test(mod))
          alt = true;
        else if (/^(c|ctrl|control)$/i.test(mod))
          ctrl = true;
        else if (/^s(hift)?$/i.test(mod))
          shift2 = true;
        else if (/^mod$/i.test(mod)) {
          if (platform2 == "mac")
            meta2 = true;
          else
            ctrl = true;
        } else
          throw new Error("Unrecognized modifier name: " + mod);
      }
      if (alt)
        result = "Alt-" + result;
      if (ctrl)
        result = "Ctrl-" + result;
      if (meta2)
        result = "Meta-" + result;
      if (shift2)
        result = "Shift-" + result;
      return result;
    }
    function modifiers(name2, event, shift2) {
      if (event.altKey)
        name2 = "Alt-" + name2;
      if (event.ctrlKey)
        name2 = "Ctrl-" + name2;
      if (event.metaKey)
        name2 = "Meta-" + name2;
      if (shift2 !== false && event.shiftKey)
        name2 = "Shift-" + name2;
      return name2;
    }
    const handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
      keydown(event, view) {
        return runHandlers(getKeymap(view.state), event, view, "editor");
      }
    }));
    const keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
    const Keymaps = /* @__PURE__ */ new WeakMap();
    function getKeymap(state) {
      let bindings = state.facet(keymap);
      let map2 = Keymaps.get(bindings);
      if (!map2)
        Keymaps.set(bindings, map2 = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
      return map2;
    }
    function runScopeHandlers(view, event, scope) {
      return runHandlers(getKeymap(view.state), event, view, scope);
    }
    let storedPrefix = null;
    const PrefixTimeout = 4e3;
    function buildKeymap(bindings, platform2 = currentPlatform) {
      let bound = /* @__PURE__ */ Object.create(null);
      let isPrefix = /* @__PURE__ */ Object.create(null);
      let checkPrefix = (name2, is) => {
        let current = isPrefix[name2];
        if (current == null)
          isPrefix[name2] = is;
        else if (current != is)
          throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
      };
      let add2 = (scope, key, command2, preventDefault, stopPropagation) => {
        var _a2, _b;
        let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
        let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform2));
        for (let i2 = 1; i2 < parts.length; i2++) {
          let prefix = parts.slice(0, i2).join(" ");
          checkPrefix(prefix, true);
          if (!scopeObj[prefix])
            scopeObj[prefix] = {
              preventDefault: true,
              stopPropagation: false,
              run: [(view) => {
                let ourObj = storedPrefix = { view, prefix, scope };
                setTimeout(() => {
                  if (storedPrefix == ourObj)
                    storedPrefix = null;
                }, PrefixTimeout);
                return true;
              }]
            };
        }
        let full = parts.join(" ");
        checkPrefix(full, false);
        let binding = scopeObj[full] || (scopeObj[full] = {
          preventDefault: false,
          stopPropagation: false,
          run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
        });
        if (command2)
          binding.run.push(command2);
        if (preventDefault)
          binding.preventDefault = true;
        if (stopPropagation)
          binding.stopPropagation = true;
      };
      for (let b of bindings) {
        let scopes = b.scope ? b.scope.split(" ") : ["editor"];
        if (b.any)
          for (let scope of scopes) {
            let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
            if (!scopeObj._any)
              scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
            let { any } = b;
            for (let key in scopeObj)
              scopeObj[key].run.push((view) => any(view, currentKeyEvent));
          }
        let name2 = b[platform2] || b.key;
        if (!name2)
          continue;
        for (let scope of scopes) {
          add2(scope, name2, b.run, b.preventDefault, b.stopPropagation);
          if (b.shift)
            add2(scope, "Shift-" + name2, b.shift, b.preventDefault, b.stopPropagation);
        }
      }
      return bound;
    }
    let currentKeyEvent = null;
    function runHandlers(map2, event, view, scope) {
      currentKeyEvent = event;
      let name2 = keyName(event);
      let charCode = codePointAt(name2, 0), isChar = codePointSize(charCode) == name2.length && name2 != " ";
      let prefix = "", handled = false, prevented = false, stopPropagation = false;
      if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
        prefix = storedPrefix.prefix + " ";
        if (modifierCodes.indexOf(event.keyCode) < 0) {
          prevented = true;
          storedPrefix = null;
        }
      }
      let ran = /* @__PURE__ */ new Set();
      let runFor = (binding) => {
        if (binding) {
          for (let cmd2 of binding.run)
            if (!ran.has(cmd2)) {
              ran.add(cmd2);
              if (cmd2(view)) {
                if (binding.stopPropagation)
                  stopPropagation = true;
                return true;
              }
            }
          if (binding.preventDefault) {
            if (binding.stopPropagation)
              stopPropagation = true;
            prevented = true;
          }
        }
        return false;
      };
      let scopeObj = map2[scope], baseName, shiftName;
      if (scopeObj) {
        if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)])) {
          handled = true;
        } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
        !(browser.windows && event.ctrlKey && event.altKey) && // Alt-combinations on macOS tend to be typed characters
        !(browser.mac && event.altKey && !(event.ctrlKey || event.metaKey)) && (baseName = base[event.keyCode]) && baseName != name2) {
          if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
            handled = true;
          } else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
            handled = true;
          }
        } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name2, event, true)])) {
          handled = true;
        }
        if (!handled && runFor(scopeObj._any))
          handled = true;
      }
      if (prevented)
        handled = true;
      if (handled && stopPropagation)
        event.stopPropagation();
      currentKeyEvent = null;
      return handled;
    }
    class RectangleMarker {
      /**
      Create a marker with the given class and dimensions. If `width`
      is null, the DOM element will get no width style.
      */
      constructor(className, left, top2, width, height) {
        this.className = className;
        this.left = left;
        this.top = top2;
        this.width = width;
        this.height = height;
      }
      draw() {
        let elt = document.createElement("div");
        elt.className = this.className;
        this.adjust(elt);
        return elt;
      }
      update(elt, prev) {
        if (prev.className != this.className)
          return false;
        this.adjust(elt);
        return true;
      }
      adjust(elt) {
        elt.style.left = this.left + "px";
        elt.style.top = this.top + "px";
        if (this.width != null)
          elt.style.width = this.width + "px";
        elt.style.height = this.height + "px";
      }
      eq(p) {
        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
      }
      /**
      Create a set of rectangles for the given selection range,
      assigning them theclass`className`. Will create a single
      rectangle for empty ranges, and a set of selection-style
      rectangles covering the range's content (in a bidi-aware
      way) for non-empty ones.
      */
      static forRange(view, className, range) {
        if (range.empty) {
          let pos = view.coordsAtPos(range.head, range.assoc || 1);
          if (!pos)
            return [];
          let base2 = getBase(view);
          return [new RectangleMarker(className, pos.left - base2.left, pos.top - base2.top, null, pos.bottom - pos.top)];
        } else {
          return rectanglesForRange(view, className, range);
        }
      }
    }
    function getBase(view) {
      let rect = view.scrollDOM.getBoundingClientRect();
      let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
      return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
    }
    function wrappedLine(view, pos, side, inside2) {
      let coords = view.coordsAtPos(pos, side * 2);
      if (!coords)
        return inside2;
      let editorRect = view.dom.getBoundingClientRect();
      let y = (coords.top + coords.bottom) / 2;
      let left = view.posAtCoords({ x: editorRect.left + 1, y });
      let right = view.posAtCoords({ x: editorRect.right - 1, y });
      if (left == null || right == null)
        return inside2;
      return { from: Math.max(inside2.from, Math.min(left, right)), to: Math.min(inside2.to, Math.max(left, right)) };
    }
    function rectanglesForRange(view, className, range) {
      if (range.to <= view.viewport.from || range.from >= view.viewport.to)
        return [];
      let from2 = Math.max(range.from, view.viewport.from), to2 = Math.min(range.to, view.viewport.to);
      let ltr = view.textDirection == Direction.LTR;
      let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
      let lineElt = content2.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
      let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
      let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
      let startBlock = blockAt(view, from2, 1), endBlock = blockAt(view, to2, -1);
      let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
      let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
      if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
        visualStart = wrappedLine(view, from2, 1, visualStart);
      if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
        visualEnd = wrappedLine(view, to2, -1, visualEnd);
      if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {
        return pieces(drawForLine(range.from, range.to, visualStart));
      } else {
        let top2 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
        let between = [];
        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top2.bottom + view.defaultLineHeight / 2 < bottom.top)
          between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
        else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text)
          top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
        return pieces(top2).concat(between).concat(pieces(bottom));
      }
      function piece(left, top2, right, bottom) {
        return new RectangleMarker(className, left - base2.left, top2 - base2.top, right - left, bottom - top2);
      }
      function pieces({ top: top2, bottom, horizontal }) {
        let pieces2 = [];
        for (let i2 = 0; i2 < horizontal.length; i2 += 2)
          pieces2.push(piece(horizontal[i2], top2, horizontal[i2 + 1], bottom));
        return pieces2;
      }
      function drawForLine(from3, to3, line) {
        let top2 = 1e9, bottom = -1e9, horizontal = [];
        function addSpan(from4, fromOpen, to4, toOpen, dir) {
          let fromCoords = view.coordsAtPos(from4, from4 == line.to ? -2 : 2);
          let toCoords = view.coordsAtPos(to4, to4 == line.from ? 2 : -2);
          if (!fromCoords || !toCoords)
            return;
          top2 = Math.min(fromCoords.top, toCoords.top, top2);
          bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
          if (dir == Direction.LTR)
            horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
          else
            horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
        }
        let start = from3 !== null && from3 !== void 0 ? from3 : line.from, end = to3 !== null && to3 !== void 0 ? to3 : line.to;
        for (let r of view.visibleRanges)
          if (r.to > start && r.from < end) {
            for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {
              let docLine = view.state.doc.lineAt(pos);
              for (let span of view.bidiSpans(docLine)) {
                let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
                if (spanFrom >= endPos)
                  break;
                if (spanTo > pos)
                  addSpan(Math.max(spanFrom, pos), from3 == null && spanFrom <= start, Math.min(spanTo, endPos), to3 == null && spanTo >= end, span.dir);
              }
              pos = docLine.to + 1;
              if (pos >= endPos)
                break;
            }
          }
        if (horizontal.length == 0)
          addSpan(start, from3 == null, end, to3 == null, view.textDirection);
        return { top: top2, bottom, horizontal };
      }
      function drawForWidget(block, top2) {
        let y = contentRect.top + (top2 ? block.top : block.bottom);
        return { top: y, bottom: y, horizontal: [] };
      }
    }
    function sameMarker(a, b) {
      return a.constructor == b.constructor && a.eq(b);
    }
    class LayerView {
      constructor(view, layer2) {
        this.view = view;
        this.layer = layer2;
        this.drawn = [];
        this.scaleX = 1;
        this.scaleY = 1;
        this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
        this.dom = view.scrollDOM.appendChild(document.createElement("div"));
        this.dom.classList.add("cm-layer");
        if (layer2.above)
          this.dom.classList.add("cm-layer-above");
        if (layer2.class)
          this.dom.classList.add(layer2.class);
        this.scale();
        this.dom.setAttribute("aria-hidden", "true");
        this.setOrder(view.state);
        view.requestMeasure(this.measureReq);
        if (layer2.mount)
          layer2.mount(this.dom, view);
      }
      update(update) {
        if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
          this.setOrder(update.state);
        if (this.layer.update(update, this.dom) || update.geometryChanged) {
          this.scale();
          update.view.requestMeasure(this.measureReq);
        }
      }
      docViewUpdate(view) {
        if (this.layer.updateOnDocViewUpdate !== false)
          view.requestMeasure(this.measureReq);
      }
      setOrder(state) {
        let pos = 0, order = state.facet(layerOrder);
        while (pos < order.length && order[pos] != this.layer)
          pos++;
        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
      }
      measure() {
        return this.layer.markers(this.view);
      }
      scale() {
        let { scaleX, scaleY } = this.view;
        if (scaleX != this.scaleX || scaleY != this.scaleY) {
          this.scaleX = scaleX;
          this.scaleY = scaleY;
          this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
        }
      }
      draw(markers) {
        if (markers.length != this.drawn.length || markers.some((p, i2) => !sameMarker(p, this.drawn[i2]))) {
          let old = this.dom.firstChild, oldI = 0;
          for (let marker of markers) {
            if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
              old = old.nextSibling;
              oldI++;
            } else {
              this.dom.insertBefore(marker.draw(), old);
            }
          }
          while (old) {
            let next = old.nextSibling;
            old.remove();
            old = next;
          }
          this.drawn = markers;
          if (browser.safari && browser.safari_version >= 26)
            this.dom.style.display = this.dom.firstChild ? "" : "none";
        }
      }
      destroy() {
        if (this.layer.destroy)
          this.layer.destroy(this.dom, this.view);
        this.dom.remove();
      }
    }
    const layerOrder = /* @__PURE__ */ Facet.define();
    function layer(config2) {
      return [
        ViewPlugin.define((v) => new LayerView(v, config2)),
        layerOrder.of(config2)
      ];
    }
    const selectionConfig = /* @__PURE__ */ Facet.define({
      combine(configs) {
        return combineConfig(configs, {
          cursorBlinkRate: 1200,
          drawRangeCursor: true
        }, {
          cursorBlinkRate: (a, b) => Math.min(a, b),
          drawRangeCursor: (a, b) => a || b
        });
      }
    });
    function drawSelection(config2 = {}) {
      return [
        selectionConfig.of(config2),
        cursorLayer,
        selectionLayer,
        hideNativeSelection,
        nativeSelectionHidden.of(true)
      ];
    }
    function configChanged(update) {
      return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
    }
    const cursorLayer = /* @__PURE__ */ layer({
      above: true,
      markers(view) {
        let { state } = view, conf = state.facet(selectionConfig);
        let cursors = [];
        for (let r of state.selection.ranges) {
          let prim = r == state.selection.main;
          if (r.empty || conf.drawRangeCursor) {
            let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
            let cursor2 = r.empty ? r : EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
            for (let piece of RectangleMarker.forRange(view, className, cursor2))
              cursors.push(piece);
          }
        }
        return cursors;
      },
      update(update, dom) {
        if (update.transactions.some((tr) => tr.selection))
          dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
        let confChange = configChanged(update);
        if (confChange)
          setBlinkRate(update.state, dom);
        return update.docChanged || update.selectionSet || confChange;
      },
      mount(dom, view) {
        setBlinkRate(view.state, dom);
      },
      class: "cm-cursorLayer"
    });
    function setBlinkRate(state, dom) {
      dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
    }
    const selectionLayer = /* @__PURE__ */ layer({
      above: false,
      markers(view) {
        return view.state.selection.ranges.map((r) => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r)).reduce((a, b) => a.concat(b));
      },
      update(update, dom) {
        return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
      },
      class: "cm-selectionLayer"
    });
    const hideNativeSelection = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.theme({
      ".cm-line": {
        "& ::selection, &::selection": { backgroundColor: "transparent !important" },
        caretColor: "transparent !important"
      },
      ".cm-content": {
        caretColor: "transparent !important",
        "& :focus": {
          caretColor: "initial !important",
          "&::selection, & ::selection": {
            backgroundColor: "Highlight !important"
          }
        }
      }
    }));
    const setDropCursorPos = /* @__PURE__ */ StateEffect.define({
      map(pos, mapping) {
        return pos == null ? null : mapping.mapPos(pos);
      }
    });
    const dropCursorPos = /* @__PURE__ */ StateField.define({
      create() {
        return null;
      },
      update(pos, tr) {
        if (pos != null)
          pos = tr.changes.mapPos(pos);
        return tr.effects.reduce((pos2, e) => e.is(setDropCursorPos) ? e.value : pos2, pos);
      }
    });
    const drawDropCursor = /* @__PURE__ */ ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.cursor = null;
        this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
      }
      update(update) {
        var _a2;
        let cursorPos = update.state.field(dropCursorPos);
        if (cursorPos == null) {
          if (this.cursor != null) {
            (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
            this.cursor = null;
          }
        } else {
          if (!this.cursor) {
            this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
            this.cursor.className = "cm-dropCursor";
          }
          if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
            this.view.requestMeasure(this.measureReq);
        }
      }
      readPos() {
        let { view } = this;
        let pos = view.state.field(dropCursorPos);
        let rect = pos != null && view.coordsAtPos(pos);
        if (!rect)
          return null;
        let outer = view.scrollDOM.getBoundingClientRect();
        return {
          left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
          top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
          height: rect.bottom - rect.top
        };
      }
      drawCursor(pos) {
        if (this.cursor) {
          let { scaleX, scaleY } = this.view;
          if (pos) {
            this.cursor.style.left = pos.left / scaleX + "px";
            this.cursor.style.top = pos.top / scaleY + "px";
            this.cursor.style.height = pos.height / scaleY + "px";
          } else {
            this.cursor.style.left = "-100000px";
          }
        }
      }
      destroy() {
        if (this.cursor)
          this.cursor.remove();
      }
      setDropPos(pos) {
        if (this.view.state.field(dropCursorPos) != pos)
          this.view.dispatch({ effects: setDropCursorPos.of(pos) });
      }
    }, {
      eventObservers: {
        dragover(event) {
          this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
        },
        dragleave(event) {
          if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
            this.setDropPos(null);
        },
        dragend() {
          this.setDropPos(null);
        },
        drop() {
          this.setDropPos(null);
        }
      }
    });
    function dropCursor() {
      return [dropCursorPos, drawDropCursor];
    }
    function iterMatches(doc2, re, from2, to2, f) {
      re.lastIndex = 0;
      for (let cursor2 = doc2.iterRange(from2, to2), pos = from2, m; !cursor2.next().done; pos += cursor2.value.length) {
        if (!cursor2.lineBreak)
          while (m = re.exec(cursor2.value))
            f(pos + m.index, m);
      }
    }
    function matchRanges(view, maxLength) {
      let visible = view.visibleRanges;
      if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
        return visible;
      let result = [];
      for (let { from: from2, to: to2 } of visible) {
        from2 = Math.max(view.state.doc.lineAt(from2).from, from2 - maxLength);
        to2 = Math.min(view.state.doc.lineAt(to2).to, to2 + maxLength);
        if (result.length && result[result.length - 1].to >= from2)
          result[result.length - 1].to = to2;
        else
          result.push({ from: from2, to: to2 });
      }
      return result;
    }
    class MatchDecorator {
      /**
      Create a decorator.
      */
      constructor(config2) {
        const { regexp, decoration, decorate, boundary, maxLength = 1e3 } = config2;
        if (!regexp.global)
          throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
        this.regexp = regexp;
        if (decorate) {
          this.addMatch = (match, view, from2, add2) => decorate(add2, from2, from2 + match[0].length, match, view);
        } else if (typeof decoration == "function") {
          this.addMatch = (match, view, from2, add2) => {
            let deco = decoration(match, view, from2);
            if (deco)
              add2(from2, from2 + match[0].length, deco);
          };
        } else if (decoration) {
          this.addMatch = (match, _view, from2, add2) => add2(from2, from2 + match[0].length, decoration);
        } else {
          throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
        }
        this.boundary = boundary;
        this.maxLength = maxLength;
      }
      /**
      Compute the full set of decorations for matches in the given
      view's viewport. You'll want to call this when initializing your
      plugin.
      */
      createDeco(view) {
        let build = new RangeSetBuilder(), add2 = build.add.bind(build);
        for (let { from: from2, to: to2 } of matchRanges(view, this.maxLength))
          iterMatches(view.state.doc, this.regexp, from2, to2, (from3, m) => this.addMatch(m, view, from3, add2));
        return build.finish();
      }
      /**
      Update a set of decorations for a view update. `deco` _must_ be
      the set of decorations produced by _this_ `MatchDecorator` for
      the view state before the update.
      */
      updateDeco(update, deco) {
        let changeFrom = 1e9, changeTo = -1;
        if (update.docChanged)
          update.changes.iterChanges((_f, _t, from2, to2) => {
            if (to2 >= update.view.viewport.from && from2 <= update.view.viewport.to) {
              changeFrom = Math.min(from2, changeFrom);
              changeTo = Math.max(to2, changeTo);
            }
          });
        if (update.viewportMoved || changeTo - changeFrom > 1e3)
          return this.createDeco(update.view);
        if (changeTo > -1)
          return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
        return deco;
      }
      updateRange(view, deco, updateFrom, updateTo) {
        for (let r of view.visibleRanges) {
          let from2 = Math.max(r.from, updateFrom), to2 = Math.min(r.to, updateTo);
          if (to2 >= from2) {
            let fromLine = view.state.doc.lineAt(from2), toLine = fromLine.to < to2 ? view.state.doc.lineAt(to2) : fromLine;
            let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
            if (this.boundary) {
              for (; from2 > fromLine.from; from2--)
                if (this.boundary.test(fromLine.text[from2 - 1 - fromLine.from])) {
                  start = from2;
                  break;
                }
              for (; to2 < toLine.to; to2++)
                if (this.boundary.test(toLine.text[to2 - toLine.from])) {
                  end = to2;
                  break;
                }
            }
            let ranges = [], m;
            let add2 = (from3, to3, deco2) => ranges.push(deco2.range(from3, to3));
            if (fromLine == toLine) {
              this.regexp.lastIndex = start - fromLine.from;
              while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
                this.addMatch(m, view, m.index + fromLine.from, add2);
            } else {
              iterMatches(view.state.doc, this.regexp, start, end, (from3, m2) => this.addMatch(m2, view, from3, add2));
            }
            deco = deco.update({ filterFrom: start, filterTo: end, filter: (from3, to3) => from3 < start || to3 > end, add: ranges });
          }
        }
        return deco;
      }
    }
    const UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
    const Specials = /* @__PURE__ */ new RegExp("[\0-\b\n--\u2028\u2029\uFEFF-]", UnicodeRegexpSupport);
    const Names = {
      0: "null",
      7: "bell",
      8: "backspace",
      10: "newline",
      11: "vertical tab",
      13: "carriage return",
      27: "escape",
      8203: "zero width space",
      8204: "zero width non-joiner",
      8205: "zero width joiner",
      8206: "left-to-right mark",
      8207: "right-to-left mark",
      8232: "line separator",
      8237: "left-to-right override",
      8238: "right-to-left override",
      8294: "left-to-right isolate",
      8295: "right-to-left isolate",
      8297: "pop directional isolate",
      8233: "paragraph separator",
      65279: "zero width no-break space",
      65532: "object replacement"
    };
    let _supportsTabSize = null;
    function supportsTabSize() {
      var _a2;
      if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
        let styles2 = document.body.style;
        _supportsTabSize = ((_a2 = styles2.tabSize) !== null && _a2 !== void 0 ? _a2 : styles2.MozTabSize) != null;
      }
      return _supportsTabSize || false;
    }
    const specialCharConfig = /* @__PURE__ */ Facet.define({
      combine(configs) {
        let config2 = combineConfig(configs, {
          render: null,
          specialChars: Specials,
          addSpecialChars: null
        });
        if (config2.replaceTabs = !supportsTabSize())
          config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
        if (config2.addSpecialChars)
          config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
        return config2;
      }
    });
    function highlightSpecialChars(config2 = {}) {
      return [specialCharConfig.of(config2), specialCharPlugin()];
    }
    let _plugin = null;
    function specialCharPlugin() {
      return _plugin || (_plugin = ViewPlugin.fromClass(class {
        constructor(view) {
          this.view = view;
          this.decorations = Decoration.none;
          this.decorationCache = /* @__PURE__ */ Object.create(null);
          this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
          this.decorations = this.decorator.createDeco(view);
        }
        makeDecorator(conf) {
          return new MatchDecorator({
            regexp: conf.specialChars,
            decoration: (m, view, pos) => {
              let { doc: doc2 } = view.state;
              let code2 = codePointAt(m[0], 0);
              if (code2 == 9) {
                let line = doc2.lineAt(pos);
                let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
                return Decoration.replace({
                  widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)
                });
              }
              return this.decorationCache[code2] || (this.decorationCache[code2] = Decoration.replace({ widget: new SpecialCharWidget(conf, code2) }));
            },
            boundary: conf.replaceTabs ? void 0 : /[^]/
          });
        }
        update(update) {
          let conf = update.state.facet(specialCharConfig);
          if (update.startState.facet(specialCharConfig) != conf) {
            this.decorator = this.makeDecorator(conf);
            this.decorations = this.decorator.createDeco(update.view);
          } else {
            this.decorations = this.decorator.updateDeco(update, this.decorations);
          }
        }
      }, {
        decorations: (v) => v.decorations
      }));
    }
    const DefaultPlaceholder = "";
    function placeholder$1(code2) {
      if (code2 >= 32)
        return DefaultPlaceholder;
      if (code2 == 10)
        return "";
      return String.fromCharCode(9216 + code2);
    }
    class SpecialCharWidget extends WidgetType {
      constructor(options, code2) {
        super();
        this.options = options;
        this.code = code2;
      }
      eq(other) {
        return other.code == this.code;
      }
      toDOM(view) {
        let ph = placeholder$1(this.code);
        let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
        let custom = this.options.render && this.options.render(this.code, desc, ph);
        if (custom)
          return custom;
        let span = document.createElement("span");
        span.textContent = ph;
        span.title = desc;
        span.setAttribute("aria-label", desc);
        span.className = "cm-specialChar";
        return span;
      }
      ignoreEvent() {
        return false;
      }
    }
    class TabWidget extends WidgetType {
      constructor(width) {
        super();
        this.width = width;
      }
      eq(other) {
        return other.width == this.width;
      }
      toDOM() {
        let span = document.createElement("span");
        span.textContent = "	";
        span.className = "cm-tab";
        span.style.width = this.width + "px";
        return span;
      }
      ignoreEvent() {
        return false;
      }
    }
    function highlightActiveLine() {
      return activeLineHighlighter;
    }
    const lineDeco = /* @__PURE__ */ Decoration.line({ class: "cm-activeLine" });
    const activeLineHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
      constructor(view) {
        this.decorations = this.getDeco(view);
      }
      update(update) {
        if (update.docChanged || update.selectionSet)
          this.decorations = this.getDeco(update.view);
      }
      getDeco(view) {
        let lastLineStart = -1, deco = [];
        for (let r of view.state.selection.ranges) {
          let line = view.lineBlockAt(r.head);
          if (line.from > lastLineStart) {
            deco.push(lineDeco.range(line.from));
            lastLineStart = line.from;
          }
        }
        return Decoration.set(deco);
      }
    }, {
      decorations: (v) => v.decorations
    });
    class Placeholder extends WidgetType {
      constructor(content2) {
        super();
        this.content = content2;
      }
      toDOM(view) {
        let wrap = document.createElement("span");
        wrap.className = "cm-placeholder";
        wrap.style.pointerEvents = "none";
        wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(view) : this.content.cloneNode(true));
        wrap.setAttribute("aria-hidden", "true");
        return wrap;
      }
      coordsAt(dom) {
        let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];
        if (!rects.length)
          return null;
        let style = window.getComputedStyle(dom.parentNode);
        let rect = flattenRect(rects[0], style.direction != "rtl");
        let lineHeight = parseInt(style.lineHeight);
        if (rect.bottom - rect.top > lineHeight * 1.5)
          return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.top + lineHeight };
        return rect;
      }
      ignoreEvent() {
        return false;
      }
    }
    function placeholder(content2) {
      let plugin = ViewPlugin.fromClass(class {
        constructor(view) {
          this.view = view;
          this.placeholder = content2 ? Decoration.set([Decoration.widget({ widget: new Placeholder(content2), side: 1 }).range(0)]) : Decoration.none;
        }
        get decorations() {
          return this.view.state.doc.length ? Decoration.none : this.placeholder;
        }
      }, { decorations: (v) => v.decorations });
      return typeof content2 == "string" ? [
        plugin,
        EditorView.contentAttributes.of({ "aria-placeholder": content2 })
      ] : plugin;
    }
    const MaxOff = 2e3;
    function rectangleFor(state, a, b) {
      let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
      let ranges = [];
      if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
        for (let i2 = startLine; i2 <= endLine; i2++) {
          let line = state.doc.line(i2);
          if (line.length <= endOff)
            ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
        }
      } else {
        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
        for (let i2 = startLine; i2 <= endLine; i2++) {
          let line = state.doc.line(i2);
          let start = findColumn$1(line.text, startCol, state.tabSize, true);
          if (start < 0) {
            ranges.push(EditorSelection.cursor(line.to));
          } else {
            let end = findColumn$1(line.text, endCol, state.tabSize);
            ranges.push(EditorSelection.range(line.from + start, line.from + end));
          }
        }
      }
      return ranges;
    }
    function absoluteColumn(view, x) {
      let ref = view.coordsAtPos(view.viewport.from);
      return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
    }
    function getPos(view, event) {
      let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
      let line = view.state.doc.lineAt(offset), off = offset - line.from;
      let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
      return { line: line.number, col, off };
    }
    function rectangleSelectionStyle(view, event) {
      let start = getPos(view, event), startSel = view.state.selection;
      if (!start)
        return null;
      return {
        update(update) {
          if (update.docChanged) {
            let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
            let newLine = update.state.doc.lineAt(newStart);
            start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
            startSel = startSel.map(update.changes);
          }
        },
        get(event2, _extend, multiple) {
          let cur2 = getPos(view, event2);
          if (!cur2)
            return startSel;
          let ranges = rectangleFor(view.state, start, cur2);
          if (!ranges.length)
            return startSel;
          if (multiple)
            return EditorSelection.create(ranges.concat(startSel.ranges));
          else
            return EditorSelection.create(ranges);
        }
      };
    }
    function rectangularSelection(options) {
      let filter = ((e) => e.altKey && e.button == 0);
      return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
    }
    const keys = {
      Alt: [18, (e) => !!e.altKey],
      Control: [17, (e) => !!e.ctrlKey],
      Shift: [16, (e) => !!e.shiftKey],
      Meta: [91, (e) => !!e.metaKey]
    };
    const showCrosshair = { style: "cursor: crosshair" };
    function crosshairCursor(options = {}) {
      let [code2, getter] = keys[options.key || "Alt"];
      let plugin = ViewPlugin.fromClass(class {
        constructor(view) {
          this.view = view;
          this.isDown = false;
        }
        set(isDown) {
          if (this.isDown != isDown) {
            this.isDown = isDown;
            this.view.update([]);
          }
        }
      }, {
        eventObservers: {
          keydown(e) {
            this.set(e.keyCode == code2 || getter(e));
          },
          keyup(e) {
            if (e.keyCode == code2 || !getter(e))
              this.set(false);
          },
          mousemove(e) {
            this.set(getter(e));
          }
        }
      });
      return [
        plugin,
        EditorView.contentAttributes.of((view) => {
          var _a2;
          return ((_a2 = view.plugin(plugin)) === null || _a2 === void 0 ? void 0 : _a2.isDown) ? showCrosshair : null;
        })
      ];
    }
    const Outside = "-10000px";
    class TooltipViewManager {
      constructor(view, facet, createTooltipView, removeTooltipView) {
        this.facet = facet;
        this.createTooltipView = createTooltipView;
        this.removeTooltipView = removeTooltipView;
        this.input = view.state.facet(facet);
        this.tooltips = this.input.filter((t2) => t2);
        let prev = null;
        this.tooltipViews = this.tooltips.map((t2) => prev = createTooltipView(t2, prev));
      }
      update(update, above) {
        var _a2;
        let input = update.state.facet(this.facet);
        let tooltips = input.filter((x) => x);
        if (input === this.input) {
          for (let t2 of this.tooltipViews)
            if (t2.update)
              t2.update(update);
          return false;
        }
        let tooltipViews = [], newAbove = above ? [] : null;
        for (let i2 = 0; i2 < tooltips.length; i2++) {
          let tip = tooltips[i2], known = -1;
          if (!tip)
            continue;
          for (let i3 = 0; i3 < this.tooltips.length; i3++) {
            let other = this.tooltips[i3];
            if (other && other.create == tip.create)
              known = i3;
          }
          if (known < 0) {
            tooltipViews[i2] = this.createTooltipView(tip, i2 ? tooltipViews[i2 - 1] : null);
            if (newAbove)
              newAbove[i2] = !!tip.above;
          } else {
            let tooltipView = tooltipViews[i2] = this.tooltipViews[known];
            if (newAbove)
              newAbove[i2] = above[known];
            if (tooltipView.update)
              tooltipView.update(update);
          }
        }
        for (let t2 of this.tooltipViews)
          if (tooltipViews.indexOf(t2) < 0) {
            this.removeTooltipView(t2);
            (_a2 = t2.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t2);
          }
        if (above) {
          newAbove.forEach((val, i2) => above[i2] = val);
          above.length = newAbove.length;
        }
        this.input = input;
        this.tooltips = tooltips;
        this.tooltipViews = tooltipViews;
        return true;
      }
    }
    function windowSpace(view) {
      let docElt = view.dom.ownerDocument.documentElement;
      return { top: 0, left: 0, bottom: docElt.clientHeight, right: docElt.clientWidth };
    }
    const tooltipConfig = /* @__PURE__ */ Facet.define({
      combine: (values) => {
        var _a2, _b, _c;
        return {
          position: browser.ios ? "absolute" : ((_a2 = values.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
          parent: ((_b = values.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
          tooltipSpace: ((_c = values.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
        };
      }
    });
    const knownHeight = /* @__PURE__ */ new WeakMap();
    const tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.above = [];
        this.inView = true;
        this.madeAbsolute = false;
        this.lastTransaction = 0;
        this.measureTimeout = -1;
        let config2 = view.state.facet(tooltipConfig);
        this.position = config2.position;
        this.parent = config2.parent;
        this.classes = view.themeClasses;
        this.createContainer();
        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
        this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
        this.manager = new TooltipViewManager(view, showTooltip, (t2, p) => this.createTooltip(t2, p), (t2) => {
          if (this.resizeObserver)
            this.resizeObserver.unobserve(t2.dom);
          t2.dom.remove();
        });
        this.above = this.manager.tooltips.map((t2) => !!t2.above);
        this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
          if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
            this.measureSoon();
        }, { threshold: [1] }) : null;
        this.observeIntersection();
        view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
        this.maybeMeasure();
      }
      createContainer() {
        if (this.parent) {
          this.container = document.createElement("div");
          this.container.style.position = "relative";
          this.container.className = this.view.themeClasses;
          this.parent.appendChild(this.container);
        } else {
          this.container = this.view.dom;
        }
      }
      observeIntersection() {
        if (this.intersectionObserver) {
          this.intersectionObserver.disconnect();
          for (let tooltip of this.manager.tooltipViews)
            this.intersectionObserver.observe(tooltip.dom);
        }
      }
      measureSoon() {
        if (this.measureTimeout < 0)
          this.measureTimeout = setTimeout(() => {
            this.measureTimeout = -1;
            this.maybeMeasure();
          }, 50);
      }
      update(update) {
        if (update.transactions.length)
          this.lastTransaction = Date.now();
        let updated = this.manager.update(update, this.above);
        if (updated)
          this.observeIntersection();
        let shouldMeasure = updated || update.geometryChanged;
        let newConfig = update.state.facet(tooltipConfig);
        if (newConfig.position != this.position && !this.madeAbsolute) {
          this.position = newConfig.position;
          for (let t2 of this.manager.tooltipViews)
            t2.dom.style.position = this.position;
          shouldMeasure = true;
        }
        if (newConfig.parent != this.parent) {
          if (this.parent)
            this.container.remove();
          this.parent = newConfig.parent;
          this.createContainer();
          for (let t2 of this.manager.tooltipViews)
            this.container.appendChild(t2.dom);
          shouldMeasure = true;
        } else if (this.parent && this.view.themeClasses != this.classes) {
          this.classes = this.container.className = this.view.themeClasses;
        }
        if (shouldMeasure)
          this.maybeMeasure();
      }
      createTooltip(tooltip, prev) {
        let tooltipView = tooltip.create(this.view);
        let before = prev ? prev.dom : null;
        tooltipView.dom.classList.add("cm-tooltip");
        if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
          let arrow = document.createElement("div");
          arrow.className = "cm-tooltip-arrow";
          tooltipView.dom.appendChild(arrow);
        }
        tooltipView.dom.style.position = this.position;
        tooltipView.dom.style.top = Outside;
        tooltipView.dom.style.left = "0px";
        this.container.insertBefore(tooltipView.dom, before);
        if (tooltipView.mount)
          tooltipView.mount(this.view);
        if (this.resizeObserver)
          this.resizeObserver.observe(tooltipView.dom);
        return tooltipView;
      }
      destroy() {
        var _a2, _b, _c;
        this.view.win.removeEventListener("resize", this.measureSoon);
        for (let tooltipView of this.manager.tooltipViews) {
          tooltipView.dom.remove();
          (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
        }
        if (this.parent)
          this.container.remove();
        (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
        clearTimeout(this.measureTimeout);
      }
      readMeasure() {
        let scaleX = 1, scaleY = 1, makeAbsolute = false;
        if (this.position == "fixed" && this.manager.tooltipViews.length) {
          let { dom } = this.manager.tooltipViews[0];
          if (browser.safari) {
            let rect = dom.getBoundingClientRect();
            makeAbsolute = Math.abs(rect.top + 1e4) > 1 || Math.abs(rect.left) > 1;
          } else {
            makeAbsolute = !!dom.offsetParent && dom.offsetParent != this.container.ownerDocument.body;
          }
        }
        if (makeAbsolute || this.position == "absolute") {
          if (this.parent) {
            let rect = this.parent.getBoundingClientRect();
            if (rect.width && rect.height) {
              scaleX = rect.width / this.parent.offsetWidth;
              scaleY = rect.height / this.parent.offsetHeight;
            }
          } else {
            ({ scaleX, scaleY } = this.view.viewState);
          }
        }
        let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);
        return {
          visible: {
            left: visible.left + margins.left,
            top: visible.top + margins.top,
            right: visible.right - margins.right,
            bottom: visible.bottom - margins.bottom
          },
          parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
          pos: this.manager.tooltips.map((t2, i2) => {
            let tv = this.manager.tooltipViews[i2];
            return tv.getCoords ? tv.getCoords(t2.pos) : this.view.coordsAtPos(t2.pos);
          }),
          size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
          space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
          scaleX,
          scaleY,
          makeAbsolute
        };
      }
      writeMeasure(measured) {
        var _a2;
        if (measured.makeAbsolute) {
          this.madeAbsolute = true;
          this.position = "absolute";
          for (let t2 of this.manager.tooltipViews)
            t2.dom.style.position = "absolute";
        }
        let { visible, space, scaleX, scaleY } = measured;
        let others = [];
        for (let i2 = 0; i2 < this.manager.tooltips.length; i2++) {
          let tooltip = this.manager.tooltips[i2], tView = this.manager.tooltipViews[i2], { dom } = tView;
          let pos = measured.pos[i2], size = measured.size[i2];
          if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space.top) || pos.top >= Math.min(visible.bottom, space.bottom) || pos.right < Math.max(visible.left, space.left) - 0.1 || pos.left > Math.min(visible.right, space.right) + 0.1)) {
            dom.style.top = Outside;
            continue;
          }
          let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
          let arrowHeight = arrow ? 7 : 0;
          let width = size.right - size.left, height = (_a2 = knownHeight.get(tView)) !== null && _a2 !== void 0 ? _a2 : size.bottom - size.top;
          let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
          let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.max(space.left, Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space.right - width)) : Math.min(Math.max(space.left, pos.left - width + (arrow ? 14 : 0) - offset.x), space.right - width);
          let above = this.above[i2];
          if (!tooltip.strictSide && (above ? pos.top - height - arrowHeight - offset.y < space.top : pos.bottom + height + arrowHeight + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top)
            above = this.above[i2] = !above;
          let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
          if (spaceVert < height && tView.resize !== false) {
            if (spaceVert < this.view.defaultLineHeight) {
              dom.style.top = Outside;
              continue;
            }
            knownHeight.set(tView, height);
            dom.style.height = (height = spaceVert) / scaleY + "px";
          } else if (dom.style.height) {
            dom.style.height = "";
          }
          let top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
          let right = left + width;
          if (tView.overlap !== true) {
            for (let r of others)
              if (r.left < right && r.right > left && r.top < top2 + height && r.bottom > top2)
                top2 = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
          }
          if (this.position == "absolute") {
            dom.style.top = (top2 - measured.parent.top) / scaleY + "px";
            setLeftStyle(dom, (left - measured.parent.left) / scaleX);
          } else {
            dom.style.top = top2 / scaleY + "px";
            setLeftStyle(dom, left / scaleX);
          }
          if (arrow) {
            let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7);
            arrow.style.left = arrowLeft / scaleX + "px";
          }
          if (tView.overlap !== true)
            others.push({ left, top: top2, right, bottom: top2 + height });
          dom.classList.toggle("cm-tooltip-above", above);
          dom.classList.toggle("cm-tooltip-below", !above);
          if (tView.positioned)
            tView.positioned(measured.space);
        }
      }
      maybeMeasure() {
        if (this.manager.tooltips.length) {
          if (this.view.inView)
            this.view.requestMeasure(this.measureReq);
          if (this.inView != this.view.inView) {
            this.inView = this.view.inView;
            if (!this.inView)
              for (let tv of this.manager.tooltipViews)
                tv.dom.style.top = Outside;
          }
        }
      }
    }, {
      eventObservers: {
        scroll() {
          this.maybeMeasure();
        }
      }
    });
    function setLeftStyle(elt, value) {
      let current = parseInt(elt.style.left, 10);
      if (isNaN(current) || Math.abs(value - current) > 1)
        elt.style.left = value + "px";
    }
    const baseTheme$4 = /* @__PURE__ */ EditorView.baseTheme({
      ".cm-tooltip": {
        zIndex: 500,
        boxSizing: "border-box"
      },
      "&light .cm-tooltip": {
        border: "1px solid #bbb",
        backgroundColor: "#f5f5f5"
      },
      "&light .cm-tooltip-section:not(:first-child)": {
        borderTop: "1px solid #bbb"
      },
      "&dark .cm-tooltip": {
        backgroundColor: "#333338",
        color: "white"
      },
      ".cm-tooltip-arrow": {
        height: `${7}px`,
        width: `${7 * 2}px`,
        position: "absolute",
        zIndex: -1,
        overflow: "hidden",
        "&:before, &:after": {
          content: "''",
          position: "absolute",
          width: 0,
          height: 0,
          borderLeft: `${7}px solid transparent`,
          borderRight: `${7}px solid transparent`
        },
        ".cm-tooltip-above &": {
          bottom: `-${7}px`,
          "&:before": {
            borderTop: `${7}px solid #bbb`
          },
          "&:after": {
            borderTop: `${7}px solid #f5f5f5`,
            bottom: "1px"
          }
        },
        ".cm-tooltip-below &": {
          top: `-${7}px`,
          "&:before": {
            borderBottom: `${7}px solid #bbb`
          },
          "&:after": {
            borderBottom: `${7}px solid #f5f5f5`,
            top: "1px"
          }
        }
      },
      "&dark .cm-tooltip .cm-tooltip-arrow": {
        "&:before": {
          borderTopColor: "#333338",
          borderBottomColor: "#333338"
        },
        "&:after": {
          borderTopColor: "transparent",
          borderBottomColor: "transparent"
        }
      }
    });
    const noOffset = { x: 0, y: 0 };
    const showTooltip = /* @__PURE__ */ Facet.define({
      enables: [tooltipPlugin, baseTheme$4]
    });
    const showHoverTooltip = /* @__PURE__ */ Facet.define({
      combine: (inputs) => inputs.reduce((a, i2) => a.concat(i2), [])
    });
    class HoverTooltipHost {
      // Needs to be static so that host tooltip instances always match
      static create(view) {
        return new HoverTooltipHost(view);
      }
      constructor(view) {
        this.view = view;
        this.mounted = false;
        this.dom = document.createElement("div");
        this.dom.classList.add("cm-tooltip-hover");
        this.manager = new TooltipViewManager(view, showHoverTooltip, (t2, p) => this.createHostedView(t2, p), (t2) => t2.dom.remove());
      }
      createHostedView(tooltip, prev) {
        let hostedView = tooltip.create(this.view);
        hostedView.dom.classList.add("cm-tooltip-section");
        this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);
        if (this.mounted && hostedView.mount)
          hostedView.mount(this.view);
        return hostedView;
      }
      mount(view) {
        for (let hostedView of this.manager.tooltipViews) {
          if (hostedView.mount)
            hostedView.mount(view);
        }
        this.mounted = true;
      }
      positioned(space) {
        for (let hostedView of this.manager.tooltipViews) {
          if (hostedView.positioned)
            hostedView.positioned(space);
        }
      }
      update(update) {
        this.manager.update(update);
      }
      destroy() {
        var _a2;
        for (let t2 of this.manager.tooltipViews)
          (_a2 = t2.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t2);
      }
      passProp(name2) {
        let value = void 0;
        for (let view of this.manager.tooltipViews) {
          let given = view[name2];
          if (given !== void 0) {
            if (value === void 0)
              value = given;
            else if (value !== given)
              return void 0;
          }
        }
        return value;
      }
      get offset() {
        return this.passProp("offset");
      }
      get getCoords() {
        return this.passProp("getCoords");
      }
      get overlap() {
        return this.passProp("overlap");
      }
      get resize() {
        return this.passProp("resize");
      }
    }
    const showHoverTooltipHost = /* @__PURE__ */ showTooltip.compute([showHoverTooltip], (state) => {
      let tooltips = state.facet(showHoverTooltip);
      if (tooltips.length === 0)
        return null;
      return {
        pos: Math.min(...tooltips.map((t2) => t2.pos)),
        end: Math.max(...tooltips.map((t2) => {
          var _a2;
          return (_a2 = t2.end) !== null && _a2 !== void 0 ? _a2 : t2.pos;
        })),
        create: HoverTooltipHost.create,
        above: tooltips[0].above,
        arrow: tooltips.some((t2) => t2.arrow)
      };
    });
    class HoverPlugin {
      constructor(view, source2, field, setHover, hoverTime) {
        this.view = view;
        this.source = source2;
        this.field = field;
        this.setHover = setHover;
        this.hoverTime = hoverTime;
        this.hoverTimeout = -1;
        this.restartTimeout = -1;
        this.pending = null;
        this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
        this.checkHover = this.checkHover.bind(this);
        view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
        view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
      }
      update() {
        if (this.pending) {
          this.pending = null;
          clearTimeout(this.restartTimeout);
          this.restartTimeout = setTimeout(() => this.startHover(), 20);
        }
      }
      get active() {
        return this.view.state.field(this.field);
      }
      checkHover() {
        this.hoverTimeout = -1;
        if (this.active.length)
          return;
        let hovered = Date.now() - this.lastMove.time;
        if (hovered < this.hoverTime)
          this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
        else
          this.startHover();
      }
      startHover() {
        clearTimeout(this.restartTimeout);
        let { view, lastMove } = this;
        let desc = view.docView.nearest(lastMove.target);
        if (!desc)
          return;
        let pos, side = 1;
        if (desc instanceof WidgetView) {
          pos = desc.posAtStart;
        } else {
          pos = view.posAtCoords(lastMove);
          if (pos == null)
            return;
          let posCoords = view.coordsAtPos(pos);
          if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth)
            return;
          let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s) => s.from <= pos && s.to >= pos);
          let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
          side = lastMove.x < posCoords.left ? -rtl : rtl;
        }
        let open = this.source(view, pos, side);
        if (open === null || open === void 0 ? void 0 : open.then) {
          let pending = this.pending = { pos };
          open.then((result) => {
            if (this.pending == pending) {
              this.pending = null;
              if (result && !(Array.isArray(result) && !result.length))
                view.dispatch({ effects: this.setHover.of(Array.isArray(result) ? result : [result]) });
            }
          }, (e) => logException(view.state, e, "hover tooltip"));
        } else if (open && !(Array.isArray(open) && !open.length)) {
          view.dispatch({ effects: this.setHover.of(Array.isArray(open) ? open : [open]) });
        }
      }
      get tooltip() {
        let plugin = this.view.plugin(tooltipPlugin);
        let index2 = plugin ? plugin.manager.tooltips.findIndex((t2) => t2.create == HoverTooltipHost.create) : -1;
        return index2 > -1 ? plugin.manager.tooltipViews[index2] : null;
      }
      mousemove(event) {
        var _a2, _b;
        this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
        if (this.hoverTimeout < 0)
          this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
        let { active, tooltip } = this;
        if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {
          let { pos } = active[0] || this.pending, end = (_b = (_a2 = active[0]) === null || _a2 === void 0 ? void 0 : _a2.end) !== null && _b !== void 0 ? _b : pos;
          if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {
            this.view.dispatch({ effects: this.setHover.of([]) });
            this.pending = null;
          }
        }
      }
      mouseleave(event) {
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = -1;
        let { active } = this;
        if (active.length) {
          let { tooltip } = this;
          let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);
          if (!inTooltip)
            this.view.dispatch({ effects: this.setHover.of([]) });
          else
            this.watchTooltipLeave(tooltip.dom);
        }
      }
      watchTooltipLeave(tooltip) {
        let watch = (event) => {
          tooltip.removeEventListener("mouseleave", watch);
          if (this.active.length && !this.view.dom.contains(event.relatedTarget))
            this.view.dispatch({ effects: this.setHover.of([]) });
        };
        tooltip.addEventListener("mouseleave", watch);
      }
      destroy() {
        clearTimeout(this.hoverTimeout);
        this.view.dom.removeEventListener("mouseleave", this.mouseleave);
        this.view.dom.removeEventListener("mousemove", this.mousemove);
      }
    }
    const tooltipMargin = 4;
    function isInTooltip(tooltip, event) {
      let { left, right, top: top2, bottom } = tooltip.getBoundingClientRect(), arrow;
      if (arrow = tooltip.querySelector(".cm-tooltip-arrow")) {
        let arrowRect = arrow.getBoundingClientRect();
        top2 = Math.min(arrowRect.top, top2);
        bottom = Math.max(arrowRect.bottom, bottom);
      }
      return event.clientX >= left - tooltipMargin && event.clientX <= right + tooltipMargin && event.clientY >= top2 - tooltipMargin && event.clientY <= bottom + tooltipMargin;
    }
    function isOverRange(view, from2, to2, x, y, margin) {
      let rect = view.scrollDOM.getBoundingClientRect();
      let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
      if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y)
        return false;
      let pos = view.posAtCoords({ x, y }, false);
      return pos >= from2 && pos <= to2;
    }
    function hoverTooltip(source2, options = {}) {
      let setHover = StateEffect.define();
      let hoverState = StateField.define({
        create() {
          return [];
        },
        update(value, tr) {
          if (value.length) {
            if (options.hideOnChange && (tr.docChanged || tr.selection))
              value = [];
            else if (options.hideOn)
              value = value.filter((v) => !options.hideOn(tr, v));
            if (tr.docChanged) {
              let mapped = [];
              for (let tooltip of value) {
                let newPos = tr.changes.mapPos(tooltip.pos, -1, MapMode.TrackDel);
                if (newPos != null) {
                  let copy2 = Object.assign(/* @__PURE__ */ Object.create(null), tooltip);
                  copy2.pos = newPos;
                  if (copy2.end != null)
                    copy2.end = tr.changes.mapPos(copy2.end);
                  mapped.push(copy2);
                }
              }
              value = mapped;
            }
          }
          for (let effect of tr.effects) {
            if (effect.is(setHover))
              value = effect.value;
            if (effect.is(closeHoverTooltipEffect))
              value = [];
          }
          return value;
        },
        provide: (f) => showHoverTooltip.from(f)
      });
      return {
        active: hoverState,
        extension: [
          hoverState,
          ViewPlugin.define((view) => new HoverPlugin(
            view,
            source2,
            hoverState,
            setHover,
            options.hoverTime || 300
            /* Hover.Time */
          )),
          showHoverTooltipHost
        ]
      };
    }
    function getTooltip(view, tooltip) {
      let plugin = view.plugin(tooltipPlugin);
      if (!plugin)
        return null;
      let found = plugin.manager.tooltips.indexOf(tooltip);
      return found < 0 ? null : plugin.manager.tooltipViews[found];
    }
    const closeHoverTooltipEffect = /* @__PURE__ */ StateEffect.define();
    const panelConfig = /* @__PURE__ */ Facet.define({
      combine(configs) {
        let topContainer, bottomContainer;
        for (let c of configs) {
          topContainer = topContainer || c.topContainer;
          bottomContainer = bottomContainer || c.bottomContainer;
        }
        return { topContainer, bottomContainer };
      }
    });
    function getPanel(view, panel) {
      let plugin = view.plugin(panelPlugin);
      let index2 = plugin ? plugin.specs.indexOf(panel) : -1;
      return index2 > -1 ? plugin.panels[index2] : null;
    }
    const panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
      constructor(view) {
        this.input = view.state.facet(showPanel);
        this.specs = this.input.filter((s) => s);
        this.panels = this.specs.map((spec) => spec(view));
        let conf = view.state.facet(panelConfig);
        this.top = new PanelGroup(view, true, conf.topContainer);
        this.bottom = new PanelGroup(view, false, conf.bottomContainer);
        this.top.sync(this.panels.filter((p) => p.top));
        this.bottom.sync(this.panels.filter((p) => !p.top));
        for (let p of this.panels) {
          p.dom.classList.add("cm-panel");
          if (p.mount)
            p.mount();
        }
      }
      update(update) {
        let conf = update.state.facet(panelConfig);
        if (this.top.container != conf.topContainer) {
          this.top.sync([]);
          this.top = new PanelGroup(update.view, true, conf.topContainer);
        }
        if (this.bottom.container != conf.bottomContainer) {
          this.bottom.sync([]);
          this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
        }
        this.top.syncClasses();
        this.bottom.syncClasses();
        let input = update.state.facet(showPanel);
        if (input != this.input) {
          let specs = input.filter((x) => x);
          let panels = [], top2 = [], bottom = [], mount = [];
          for (let spec of specs) {
            let known = this.specs.indexOf(spec), panel;
            if (known < 0) {
              panel = spec(update.view);
              mount.push(panel);
            } else {
              panel = this.panels[known];
              if (panel.update)
                panel.update(update);
            }
            panels.push(panel);
            (panel.top ? top2 : bottom).push(panel);
          }
          this.specs = specs;
          this.panels = panels;
          this.top.sync(top2);
          this.bottom.sync(bottom);
          for (let p of mount) {
            p.dom.classList.add("cm-panel");
            if (p.mount)
              p.mount();
          }
        } else {
          for (let p of this.panels)
            if (p.update)
              p.update(update);
        }
      }
      destroy() {
        this.top.sync([]);
        this.bottom.sync([]);
      }
    }, {
      provide: (plugin) => EditorView.scrollMargins.of((view) => {
        let value = view.plugin(plugin);
        return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
      })
    });
    class PanelGroup {
      constructor(view, top2, container2) {
        this.view = view;
        this.top = top2;
        this.container = container2;
        this.dom = void 0;
        this.classes = "";
        this.panels = [];
        this.syncClasses();
      }
      sync(panels) {
        for (let p of this.panels)
          if (p.destroy && panels.indexOf(p) < 0)
            p.destroy();
        this.panels = panels;
        this.syncDOM();
      }
      syncDOM() {
        if (this.panels.length == 0) {
          if (this.dom) {
            this.dom.remove();
            this.dom = void 0;
          }
          return;
        }
        if (!this.dom) {
          this.dom = document.createElement("div");
          this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
          this.dom.style[this.top ? "top" : "bottom"] = "0";
          let parent = this.container || this.view.dom;
          parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
        }
        let curDOM = this.dom.firstChild;
        for (let panel of this.panels) {
          if (panel.dom.parentNode == this.dom) {
            while (curDOM != panel.dom)
              curDOM = rm(curDOM);
            curDOM = curDOM.nextSibling;
          } else {
            this.dom.insertBefore(panel.dom, curDOM);
          }
        }
        while (curDOM)
          curDOM = rm(curDOM);
      }
      scrollMargin() {
        return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
      }
      syncClasses() {
        if (!this.container || this.classes == this.view.themeClasses)
          return;
        for (let cls of this.classes.split(" "))
          if (cls)
            this.container.classList.remove(cls);
        for (let cls of (this.classes = this.view.themeClasses).split(" "))
          if (cls)
            this.container.classList.add(cls);
      }
    }
    function rm(node) {
      let next = node.nextSibling;
      node.remove();
      return next;
    }
    const showPanel = /* @__PURE__ */ Facet.define({
      enables: panelPlugin
    });
    class GutterMarker extends RangeValue {
      /**
      @internal
      */
      compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
      }
      /**
      Compare this marker to another marker of the same type.
      */
      eq(other) {
        return false;
      }
      /**
      Called if the marker has a `toDOM` method and its representation
      was removed from a gutter.
      */
      destroy(dom) {
      }
    }
    GutterMarker.prototype.elementClass = "";
    GutterMarker.prototype.toDOM = void 0;
    GutterMarker.prototype.mapMode = MapMode.TrackBefore;
    GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
    GutterMarker.prototype.point = true;
    const gutterLineClass = /* @__PURE__ */ Facet.define();
    const gutterWidgetClass = /* @__PURE__ */ Facet.define();
    const defaults$1 = {
      class: "",
      renderEmptyElements: false,
      elementStyle: "",
      markers: () => RangeSet.empty,
      lineMarker: () => null,
      widgetMarker: () => null,
      lineMarkerChange: null,
      initialSpacer: null,
      updateSpacer: null,
      domEventHandlers: {},
      side: "before"
    };
    const activeGutters = /* @__PURE__ */ Facet.define();
    function gutter(config2) {
      return [gutters(), activeGutters.of(__spreadValues(__spreadValues({}, defaults$1), config2))];
    }
    const unfixGutters = /* @__PURE__ */ Facet.define({
      combine: (values) => values.some((x) => x)
    });
    function gutters(config2) {
      let result = [
        gutterView
      ];
      return result;
    }
    const gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.domAfter = null;
        this.prevViewport = view.viewport;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutters cm-gutters-before";
        this.dom.setAttribute("aria-hidden", "true");
        this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
        this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
        this.fixed = !view.state.facet(unfixGutters);
        for (let gutter2 of this.gutters) {
          if (gutter2.config.side == "after")
            this.getDOMAfter().appendChild(gutter2.dom);
          else
            this.dom.appendChild(gutter2.dom);
        }
        if (this.fixed) {
          this.dom.style.position = "sticky";
        }
        this.syncGutters(false);
        view.scrollDOM.insertBefore(this.dom, view.contentDOM);
      }
      getDOMAfter() {
        if (!this.domAfter) {
          this.domAfter = document.createElement("div");
          this.domAfter.className = "cm-gutters cm-gutters-after";
          this.domAfter.setAttribute("aria-hidden", "true");
          this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
          this.domAfter.style.position = this.fixed ? "sticky" : "";
          this.view.scrollDOM.appendChild(this.domAfter);
        }
        return this.domAfter;
      }
      update(update) {
        if (this.updateGutters(update)) {
          let vpA = this.prevViewport, vpB = update.view.viewport;
          let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
          this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
        }
        if (update.geometryChanged) {
          let min = this.view.contentHeight / this.view.scaleY + "px";
          this.dom.style.minHeight = min;
          if (this.domAfter)
            this.domAfter.style.minHeight = min;
        }
        if (this.view.state.facet(unfixGutters) != !this.fixed) {
          this.fixed = !this.fixed;
          this.dom.style.position = this.fixed ? "sticky" : "";
          if (this.domAfter)
            this.domAfter.style.position = this.fixed ? "sticky" : "";
        }
        this.prevViewport = update.view.viewport;
      }
      syncGutters(detach) {
        let after = this.dom.nextSibling;
        if (detach) {
          this.dom.remove();
          if (this.domAfter)
            this.domAfter.remove();
        }
        let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
        let classSet = [];
        let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
        for (let line of this.view.viewportLineBlocks) {
          if (classSet.length)
            classSet = [];
          if (Array.isArray(line.type)) {
            let first = true;
            for (let b of line.type) {
              if (b.type == BlockType.Text && first) {
                advanceCursor(lineClasses, classSet, b.from);
                for (let cx of contexts)
                  cx.line(this.view, b, classSet);
                first = false;
              } else if (b.widget) {
                for (let cx of contexts)
                  cx.widget(this.view, b);
              }
            }
          } else if (line.type == BlockType.Text) {
            advanceCursor(lineClasses, classSet, line.from);
            for (let cx of contexts)
              cx.line(this.view, line, classSet);
          } else if (line.widget) {
            for (let cx of contexts)
              cx.widget(this.view, line);
          }
        }
        for (let cx of contexts)
          cx.finish();
        if (detach) {
          this.view.scrollDOM.insertBefore(this.dom, after);
          if (this.domAfter)
            this.view.scrollDOM.appendChild(this.domAfter);
        }
      }
      updateGutters(update) {
        let prev = update.startState.facet(activeGutters), cur2 = update.state.facet(activeGutters);
        let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
        if (prev == cur2) {
          for (let gutter2 of this.gutters)
            if (gutter2.update(update))
              change = true;
        } else {
          change = true;
          let gutters2 = [];
          for (let conf of cur2) {
            let known = prev.indexOf(conf);
            if (known < 0) {
              gutters2.push(new SingleGutterView(this.view, conf));
            } else {
              this.gutters[known].update(update);
              gutters2.push(this.gutters[known]);
            }
          }
          for (let g of this.gutters) {
            g.dom.remove();
            if (gutters2.indexOf(g) < 0)
              g.destroy();
          }
          for (let g of gutters2) {
            if (g.config.side == "after")
              this.getDOMAfter().appendChild(g.dom);
            else
              this.dom.appendChild(g.dom);
          }
          this.gutters = gutters2;
        }
        return change;
      }
      destroy() {
        for (let view of this.gutters)
          view.destroy();
        this.dom.remove();
        if (this.domAfter)
          this.domAfter.remove();
      }
    }, {
      provide: (plugin) => EditorView.scrollMargins.of((view) => {
        let value = view.plugin(plugin);
        if (!value || value.gutters.length == 0 || !value.fixed)
          return null;
        let before = value.dom.offsetWidth * view.scaleX, after = value.domAfter ? value.domAfter.offsetWidth * view.scaleX : 0;
        return view.textDirection == Direction.LTR ? { left: before, right: after } : { right: before, left: after };
      })
    });
    function asArray(val) {
      return Array.isArray(val) ? val : [val];
    }
    function advanceCursor(cursor2, collect, pos) {
      while (cursor2.value && cursor2.from <= pos) {
        if (cursor2.from == pos)
          collect.push(cursor2.value);
        cursor2.next();
      }
    }
    class UpdateContext {
      constructor(gutter2, viewport, height) {
        this.gutter = gutter2;
        this.height = height;
        this.i = 0;
        this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
      }
      addElement(view, block, markers) {
        let { gutter: gutter2 } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
        if (this.i == gutter2.elements.length) {
          let newElt = new GutterElement(view, height, above, markers);
          gutter2.elements.push(newElt);
          gutter2.dom.appendChild(newElt.dom);
        } else {
          gutter2.elements[this.i].update(view, height, above, markers);
        }
        this.height = block.bottom;
        this.i++;
      }
      line(view, line, extraMarkers) {
        let localMarkers = [];
        advanceCursor(this.cursor, localMarkers, line.from);
        if (extraMarkers.length)
          localMarkers = localMarkers.concat(extraMarkers);
        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
        if (forLine)
          localMarkers.unshift(forLine);
        let gutter2 = this.gutter;
        if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
          return;
        this.addElement(view, line, localMarkers);
      }
      widget(view, block) {
        let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [marker] : null;
        for (let cls of view.state.facet(gutterWidgetClass)) {
          let marker2 = cls(view, block.widget, block);
          if (marker2)
            (markers || (markers = [])).push(marker2);
        }
        if (markers)
          this.addElement(view, block, markers);
      }
      finish() {
        let gutter2 = this.gutter;
        while (gutter2.elements.length > this.i) {
          let last = gutter2.elements.pop();
          gutter2.dom.removeChild(last.dom);
          last.destroy();
        }
      }
    }
    class SingleGutterView {
      constructor(view, config2) {
        this.view = view;
        this.config = config2;
        this.elements = [];
        this.spacer = null;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
        for (let prop in config2.domEventHandlers) {
          this.dom.addEventListener(prop, (event) => {
            let target = event.target, y;
            if (target != this.dom && this.dom.contains(target)) {
              while (target.parentNode != this.dom)
                target = target.parentNode;
              let rect = target.getBoundingClientRect();
              y = (rect.top + rect.bottom) / 2;
            } else {
              y = event.clientY;
            }
            let line = view.lineBlockAtHeight(y - view.documentTop);
            if (config2.domEventHandlers[prop](view, line, event))
              event.preventDefault();
          });
        }
        this.markers = asArray(config2.markers(view));
        if (config2.initialSpacer) {
          this.spacer = new GutterElement(view, 0, 0, [config2.initialSpacer(view)]);
          this.dom.appendChild(this.spacer.dom);
          this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
        }
      }
      update(update) {
        let prevMarkers = this.markers;
        this.markers = asArray(this.config.markers(update.view));
        if (this.spacer && this.config.updateSpacer) {
          let updated = this.config.updateSpacer(this.spacer.markers[0], update);
          if (updated != this.spacer.markers[0])
            this.spacer.update(update.view, 0, 0, [updated]);
        }
        let vp = update.view.viewport;
        return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
      }
      destroy() {
        for (let elt of this.elements)
          elt.destroy();
      }
    }
    class GutterElement {
      constructor(view, height, above, markers) {
        this.height = -1;
        this.above = 0;
        this.markers = [];
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutterElement";
        this.update(view, height, above, markers);
      }
      update(view, height, above, markers) {
        if (this.height != height) {
          this.height = height;
          this.dom.style.height = height + "px";
        }
        if (this.above != above)
          this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
        if (!sameMarkers(this.markers, markers))
          this.setMarkers(view, markers);
      }
      setMarkers(view, markers) {
        let cls = "cm-gutterElement", domPos = this.dom.firstChild;
        for (let iNew = 0, iOld = 0; ; ) {
          let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
          if (marker) {
            let c = marker.elementClass;
            if (c)
              cls += " " + c;
            for (let i2 = iOld; i2 < this.markers.length; i2++)
              if (this.markers[i2].compare(marker)) {
                skipTo = i2;
                matched = true;
                break;
              }
          } else {
            skipTo = this.markers.length;
          }
          while (iOld < skipTo) {
            let next = this.markers[iOld++];
            if (next.toDOM) {
              next.destroy(domPos);
              let after = domPos.nextSibling;
              domPos.remove();
              domPos = after;
            }
          }
          if (!marker)
            break;
          if (marker.toDOM) {
            if (matched)
              domPos = domPos.nextSibling;
            else
              this.dom.insertBefore(marker.toDOM(view), domPos);
          }
          if (matched)
            iOld++;
        }
        this.dom.className = cls;
        this.markers = markers;
      }
      destroy() {
        this.setMarkers(null, []);
      }
    }
    function sameMarkers(a, b) {
      if (a.length != b.length)
        return false;
      for (let i2 = 0; i2 < a.length; i2++)
        if (!a[i2].compare(b[i2]))
          return false;
      return true;
    }
    const lineNumberMarkers = /* @__PURE__ */ Facet.define();
    const lineNumberWidgetMarker = /* @__PURE__ */ Facet.define();
    const lineNumberConfig = /* @__PURE__ */ Facet.define({
      combine(values) {
        return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
          domEventHandlers(a, b) {
            let result = Object.assign({}, a);
            for (let event in b) {
              let exists = result[event], add2 = b[event];
              result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add2(view, line, event2) : add2;
            }
            return result;
          }
        });
      }
    });
    class NumberMarker extends GutterMarker {
      constructor(number2) {
        super();
        this.number = number2;
      }
      eq(other) {
        return this.number == other.number;
      }
      toDOM() {
        return document.createTextNode(this.number);
      }
    }
    function formatNumber(view, number2) {
      return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
    }
    const lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state) => ({
      class: "cm-lineNumbers",
      renderEmptyElements: false,
      markers(view) {
        return view.state.facet(lineNumberMarkers);
      },
      lineMarker(view, line, others) {
        if (others.some((m) => m.toDOM))
          return null;
        return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
      },
      widgetMarker: (view, widget, block) => {
        for (let m of view.state.facet(lineNumberWidgetMarker)) {
          let result = m(view, widget, block);
          if (result)
            return result;
        }
        return null;
      },
      lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
      initialSpacer(view) {
        return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
      },
      updateSpacer(spacer, update) {
        let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
        return max == spacer.number ? spacer : new NumberMarker(max);
      },
      domEventHandlers: state.facet(lineNumberConfig).domEventHandlers,
      side: "before"
    }));
    function lineNumbers(config2 = {}) {
      return [
        lineNumberConfig.of(config2),
        gutters(),
        lineNumberGutter
      ];
    }
    function maxLineNumber(lines) {
      let last = 9;
      while (last < lines)
        last = last * 10 + 9;
      return last;
    }
    const activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
      constructor() {
        super(...arguments);
        this.elementClass = "cm-activeLineGutter";
      }
    }();
    const activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state) => {
      let marks = [], last = -1;
      for (let range of state.selection.ranges) {
        let linePos = state.doc.lineAt(range.head).from;
        if (linePos > last) {
          last = linePos;
          marks.push(activeLineGutterMarker.range(linePos));
        }
      }
      return RangeSet.of(marks);
    });
    function highlightActiveLineGutter() {
      return activeLineGutterHighlighter;
    }
    const DefaultBufferLength = 1024;
    let nextPropID = 0;
    class Range {
      constructor(from2, to2) {
        this.from = from2;
        this.to = to2;
      }
    }
    class NodeProp {
      /**
      Create a new node prop type.
      */
      constructor(config2 = {}) {
        this.id = nextPropID++;
        this.perNode = !!config2.perNode;
        this.deserialize = config2.deserialize || (() => {
          throw new Error("This node type doesn't define a deserialize function");
        });
        this.combine = config2.combine || null;
      }
      /**
      This is meant to be used with
      [`NodeSet.extend`](#common.NodeSet.extend) or
      [`LRParser.configure`](#lr.ParserConfig.props) to compute
      prop values for each node type in the set. Takes a [match
      object](#common.NodeType^match) or function that returns undefined
      if the node type doesn't get this prop, and the prop's value if
      it does.
      */
      add(match) {
        if (this.perNode)
          throw new RangeError("Can't add per-node props to node types");
        if (typeof match != "function")
          match = NodeType.match(match);
        return (type) => {
          let result = match(type);
          return result === void 0 ? null : [this, result];
        };
      }
    }
    NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
    NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
    NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
    NodeProp.isolate = new NodeProp({ deserialize: (value) => {
      if (value && value != "rtl" && value != "ltr" && value != "auto")
        throw new RangeError("Invalid value for isolate: " + value);
      return value || "auto";
    } });
    NodeProp.contextHash = new NodeProp({ perNode: true });
    NodeProp.lookAhead = new NodeProp({ perNode: true });
    NodeProp.mounted = new NodeProp({ perNode: true });
    class MountedTree {
      constructor(tree, overlay, parser2) {
        this.tree = tree;
        this.overlay = overlay;
        this.parser = parser2;
      }
      /**
      @internal
      */
      static get(tree) {
        return tree && tree.props && tree.props[NodeProp.mounted.id];
      }
    }
    const noProps = /* @__PURE__ */ Object.create(null);
    class NodeType {
      /**
      @internal
      */
      constructor(name2, props, id2, flags = 0) {
        this.name = name2;
        this.props = props;
        this.id = id2;
        this.flags = flags;
      }
      /**
      Define a node type.
      */
      static define(spec) {
        let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
        let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
          for (let src of spec.props) {
            if (!Array.isArray(src))
              src = src(type);
            if (src) {
              if (src[0].perNode)
                throw new RangeError("Can't store a per-node prop on a node type");
              props[src[0].id] = src[1];
            }
          }
        return type;
      }
      /**
      Retrieves a node prop for this type. Will return `undefined` if
      the prop isn't present on this node.
      */
      prop(prop) {
        return this.props[prop.id];
      }
      /**
      True when this is the top node of a grammar.
      */
      get isTop() {
        return (this.flags & 1) > 0;
      }
      /**
      True when this node is produced by a skip rule.
      */
      get isSkipped() {
        return (this.flags & 2) > 0;
      }
      /**
      Indicates whether this is an error node.
      */
      get isError() {
        return (this.flags & 4) > 0;
      }
      /**
      When true, this node type doesn't correspond to a user-declared
      named node, for example because it is used to cache repetition.
      */
      get isAnonymous() {
        return (this.flags & 8) > 0;
      }
      /**
      Returns true when this node's name or one of its
      [groups](#common.NodeProp^group) matches the given string.
      */
      is(name2) {
        if (typeof name2 == "string") {
          if (this.name == name2)
            return true;
          let group = this.prop(NodeProp.group);
          return group ? group.indexOf(name2) > -1 : false;
        }
        return this.id == name2;
      }
      /**
      Create a function from node types to arbitrary values by
      specifying an object whose property names are node or
      [group](#common.NodeProp^group) names. Often useful with
      [`NodeProp.add`](#common.NodeProp.add). You can put multiple
      names, separated by spaces, in a single property name to map
      multiple node names to a single value.
      */
      static match(map2) {
        let direct = /* @__PURE__ */ Object.create(null);
        for (let prop in map2)
          for (let name2 of prop.split(" "))
            direct[name2] = map2[prop];
        return (node) => {
          for (let groups = node.prop(NodeProp.group), i2 = -1; i2 < (groups ? groups.length : 0); i2++) {
            let found = direct[i2 < 0 ? node.name : groups[i2]];
            if (found)
              return found;
          }
        };
      }
    }
    NodeType.none = new NodeType(
      "",
      /* @__PURE__ */ Object.create(null),
      0,
      8
      /* NodeFlag.Anonymous */
    );
    class NodeSet {
      /**
      Create a set with the given types. The `id` property of each
      type should correspond to its position within the array.
      */
      constructor(types2) {
        this.types = types2;
        for (let i2 = 0; i2 < types2.length; i2++)
          if (types2[i2].id != i2)
            throw new RangeError("Node type ids should correspond to array positions when creating a node set");
      }
      /**
      Create a copy of this set with some node properties added. The
      arguments to this method can be created with
      [`NodeProp.add`](#common.NodeProp.add).
      */
      extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
          let newProps = null;
          for (let source2 of props) {
            let add2 = source2(type);
            if (add2) {
              if (!newProps)
                newProps = Object.assign({}, type.props);
              let value = add2[1], prop = add2[0];
              if (prop.combine && prop.id in newProps)
                value = prop.combine(newProps[prop.id], value);
              newProps[prop.id] = value;
            }
          }
          newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
      }
    }
    const CachedNode = /* @__PURE__ */ new WeakMap(), CachedInnerNode = /* @__PURE__ */ new WeakMap();
    var IterMode;
    (function(IterMode2) {
      IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
      IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
      IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
      IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
    })(IterMode || (IterMode = {}));
    class Tree {
      /**
      Construct a new tree. See also [`Tree.build`](#common.Tree^build).
      */
      constructor(type, children, positions2, length, props) {
        this.type = type;
        this.children = children;
        this.positions = positions2;
        this.length = length;
        this.props = null;
        if (props && props.length) {
          this.props = /* @__PURE__ */ Object.create(null);
          for (let [prop, value] of props)
            this.props[typeof prop == "number" ? prop : prop.id] = value;
        }
      }
      /**
      @internal
      */
      toString() {
        let mounted = MountedTree.get(this);
        if (mounted && !mounted.overlay)
          return mounted.tree.toString();
        let children = "";
        for (let ch of this.children) {
          let str = ch.toString();
          if (str) {
            if (children)
              children += ",";
            children += str;
          }
        }
        return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
      }
      /**
      Get a [tree cursor](#common.TreeCursor) positioned at the top of
      the tree. Mode can be used to [control](#common.IterMode) which
      nodes the cursor visits.
      */
      cursor(mode = 0) {
        return new TreeCursor(this.topNode, mode);
      }
      /**
      Get a [tree cursor](#common.TreeCursor) pointing into this tree
      at the given position and side (see
      [`moveTo`](#common.TreeCursor.moveTo).
      */
      cursorAt(pos, side = 0, mode = 0) {
        let scope = CachedNode.get(this) || this.topNode;
        let cursor2 = new TreeCursor(scope);
        cursor2.moveTo(pos, side);
        CachedNode.set(this, cursor2._tree);
        return cursor2;
      }
      /**
      Get a [syntax node](#common.SyntaxNode) object for the top of the
      tree.
      */
      get topNode() {
        return new TreeNode(this, 0, 0, null);
      }
      /**
      Get the [syntax node](#common.SyntaxNode) at the given position.
      If `side` is -1, this will move into nodes that end at the
      position. If 1, it'll move into nodes that start at the
      position. With 0, it'll only enter nodes that cover the position
      from both sides.
      
      Note that this will not enter
      [overlays](#common.MountedTree.overlay), and you often want
      [`resolveInner`](#common.Tree.resolveInner) instead.
      */
      resolve(pos, side = 0) {
        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
        CachedNode.set(this, node);
        return node;
      }
      /**
      Like [`resolve`](#common.Tree.resolve), but will enter
      [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
      pointing into the innermost overlaid tree at the given position
      (with parent links going through all parent structure, including
      the host trees).
      */
      resolveInner(pos, side = 0) {
        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
        CachedInnerNode.set(this, node);
        return node;
      }
      /**
      In some situations, it can be useful to iterate through all
      nodes around a position, including those in overlays that don't
      directly cover the position. This method gives you an iterator
      that will produce all nodes, from small to big, around the given
      position.
      */
      resolveStack(pos, side = 0) {
        return stackIterator(this, pos, side);
      }
      /**
      Iterate over the tree and its children, calling `enter` for any
      node that touches the `from`/`to` region (if given) before
      running over such a node's children, and `leave` (if given) when
      leaving the node. When `enter` returns `false`, that node will
      not have its children iterated over (or `leave` called).
      */
      iterate(spec) {
        let { enter, leave, from: from2 = 0, to: to2 = this.length } = spec;
        let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
        for (let c = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
          let entered = false;
          if (c.from <= to2 && c.to >= from2 && (!anon && c.type.isAnonymous || enter(c) !== false)) {
            if (c.firstChild())
              continue;
            entered = true;
          }
          for (; ; ) {
            if (entered && leave && (anon || !c.type.isAnonymous))
              leave(c);
            if (c.nextSibling())
              break;
            if (!c.parent())
              return;
            entered = true;
          }
        }
      }
      /**
      Get the value of the given [node prop](#common.NodeProp) for this
      node. Works with both per-node and per-type props.
      */
      prop(prop) {
        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
      }
      /**
      Returns the node's [per-node props](#common.NodeProp.perNode) in a
      format that can be passed to the [`Tree`](#common.Tree)
      constructor.
      */
      get propValues() {
        let result = [];
        if (this.props)
          for (let id2 in this.props)
            result.push([+id2, this.props[id2]]);
        return result;
      }
      /**
      Balance the direct children of this tree, producing a copy of
      which may have children grouped into subtrees with type
      [`NodeType.none`](#common.NodeType^none).
      */
      balance(config2 = {}) {
        return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions2, length) => new Tree(this.type, children, positions2, length, this.propValues), config2.makeTree || ((children, positions2, length) => new Tree(NodeType.none, children, positions2, length)));
      }
      /**
      Build a tree from a postfix-ordered buffer of node information,
      or a cursor over such a buffer.
      */
      static build(data) {
        return buildTree(data);
      }
    }
    Tree.empty = new Tree(NodeType.none, [], [], 0);
    class FlatBufferCursor {
      constructor(buffer, index2) {
        this.buffer = buffer;
        this.index = index2;
      }
      get id() {
        return this.buffer[this.index - 4];
      }
      get start() {
        return this.buffer[this.index - 3];
      }
      get end() {
        return this.buffer[this.index - 2];
      }
      get size() {
        return this.buffer[this.index - 1];
      }
      get pos() {
        return this.index;
      }
      next() {
        this.index -= 4;
      }
      fork() {
        return new FlatBufferCursor(this.buffer, this.index);
      }
    }
    class TreeBuffer {
      /**
      Create a tree buffer.
      */
      constructor(buffer, length, set2) {
        this.buffer = buffer;
        this.length = length;
        this.set = set2;
      }
      /**
      @internal
      */
      get type() {
        return NodeType.none;
      }
      /**
      @internal
      */
      toString() {
        let result = [];
        for (let index2 = 0; index2 < this.buffer.length; ) {
          result.push(this.childString(index2));
          index2 = this.buffer[index2 + 3];
        }
        return result.join(",");
      }
      /**
      @internal
      */
      childString(index2) {
        let id2 = this.buffer[index2], endIndex = this.buffer[index2 + 3];
        let type = this.set.types[id2], result = type.name;
        if (/\W/.test(result) && !type.isError)
          result = JSON.stringify(result);
        index2 += 4;
        if (endIndex == index2)
          return result;
        let children = [];
        while (index2 < endIndex) {
          children.push(this.childString(index2));
          index2 = this.buffer[index2 + 3];
        }
        return result + "(" + children.join(",") + ")";
      }
      /**
      @internal
      */
      findChild(startIndex, endIndex, dir, pos, side) {
        let { buffer } = this, pick = -1;
        for (let i2 = startIndex; i2 != endIndex; i2 = buffer[i2 + 3]) {
          if (checkSide(side, pos, buffer[i2 + 1], buffer[i2 + 2])) {
            pick = i2;
            if (dir > 0)
              break;
          }
        }
        return pick;
      }
      /**
      @internal
      */
      slice(startI, endI, from2) {
        let b = this.buffer;
        let copy2 = new Uint16Array(endI - startI), len = 0;
        for (let i2 = startI, j = 0; i2 < endI; ) {
          copy2[j++] = b[i2++];
          copy2[j++] = b[i2++] - from2;
          let to2 = copy2[j++] = b[i2++] - from2;
          copy2[j++] = b[i2++] - startI;
          len = Math.max(len, to2);
        }
        return new TreeBuffer(copy2, len, this.set);
      }
    }
    function checkSide(side, pos, from2, to2) {
      switch (side) {
        case -2:
          return from2 < pos;
        case -1:
          return to2 >= pos && from2 < pos;
        case 0:
          return from2 < pos && to2 > pos;
        case 1:
          return from2 <= pos && to2 > pos;
        case 2:
          return to2 > pos;
        case 4:
          return true;
      }
    }
    function resolveNode(node, pos, side, overlays) {
      var _a2;
      while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
        if (!parent)
          return node;
        node = parent;
      }
      let mode = overlays ? 0 : IterMode.IgnoreOverlays;
      if (overlays)
        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
          if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
            node = parent;
        }
      for (; ; ) {
        let inner = node.enter(pos, side, mode);
        if (!inner)
          return node;
        node = inner;
      }
    }
    class BaseNode {
      cursor(mode = 0) {
        return new TreeCursor(this, mode);
      }
      getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
      }
      getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
      }
      resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
      }
      resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
      }
      matchContext(context) {
        return matchNodeContext(this.parent, context);
      }
      enterUnfinishedNodesBefore(pos) {
        let scan = this.childBefore(pos), node = this;
        while (scan) {
          let last = scan.lastChild;
          if (!last || last.to != scan.to)
            break;
          if (last.type.isError && last.from == last.to) {
            node = scan;
            scan = last.prevSibling;
          } else {
            scan = last;
          }
        }
        return node;
      }
      get node() {
        return this;
      }
      get next() {
        return this.parent;
      }
    }
    class TreeNode extends BaseNode {
      constructor(_tree, from2, index2, _parent) {
        super();
        this._tree = _tree;
        this.from = from2;
        this.index = index2;
        this._parent = _parent;
      }
      get type() {
        return this._tree.type;
      }
      get name() {
        return this._tree.type.name;
      }
      get to() {
        return this.from + this._tree.length;
      }
      nextChild(i2, dir, pos, side, mode = 0) {
        for (let parent = this; ; ) {
          for (let { children, positions: positions2 } = parent._tree, e = dir > 0 ? children.length : -1; i2 != e; i2 += dir) {
            let next = children[i2], start = positions2[i2] + parent.from;
            if (!checkSide(side, pos, start, start + next.length))
              continue;
            if (next instanceof TreeBuffer) {
              if (mode & IterMode.ExcludeBuffers)
                continue;
              let index2 = next.findChild(0, next.buffer.length, dir, pos - start, side);
              if (index2 > -1)
                return new BufferNode(new BufferContext(parent, next, i2, start), null, index2);
            } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
              let mounted;
              if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
                return new TreeNode(mounted.tree, start, i2, parent);
              let inner = new TreeNode(next, start, i2, parent);
              return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
            }
          }
          if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
            return null;
          if (parent.index >= 0)
            i2 = parent.index + dir;
          else
            i2 = dir < 0 ? -1 : parent._parent._tree.children.length;
          parent = parent._parent;
          if (!parent)
            return null;
        }
      }
      get firstChild() {
        return this.nextChild(
          0,
          1,
          0,
          4
          /* Side.DontCare */
        );
      }
      get lastChild() {
        return this.nextChild(
          this._tree.children.length - 1,
          -1,
          0,
          4
          /* Side.DontCare */
        );
      }
      childAfter(pos) {
        return this.nextChild(
          0,
          1,
          pos,
          2
          /* Side.After */
        );
      }
      childBefore(pos) {
        return this.nextChild(
          this._tree.children.length - 1,
          -1,
          pos,
          -2
          /* Side.Before */
        );
      }
      prop(prop) {
        return this._tree.prop(prop);
      }
      enter(pos, side, mode = 0) {
        let mounted;
        if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
          let rPos = pos - this.from;
          for (let { from: from2, to: to2 } of mounted.overlay) {
            if ((side > 0 ? from2 <= rPos : from2 < rPos) && (side < 0 ? to2 >= rPos : to2 > rPos))
              return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
          }
        }
        return this.nextChild(0, 1, pos, side, mode);
      }
      nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
          val = val._parent;
        return val;
      }
      get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
      }
      get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(
          this.index + 1,
          1,
          0,
          4
          /* Side.DontCare */
        ) : null;
      }
      get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(
          this.index - 1,
          -1,
          0,
          4
          /* Side.DontCare */
        ) : null;
      }
      get tree() {
        return this._tree;
      }
      toTree() {
        return this._tree;
      }
      /**
      @internal
      */
      toString() {
        return this._tree.toString();
      }
    }
    function getChildren(node, type, before, after) {
      let cur2 = node.cursor(), result = [];
      if (!cur2.firstChild())
        return result;
      if (before != null)
        for (let found = false; !found; ) {
          found = cur2.type.is(before);
          if (!cur2.nextSibling())
            return result;
        }
      for (; ; ) {
        if (after != null && cur2.type.is(after))
          return result;
        if (cur2.type.is(type))
          result.push(cur2.node);
        if (!cur2.nextSibling())
          return after == null ? result : [];
      }
    }
    function matchNodeContext(node, context, i2 = context.length - 1) {
      for (let p = node; i2 >= 0; p = p.parent) {
        if (!p)
          return false;
        if (!p.type.isAnonymous) {
          if (context[i2] && context[i2] != p.name)
            return false;
          i2--;
        }
      }
      return true;
    }
    class BufferContext {
      constructor(parent, buffer, index2, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index2;
        this.start = start;
      }
    }
    class BufferNode extends BaseNode {
      get name() {
        return this.type.name;
      }
      get from() {
        return this.context.start + this.context.buffer.buffer[this.index + 1];
      }
      get to() {
        return this.context.start + this.context.buffer.buffer[this.index + 2];
      }
      constructor(context, _parent, index2) {
        super();
        this.context = context;
        this._parent = _parent;
        this.index = index2;
        this.type = context.buffer.set.types[context.buffer.buffer[index2]];
      }
      child(dir, pos, side) {
        let { buffer } = this.context;
        let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
        return index2 < 0 ? null : new BufferNode(this.context, this, index2);
      }
      get firstChild() {
        return this.child(
          1,
          0,
          4
          /* Side.DontCare */
        );
      }
      get lastChild() {
        return this.child(
          -1,
          0,
          4
          /* Side.DontCare */
        );
      }
      childAfter(pos) {
        return this.child(
          1,
          pos,
          2
          /* Side.After */
        );
      }
      childBefore(pos) {
        return this.child(
          -1,
          pos,
          -2
          /* Side.Before */
        );
      }
      prop(prop) {
        return this.type.prop(prop);
      }
      enter(pos, side, mode = 0) {
        if (mode & IterMode.ExcludeBuffers)
          return null;
        let { buffer } = this.context;
        let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
        return index2 < 0 ? null : new BufferNode(this.context, this, index2);
      }
      get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
      }
      externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(
          this.context.index + dir,
          dir,
          0,
          4
          /* Side.DontCare */
        );
      }
      get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
          return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
      }
      get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
          return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(
          parentStart,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
      }
      get tree() {
        return null;
      }
      toTree() {
        let children = [], positions2 = [];
        let { buffer } = this.context;
        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
        if (endI > startI) {
          let from2 = buffer.buffer[this.index + 1];
          children.push(buffer.slice(startI, endI, from2));
          positions2.push(0);
        }
        return new Tree(this.type, children, positions2, this.to - this.from);
      }
      /**
      @internal
      */
      toString() {
        return this.context.buffer.childString(this.index);
      }
    }
    function iterStack(heads) {
      if (!heads.length)
        return null;
      let pick = 0, picked = heads[0];
      for (let i2 = 1; i2 < heads.length; i2++) {
        let node = heads[i2];
        if (node.from > picked.from || node.to < picked.to) {
          picked = node;
          pick = i2;
        }
      }
      let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
      let newHeads = heads.slice();
      if (next)
        newHeads[pick] = next;
      else
        newHeads.splice(pick, 1);
      return new StackIterator(newHeads, picked);
    }
    class StackIterator {
      constructor(heads, node) {
        this.heads = heads;
        this.node = node;
      }
      get next() {
        return iterStack(this.heads);
      }
    }
    function stackIterator(tree, pos, side) {
      let inner = tree.resolveInner(pos, side), layers = null;
      for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
        if (scan.index < 0) {
          let parent = scan.parent;
          (layers || (layers = [inner])).push(parent.resolve(pos, side));
          scan = parent;
        } else {
          let mount = MountedTree.get(scan.tree);
          if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
            let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
            (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
          }
        }
      }
      return layers ? iterStack(layers) : inner;
    }
    class TreeCursor {
      /**
      Shorthand for `.type.name`.
      */
      get name() {
        return this.type.name;
      }
      /**
      @internal
      */
      constructor(node, mode = 0) {
        this.mode = mode;
        this.buffer = null;
        this.stack = [];
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
          this.yieldNode(node);
        } else {
          this._tree = node.context.parent;
          this.buffer = node.context;
          for (let n = node._parent; n; n = n._parent)
            this.stack.unshift(n.index);
          this.bufferNode = node;
          this.yieldBuf(node.index);
        }
      }
      yieldNode(node) {
        if (!node)
          return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
      }
      yieldBuf(index2, type) {
        this.index = index2;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index2]];
        this.from = start + buffer.buffer[index2 + 1];
        this.to = start + buffer.buffer[index2 + 2];
        return true;
      }
      /**
      @internal
      */
      yield(node) {
        if (!node)
          return false;
        if (node instanceof TreeNode) {
          this.buffer = null;
          return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
      }
      /**
      @internal
      */
      toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
      }
      /**
      @internal
      */
      enterChild(dir, pos, side) {
        if (!this.buffer)
          return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
        let { buffer } = this.buffer;
        let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
        if (index2 < 0)
          return false;
        this.stack.push(this.index);
        return this.yieldBuf(index2);
      }
      /**
      Move the cursor to this node's first child. When this returns
      false, the node has no child, and the cursor has not been moved.
      */
      firstChild() {
        return this.enterChild(
          1,
          0,
          4
          /* Side.DontCare */
        );
      }
      /**
      Move the cursor to this node's last child.
      */
      lastChild() {
        return this.enterChild(
          -1,
          0,
          4
          /* Side.DontCare */
        );
      }
      /**
      Move the cursor to the first child that ends after `pos`.
      */
      childAfter(pos) {
        return this.enterChild(
          1,
          pos,
          2
          /* Side.After */
        );
      }
      /**
      Move to the last child that starts before `pos`.
      */
      childBefore(pos) {
        return this.enterChild(
          -1,
          pos,
          -2
          /* Side.Before */
        );
      }
      /**
      Move the cursor to the child around `pos`. If side is -1 the
      child may end at that position, when 1 it may start there. This
      will also enter [overlaid](#common.MountedTree.overlay)
      [mounted](#common.NodeProp^mounted) trees unless `overlays` is
      set to false.
      */
      enter(pos, side, mode = this.mode) {
        if (!this.buffer)
          return this.yield(this._tree.enter(pos, side, mode));
        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
      }
      /**
      Move to the node's parent node, if this isn't the top node.
      */
      parent() {
        if (!this.buffer)
          return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
          return this.yieldBuf(this.stack.pop());
        let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
      }
      /**
      @internal
      */
      sibling(dir) {
        if (!this.buffer)
          return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
          let parentStart = d < 0 ? 0 : this.stack[d] + 4;
          if (this.index != parentStart)
            return this.yieldBuf(buffer.findChild(
              parentStart,
              this.index,
              -1,
              0,
              4
              /* Side.DontCare */
            ));
        } else {
          let after = buffer.buffer[this.index + 3];
          if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
            return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
      }
      /**
      Move to this node's next sibling, if any.
      */
      nextSibling() {
        return this.sibling(1);
      }
      /**
      Move to this node's previous sibling, if any.
      */
      prevSibling() {
        return this.sibling(-1);
      }
      atLastNode(dir) {
        let index2, parent, { buffer } = this;
        if (buffer) {
          if (dir > 0) {
            if (this.index < buffer.buffer.buffer.length)
              return false;
          } else {
            for (let i2 = 0; i2 < this.index; i2++)
              if (buffer.buffer.buffer[i2 + 3] < this.index)
                return false;
          }
          ({ index: index2, parent } = buffer);
        } else {
          ({ index: index2, _parent: parent } = this._tree);
        }
        for (; parent; { index: index2, _parent: parent } = parent) {
          if (index2 > -1)
            for (let i2 = index2 + dir, e = dir < 0 ? -1 : parent._tree.children.length; i2 != e; i2 += dir) {
              let child = parent._tree.children[i2];
              if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
                return false;
            }
        }
        return true;
      }
      move(dir, enter) {
        if (enter && this.enterChild(
          dir,
          0,
          4
          /* Side.DontCare */
        ))
          return true;
        for (; ; ) {
          if (this.sibling(dir))
            return true;
          if (this.atLastNode(dir) || !this.parent())
            return false;
        }
      }
      /**
      Move to the next node in a
      [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
      traversal, going from a node to its first child or, if the
      current node is empty or `enter` is false, its next sibling or
      the next sibling of the first parent node that has one.
      */
      next(enter = true) {
        return this.move(1, enter);
      }
      /**
      Move to the next node in a last-to-first pre-order traversal. A
      node is followed by its last child or, if it has none, its
      previous sibling or the previous sibling of the first parent
      node that has one.
      */
      prev(enter = true) {
        return this.move(-1, enter);
      }
      /**
      Move the cursor to the innermost node that covers `pos`. If
      `side` is -1, it will enter nodes that end at `pos`. If it is 1,
      it will enter nodes that start at `pos`.
      */
      moveTo(pos, side = 0) {
        while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
          if (!this.parent())
            break;
        while (this.enterChild(1, pos, side)) {
        }
        return this;
      }
      /**
      Get a [syntax node](#common.SyntaxNode) at the cursor's current
      position.
      */
      get node() {
        if (!this.buffer)
          return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
          scan: for (let index2 = this.index, d = this.stack.length; d >= 0; ) {
            for (let c = cache; c; c = c._parent)
              if (c.index == index2) {
                if (index2 == this.index)
                  return c;
                result = c;
                depth = d + 1;
                break scan;
              }
            index2 = this.stack[--d];
          }
        }
        for (let i2 = depth; i2 < this.stack.length; i2++)
          result = new BufferNode(this.buffer, result, this.stack[i2]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
      }
      /**
      Get the [tree](#common.Tree) that represents the current node, if
      any. Will return null when the node is in a [tree
      buffer](#common.TreeBuffer).
      */
      get tree() {
        return this.buffer ? null : this._tree._tree;
      }
      /**
      Iterate over the current node and all its descendants, calling
      `enter` when entering a node and `leave`, if given, when leaving
      one. When `enter` returns `false`, any children of that node are
      skipped, and `leave` isn't called for it.
      */
      iterate(enter, leave) {
        for (let depth = 0; ; ) {
          let mustLeave = false;
          if (this.type.isAnonymous || enter(this) !== false) {
            if (this.firstChild()) {
              depth++;
              continue;
            }
            if (!this.type.isAnonymous)
              mustLeave = true;
          }
          for (; ; ) {
            if (mustLeave && leave)
              leave(this);
            mustLeave = this.type.isAnonymous;
            if (!depth)
              return;
            if (this.nextSibling())
              break;
            this.parent();
            depth--;
            mustLeave = true;
          }
        }
      }
      /**
      Test whether the current node matches a given contexta sequence
      of direct parent node names. Empty strings in the context array
      are treated as wildcards.
      */
      matchContext(context) {
        if (!this.buffer)
          return matchNodeContext(this.node.parent, context);
        let { buffer } = this.buffer, { types: types2 } = buffer.set;
        for (let i2 = context.length - 1, d = this.stack.length - 1; i2 >= 0; d--) {
          if (d < 0)
            return matchNodeContext(this._tree, context, i2);
          let type = types2[buffer.buffer[this.stack[d]]];
          if (!type.isAnonymous) {
            if (context[i2] && context[i2] != type.name)
              return false;
            i2--;
          }
        }
        return true;
      }
    }
    function hasChild(tree) {
      return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
    }
    function buildTree(data) {
      var _a2;
      let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
      let cursor2 = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
      let types2 = nodeSet.types;
      let contextHash = 0, lookAhead = 0;
      function takeNode(parentStart, minPos, children2, positions3, inRepeat, depth) {
        let { id: id2, start, end, size } = cursor2;
        let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
        if (size < 0) {
          cursor2.next();
          if (size == -1) {
            let node2 = reused[id2];
            children2.push(node2);
            positions3.push(start - parentStart);
            return;
          } else if (size == -3) {
            contextHash = id2;
            return;
          } else if (size == -4) {
            lookAhead = id2;
            return;
          } else {
            throw new RangeError(`Unrecognized record size: ${size}`);
          }
        }
        let type = types2[id2], node, buffer2;
        let startPos = start - parentStart;
        if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor2.pos - minPos, inRepeat))) {
          let data2 = new Uint16Array(buffer2.size - buffer2.skip);
          let endPos = cursor2.pos - buffer2.size, index2 = data2.length;
          while (cursor2.pos > endPos)
            index2 = copyToBuffer(buffer2.start, data2, index2);
          node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
          startPos = buffer2.start - parentStart;
        } else {
          let endPos = cursor2.pos - size;
          cursor2.next();
          let localChildren = [], localPositions = [];
          let localInRepeat = id2 >= minRepeatType ? id2 : -1;
          let lastGroup = 0, lastEnd = end;
          while (cursor2.pos > endPos) {
            if (localInRepeat >= 0 && cursor2.id == localInRepeat && cursor2.size >= 0) {
              if (cursor2.end <= lastEnd - maxBufferLength) {
                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor2.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
                lastGroup = localChildren.length;
                lastEnd = cursor2.end;
              }
              cursor2.next();
            } else if (depth > 2500) {
              takeFlatNode(start, endPos, localChildren, localPositions);
            } else {
              takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
            }
          }
          if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
          localChildren.reverse();
          localPositions.reverse();
          if (localInRepeat > -1 && lastGroup > 0) {
            let make = makeBalanced(type, contextAtStart);
            node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
          } else {
            node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
          }
        }
        children2.push(node);
        positions3.push(startPos);
      }
      function takeFlatNode(parentStart, minPos, children2, positions3) {
        let nodes = [];
        let nodeCount = 0, stopAt = -1;
        while (cursor2.pos > minPos) {
          let { id: id2, start, end, size } = cursor2;
          if (size > 4) {
            cursor2.next();
          } else if (stopAt > -1 && start < stopAt) {
            break;
          } else {
            if (stopAt < 0)
              stopAt = end - maxBufferLength;
            nodes.push(id2, start, end);
            nodeCount++;
            cursor2.next();
          }
        }
        if (nodeCount) {
          let buffer2 = new Uint16Array(nodeCount * 4);
          let start = nodes[nodes.length - 2];
          for (let i2 = nodes.length - 3, j = 0; i2 >= 0; i2 -= 3) {
            buffer2[j++] = nodes[i2];
            buffer2[j++] = nodes[i2 + 1] - start;
            buffer2[j++] = nodes[i2 + 2] - start;
            buffer2[j++] = j;
          }
          children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet));
          positions3.push(start - parentStart);
        }
      }
      function makeBalanced(type, contextHash2) {
        return (children2, positions3, length2) => {
          let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
          if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
            if (!lastI && last.type == type && last.length == length2)
              return last;
            if (lookAheadProp = last.prop(NodeProp.lookAhead))
              lookAhead2 = positions3[lastI] + last.length + lookAheadProp;
          }
          return makeTree(type, children2, positions3, length2, lookAhead2, contextHash2);
        };
      }
      function makeRepeatLeaf(children2, positions3, base2, i2, from2, to2, type, lookAhead2, contextHash2) {
        let localChildren = [], localPositions = [];
        while (children2.length > i2) {
          localChildren.push(children2.pop());
          localPositions.push(positions3.pop() + base2 - from2);
        }
        children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to2 - from2, lookAhead2 - to2, contextHash2));
        positions3.push(from2 - base2);
      }
      function makeTree(type, children2, positions3, length2, lookAhead2, contextHash2, props) {
        if (contextHash2) {
          let pair2 = [NodeProp.contextHash, contextHash2];
          props = props ? [pair2].concat(props) : [pair2];
        }
        if (lookAhead2 > 25) {
          let pair2 = [NodeProp.lookAhead, lookAhead2];
          props = props ? [pair2].concat(props) : [pair2];
        }
        return new Tree(type, children2, positions3, length2, props);
      }
      function findBufferSize(maxSize, inRepeat) {
        let fork = cursor2.fork();
        let size = 0, start = 0, skip2 = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
          let nodeSize2 = fork.size;
          if (fork.id == inRepeat && nodeSize2 >= 0) {
            result.size = size;
            result.start = start;
            result.skip = skip2;
            skip2 += 4;
            size += 4;
            fork.next();
            continue;
          }
          let startPos = fork.pos - nodeSize2;
          if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
            break;
          let localSkipped = fork.id >= minRepeatType ? 4 : 0;
          let nodeStart2 = fork.start;
          fork.next();
          while (fork.pos > startPos) {
            if (fork.size < 0) {
              if (fork.size == -3 || fork.size == -4)
                localSkipped += 4;
              else
                break scan;
            } else if (fork.id >= minRepeatType) {
              localSkipped += 4;
            }
            fork.next();
          }
          start = nodeStart2;
          size += nodeSize2;
          skip2 += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
          result.size = size;
          result.start = start;
          result.skip = skip2;
        }
        return result.size > 4 ? result : void 0;
      }
      function copyToBuffer(bufferStart, buffer2, index2) {
        let { id: id2, start, end, size } = cursor2;
        cursor2.next();
        if (size >= 0 && id2 < minRepeatType) {
          let startIndex = index2;
          if (size > 4) {
            let endPos = cursor2.pos - (size - 4);
            while (cursor2.pos > endPos)
              index2 = copyToBuffer(bufferStart, buffer2, index2);
          }
          buffer2[--index2] = startIndex;
          buffer2[--index2] = end - bufferStart;
          buffer2[--index2] = start - bufferStart;
          buffer2[--index2] = id2;
        } else if (size == -3) {
          contextHash = id2;
        } else if (size == -4) {
          lookAhead = id2;
        }
        return index2;
      }
      let children = [], positions2 = [];
      while (cursor2.pos > 0)
        takeNode(data.start || 0, data.bufferStart || 0, children, positions2, -1, 0);
      let length = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions2[0] + children[0].length : 0;
      return new Tree(types2[data.topID], children.reverse(), positions2.reverse(), length);
    }
    const nodeSizeCache = /* @__PURE__ */ new WeakMap();
    function nodeSize(balanceType, node) {
      if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
        return 1;
      let size = nodeSizeCache.get(node);
      if (size == null) {
        size = 1;
        for (let child of node.children) {
          if (child.type != balanceType || !(child instanceof Tree)) {
            size = 1;
            break;
          }
          size += nodeSize(balanceType, child);
        }
        nodeSizeCache.set(node, size);
      }
      return size;
    }
    function balanceRange(balanceType, children, positions2, from2, to2, start, length, mkTop, mkTree) {
      let total = 0;
      for (let i2 = from2; i2 < to2; i2++)
        total += nodeSize(balanceType, children[i2]);
      let maxChild = Math.ceil(
        total * 1.5 / 8
        /* Balance.BranchFactor */
      );
      let localChildren = [], localPositions = [];
      function divide(children2, positions3, from3, to3, offset) {
        for (let i2 = from3; i2 < to3; ) {
          let groupFrom = i2, groupStart = positions3[i2], groupSize = nodeSize(balanceType, children2[i2]);
          i2++;
          for (; i2 < to3; i2++) {
            let nextSize = nodeSize(balanceType, children2[i2]);
            if (groupSize + nextSize >= maxChild)
              break;
            groupSize += nextSize;
          }
          if (i2 == groupFrom + 1) {
            if (groupSize > maxChild) {
              let only = children2[groupFrom];
              divide(only.children, only.positions, 0, only.children.length, positions3[groupFrom] + offset);
              continue;
            }
            localChildren.push(children2[groupFrom]);
          } else {
            let length2 = positions3[i2 - 1] + children2[i2 - 1].length - groupStart;
            localChildren.push(balanceRange(balanceType, children2, positions3, groupFrom, i2, groupStart, length2, null, mkTree));
          }
          localPositions.push(groupStart + offset - start);
        }
      }
      divide(children, positions2, from2, to2, 0);
      return (mkTop || mkTree)(localChildren, localPositions, length);
    }
    class TreeFragment {
      /**
      Construct a tree fragment. You'll usually want to use
      [`addTree`](#common.TreeFragment^addTree) and
      [`applyChanges`](#common.TreeFragment^applyChanges) instead of
      calling this directly.
      */
      constructor(from2, to2, tree, offset, openStart = false, openEnd = false) {
        this.from = from2;
        this.to = to2;
        this.tree = tree;
        this.offset = offset;
        this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
      }
      /**
      Whether the start of the fragment represents the start of a
      parse, or the end of a change. (In the second case, it may not
      be safe to reuse some nodes at the start, depending on the
      parsing algorithm.)
      */
      get openStart() {
        return (this.open & 1) > 0;
      }
      /**
      Whether the end of the fragment represents the end of a
      full-document parse, or the start of a change.
      */
      get openEnd() {
        return (this.open & 2) > 0;
      }
      /**
      Create a set of fragments from a freshly parsed tree, or update
      an existing set of fragments by replacing the ones that overlap
      with a tree with content from the new tree. When `partial` is
      true, the parse is treated as incomplete, and the resulting
      fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
      true.
      */
      static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
        for (let f of fragments)
          if (f.to > tree.length)
            result.push(f);
        return result;
      }
      /**
      Apply a set of edits to an array of fragments, removing or
      splitting fragments as necessary to remove edited ranges, and
      adjusting offsets for fragments that moved.
      */
      static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
          return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        for (let cI = 0, pos = 0, off = 0; ; cI++) {
          let nextC = cI < changes.length ? changes[cI] : null;
          let nextPos = nextC ? nextC.fromA : 1e9;
          if (nextPos - pos >= minGap)
            while (nextF && nextF.from < nextPos) {
              let cut = nextF;
              if (pos >= cut.from || nextPos <= cut.to || off) {
                let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
              }
              if (cut)
                result.push(cut);
              if (nextF.to > nextPos)
                break;
              nextF = fI < fragments.length ? fragments[fI++] : null;
            }
          if (!nextC)
            break;
          pos = nextC.toA;
          off = nextC.toA - nextC.toB;
        }
        return result;
      }
    }
    class Parser {
      /**
      Start a parse, returning a [partial parse](#common.PartialParse)
      object. [`fragments`](#common.TreeFragment) can be passed in to
      make the parse incremental.
      
      By default, the entire input is parsed. You can pass `ranges`,
      which should be a sorted array of non-empty, non-overlapping
      ranges, to parse only those ranges. The tree returned in that
      case will start at `ranges[0].from`.
      */
      startParse(input, fragments, ranges) {
        if (typeof input == "string")
          input = new StringInput(input);
        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map((r) => new Range(r.from, r.to)) : [new Range(0, 0)];
        return this.createParse(input, fragments || [], ranges);
      }
      /**
      Run a full parse, returning the resulting tree.
      */
      parse(input, fragments, ranges) {
        let parse2 = this.startParse(input, fragments, ranges);
        for (; ; ) {
          let done = parse2.advance();
          if (done)
            return done;
        }
      }
    }
    class StringInput {
      constructor(string2) {
        this.string = string2;
      }
      get length() {
        return this.string.length;
      }
      chunk(from2) {
        return this.string.slice(from2);
      }
      get lineChunks() {
        return false;
      }
      read(from2, to2) {
        return this.string.slice(from2, to2);
      }
    }
    new NodeProp({ perNode: true });
    let nextTagID = 0;
    let Tag$1 = class Tag2 {
      /**
      @internal
      */
      constructor(name2, set2, base2, modified2) {
        this.name = name2;
        this.set = set2;
        this.base = base2;
        this.modified = modified2;
        this.id = nextTagID++;
      }
      toString() {
        let { name: name2 } = this;
        for (let mod of this.modified)
          if (mod.name)
            name2 = `${mod.name}(${name2})`;
        return name2;
      }
      static define(nameOrParent, parent) {
        let name2 = typeof nameOrParent == "string" ? nameOrParent : "?";
        if (nameOrParent instanceof Tag2)
          parent = nameOrParent;
        if (parent === null || parent === void 0 ? void 0 : parent.base)
          throw new Error("Can not derive from a modified tag");
        let tag = new Tag2(name2, [], null, []);
        tag.set.push(tag);
        if (parent)
          for (let t2 of parent.set)
            tag.set.push(t2);
        return tag;
      }
      /**
      Define a tag _modifier_, which is a function that, given a tag,
      will return a tag that is a subtag of the original. Applying the
      same modifier to a twice tag will return the same value (`m1(t1)
      == m1(t1)`) and applying multiple modifiers will, regardless or
      order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
      
      When multiple modifiers are applied to a given base tag, each
      smaller set of modifiers is registered as a parent, so that for
      example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
      `m1(m3(t1)`, and so on.
      */
      static defineModifier(name2) {
        let mod = new Modifier(name2);
        return (tag) => {
          if (tag.modified.indexOf(mod) > -1)
            return tag;
          return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
        };
      }
    };
    let nextModifierID = 0;
    class Modifier {
      constructor(name2) {
        this.name = name2;
        this.instances = [];
        this.id = nextModifierID++;
      }
      static get(base2, mods) {
        if (!mods.length)
          return base2;
        let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray(mods, t2.modified));
        if (exists)
          return exists;
        let set2 = [], tag = new Tag$1(base2.name, set2, base2, mods);
        for (let m of mods)
          m.instances.push(tag);
        let configs = powerSet(mods);
        for (let parent of base2.set)
          if (!parent.modified.length)
            for (let config2 of configs)
              set2.push(Modifier.get(parent, config2));
        return tag;
      }
    }
    function sameArray(a, b) {
      return a.length == b.length && a.every((x, i2) => x == b[i2]);
    }
    function powerSet(array) {
      let sets = [[]];
      for (let i2 = 0; i2 < array.length; i2++) {
        for (let j = 0, e = sets.length; j < e; j++) {
          sets.push(sets[j].concat(array[i2]));
        }
      }
      return sets.sort((a, b) => b.length - a.length);
    }
    function styleTags(spec) {
      let byName = /* @__PURE__ */ Object.create(null);
      for (let prop in spec) {
        let tags2 = spec[prop];
        if (!Array.isArray(tags2))
          tags2 = [tags2];
        for (let part of prop.split(" "))
          if (part) {
            let pieces = [], mode = 2, rest = part;
            for (let pos = 0; ; ) {
              if (rest == "..." && pos > 0 && pos + 3 == part.length) {
                mode = 1;
                break;
              }
              let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
              if (!m)
                throw new RangeError("Invalid path: " + part);
              pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
              pos += m[0].length;
              if (pos == part.length)
                break;
              let next = part[pos++];
              if (pos == part.length && next == "!") {
                mode = 0;
                break;
              }
              if (next != "/")
                throw new RangeError("Invalid path: " + part);
              rest = part.slice(pos);
            }
            let last = pieces.length - 1, inner = pieces[last];
            if (!inner)
              throw new RangeError("Invalid path: " + part);
            let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
            byName[inner] = rule.sort(byName[inner]);
          }
      }
      return ruleNodeProp.add(byName);
    }
    const ruleNodeProp = new NodeProp({
      combine(a, b) {
        let cur2, root, take;
        while (a || b) {
          if (!a || b && a.depth >= b.depth) {
            take = b;
            b = b.next;
          } else {
            take = a;
            a = a.next;
          }
          if (cur2 && cur2.mode == take.mode && !take.context && !cur2.context)
            continue;
          let copy2 = new Rule(take.tags, take.mode, take.context);
          if (cur2)
            cur2.next = copy2;
          else
            root = copy2;
          cur2 = copy2;
        }
        return root;
      }
    });
    class Rule {
      constructor(tags2, mode, context, next) {
        this.tags = tags2;
        this.mode = mode;
        this.context = context;
        this.next = next;
      }
      get opaque() {
        return this.mode == 0;
      }
      get inherit() {
        return this.mode == 1;
      }
      sort(other) {
        if (!other || other.depth < this.depth) {
          this.next = other;
          return this;
        }
        other.next = this.sort(other.next);
        return other;
      }
      get depth() {
        return this.context ? this.context.length : 0;
      }
    }
    Rule.empty = new Rule([], 2, null);
    function tagHighlighter(tags2, options) {
      let map2 = /* @__PURE__ */ Object.create(null);
      for (let style of tags2) {
        if (!Array.isArray(style.tag))
          map2[style.tag.id] = style.class;
        else
          for (let tag of style.tag)
            map2[tag.id] = style.class;
      }
      let { scope, all: all2 = null } = options || {};
      return {
        style: (tags3) => {
          let cls = all2;
          for (let tag of tags3) {
            for (let sub of tag.set) {
              let tagClass = map2[sub.id];
              if (tagClass) {
                cls = cls ? cls + " " + tagClass : tagClass;
                break;
              }
            }
          }
          return cls;
        },
        scope
      };
    }
    function highlightTags(highlighters, tags2) {
      let result = null;
      for (let highlighter of highlighters) {
        let value = highlighter.style(tags2);
        if (value)
          result = result ? result + " " + value : value;
      }
      return result;
    }
    function highlightTree(tree, highlighter, putStyle, from2 = 0, to2 = tree.length) {
      let builder = new HighlightBuilder(from2, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
      builder.highlightRange(tree.cursor(), from2, to2, "", builder.highlighters);
      builder.flush(to2);
    }
    class HighlightBuilder {
      constructor(at, highlighters, span) {
        this.at = at;
        this.highlighters = highlighters;
        this.span = span;
        this.class = "";
      }
      startSpan(at, cls) {
        if (cls != this.class) {
          this.flush(at);
          if (at > this.at)
            this.at = at;
          this.class = cls;
        }
      }
      flush(to2) {
        if (to2 > this.at && this.class)
          this.span(this.at, to2, this.class);
      }
      highlightRange(cursor2, from2, to2, inheritedClass, highlighters) {
        let { type, from: start, to: end } = cursor2;
        if (start >= to2 || end <= from2)
          return;
        if (type.isTop)
          highlighters = this.highlighters.filter((h) => !h.scope || h.scope(type));
        let cls = inheritedClass;
        let rule = getStyleTags(cursor2) || Rule.empty;
        let tagCls = highlightTags(highlighters, rule.tags);
        if (tagCls) {
          if (cls)
            cls += " ";
          cls += tagCls;
          if (rule.mode == 1)
            inheritedClass += (inheritedClass ? " " : "") + tagCls;
        }
        this.startSpan(Math.max(from2, start), cls);
        if (rule.opaque)
          return;
        let mounted = cursor2.tree && cursor2.tree.prop(NodeProp.mounted);
        if (mounted && mounted.overlay) {
          let inner = cursor2.node.enter(mounted.overlay[0].from + start, 1);
          let innerHighlighters = this.highlighters.filter((h) => !h.scope || h.scope(mounted.tree.type));
          let hasChild2 = cursor2.firstChild();
          for (let i2 = 0, pos = start; ; i2++) {
            let next = i2 < mounted.overlay.length ? mounted.overlay[i2] : null;
            let nextPos = next ? next.from + start : end;
            let rangeFrom2 = Math.max(from2, pos), rangeTo2 = Math.min(to2, nextPos);
            if (rangeFrom2 < rangeTo2 && hasChild2) {
              while (cursor2.from < rangeTo2) {
                this.highlightRange(cursor2, rangeFrom2, rangeTo2, inheritedClass, highlighters);
                this.startSpan(Math.min(rangeTo2, cursor2.to), cls);
                if (cursor2.to >= nextPos || !cursor2.nextSibling())
                  break;
              }
            }
            if (!next || nextPos > to2)
              break;
            pos = next.to + start;
            if (pos > from2) {
              this.highlightRange(inner.cursor(), Math.max(from2, next.from + start), Math.min(to2, pos), "", innerHighlighters);
              this.startSpan(Math.min(to2, pos), cls);
            }
          }
          if (hasChild2)
            cursor2.parent();
        } else if (cursor2.firstChild()) {
          if (mounted)
            inheritedClass = "";
          do {
            if (cursor2.to <= from2)
              continue;
            if (cursor2.from >= to2)
              break;
            this.highlightRange(cursor2, from2, to2, inheritedClass, highlighters);
            this.startSpan(Math.min(to2, cursor2.to), cls);
          } while (cursor2.nextSibling());
          cursor2.parent();
        }
      }
    }
    function getStyleTags(node) {
      let rule = node.type.prop(ruleNodeProp);
      while (rule && rule.context && !node.matchContext(rule.context))
        rule = rule.next;
      return rule || null;
    }
    const t = Tag$1.define;
    const comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content$3 = t(), heading = t(content$3), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();
    const tags = {
      /**
      A comment.
      */
      comment,
      /**
      A line [comment](#highlight.tags.comment).
      */
      lineComment: t(comment),
      /**
      A block [comment](#highlight.tags.comment).
      */
      blockComment: t(comment),
      /**
      A documentation [comment](#highlight.tags.comment).
      */
      docComment: t(comment),
      /**
      Any kind of identifier.
      */
      name,
      /**
      The [name](#highlight.tags.name) of a variable.
      */
      variableName: t(name),
      /**
      A type [name](#highlight.tags.name).
      */
      typeName,
      /**
      A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
      */
      tagName: t(typeName),
      /**
      A property or field [name](#highlight.tags.name).
      */
      propertyName,
      /**
      An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
      */
      attributeName: t(propertyName),
      /**
      The [name](#highlight.tags.name) of a class.
      */
      className: t(name),
      /**
      A label [name](#highlight.tags.name).
      */
      labelName: t(name),
      /**
      A namespace [name](#highlight.tags.name).
      */
      namespace: t(name),
      /**
      The [name](#highlight.tags.name) of a macro.
      */
      macroName: t(name),
      /**
      A literal value.
      */
      literal,
      /**
      A string [literal](#highlight.tags.literal).
      */
      string,
      /**
      A documentation [string](#highlight.tags.string).
      */
      docString: t(string),
      /**
      A character literal (subtag of [string](#highlight.tags.string)).
      */
      character: t(string),
      /**
      An attribute value (subtag of [string](#highlight.tags.string)).
      */
      attributeValue: t(string),
      /**
      A number [literal](#highlight.tags.literal).
      */
      number,
      /**
      An integer [number](#highlight.tags.number) literal.
      */
      integer: t(number),
      /**
      A floating-point [number](#highlight.tags.number) literal.
      */
      float: t(number),
      /**
      A boolean [literal](#highlight.tags.literal).
      */
      bool: t(literal),
      /**
      Regular expression [literal](#highlight.tags.literal).
      */
      regexp: t(literal),
      /**
      An escape [literal](#highlight.tags.literal), for example a
      backslash escape in a string.
      */
      escape: t(literal),
      /**
      A color [literal](#highlight.tags.literal).
      */
      color: t(literal),
      /**
      A URL [literal](#highlight.tags.literal).
      */
      url: t(literal),
      /**
      A language keyword.
      */
      keyword,
      /**
      The [keyword](#highlight.tags.keyword) for the self or this
      object.
      */
      self: t(keyword),
      /**
      The [keyword](#highlight.tags.keyword) for null.
      */
      null: t(keyword),
      /**
      A [keyword](#highlight.tags.keyword) denoting some atomic value.
      */
      atom: t(keyword),
      /**
      A [keyword](#highlight.tags.keyword) that represents a unit.
      */
      unit: t(keyword),
      /**
      A modifier [keyword](#highlight.tags.keyword).
      */
      modifier: t(keyword),
      /**
      A [keyword](#highlight.tags.keyword) that acts as an operator.
      */
      operatorKeyword: t(keyword),
      /**
      A control-flow related [keyword](#highlight.tags.keyword).
      */
      controlKeyword: t(keyword),
      /**
      A [keyword](#highlight.tags.keyword) that defines something.
      */
      definitionKeyword: t(keyword),
      /**
      A [keyword](#highlight.tags.keyword) related to defining or
      interfacing with modules.
      */
      moduleKeyword: t(keyword),
      /**
      An operator.
      */
      operator,
      /**
      An [operator](#highlight.tags.operator) that dereferences something.
      */
      derefOperator: t(operator),
      /**
      Arithmetic-related [operator](#highlight.tags.operator).
      */
      arithmeticOperator: t(operator),
      /**
      Logical [operator](#highlight.tags.operator).
      */
      logicOperator: t(operator),
      /**
      Bit [operator](#highlight.tags.operator).
      */
      bitwiseOperator: t(operator),
      /**
      Comparison [operator](#highlight.tags.operator).
      */
      compareOperator: t(operator),
      /**
      [Operator](#highlight.tags.operator) that updates its operand.
      */
      updateOperator: t(operator),
      /**
      [Operator](#highlight.tags.operator) that defines something.
      */
      definitionOperator: t(operator),
      /**
      Type-related [operator](#highlight.tags.operator).
      */
      typeOperator: t(operator),
      /**
      Control-flow [operator](#highlight.tags.operator).
      */
      controlOperator: t(operator),
      /**
      Program or markup punctuation.
      */
      punctuation,
      /**
      [Punctuation](#highlight.tags.punctuation) that separates
      things.
      */
      separator: t(punctuation),
      /**
      Bracket-style [punctuation](#highlight.tags.punctuation).
      */
      bracket,
      /**
      Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
      tokens).
      */
      angleBracket: t(bracket),
      /**
      Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
      tokens).
      */
      squareBracket: t(bracket),
      /**
      Parentheses (usually `(` and `)` tokens). Subtag of
      [bracket](#highlight.tags.bracket).
      */
      paren: t(bracket),
      /**
      Braces (usually `{` and `}` tokens). Subtag of
      [bracket](#highlight.tags.bracket).
      */
      brace: t(bracket),
      /**
      Content, for example plain text in XML or markup documents.
      */
      content: content$3,
      /**
      [Content](#highlight.tags.content) that represents a heading.
      */
      heading,
      /**
      A level 1 [heading](#highlight.tags.heading).
      */
      heading1: t(heading),
      /**
      A level 2 [heading](#highlight.tags.heading).
      */
      heading2: t(heading),
      /**
      A level 3 [heading](#highlight.tags.heading).
      */
      heading3: t(heading),
      /**
      A level 4 [heading](#highlight.tags.heading).
      */
      heading4: t(heading),
      /**
      A level 5 [heading](#highlight.tags.heading).
      */
      heading5: t(heading),
      /**
      A level 6 [heading](#highlight.tags.heading).
      */
      heading6: t(heading),
      /**
      A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
      */
      contentSeparator: t(content$3),
      /**
      [Content](#highlight.tags.content) that represents a list.
      */
      list: t(content$3),
      /**
      [Content](#highlight.tags.content) that represents a quote.
      */
      quote: t(content$3),
      /**
      [Content](#highlight.tags.content) that is emphasized.
      */
      emphasis: t(content$3),
      /**
      [Content](#highlight.tags.content) that is styled strong.
      */
      strong: t(content$3),
      /**
      [Content](#highlight.tags.content) that is part of a link.
      */
      link: t(content$3),
      /**
      [Content](#highlight.tags.content) that is styled as code or
      monospace.
      */
      monospace: t(content$3),
      /**
      [Content](#highlight.tags.content) that has a strike-through
      style.
      */
      strikethrough: t(content$3),
      /**
      Inserted text in a change-tracking format.
      */
      inserted: t(),
      /**
      Deleted text.
      */
      deleted: t(),
      /**
      Changed text.
      */
      changed: t(),
      /**
      An invalid or unsyntactic element.
      */
      invalid: t(),
      /**
      Metadata or meta-instruction.
      */
      meta,
      /**
      [Metadata](#highlight.tags.meta) that applies to the entire
      document.
      */
      documentMeta: t(meta),
      /**
      [Metadata](#highlight.tags.meta) that annotates or adds
      attributes to a given syntactic element.
      */
      annotation: t(meta),
      /**
      Processing instruction or preprocessor directive. Subtag of
      [meta](#highlight.tags.meta).
      */
      processingInstruction: t(meta),
      /**
      [Modifier](#highlight.Tag^defineModifier) that indicates that a
      given element is being defined. Expected to be used with the
      various [name](#highlight.tags.name) tags.
      */
      definition: Tag$1.defineModifier("definition"),
      /**
      [Modifier](#highlight.Tag^defineModifier) that indicates that
      something is constant. Mostly expected to be used with
      [variable names](#highlight.tags.variableName).
      */
      constant: Tag$1.defineModifier("constant"),
      /**
      [Modifier](#highlight.Tag^defineModifier) used to indicate that
      a [variable](#highlight.tags.variableName) or [property
      name](#highlight.tags.propertyName) is being called or defined
      as a function.
      */
      function: Tag$1.defineModifier("function"),
      /**
      [Modifier](#highlight.Tag^defineModifier) that can be applied to
      [names](#highlight.tags.name) to indicate that they belong to
      the language's standard environment.
      */
      standard: Tag$1.defineModifier("standard"),
      /**
      [Modifier](#highlight.Tag^defineModifier) that indicates a given
      [names](#highlight.tags.name) is local to some scope.
      */
      local: Tag$1.defineModifier("local"),
      /**
      A generic variant [modifier](#highlight.Tag^defineModifier) that
      can be used to tag language-specific alternative variants of
      some common tag. It is recommended for themes to define special
      forms of at least the [string](#highlight.tags.string) and
      [variable name](#highlight.tags.variableName) tags, since those
      come up a lot.
      */
      special: Tag$1.defineModifier("special")
    };
    for (let name2 in tags) {
      let val = tags[name2];
      if (val instanceof Tag$1)
        val.name = name2;
    }
    tagHighlighter([
      { tag: tags.link, class: "tok-link" },
      { tag: tags.heading, class: "tok-heading" },
      { tag: tags.emphasis, class: "tok-emphasis" },
      { tag: tags.strong, class: "tok-strong" },
      { tag: tags.keyword, class: "tok-keyword" },
      { tag: tags.atom, class: "tok-atom" },
      { tag: tags.bool, class: "tok-bool" },
      { tag: tags.url, class: "tok-url" },
      { tag: tags.labelName, class: "tok-labelName" },
      { tag: tags.inserted, class: "tok-inserted" },
      { tag: tags.deleted, class: "tok-deleted" },
      { tag: tags.literal, class: "tok-literal" },
      { tag: tags.string, class: "tok-string" },
      { tag: tags.number, class: "tok-number" },
      { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
      { tag: tags.variableName, class: "tok-variableName" },
      { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
      { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
      { tag: tags.special(tags.variableName), class: "tok-variableName2" },
      { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
      { tag: tags.typeName, class: "tok-typeName" },
      { tag: tags.namespace, class: "tok-namespace" },
      { tag: tags.className, class: "tok-className" },
      { tag: tags.macroName, class: "tok-macroName" },
      { tag: tags.propertyName, class: "tok-propertyName" },
      { tag: tags.operator, class: "tok-operator" },
      { tag: tags.comment, class: "tok-comment" },
      { tag: tags.meta, class: "tok-meta" },
      { tag: tags.invalid, class: "tok-invalid" },
      { tag: tags.punctuation, class: "tok-punctuation" }
    ]);
    var _a;
    const languageDataProp = /* @__PURE__ */ new NodeProp();
    function defineLanguageFacet(baseData) {
      return Facet.define({
        combine: baseData ? (values) => values.concat(baseData) : void 0
      });
    }
    const sublanguageProp = /* @__PURE__ */ new NodeProp();
    class Language {
      /**
      Construct a language object. If you need to invoke this
      directly, first define a data facet with
      [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
      configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
      to the language's outer syntax node.
      */
      constructor(data, parser2, extraExtensions = [], name2 = "") {
        this.data = data;
        this.name = name2;
        if (!EditorState.prototype.hasOwnProperty("tree"))
          Object.defineProperty(EditorState.prototype, "tree", { get() {
            return syntaxTree(this);
          } });
        this.parser = parser2;
        this.extension = [
          language.of(this),
          EditorState.languageData.of((state, pos, side) => {
            let top2 = topNodeAt(state, pos, side), data2 = top2.type.prop(languageDataProp);
            if (!data2)
              return [];
            let base2 = state.facet(data2), sub = top2.type.prop(sublanguageProp);
            if (sub) {
              let innerNode = top2.resolve(pos - top2.from, side);
              for (let sublang of sub)
                if (sublang.test(innerNode, state)) {
                  let data3 = state.facet(sublang.facet);
                  return sublang.type == "replace" ? data3 : data3.concat(base2);
                }
            }
            return base2;
          })
        ].concat(extraExtensions);
      }
      /**
      Query whether this language is active at the given position.
      */
      isActiveAt(state, pos, side = -1) {
        return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
      }
      /**
      Find the document regions that were parsed using this language.
      The returned regions will _include_ any nested languages rooted
      in this language, when those exist.
      */
      findRegions(state) {
        let lang = state.facet(language);
        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
          return [{ from: 0, to: state.doc.length }];
        if (!lang || !lang.allowsNesting)
          return [];
        let result = [];
        let explore = (tree, from2) => {
          if (tree.prop(languageDataProp) == this.data) {
            result.push({ from: from2, to: from2 + tree.length });
            return;
          }
          let mount = tree.prop(NodeProp.mounted);
          if (mount) {
            if (mount.tree.prop(languageDataProp) == this.data) {
              if (mount.overlay)
                for (let r of mount.overlay)
                  result.push({ from: r.from + from2, to: r.to + from2 });
              else
                result.push({ from: from2, to: from2 + tree.length });
              return;
            } else if (mount.overlay) {
              let size = result.length;
              explore(mount.tree, mount.overlay[0].from + from2);
              if (result.length > size)
                return;
            }
          }
          for (let i2 = 0; i2 < tree.children.length; i2++) {
            let ch = tree.children[i2];
            if (ch instanceof Tree)
              explore(ch, tree.positions[i2] + from2);
          }
        };
        explore(syntaxTree(state), 0);
        return result;
      }
      /**
      Indicates whether this language allows nested languages. The
      default implementation returns true.
      */
      get allowsNesting() {
        return true;
      }
    }
    Language.setState = /* @__PURE__ */ StateEffect.define();
    function topNodeAt(state, pos, side) {
      let topLang = state.facet(language), tree = syntaxTree(state).topNode;
      if (!topLang || topLang.allowsNesting) {
        for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
          if (node.type.isTop)
            tree = node;
      }
      return tree;
    }
    class LRLanguage extends Language {
      constructor(data, parser2, name2) {
        super(data, parser2, [], name2);
        this.parser = parser2;
      }
      /**
      Define a language from a parser.
      */
      static define(spec) {
        let data = defineLanguageFacet(spec.languageData);
        return new LRLanguage(data, spec.parser.configure({
          props: [languageDataProp.add((type) => type.isTop ? data : void 0)]
        }), spec.name);
      }
      /**
      Create a new instance of this language with a reconfigured
      version of its parser and optionally a new name.
      */
      configure(options, name2) {
        return new LRLanguage(this.data, this.parser.configure(options), name2 || this.name);
      }
      get allowsNesting() {
        return this.parser.hasWrappers();
      }
    }
    function syntaxTree(state) {
      let field = state.field(Language.state, false);
      return field ? field.tree : Tree.empty;
    }
    class DocInput {
      /**
      Create an input object for the given document.
      */
      constructor(doc2) {
        this.doc = doc2;
        this.cursorPos = 0;
        this.string = "";
        this.cursor = doc2.iter();
      }
      get length() {
        return this.doc.length;
      }
      syncTo(pos) {
        this.string = this.cursor.next(pos - this.cursorPos).value;
        this.cursorPos = pos + this.string.length;
        return this.cursorPos - this.string.length;
      }
      chunk(pos) {
        this.syncTo(pos);
        return this.string;
      }
      get lineChunks() {
        return true;
      }
      read(from2, to2) {
        let stringStart = this.cursorPos - this.string.length;
        if (from2 < stringStart || to2 >= this.cursorPos)
          return this.doc.sliceString(from2, to2);
        else
          return this.string.slice(from2 - stringStart, to2 - stringStart);
      }
    }
    let currentContext = null;
    class ParseContext {
      constructor(parser2, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
        this.parser = parser2;
        this.state = state;
        this.fragments = fragments;
        this.tree = tree;
        this.treeLen = treeLen;
        this.viewport = viewport;
        this.skipped = skipped;
        this.scheduleOn = scheduleOn;
        this.parse = null;
        this.tempSkipped = [];
      }
      /**
      @internal
      */
      static create(parser2, state, viewport) {
        return new ParseContext(parser2, state, [], Tree.empty, 0, viewport, [], null);
      }
      startParse() {
        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
      }
      /**
      @internal
      */
      work(until, upto) {
        if (upto != null && upto >= this.state.doc.length)
          upto = void 0;
        if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
          this.takeTree();
          return true;
        }
        return this.withContext(() => {
          var _a2;
          if (typeof until == "number") {
            let endTime = Date.now() + until;
            until = () => Date.now() > endTime;
          }
          if (!this.parse)
            this.parse = this.startParse();
          if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
            this.parse.stopAt(upto);
          for (; ; ) {
            let done = this.parse.advance();
            if (done) {
              this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
              this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
              this.tree = done;
              this.parse = null;
              if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
                this.parse = this.startParse();
              else
                return true;
            }
            if (until())
              return false;
          }
        });
      }
      /**
      @internal
      */
      takeTree() {
        let pos, tree;
        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
          if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
            this.parse.stopAt(pos);
          this.withContext(() => {
            while (!(tree = this.parse.advance())) {
            }
          });
          this.treeLen = pos;
          this.tree = tree;
          this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
          this.parse = null;
        }
      }
      withContext(f) {
        let prev = currentContext;
        currentContext = this;
        try {
          return f();
        } finally {
          currentContext = prev;
        }
      }
      withoutTempSkipped(fragments) {
        for (let r; r = this.tempSkipped.pop(); )
          fragments = cutFragments(fragments, r.from, r.to);
        return fragments;
      }
      /**
      @internal
      */
      changes(changes, newState) {
        let { fragments, tree, treeLen, viewport, skipped } = this;
        this.takeTree();
        if (!changes.empty) {
          let ranges = [];
          changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
          fragments = TreeFragment.applyChanges(fragments, ranges);
          tree = Tree.empty;
          treeLen = 0;
          viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
          if (this.skipped.length) {
            skipped = [];
            for (let r of this.skipped) {
              let from2 = changes.mapPos(r.from, 1), to2 = changes.mapPos(r.to, -1);
              if (from2 < to2)
                skipped.push({ from: from2, to: to2 });
            }
          }
        }
        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
      }
      /**
      @internal
      */
      updateViewport(viewport) {
        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
          return false;
        this.viewport = viewport;
        let startLen = this.skipped.length;
        for (let i2 = 0; i2 < this.skipped.length; i2++) {
          let { from: from2, to: to2 } = this.skipped[i2];
          if (from2 < viewport.to && to2 > viewport.from) {
            this.fragments = cutFragments(this.fragments, from2, to2);
            this.skipped.splice(i2--, 1);
          }
        }
        if (this.skipped.length >= startLen)
          return false;
        this.reset();
        return true;
      }
      /**
      @internal
      */
      reset() {
        if (this.parse) {
          this.takeTree();
          this.parse = null;
        }
      }
      /**
      Notify the parse scheduler that the given region was skipped
      because it wasn't in view, and the parse should be restarted
      when it comes into view.
      */
      skipUntilInView(from2, to2) {
        this.skipped.push({ from: from2, to: to2 });
      }
      /**
      Returns a parser intended to be used as placeholder when
      asynchronously loading a nested parser. It'll skip its input and
      mark it as not-really-parsed, so that the next update will parse
      it again.
      
      When `until` is given, a reparse will be scheduled when that
      promise resolves.
      */
      static getSkippingParser(until) {
        return new class extends Parser {
          createParse(input, fragments, ranges) {
            let from2 = ranges[0].from, to2 = ranges[ranges.length - 1].to;
            let parser2 = {
              parsedPos: from2,
              advance() {
                let cx = currentContext;
                if (cx) {
                  for (let r of ranges)
                    cx.tempSkipped.push(r);
                  if (until)
                    cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
                }
                this.parsedPos = to2;
                return new Tree(NodeType.none, [], [], to2 - from2);
              },
              stoppedAt: null,
              stopAt() {
              }
            };
            return parser2;
          }
        }();
      }
      /**
      @internal
      */
      isDone(upto) {
        upto = Math.min(upto, this.state.doc.length);
        let frags = this.fragments;
        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
      }
      /**
      Get the context for the current parse, or `null` if no editor
      parse is in progress.
      */
      static get() {
        return currentContext;
      }
    }
    function cutFragments(fragments, from2, to2) {
      return TreeFragment.applyChanges(fragments, [{ fromA: from2, toA: to2, fromB: from2, toB: to2 }]);
    }
    class LanguageState {
      constructor(context) {
        this.context = context;
        this.tree = context.tree;
      }
      apply(tr) {
        if (!tr.docChanged && this.tree == this.context.tree)
          return this;
        let newCx = this.context.changes(tr.changes, tr.state);
        let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
        if (!newCx.work(20, upto))
          newCx.takeTree();
        return new LanguageState(newCx);
      }
      static init(state) {
        let vpTo = Math.min(3e3, state.doc.length);
        let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
        if (!parseState.work(20, vpTo))
          parseState.takeTree();
        return new LanguageState(parseState);
      }
    }
    Language.state = /* @__PURE__ */ StateField.define({
      create: LanguageState.init,
      update(value, tr) {
        for (let e of tr.effects)
          if (e.is(Language.setState))
            return e.value;
        if (tr.startState.facet(language) != tr.state.facet(language))
          return LanguageState.init(tr.state);
        return value.apply(tr);
      }
    });
    let requestIdle = (callback2) => {
      let timeout = setTimeout(
        () => callback2(),
        500
        /* Work.MaxPause */
      );
      return () => clearTimeout(timeout);
    };
    if (typeof requestIdleCallback != "undefined")
      requestIdle = (callback2) => {
        let idle = -1, timeout = setTimeout(
          () => {
            idle = requestIdleCallback(callback2, {
              timeout: 500 - 100
              /* Work.MinPause */
            });
          },
          100
          /* Work.MinPause */
        );
        return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
      };
    const isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
    const parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
      constructor(view) {
        this.view = view;
        this.working = null;
        this.workScheduled = 0;
        this.chunkEnd = -1;
        this.chunkBudget = -1;
        this.work = this.work.bind(this);
        this.scheduleWork();
      }
      update(update) {
        let cx = this.view.state.field(Language.state).context;
        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
          this.scheduleWork();
        if (update.docChanged || update.selectionSet) {
          if (this.view.hasFocus)
            this.chunkBudget += 50;
          this.scheduleWork();
        }
        this.checkAsyncSchedule(cx);
      }
      scheduleWork() {
        if (this.working)
          return;
        let { state } = this.view, field = state.field(Language.state);
        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
          this.working = requestIdle(this.work);
      }
      work(deadline) {
        this.working = null;
        let now = Date.now();
        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
          this.chunkEnd = now + 3e4;
          this.chunkBudget = 3e3;
        }
        if (this.chunkBudget <= 0)
          return;
        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
        if (field.tree == field.context.tree && field.context.isDone(
          vpTo + 1e5
          /* Work.MaxParseAhead */
        ))
          return;
        let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
        let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
        let done = field.context.work(() => {
          return isInputPending && isInputPending() || Date.now() > endTime;
        }, vpTo + (viewportFirst ? 0 : 1e5));
        this.chunkBudget -= Date.now() - now;
        if (done || this.chunkBudget <= 0) {
          field.context.takeTree();
          this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
        }
        if (this.chunkBudget > 0 && !(done && !viewportFirst))
          this.scheduleWork();
        this.checkAsyncSchedule(field.context);
      }
      checkAsyncSchedule(cx) {
        if (cx.scheduleOn) {
          this.workScheduled++;
          cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
          cx.scheduleOn = null;
        }
      }
      destroy() {
        if (this.working)
          this.working();
      }
      isWorking() {
        return !!(this.working || this.workScheduled > 0);
      }
    }, {
      eventHandlers: { focus() {
        this.scheduleWork();
      } }
    });
    const language = /* @__PURE__ */ Facet.define({
      combine(languages) {
        return languages.length ? languages[0] : null;
      },
      enables: (language2) => [
        Language.state,
        parseWorker,
        EditorView.contentAttributes.compute([language2], (state) => {
          let lang = state.facet(language2);
          return lang && lang.name ? { "data-language": lang.name } : {};
        })
      ]
    });
    class LanguageSupport {
      /**
      Create a language support object.
      */
      constructor(language2, support = []) {
        this.language = language2;
        this.support = support;
        this.extension = [language2, support];
      }
    }
    const indentService = /* @__PURE__ */ Facet.define();
    const indentUnit = /* @__PURE__ */ Facet.define({
      combine: (values) => {
        if (!values.length)
          return "  ";
        let unit = values[0];
        if (!unit || /\S/.test(unit) || Array.from(unit).some((e) => e != unit[0]))
          throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
        return unit;
      }
    });
    function getIndentUnit(state) {
      let unit = state.facet(indentUnit);
      return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
    }
    function indentString(state, cols) {
      let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
      if (ch == "	") {
        while (cols >= ts) {
          result += "	";
          cols -= ts;
        }
        ch = " ";
      }
      for (let i2 = 0; i2 < cols; i2++)
        result += ch;
      return result;
    }
    function getIndentation(context, pos) {
      if (context instanceof EditorState)
        context = new IndentContext(context);
      for (let service of context.state.facet(indentService)) {
        let result = service(context, pos);
        if (result !== void 0)
          return result;
      }
      let tree = syntaxTree(context.state);
      return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
    }
    class IndentContext {
      /**
      Create an indent context.
      */
      constructor(state, options = {}) {
        this.state = state;
        this.options = options;
        this.unit = getIndentUnit(state);
      }
      /**
      Get a description of the line at the given position, taking
      [simulated line
      breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
      into account. If there is such a break at `pos`, the `bias`
      argument determines whether the part of the line line before or
      after the break is used.
      */
      lineAt(pos, bias = 1) {
        let line = this.state.doc.lineAt(pos);
        let { simulateBreak, simulateDoubleBreak } = this.options;
        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
          if (simulateDoubleBreak && simulateBreak == pos)
            return { text: "", from: pos };
          else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
            return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
          else
            return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
        }
        return line;
      }
      /**
      Get the text directly after `pos`, either the entire line
      or the next 100 characters, whichever is shorter.
      */
      textAfterPos(pos, bias = 1) {
        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
          return "";
        let { text, from: from2 } = this.lineAt(pos, bias);
        return text.slice(pos - from2, Math.min(text.length, pos + 100 - from2));
      }
      /**
      Find the column for the given position.
      */
      column(pos, bias = 1) {
        let { text, from: from2 } = this.lineAt(pos, bias);
        let result = this.countColumn(text, pos - from2);
        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from2) : -1;
        if (override > -1)
          result += override - this.countColumn(text, text.search(/\S|$/));
        return result;
      }
      /**
      Find the column position (taking tabs into account) of the given
      position in the given string.
      */
      countColumn(line, pos = line.length) {
        return countColumn(line, this.state.tabSize, pos);
      }
      /**
      Find the indentation column of the line at the given point.
      */
      lineIndent(pos, bias = 1) {
        let { text, from: from2 } = this.lineAt(pos, bias);
        let override = this.options.overrideIndentation;
        if (override) {
          let overriden = override(from2);
          if (overriden > -1)
            return overriden;
        }
        return this.countColumn(text, text.search(/\S|$/));
      }
      /**
      Returns the [simulated line
      break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
      for this context, if any.
      */
      get simulatedBreak() {
        return this.options.simulateBreak || null;
      }
    }
    const indentNodeProp = /* @__PURE__ */ new NodeProp();
    function syntaxIndentation(cx, ast, pos) {
      let stack = ast.resolveStack(pos);
      let inner = ast.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos);
      if (inner != stack.node) {
        let add2 = [];
        for (let cur2 = inner; cur2 && !(cur2.from < stack.node.from || cur2.to > stack.node.to || cur2.from == stack.node.from && cur2.type == stack.node.type); cur2 = cur2.parent)
          add2.push(cur2);
        for (let i2 = add2.length - 1; i2 >= 0; i2--)
          stack = { node: add2[i2], next: stack };
      }
      return indentFor(stack, cx, pos);
    }
    function indentFor(stack, cx, pos) {
      for (let cur2 = stack; cur2; cur2 = cur2.next) {
        let strategy = indentStrategy(cur2.node);
        if (strategy)
          return strategy(TreeIndentContext.create(cx, pos, cur2));
      }
      return 0;
    }
    function ignoreClosed(cx) {
      return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
    }
    function indentStrategy(tree) {
      let strategy = tree.type.prop(indentNodeProp);
      if (strategy)
        return strategy;
      let first = tree.firstChild, close;
      if (first && (close = first.type.prop(NodeProp.closedBy))) {
        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
        return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
      }
      return tree.parent == null ? topIndent : null;
    }
    function topIndent() {
      return 0;
    }
    class TreeIndentContext extends IndentContext {
      constructor(base2, pos, context) {
        super(base2.state, base2.options);
        this.base = base2;
        this.pos = pos;
        this.context = context;
      }
      /**
      The syntax tree node to which the indentation strategy
      applies.
      */
      get node() {
        return this.context.node;
      }
      /**
      @internal
      */
      static create(base2, pos, context) {
        return new TreeIndentContext(base2, pos, context);
      }
      /**
      Get the text directly after `this.pos`, either the entire line
      or the next 100 characters, whichever is shorter.
      */
      get textAfter() {
        return this.textAfterPos(this.pos);
      }
      /**
      Get the indentation at the reference line for `this.node`, which
      is the line on which it starts, unless there is a node that is
      _not_ a parent of this node covering the start of that line. If
      so, the line at the start of that node is tried, again skipping
      on if it is covered by another such node.
      */
      get baseIndent() {
        return this.baseIndentFor(this.node);
      }
      /**
      Get the indentation for the reference line of the given node
      (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
      */
      baseIndentFor(node) {
        let line = this.state.doc.lineAt(node.from);
        for (; ; ) {
          let atBreak = node.resolve(line.from);
          while (atBreak.parent && atBreak.parent.from == atBreak.from)
            atBreak = atBreak.parent;
          if (isParent(atBreak, node))
            break;
          line = this.state.doc.lineAt(atBreak.from);
        }
        return this.lineIndent(line.from);
      }
      /**
      Continue looking for indentations in the node's parent nodes,
      and return the result of that.
      */
      continue() {
        return indentFor(this.context.next, this.base, this.pos);
      }
    }
    function isParent(parent, of) {
      for (let cur2 = of; cur2; cur2 = cur2.parent)
        if (parent == cur2)
          return true;
      return false;
    }
    function bracketedAligned(context) {
      let tree = context.node;
      let openToken = tree.childAfter(tree.from), last = tree.lastChild;
      if (!openToken)
        return null;
      let sim = context.options.simulateBreak;
      let openLine = context.state.doc.lineAt(openToken.from);
      let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
      for (let pos = openToken.to; ; ) {
        let next = tree.childAfter(pos);
        if (!next || next == last)
          return null;
        if (!next.type.isSkipped) {
          if (next.from >= lineEnd)
            return null;
          let space = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;
          return { from: openToken.from, to: openToken.to + space };
        }
        pos = next.to;
      }
    }
    function delimitedIndent({ closing: closing2, align = true, units = 1 }) {
      return (context) => delimitedStrategy(context, align, units, closing2);
    }
    function delimitedStrategy(context, align, units, closing2, closedAt) {
      let after = context.textAfter, space = after.match(/^\s*/)[0].length;
      let closed = closing2 && after.slice(space, space + closing2.length) == closing2 || closedAt == context.pos + space;
      let aligned = align ? bracketedAligned(context) : null;
      if (aligned)
        return closed ? context.column(aligned.from) : context.column(aligned.to);
      return context.baseIndent + (closed ? 0 : context.unit * units);
    }
    const DontIndentBeyond = 200;
    function indentOnInput() {
      return EditorState.transactionFilter.of((tr) => {
        if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
          return tr;
        let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
        if (!rules.length)
          return tr;
        let doc2 = tr.newDoc, { head } = tr.newSelection.main, line = doc2.lineAt(head);
        if (head > line.from + DontIndentBeyond)
          return tr;
        let lineStart = doc2.sliceString(line.from, head);
        if (!rules.some((r) => r.test(lineStart)))
          return tr;
        let { state } = tr, last = -1, changes = [];
        for (let { head: head2 } of state.selection.ranges) {
          let line2 = state.doc.lineAt(head2);
          if (line2.from == last)
            continue;
          last = line2.from;
          let indent = getIndentation(state, line2.from);
          if (indent == null)
            continue;
          let cur2 = /^\s*/.exec(line2.text)[0];
          let norm = indentString(state, indent);
          if (cur2 != norm)
            changes.push({ from: line2.from, to: line2.from + cur2.length, insert: norm });
        }
        return changes.length ? [tr, { changes, sequential: true }] : tr;
      });
    }
    const foldService = /* @__PURE__ */ Facet.define();
    const foldNodeProp = /* @__PURE__ */ new NodeProp();
    function foldInside(node) {
      let first = node.firstChild, last = node.lastChild;
      return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;
    }
    function syntaxFolding(state, start, end) {
      let tree = syntaxTree(state);
      if (tree.length < end)
        return null;
      let stack = tree.resolveStack(end, 1);
      let found = null;
      for (let iter = stack; iter; iter = iter.next) {
        let cur2 = iter.node;
        if (cur2.to <= end || cur2.from > end)
          continue;
        if (found && cur2.from < start)
          break;
        let prop = cur2.type.prop(foldNodeProp);
        if (prop && (cur2.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur2))) {
          let value = prop(cur2, state);
          if (value && value.from <= end && value.from >= start && value.to > end)
            found = value;
        }
      }
      return found;
    }
    function isUnfinished(node) {
      let ch = node.lastChild;
      return ch && ch.to == node.to && ch.type.isError;
    }
    function foldable(state, lineStart, lineEnd) {
      for (let service of state.facet(foldService)) {
        let result = service(state, lineStart, lineEnd);
        if (result)
          return result;
      }
      return syntaxFolding(state, lineStart, lineEnd);
    }
    function mapRange(range, mapping) {
      let from2 = mapping.mapPos(range.from, 1), to2 = mapping.mapPos(range.to, -1);
      return from2 >= to2 ? void 0 : { from: from2, to: to2 };
    }
    const foldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
    const unfoldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
    function selectedLines(view) {
      let lines = [];
      for (let { head } of view.state.selection.ranges) {
        if (lines.some((l) => l.from <= head && l.to >= head))
          continue;
        lines.push(view.lineBlockAt(head));
      }
      return lines;
    }
    const foldState = /* @__PURE__ */ StateField.define({
      create() {
        return Decoration.none;
      },
      update(folded, tr) {
        if (tr.isUserEvent("delete"))
          tr.changes.iterChangedRanges((fromA, toA) => folded = clearTouchedFolds(folded, fromA, toA));
        folded = folded.map(tr.changes);
        for (let e of tr.effects) {
          if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {
            let { preparePlaceholder } = tr.state.facet(foldConfig);
            let widget = !preparePlaceholder ? foldWidget : Decoration.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value)) });
            folded = folded.update({ add: [widget.range(e.value.from, e.value.to)] });
          } else if (e.is(unfoldEffect)) {
            folded = folded.update({
              filter: (from2, to2) => e.value.from != from2 || e.value.to != to2,
              filterFrom: e.value.from,
              filterTo: e.value.to
            });
          }
        }
        if (tr.selection)
          folded = clearTouchedFolds(folded, tr.selection.main.head);
        return folded;
      },
      provide: (f) => EditorView.decorations.from(f),
      toJSON(folded, state) {
        let ranges = [];
        folded.between(0, state.doc.length, (from2, to2) => {
          ranges.push(from2, to2);
        });
        return ranges;
      },
      fromJSON(value) {
        if (!Array.isArray(value) || value.length % 2)
          throw new RangeError("Invalid JSON for fold state");
        let ranges = [];
        for (let i2 = 0; i2 < value.length; ) {
          let from2 = value[i2++], to2 = value[i2++];
          if (typeof from2 != "number" || typeof to2 != "number")
            throw new RangeError("Invalid JSON for fold state");
          ranges.push(foldWidget.range(from2, to2));
        }
        return Decoration.set(ranges, true);
      }
    });
    function clearTouchedFolds(folded, from2, to2 = from2) {
      let touched = false;
      folded.between(from2, to2, (a, b) => {
        if (a < to2 && b > from2)
          touched = true;
      });
      return !touched ? folded : folded.update({
        filterFrom: from2,
        filterTo: to2,
        filter: (a, b) => a >= to2 || b <= from2
      });
    }
    function findFold(state, from2, to2) {
      var _a2;
      let found = null;
      (_a2 = state.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from2, to2, (from3, to3) => {
        if (!found || found.from > from3)
          found = { from: from3, to: to3 };
      });
      return found;
    }
    function foldExists(folded, from2, to2) {
      let found = false;
      folded.between(from2, from2, (a, b) => {
        if (a == from2 && b == to2)
          found = true;
      });
      return found;
    }
    function maybeEnable(state, other) {
      return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
    }
    const foldCode = (view) => {
      for (let line of selectedLines(view)) {
        let range = foldable(view.state, line.from, line.to);
        if (range) {
          view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });
          return true;
        }
      }
      return false;
    };
    const unfoldCode = (view) => {
      if (!view.state.field(foldState, false))
        return false;
      let effects2 = [];
      for (let line of selectedLines(view)) {
        let folded = findFold(view.state, line.from, line.to);
        if (folded)
          effects2.push(unfoldEffect.of(folded), announceFold(view, folded, false));
      }
      if (effects2.length)
        view.dispatch({ effects: effects2 });
      return effects2.length > 0;
    };
    function announceFold(view, range, fold = true) {
      let lineFrom = view.state.doc.lineAt(range.from).number, lineTo2 = view.state.doc.lineAt(range.to).number;
      return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo2}.`);
    }
    const foldAll = (view) => {
      let { state } = view, effects2 = [];
      for (let pos = 0; pos < state.doc.length; ) {
        let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);
        if (range)
          effects2.push(foldEffect.of(range));
        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
      }
      if (effects2.length)
        view.dispatch({ effects: maybeEnable(view.state, effects2) });
      return !!effects2.length;
    };
    const unfoldAll = (view) => {
      let field = view.state.field(foldState, false);
      if (!field || !field.size)
        return false;
      let effects2 = [];
      field.between(0, view.state.doc.length, (from2, to2) => {
        effects2.push(unfoldEffect.of({ from: from2, to: to2 }));
      });
      view.dispatch({ effects: effects2 });
      return true;
    };
    const foldKeymap = [
      { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
      { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
      { key: "Ctrl-Alt-[", run: foldAll },
      { key: "Ctrl-Alt-]", run: unfoldAll }
    ];
    const defaultConfig = {
      placeholderDOM: null,
      preparePlaceholder: null,
      placeholderText: ""
    };
    const foldConfig = /* @__PURE__ */ Facet.define({
      combine(values) {
        return combineConfig(values, defaultConfig);
      }
    });
    function codeFolding(config2) {
      let result = [foldState, baseTheme$1$2];
      return result;
    }
    function widgetToDOM(view, prepared) {
      let { state } = view, conf = state.facet(foldConfig);
      let onclick = (event) => {
        let line = view.lineBlockAt(view.posAtDOM(event.target));
        let folded = findFold(view.state, line.from, line.to);
        if (folded)
          view.dispatch({ effects: unfoldEffect.of(folded) });
        event.preventDefault();
      };
      if (conf.placeholderDOM)
        return conf.placeholderDOM(view, onclick, prepared);
      let element = document.createElement("span");
      element.textContent = conf.placeholderText;
      element.setAttribute("aria-label", state.phrase("folded code"));
      element.title = state.phrase("unfold");
      element.className = "cm-foldPlaceholder";
      element.onclick = onclick;
      return element;
    }
    const foldWidget = /* @__PURE__ */ Decoration.replace({ widget: /* @__PURE__ */ new class extends WidgetType {
      toDOM(view) {
        return widgetToDOM(view, null);
      }
    }() });
    class PreparedFoldWidget extends WidgetType {
      constructor(value) {
        super();
        this.value = value;
      }
      eq(other) {
        return this.value == other.value;
      }
      toDOM(view) {
        return widgetToDOM(view, this.value);
      }
    }
    const foldGutterDefaults = {
      openText: "",
      closedText: "",
      markerDOM: null,
      domEventHandlers: {},
      foldingChanged: () => false
    };
    class FoldMarker extends GutterMarker {
      constructor(config2, open) {
        super();
        this.config = config2;
        this.open = open;
      }
      eq(other) {
        return this.config == other.config && this.open == other.open;
      }
      toDOM(view) {
        if (this.config.markerDOM)
          return this.config.markerDOM(this.open);
        let span = document.createElement("span");
        span.textContent = this.open ? this.config.openText : this.config.closedText;
        span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
        return span;
      }
    }
    function foldGutter(config2 = {}) {
      let fullConfig = __spreadValues(__spreadValues({}, foldGutterDefaults), config2);
      let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
      let markers = ViewPlugin.fromClass(class {
        constructor(view) {
          this.from = view.viewport.from;
          this.markers = this.buildMarkers(view);
        }
        update(update) {
          if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update))
            this.markers = this.buildMarkers(update.view);
        }
        buildMarkers(view) {
          let builder = new RangeSetBuilder();
          for (let line of view.viewportLineBlocks) {
            let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
            if (mark)
              builder.add(line.from, line.from, mark);
          }
          return builder.finish();
        }
      });
      let { domEventHandlers } = fullConfig;
      return [
        markers,
        gutter({
          class: "cm-foldGutter",
          markers(view) {
            var _a2;
            return ((_a2 = view.plugin(markers)) === null || _a2 === void 0 ? void 0 : _a2.markers) || RangeSet.empty;
          },
          initialSpacer() {
            return new FoldMarker(fullConfig, false);
          },
          domEventHandlers: __spreadProps(__spreadValues({}, domEventHandlers), {
            click: (view, line, event) => {
              if (domEventHandlers.click && domEventHandlers.click(view, line, event))
                return true;
              let folded = findFold(view.state, line.from, line.to);
              if (folded) {
                view.dispatch({ effects: unfoldEffect.of(folded) });
                return true;
              }
              let range = foldable(view.state, line.from, line.to);
              if (range) {
                view.dispatch({ effects: foldEffect.of(range) });
                return true;
              }
              return false;
            }
          })
        }),
        codeFolding()
      ];
    }
    const baseTheme$1$2 = /* @__PURE__ */ EditorView.baseTheme({
      ".cm-foldPlaceholder": {
        backgroundColor: "#eee",
        border: "1px solid #ddd",
        color: "#888",
        borderRadius: ".2em",
        margin: "0 1px",
        padding: "0 1px",
        cursor: "pointer"
      },
      ".cm-foldGutter span": {
        padding: "0 1px",
        cursor: "pointer"
      }
    });
    class HighlightStyle {
      constructor(specs, options) {
        this.specs = specs;
        let modSpec;
        function def(spec) {
          let cls = StyleModule.newName();
          (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
          return cls;
        }
        const all2 = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
        const scopeOpt = options.scope;
        this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
        this.style = tagHighlighter(specs.map((style) => ({
          tag: style.tag,
          class: style.class || def(Object.assign({}, style, { tag: null }))
        })), {
          all: all2
        }).style;
        this.module = modSpec ? new StyleModule(modSpec) : null;
        this.themeType = options.themeType;
      }
      /**
      Create a highlighter style that associates the given styles to
      the given tags. The specs must be objects that hold a style tag
      or array of tags in their `tag` property, and either a single
      `class` property providing a static CSS class (for highlighter
      that rely on external styling), or a
      [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
      set of CSS properties (which define the styling for those tags).
      
      The CSS rules created for a highlighter will be emitted in the
      order of the spec's properties. That means that for elements that
      have multiple tags associated with them, styles defined further
      down in the list will have a higher CSS precedence than styles
      defined earlier.
      */
      static define(specs, options) {
        return new HighlightStyle(specs, options || {});
      }
    }
    const highlighterFacet = /* @__PURE__ */ Facet.define();
    const fallbackHighlighter = /* @__PURE__ */ Facet.define({
      combine(values) {
        return values.length ? [values[0]] : null;
      }
    });
    function getHighlighters(state) {
      let main = state.facet(highlighterFacet);
      return main.length ? main : state.facet(fallbackHighlighter);
    }
    function syntaxHighlighting(highlighter, options) {
      let ext = [treeHighlighter], themeType;
      if (highlighter instanceof HighlightStyle) {
        if (highlighter.module)
          ext.push(EditorView.styleModule.of(highlighter.module));
        themeType = highlighter.themeType;
      }
      if (options === null || options === void 0 ? void 0 : options.fallback)
        ext.push(fallbackHighlighter.of(highlighter));
      else if (themeType)
        ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
          return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
        }));
      else
        ext.push(highlighterFacet.of(highlighter));
      return ext;
    }
    class TreeHighlighter {
      constructor(view) {
        this.markCache = /* @__PURE__ */ Object.create(null);
        this.tree = syntaxTree(view.state);
        this.decorations = this.buildDeco(view, getHighlighters(view.state));
        this.decoratedTo = view.viewport.to;
      }
      update(update) {
        let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
        let styleChange = highlighters != getHighlighters(update.startState);
        let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);
        if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
          this.decorations = this.decorations.map(update.changes);
          this.decoratedTo = decoratedToMapped;
        } else if (tree != this.tree || update.viewportChanged || styleChange) {
          this.tree = tree;
          this.decorations = this.buildDeco(update.view, highlighters);
          this.decoratedTo = viewport.to;
        }
      }
      buildDeco(view, highlighters) {
        if (!highlighters || !this.tree.length)
          return Decoration.none;
        let builder = new RangeSetBuilder();
        for (let { from: from2, to: to2 } of view.visibleRanges) {
          highlightTree(this.tree, highlighters, (from3, to3, style) => {
            builder.add(from3, to3, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
          }, from2, to2);
        }
        return builder.finish();
      }
    }
    const treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
      decorations: (v) => v.decorations
    }));
    const defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
      {
        tag: tags.meta,
        color: "#404740"
      },
      {
        tag: tags.link,
        textDecoration: "underline"
      },
      {
        tag: tags.heading,
        textDecoration: "underline",
        fontWeight: "bold"
      },
      {
        tag: tags.emphasis,
        fontStyle: "italic"
      },
      {
        tag: tags.strong,
        fontWeight: "bold"
      },
      {
        tag: tags.strikethrough,
        textDecoration: "line-through"
      },
      {
        tag: tags.keyword,
        color: "#708"
      },
      {
        tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
        color: "#219"
      },
      {
        tag: [tags.literal, tags.inserted],
        color: "#164"
      },
      {
        tag: [tags.string, tags.deleted],
        color: "#a11"
      },
      {
        tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
        color: "#e40"
      },
      {
        tag: /* @__PURE__ */ tags.definition(tags.variableName),
        color: "#00f"
      },
      {
        tag: /* @__PURE__ */ tags.local(tags.variableName),
        color: "#30a"
      },
      {
        tag: [tags.typeName, tags.namespace],
        color: "#085"
      },
      {
        tag: tags.className,
        color: "#167"
      },
      {
        tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
        color: "#256"
      },
      {
        tag: /* @__PURE__ */ tags.definition(tags.propertyName),
        color: "#00c"
      },
      {
        tag: tags.comment,
        color: "#940"
      },
      {
        tag: tags.invalid,
        color: "#f00"
      }
    ]);
    const baseTheme$3 = /* @__PURE__ */ EditorView.baseTheme({
      "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
      "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
    });
    const DefaultScanDist = 1e4, DefaultBrackets = "()[]{}";
    const bracketMatchingConfig = /* @__PURE__ */ Facet.define({
      combine(configs) {
        return combineConfig(configs, {
          afterCursor: true,
          brackets: DefaultBrackets,
          maxScanDistance: DefaultScanDist,
          renderMatch: defaultRenderMatch
        });
      }
    });
    const matchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-matchingBracket" }), nonmatchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-nonmatchingBracket" });
    function defaultRenderMatch(match) {
      let decorations2 = [];
      let mark = match.matched ? matchingMark : nonmatchingMark;
      decorations2.push(mark.range(match.start.from, match.start.to));
      if (match.end)
        decorations2.push(mark.range(match.end.from, match.end.to));
      return decorations2;
    }
    const bracketMatchingState = /* @__PURE__ */ StateField.define({
      create() {
        return Decoration.none;
      },
      update(deco, tr) {
        if (!tr.docChanged && !tr.selection)
          return deco;
        let decorations2 = [];
        let config2 = tr.state.facet(bracketMatchingConfig);
        for (let range of tr.state.selection.ranges) {
          if (!range.empty)
            continue;
          let match = matchBrackets(tr.state, range.head, -1, config2) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr.state, range.head, 1, config2) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config2));
          if (match)
            decorations2 = decorations2.concat(config2.renderMatch(match, tr.state));
        }
        return Decoration.set(decorations2, true);
      },
      provide: (f) => EditorView.decorations.from(f)
    });
    const bracketMatchingUnique = [
      bracketMatchingState,
      baseTheme$3
    ];
    function bracketMatching(config2 = {}) {
      return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
    }
    const bracketMatchingHandle = /* @__PURE__ */ new NodeProp();
    function matchingNodes(node, dir, brackets) {
      let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
      if (byProp)
        return byProp;
      if (node.name.length == 1) {
        let index2 = brackets.indexOf(node.name);
        if (index2 > -1 && index2 % 2 == (dir < 0 ? 1 : 0))
          return [brackets[index2 + dir]];
      }
      return null;
    }
    function findHandle(node) {
      let hasHandle = node.type.prop(bracketMatchingHandle);
      return hasHandle ? hasHandle(node.node) : node;
    }
    function matchBrackets(state, pos, dir, config2 = {}) {
      let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
      let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
      for (let cur2 = node; cur2; cur2 = cur2.parent) {
        let matches = matchingNodes(cur2.type, dir, brackets);
        if (matches && cur2.from < cur2.to) {
          let handle = findHandle(cur2);
          if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
            return matchMarkedBrackets(state, pos, dir, cur2, handle, matches, brackets);
        }
      }
      return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
    }
    function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
      let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
      let depth = 0, cursor2 = parent === null || parent === void 0 ? void 0 : parent.cursor();
      if (cursor2 && (dir < 0 ? cursor2.childBefore(token.from) : cursor2.childAfter(token.to)))
        do {
          if (dir < 0 ? cursor2.to <= token.from : cursor2.from >= token.to) {
            if (depth == 0 && matching.indexOf(cursor2.type.name) > -1 && cursor2.from < cursor2.to) {
              let endHandle = findHandle(cursor2);
              return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0, matched: true };
            } else if (matchingNodes(cursor2.type, dir, brackets)) {
              depth++;
            } else if (matchingNodes(cursor2.type, -dir, brackets)) {
              if (depth == 0) {
                let endHandle = findHandle(cursor2);
                return {
                  start: firstToken,
                  end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : void 0,
                  matched: false
                };
              }
              depth--;
            }
          }
        } while (dir < 0 ? cursor2.prevSibling() : cursor2.nextSibling());
      return { start: firstToken, matched: false };
    }
    function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
      let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
      let bracket2 = brackets.indexOf(startCh);
      if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
        return null;
      let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
      let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
      for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
        let text = iter.value;
        if (dir < 0)
          distance += text.length;
        let basePos = pos + distance * dir;
        for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
          let found = brackets.indexOf(text[pos2]);
          if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
            continue;
          if (found % 2 == 0 == dir > 0) {
            depth++;
          } else if (depth == 1) {
            return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
          } else {
            depth--;
          }
        }
        if (dir > 0)
          distance += text.length;
      }
      return iter.done ? { start: startToken, matched: false } : null;
    }
    const noTokens = /* @__PURE__ */ Object.create(null);
    const typeArray = [NodeType.none];
    const warned = [];
    const byTag = /* @__PURE__ */ Object.create(null);
    const defaultTable = /* @__PURE__ */ Object.create(null);
    for (let [legacyName, name2] of [
      ["variable", "variableName"],
      ["variable-2", "variableName.special"],
      ["string-2", "string.special"],
      ["def", "variableName.definition"],
      ["tag", "tagName"],
      ["attribute", "attributeName"],
      ["type", "typeName"],
      ["builtin", "variableName.standard"],
      ["qualifier", "modifier"],
      ["error", "invalid"],
      ["header", "heading"],
      ["property", "propertyName"]
    ])
      defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2);
    function warnForPart(part, msg) {
      if (warned.indexOf(part) > -1)
        return;
      warned.push(part);
      console.warn(msg);
    }
    function createTokenType(extra, tagStr) {
      let tags$1 = [];
      for (let name3 of tagStr.split(" ")) {
        let found = [];
        for (let part of name3.split(".")) {
          let value = extra[part] || tags[part];
          if (!value) {
            warnForPart(part, `Unknown highlighting tag ${part}`);
          } else if (typeof value == "function") {
            if (!found.length)
              warnForPart(part, `Modifier ${part} used at start of tag`);
            else
              found = found.map(value);
          } else {
            if (found.length)
              warnForPart(part, `Tag ${part} used as modifier`);
            else
              found = Array.isArray(value) ? value : [value];
          }
        }
        for (let tag of found)
          tags$1.push(tag);
      }
      if (!tags$1.length)
        return 0;
      let name2 = tagStr.replace(/ /g, "_"), key = name2 + " " + tags$1.map((t2) => t2.id);
      let known = byTag[key];
      if (known)
        return known.id;
      let type = byTag[key] = NodeType.define({
        id: typeArray.length,
        name: name2,
        props: [styleTags({ [name2]: tags$1 })]
      });
      typeArray.push(type);
      return type.id;
    }
    ({
      rtl: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "rtl" }, bidiIsolate: Direction.RTL }),
      ltr: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "ltr" }, bidiIsolate: Direction.LTR })
    });
    const toggleComment = (target) => {
      let { state } = target, line = state.doc.lineAt(state.selection.main.from), config2 = getConfig(target.state, line.from);
      return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
    };
    function command(f, option) {
      return ({ state, dispatch }) => {
        if (state.readOnly)
          return false;
        let tr = f(option, state);
        if (!tr)
          return false;
        dispatch(state.update(tr));
        return true;
      };
    }
    const toggleLineComment = /* @__PURE__ */ command(
      changeLineComment,
      0
      /* CommentOption.Toggle */
    );
    const toggleBlockComment = /* @__PURE__ */ command(
      changeBlockComment,
      0
      /* CommentOption.Toggle */
    );
    const toggleBlockCommentByLine = /* @__PURE__ */ command(
      (o, s) => changeBlockComment(o, s, selectedLineRanges(s)),
      0
      /* CommentOption.Toggle */
    );
    function getConfig(state, pos) {
      let data = state.languageDataAt("commentTokens", pos, 1);
      return data.length ? data[0] : {};
    }
    const SearchMargin = 50;
    function findBlockComment(state, { open, close }, from2, to2) {
      let textBefore = state.sliceDoc(from2 - SearchMargin, from2);
      let textAfter = state.sliceDoc(to2, to2 + SearchMargin);
      let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
      let beforeOff = textBefore.length - spaceBefore;
      if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
        return {
          open: { pos: from2 - spaceBefore, margin: spaceBefore && 1 },
          close: { pos: to2 + spaceAfter, margin: spaceAfter && 1 }
        };
      }
      let startText, endText;
      if (to2 - from2 <= 2 * SearchMargin) {
        startText = endText = state.sliceDoc(from2, to2);
      } else {
        startText = state.sliceDoc(from2, from2 + SearchMargin);
        endText = state.sliceDoc(to2 - SearchMargin, to2);
      }
      let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
      let endOff = endText.length - endSpace - close.length;
      if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
        return {
          open: {
            pos: from2 + startSpace + open.length,
            margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
          },
          close: {
            pos: to2 - endSpace - close.length,
            margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
          }
        };
      }
      return null;
    }
    function selectedLineRanges(state) {
      let ranges = [];
      for (let r of state.selection.ranges) {
        let fromLine = state.doc.lineAt(r.from);
        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
        if (toLine.from > fromLine.from && toLine.from == r.to)
          toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);
        let last = ranges.length - 1;
        if (last >= 0 && ranges[last].to > fromLine.from)
          ranges[last].to = toLine.to;
        else
          ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
      }
      return ranges;
    }
    function changeBlockComment(option, state, ranges = state.selection.ranges) {
      let tokens = ranges.map((r) => getConfig(state, r.from).block);
      if (!tokens.every((c) => c))
        return null;
      let comments = ranges.map((r, i2) => findBlockComment(state, tokens[i2], r.from, r.to));
      if (option != 2 && !comments.every((c) => c)) {
        return { changes: state.changes(ranges.map((range, i2) => {
          if (comments[i2])
            return [];
          return [{ from: range.from, insert: tokens[i2].open + " " }, { from: range.to, insert: " " + tokens[i2].close }];
        })) };
      } else if (option != 1 && comments.some((c) => c)) {
        let changes = [];
        for (let i2 = 0, comment2; i2 < comments.length; i2++)
          if (comment2 = comments[i2]) {
            let token = tokens[i2], { open, close } = comment2;
            changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
          }
        return { changes };
      }
      return null;
    }
    function changeLineComment(option, state, ranges = state.selection.ranges) {
      let lines = [];
      let prevLine = -1;
      for (let { from: from2, to: to2 } of ranges) {
        let startI = lines.length, minIndent = 1e9;
        let token = getConfig(state, from2).line;
        if (!token)
          continue;
        for (let pos = from2; pos <= to2; ) {
          let line = state.doc.lineAt(pos);
          if (line.from > prevLine && (from2 == to2 || to2 > line.from)) {
            prevLine = line.from;
            let indent = /^\s*/.exec(line.text)[0].length;
            let empty2 = indent == line.length;
            let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
            if (indent < line.text.length && indent < minIndent)
              minIndent = indent;
            lines.push({ line, comment: comment2, token, indent, empty: empty2, single: false });
          }
          pos = line.to + 1;
        }
        if (minIndent < 1e9) {
          for (let i2 = startI; i2 < lines.length; i2++)
            if (lines[i2].indent < lines[i2].line.text.length)
              lines[i2].indent = minIndent;
        }
        if (lines.length == startI + 1)
          lines[startI].single = true;
      }
      if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
        let changes = [];
        for (let { line, token, indent, empty: empty2, single } of lines)
          if (single || !empty2)
            changes.push({ from: line.from + indent, insert: token + " " });
        let changeSet = state.changes(changes);
        return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
      } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
        let changes = [];
        for (let { line, comment: comment2, token } of lines)
          if (comment2 >= 0) {
            let from2 = line.from + comment2, to2 = from2 + token.length;
            if (line.text[to2 - line.from] == " ")
              to2++;
            changes.push({ from: from2, to: to2 });
          }
        return { changes };
      }
      return null;
    }
    const fromHistory = /* @__PURE__ */ Annotation.define();
    const isolateHistory = /* @__PURE__ */ Annotation.define();
    const invertedEffects = /* @__PURE__ */ Facet.define();
    const historyConfig = /* @__PURE__ */ Facet.define({
      combine(configs) {
        return combineConfig(configs, {
          minDepth: 100,
          newGroupDelay: 500,
          joinToEvent: (_t, isAdjacent2) => isAdjacent2
        }, {
          minDepth: Math.max,
          newGroupDelay: Math.min,
          joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)
        });
      }
    });
    const historyField_ = /* @__PURE__ */ StateField.define({
      create() {
        return HistoryState.empty;
      },
      update(state, tr) {
        let config2 = tr.state.facet(historyConfig);
        let fromHist = tr.annotation(fromHistory);
        if (fromHist) {
          let item = HistEvent.fromTransaction(tr, fromHist.selection), from2 = fromHist.side;
          let other = from2 == 0 ? state.undone : state.done;
          if (item)
            other = updateBranch(other, other.length, config2.minDepth, item);
          else
            other = addSelection(other, tr.startState.selection);
          return new HistoryState(from2 == 0 ? fromHist.rest : other, from2 == 0 ? other : fromHist.rest);
        }
        let isolate = tr.annotation(isolateHistory);
        if (isolate == "full" || isolate == "before")
          state = state.isolate();
        if (tr.annotation(Transaction.addToHistory) === false)
          return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
        let event = HistEvent.fromTransaction(tr);
        let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
        if (event)
          state = state.addChanges(event, time, userEvent, config2, tr);
        else if (tr.selection)
          state = state.addSelection(tr.startState.selection, time, userEvent, config2.newGroupDelay);
        if (isolate == "full" || isolate == "after")
          state = state.isolate();
        return state;
      },
      toJSON(value) {
        return { done: value.done.map((e) => e.toJSON()), undone: value.undone.map((e) => e.toJSON()) };
      },
      fromJSON(json) {
        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
      }
    });
    function history(config2 = {}) {
      return [
        historyField_,
        historyConfig.of(config2),
        EditorView.domEventHandlers({
          beforeinput(e, view) {
            let command2 = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
            if (!command2)
              return false;
            e.preventDefault();
            return command2(view);
          }
        })
      ];
    }
    function cmd(side, selection2) {
      return function({ state, dispatch }) {
        if (!selection2 && state.readOnly)
          return false;
        let historyState = state.field(historyField_, false);
        if (!historyState)
          return false;
        let tr = historyState.pop(side, state, selection2);
        if (!tr)
          return false;
        dispatch(tr);
        return true;
      };
    }
    const undo = /* @__PURE__ */ cmd(0, false);
    const redo = /* @__PURE__ */ cmd(1, false);
    const undoSelection = /* @__PURE__ */ cmd(0, true);
    const redoSelection = /* @__PURE__ */ cmd(1, true);
    class HistEvent {
      constructor(changes, effects2, mapped, startSelection, selectionsAfter) {
        this.changes = changes;
        this.effects = effects2;
        this.mapped = mapped;
        this.startSelection = startSelection;
        this.selectionsAfter = selectionsAfter;
      }
      setSelAfter(after) {
        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
      }
      toJSON() {
        var _a2, _b, _c;
        return {
          changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
          mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
          startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
          selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
        };
      }
      static fromJSON(json) {
        return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
      }
      // This does not check `addToHistory` and such, it assumes the
      // transaction needs to be converted to an item. Returns null when
      // there are no changes or effects in the transaction.
      static fromTransaction(tr, selection2) {
        let effects2 = none$1;
        for (let invert of tr.startState.facet(invertedEffects)) {
          let result = invert(tr);
          if (result.length)
            effects2 = effects2.concat(result);
        }
        if (!effects2.length && tr.changes.empty)
          return null;
        return new HistEvent(tr.changes.invert(tr.startState.doc), effects2, void 0, selection2 || tr.startState.selection, none$1);
      }
      static selection(selections) {
        return new HistEvent(void 0, none$1, void 0, void 0, selections);
      }
    }
    function updateBranch(branch, to2, maxLen, newEvent) {
      let start = to2 + 1 > maxLen + 20 ? to2 - maxLen - 1 : 0;
      let newBranch = branch.slice(start, to2);
      newBranch.push(newEvent);
      return newBranch;
    }
    function isAdjacent(a, b) {
      let ranges = [], isAdjacent2 = false;
      a.iterChangedRanges((f, t2) => ranges.push(f, t2));
      b.iterChangedRanges((_f, _t, f, t2) => {
        for (let i2 = 0; i2 < ranges.length; ) {
          let from2 = ranges[i2++], to2 = ranges[i2++];
          if (t2 >= from2 && f <= to2)
            isAdjacent2 = true;
        }
      });
      return isAdjacent2;
    }
    function eqSelectionShape(a, b) {
      return a.ranges.length == b.ranges.length && a.ranges.filter((r, i2) => r.empty != b.ranges[i2].empty).length === 0;
    }
    function conc(a, b) {
      return !a.length ? b : !b.length ? a : a.concat(b);
    }
    const none$1 = [];
    const MaxSelectionsPerEvent = 200;
    function addSelection(branch, selection2) {
      if (!branch.length) {
        return [HistEvent.selection([selection2])];
      } else {
        let lastEvent = branch[branch.length - 1];
        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
        if (sels.length && sels[sels.length - 1].eq(selection2))
          return branch;
        sels.push(selection2);
        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
      }
    }
    function popSelection(branch) {
      let last = branch[branch.length - 1];
      let newBranch = branch.slice();
      newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
      return newBranch;
    }
    function addMappingToBranch(branch, mapping) {
      if (!branch.length)
        return branch;
      let length = branch.length, selections = none$1;
      while (length) {
        let event = mapEvent(branch[length - 1], mapping, selections);
        if (event.changes && !event.changes.empty || event.effects.length) {
          let result = branch.slice(0, length);
          result[length - 1] = event;
          return result;
        } else {
          mapping = event.mapped;
          length--;
          selections = event.selectionsAfter;
        }
      }
      return selections.length ? [HistEvent.selection(selections)] : none$1;
    }
    function mapEvent(event, mapping, extraSelections) {
      let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none$1, extraSelections);
      if (!event.changes)
        return HistEvent.selection(selections);
      let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
      let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
      return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
    }
    const joinableUserEvent = /^(input\.type|delete)($|\.)/;
    class HistoryState {
      constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
        this.done = done;
        this.undone = undone;
        this.prevTime = prevTime;
        this.prevUserEvent = prevUserEvent;
      }
      isolate() {
        return this.prevTime ? new HistoryState(this.done, this.undone) : this;
      }
      addChanges(event, time, userEvent, config2, tr) {
        let done = this.done, lastEvent = done[done.length - 1];
        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config2.newGroupDelay && config2.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event
        userEvent == "input.type.compose")) {
          done = updateBranch(done, done.length - 1, config2.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none$1));
        } else {
          done = updateBranch(done, done.length, config2.minDepth, event);
        }
        return new HistoryState(done, none$1, time, userEvent);
      }
      addSelection(selection2, time, userEvent, newGroupDelay) {
        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none$1;
        if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection2))
          return this;
        return new HistoryState(addSelection(this.done, selection2), this.undone, time, userEvent);
      }
      addMapping(mapping) {
        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
      }
      pop(side, state, onlySelection) {
        let branch = side == 0 ? this.done : this.undone;
        if (branch.length == 0)
          return null;
        let event = branch[branch.length - 1], selection2 = event.selectionsAfter[0] || state.selection;
        if (onlySelection && event.selectionsAfter.length) {
          return state.update({
            selection: event.selectionsAfter[event.selectionsAfter.length - 1],
            annotations: fromHistory.of({ side, rest: popSelection(branch), selection: selection2 }),
            userEvent: side == 0 ? "select.undo" : "select.redo",
            scrollIntoView: true
          });
        } else if (!event.changes) {
          return null;
        } else {
          let rest = branch.length == 1 ? none$1 : branch.slice(0, branch.length - 1);
          if (event.mapped)
            rest = addMappingToBranch(rest, event.mapped);
          return state.update({
            changes: event.changes,
            selection: event.startSelection,
            effects: event.effects,
            annotations: fromHistory.of({ side, rest, selection: selection2 }),
            filter: false,
            userEvent: side == 0 ? "undo" : "redo",
            scrollIntoView: true
          });
        }
      }
    }
    HistoryState.empty = /* @__PURE__ */ new HistoryState(none$1, none$1);
    const historyKeymap = [
      { key: "Mod-z", run: undo, preventDefault: true },
      { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
      { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
      { key: "Mod-u", run: undoSelection, preventDefault: true },
      { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
    ];
    function updateSel(sel, by) {
      return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
    }
    function setSel(state, selection2) {
      return state.update({ selection: selection2, scrollIntoView: true, userEvent: "select" });
    }
    function moveSel({ state, dispatch }, how) {
      let selection2 = updateSel(state.selection, how);
      if (selection2.eq(state.selection, true))
        return false;
      dispatch(setSel(state, selection2));
      return true;
    }
    function rangeEnd(range, forward) {
      return EditorSelection.cursor(forward ? range.to : range.from);
    }
    function cursorByChar(view, forward) {
      return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
    }
    function ltrAtCursor(view) {
      return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
    }
    const cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
    const cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
    function cursorByGroup(view, forward) {
      return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
    }
    const cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
    const cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
    function interestingNode(state, node, bracketProp) {
      if (node.type.prop(bracketProp))
        return true;
      let len = node.to - node.from;
      return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
    }
    function moveBySyntax(state, start, forward) {
      let pos = syntaxTree(state).resolveInner(start.head);
      let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
      for (let at = start.head; ; ) {
        let next = forward ? pos.childAfter(at) : pos.childBefore(at);
        if (!next)
          break;
        if (interestingNode(state, next, bracketProp))
          pos = next;
        else
          at = forward ? next.to : next.from;
      }
      let bracket2 = pos.type.prop(bracketProp), match, newPos;
      if (bracket2 && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
        newPos = forward ? match.end.to : match.end.from;
      else
        newPos = forward ? pos.to : pos.from;
      return EditorSelection.cursor(newPos, forward ? -1 : 1);
    }
    const cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
    const cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
    function cursorByLine(view, forward) {
      return moveSel(view, (range) => {
        if (!range.empty)
          return rangeEnd(range, forward);
        let moved = view.moveVertically(range, forward);
        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
      });
    }
    const cursorLineUp = (view) => cursorByLine(view, false);
    const cursorLineDown = (view) => cursorByLine(view, true);
    function pageInfo(view) {
      let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
      let marginTop = 0, marginBottom = 0, height;
      if (selfScroll) {
        for (let source2 of view.state.facet(EditorView.scrollMargins)) {
          let margins = source2(view);
          if (margins === null || margins === void 0 ? void 0 : margins.top)
            marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
          if (margins === null || margins === void 0 ? void 0 : margins.bottom)
            marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
        }
        height = view.scrollDOM.clientHeight - marginTop - marginBottom;
      } else {
        height = (view.dom.ownerDocument.defaultView || window).innerHeight;
      }
      return {
        marginTop,
        marginBottom,
        selfScroll,
        height: Math.max(view.defaultLineHeight, height - 5)
      };
    }
    function cursorByPage(view, forward) {
      let page = pageInfo(view);
      let { state } = view, selection2 = updateSel(state.selection, (range) => {
        return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
      });
      if (selection2.eq(state.selection))
        return false;
      let effect;
      if (page.selfScroll) {
        let startPos = view.coordsAtPos(state.selection.main.head);
        let scrollRect = view.scrollDOM.getBoundingClientRect();
        let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
        if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
          effect = EditorView.scrollIntoView(selection2.main.head, { y: "start", yMargin: startPos.top - scrollTop });
      }
      view.dispatch(setSel(state, selection2), { effects: effect });
      return true;
    }
    const cursorPageUp = (view) => cursorByPage(view, false);
    const cursorPageDown = (view) => cursorByPage(view, true);
    function moveByLineBoundary(view, start, forward) {
      let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
      if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
        moved = view.moveToLineBoundary(start, forward, false);
      if (!forward && moved.head == line.from && line.length) {
        let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
        if (space && start.head != line.from + space)
          moved = EditorSelection.cursor(line.from + space);
      }
      return moved;
    }
    const cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
    const cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
    const cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
    const cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
    const cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
    const cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
    function toMatchingBracket(state, dispatch, extend2) {
      let found = false, selection2 = updateSel(state.selection, (range) => {
        let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
        if (!matching || !matching.end)
          return range;
        found = true;
        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
        return EditorSelection.cursor(head);
      });
      if (!found)
        return false;
      dispatch(setSel(state, selection2));
      return true;
    }
    const cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch);
    function extendSel(target, how) {
      let selection2 = updateSel(target.state.selection, (range) => {
        let head = how(range);
        return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
      });
      if (selection2.eq(target.state.selection))
        return false;
      target.dispatch(setSel(target.state, selection2));
      return true;
    }
    function selectByChar(view, forward) {
      return extendSel(view, (range) => view.moveByChar(range, forward));
    }
    const selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
    const selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
    function selectByGroup(view, forward) {
      return extendSel(view, (range) => view.moveByGroup(range, forward));
    }
    const selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
    const selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
    const selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
    const selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
    function selectByLine(view, forward) {
      return extendSel(view, (range) => view.moveVertically(range, forward));
    }
    const selectLineUp = (view) => selectByLine(view, false);
    const selectLineDown = (view) => selectByLine(view, true);
    function selectByPage(view, forward) {
      return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
    }
    const selectPageUp = (view) => selectByPage(view, false);
    const selectPageDown = (view) => selectByPage(view, true);
    const selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
    const selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
    const selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
    const selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
    const selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
    const selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
    const cursorDocStart = ({ state, dispatch }) => {
      dispatch(setSel(state, { anchor: 0 }));
      return true;
    };
    const cursorDocEnd = ({ state, dispatch }) => {
      dispatch(setSel(state, { anchor: state.doc.length }));
      return true;
    };
    const selectDocStart = ({ state, dispatch }) => {
      dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
      return true;
    };
    const selectDocEnd = ({ state, dispatch }) => {
      dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
      return true;
    };
    const selectAll = ({ state, dispatch }) => {
      dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
      return true;
    };
    const selectLine = ({ state, dispatch }) => {
      let ranges = selectedLineBlocks(state).map(({ from: from2, to: to2 }) => EditorSelection.range(from2, Math.min(to2 + 1, state.doc.length)));
      dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
      return true;
    };
    const selectParentSyntax = ({ state, dispatch }) => {
      let selection2 = updateSel(state.selection, (range) => {
        let tree = syntaxTree(state), stack = tree.resolveStack(range.from, 1);
        if (range.empty) {
          let stackBefore = tree.resolveStack(range.from, -1);
          if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)
            stack = stackBefore;
        }
        for (let cur2 = stack; cur2; cur2 = cur2.next) {
          let { node } = cur2;
          if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur2.next)
            return EditorSelection.range(node.to, node.from);
        }
        return range;
      });
      if (selection2.eq(state.selection))
        return false;
      dispatch(setSel(state, selection2));
      return true;
    };
    function addCursorVertically(view, forward) {
      let { state } = view, sel = state.selection, ranges = state.selection.ranges.slice();
      for (let range of state.selection.ranges) {
        let line = state.doc.lineAt(range.head);
        if (forward ? line.to < view.state.doc.length : line.from > 0)
          for (let cur2 = range; ; ) {
            let next = view.moveVertically(cur2, forward);
            if (next.head < line.from || next.head > line.to) {
              if (!ranges.some((r) => r.head == next.head))
                ranges.push(next);
              break;
            } else if (next.head == cur2.head) {
              break;
            } else {
              cur2 = next;
            }
          }
      }
      if (ranges.length == sel.ranges.length)
        return false;
      view.dispatch(setSel(state, EditorSelection.create(ranges, ranges.length - 1)));
      return true;
    }
    const addCursorAbove = (view) => addCursorVertically(view, false);
    const addCursorBelow = (view) => addCursorVertically(view, true);
    const simplifySelection = ({ state, dispatch }) => {
      let cur2 = state.selection, selection2 = null;
      if (cur2.ranges.length > 1)
        selection2 = EditorSelection.create([cur2.main]);
      else if (!cur2.main.empty)
        selection2 = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
      if (!selection2)
        return false;
      dispatch(setSel(state, selection2));
      return true;
    };
    function deleteBy(target, by) {
      if (target.state.readOnly)
        return false;
      let event = "delete.selection", { state } = target;
      let changes = state.changeByRange((range) => {
        let { from: from2, to: to2 } = range;
        if (from2 == to2) {
          let towards = by(range);
          if (towards < from2) {
            event = "delete.backward";
            towards = skipAtomic(target, towards, false);
          } else if (towards > from2) {
            event = "delete.forward";
            towards = skipAtomic(target, towards, true);
          }
          from2 = Math.min(from2, towards);
          to2 = Math.max(to2, towards);
        } else {
          from2 = skipAtomic(target, from2, false);
          to2 = skipAtomic(target, to2, true);
        }
        return from2 == to2 ? { range } : { changes: { from: from2, to: to2 }, range: EditorSelection.cursor(from2, from2 < range.head ? -1 : 1) };
      });
      if (changes.changes.empty)
        return false;
      target.dispatch(state.update(changes, {
        scrollIntoView: true,
        userEvent: event,
        effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
      }));
      return true;
    }
    function skipAtomic(target, pos, forward) {
      if (target instanceof EditorView)
        for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
          ranges.between(pos, pos, (from2, to2) => {
            if (from2 < pos && to2 > pos)
              pos = forward ? to2 : from2;
          });
      return pos;
    }
    const deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, (range) => {
      let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;
      if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
        if (before[before.length - 1] == "	")
          return pos - 1;
        let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
        for (let i2 = 0; i2 < drop && before[before.length - 1 - i2] == " "; i2++)
          pos--;
        targetPos = pos;
      } else {
        targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
        if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
          targetPos += forward ? 1 : -1;
        else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
          targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;
      }
      return targetPos;
    });
    const deleteCharBackward = (view) => deleteByChar(view, false, true);
    const deleteCharForward = (view) => deleteByChar(view, true, false);
    const deleteByGroup = (target, forward) => deleteBy(target, (range) => {
      let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
      let categorize = state.charCategorizer(pos);
      for (let cat = null; ; ) {
        if (pos == (forward ? line.to : line.from)) {
          if (pos == range.head && line.number != (forward ? state.doc.lines : 1))
            pos += forward ? 1 : -1;
          break;
        }
        let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
        let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
        let nextCat = categorize(nextChar2);
        if (cat != null && nextCat != cat)
          break;
        if (nextChar2 != " " || pos != range.head)
          cat = nextCat;
        pos = next;
      }
      return pos;
    });
    const deleteGroupBackward = (target) => deleteByGroup(target, false);
    const deleteGroupForward = (target) => deleteByGroup(target, true);
    const deleteToLineEnd = (view) => deleteBy(view, (range) => {
      let lineEnd = view.lineBlockAt(range.head).to;
      return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);
    });
    const deleteLineBoundaryBackward = (view) => deleteBy(view, (range) => {
      let lineStart = view.moveToLineBoundary(range, false).head;
      return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
    });
    const deleteLineBoundaryForward = (view) => deleteBy(view, (range) => {
      let lineStart = view.moveToLineBoundary(range, true).head;
      return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
    });
    const splitLine = ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      let changes = state.changeByRange((range) => {
        return {
          changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
          range: EditorSelection.cursor(range.from)
        };
      });
      dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
      return true;
    };
    const transposeChars = ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      let changes = state.changeByRange((range) => {
        if (!range.empty || range.from == 0 || range.from == state.doc.length)
          return { range };
        let pos = range.from, line = state.doc.lineAt(pos);
        let from2 = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
        let to2 = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
        return {
          changes: { from: from2, to: to2, insert: state.doc.slice(pos, to2).append(state.doc.slice(from2, pos)) },
          range: EditorSelection.cursor(to2)
        };
      });
      if (changes.changes.empty)
        return false;
      dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
      return true;
    };
    function selectedLineBlocks(state) {
      let blocks = [], upto = -1;
      for (let range of state.selection.ranges) {
        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
        if (!range.empty && range.to == endLine.from)
          endLine = state.doc.lineAt(range.to - 1);
        if (upto >= startLine.number) {
          let prev = blocks[blocks.length - 1];
          prev.to = endLine.to;
          prev.ranges.push(range);
        } else {
          blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
        }
        upto = endLine.number + 1;
      }
      return blocks;
    }
    function moveLine(state, dispatch, forward) {
      if (state.readOnly)
        return false;
      let changes = [], ranges = [];
      for (let block of selectedLineBlocks(state)) {
        if (forward ? block.to == state.doc.length : block.from == 0)
          continue;
        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
        let size = nextLine.length + 1;
        if (forward) {
          changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
          for (let r of block.ranges)
            ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
        } else {
          changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
          for (let r of block.ranges)
            ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
        }
      }
      if (!changes.length)
        return false;
      dispatch(state.update({
        changes,
        scrollIntoView: true,
        selection: EditorSelection.create(ranges, state.selection.mainIndex),
        userEvent: "move.line"
      }));
      return true;
    }
    const moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
    const moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
    function copyLine(state, dispatch, forward) {
      if (state.readOnly)
        return false;
      let changes = [];
      for (let block of selectedLineBlocks(state)) {
        if (forward)
          changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
        else
          changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
      }
      dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
      return true;
    }
    const copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
    const copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
    const deleteLine = (view) => {
      if (view.state.readOnly)
        return false;
      let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from: from2, to: to2 }) => {
        if (from2 > 0)
          from2--;
        else if (to2 < state.doc.length)
          to2++;
        return { from: from2, to: to2 };
      }));
      let selection2 = updateSel(state.selection, (range) => {
        let dist2 = void 0;
        if (view.lineWrapping) {
          let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);
          if (pos)
            dist2 = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;
        }
        return view.moveVertically(range, true, dist2);
      }).map(changes);
      view.dispatch({ changes, selection: selection2, scrollIntoView: true, userEvent: "delete.line" });
      return true;
    };
    function isBetweenBrackets(state, pos) {
      if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
        return { from: pos, to: pos };
      let context = syntaxTree(state).resolveInner(pos);
      let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
      if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from)))
        return { from: before.to, to: after.from };
      return null;
    }
    const insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
    const insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
    function newlineAndIndent(atEof) {
      return ({ state, dispatch }) => {
        if (state.readOnly)
          return false;
        let changes = state.changeByRange((range) => {
          let { from: from2, to: to2 } = range, line = state.doc.lineAt(from2);
          let explode = !atEof && from2 == to2 && isBetweenBrackets(state, from2);
          if (atEof)
            from2 = to2 = (to2 <= line.to ? line : state.doc.lineAt(to2)).to;
          let cx = new IndentContext(state, { simulateBreak: from2, simulateDoubleBreak: !!explode });
          let indent = getIndentation(cx, from2);
          if (indent == null)
            indent = countColumn(/^\s*/.exec(state.doc.lineAt(from2).text)[0], state.tabSize);
          while (to2 < line.to && /\s/.test(line.text[to2 - line.from]))
            to2++;
          if (explode)
            ({ from: from2, to: to2 } = explode);
          else if (from2 > line.from && from2 < line.from + 100 && !/\S/.test(line.text.slice(0, from2)))
            from2 = line.from;
          let insert2 = ["", indentString(state, indent)];
          if (explode)
            insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
          return {
            changes: { from: from2, to: to2, insert: Text.of(insert2) },
            range: EditorSelection.cursor(from2 + 1 + insert2[1].length)
          };
        });
        dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
        return true;
      };
    }
    function changeBySelectedLine(state, f) {
      let atLine = -1;
      return state.changeByRange((range) => {
        let changes = [];
        for (let pos = range.from; pos <= range.to; ) {
          let line = state.doc.lineAt(pos);
          if (line.number > atLine && (range.empty || range.to > line.from)) {
            f(line, changes, range);
            atLine = line.number;
          }
          pos = line.to + 1;
        }
        let changeSet = state.changes(changes);
        return {
          changes,
          range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
        };
      });
    }
    const indentSelection = ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      let updated = /* @__PURE__ */ Object.create(null);
      let context = new IndentContext(state, { overrideIndentation: (start) => {
        let found = updated[start];
        return found == null ? -1 : found;
      } });
      let changes = changeBySelectedLine(state, (line, changes2, range) => {
        let indent = getIndentation(context, line.from);
        if (indent == null)
          return;
        if (!/\S/.test(line.text))
          indent = 0;
        let cur2 = /^\s*/.exec(line.text)[0];
        let norm = indentString(state, indent);
        if (cur2 != norm || range.from < line.from + cur2.length) {
          updated[line.from] = indent;
          changes2.push({ from: line.from, to: line.from + cur2.length, insert: norm });
        }
      });
      if (!changes.changes.empty)
        dispatch(state.update(changes, { userEvent: "indent" }));
      return true;
    };
    const indentMore = ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
        changes.push({ from: line.from, insert: state.facet(indentUnit) });
      }), { userEvent: "input.indent" }));
      return true;
    };
    const indentLess = ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
        let space = /^\s*/.exec(line.text)[0];
        if (!space)
          return;
        let col = countColumn(space, state.tabSize), keep = 0;
        let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
        while (keep < space.length && keep < insert2.length && space.charCodeAt(keep) == insert2.charCodeAt(keep))
          keep++;
        changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert2.slice(keep) });
      }), { userEvent: "delete.dedent" }));
      return true;
    };
    const toggleTabFocusMode = (view) => {
      view.setTabFocusMode();
      return true;
    };
    const emacsStyleKeymap = [
      { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
      { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
      { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
      { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
      { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
      { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
      { key: "Ctrl-d", run: deleteCharForward },
      { key: "Ctrl-h", run: deleteCharBackward },
      { key: "Ctrl-k", run: deleteToLineEnd },
      { key: "Ctrl-Alt-h", run: deleteGroupBackward },
      { key: "Ctrl-o", run: splitLine },
      { key: "Ctrl-t", run: transposeChars },
      { key: "Ctrl-v", run: cursorPageDown }
    ];
    const standardKeymap = /* @__PURE__ */ [
      { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
      { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
      { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
      { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
      { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
      { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
      { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
      { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
      { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
      { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
      { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
      { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
      { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
      { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
      { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
      { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
      { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
      { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
      { key: "Enter", run: insertNewlineAndIndent, shift: insertNewlineAndIndent },
      { key: "Mod-a", run: selectAll },
      { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward, preventDefault: true },
      { key: "Delete", run: deleteCharForward, preventDefault: true },
      { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward, preventDefault: true },
      { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward, preventDefault: true },
      { mac: "Mod-Backspace", run: deleteLineBoundaryBackward, preventDefault: true },
      { mac: "Mod-Delete", run: deleteLineBoundaryForward, preventDefault: true }
    ].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
    const defaultKeymap = /* @__PURE__ */ [
      { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
      { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
      { key: "Alt-ArrowUp", run: moveLineUp },
      { key: "Shift-Alt-ArrowUp", run: copyLineUp },
      { key: "Alt-ArrowDown", run: moveLineDown },
      { key: "Shift-Alt-ArrowDown", run: copyLineDown },
      { key: "Mod-Alt-ArrowUp", run: addCursorAbove },
      { key: "Mod-Alt-ArrowDown", run: addCursorBelow },
      { key: "Escape", run: simplifySelection },
      { key: "Mod-Enter", run: insertBlankLine },
      { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
      { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
      { key: "Mod-[", run: indentLess },
      { key: "Mod-]", run: indentMore },
      { key: "Mod-Alt-\\", run: indentSelection },
      { key: "Shift-Mod-k", run: deleteLine },
      { key: "Shift-Mod-\\", run: cursorMatchingBracket },
      { key: "Mod-/", run: toggleComment },
      { key: "Alt-A", run: toggleBlockComment },
      { key: "Ctrl-m", mac: "Shift-Alt-m", run: toggleTabFocusMode }
    ].concat(standardKeymap);
    const indentWithTab = { key: "Tab", run: indentMore, shift: indentLess };
    const basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
    class SearchCursor {
      /**
      Create a text cursor. The query is the search string, `from` to
      `to` provides the region to search.
      
      When `normalize` is given, it will be called, on both the query
      string and the content it is matched against, before comparing.
      You can, for example, create a case-insensitive search by
      passing `s => s.toLowerCase()`.
      
      Text is always normalized with
      [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
      (when supported).
      */
      constructor(text, query, from2 = 0, to2 = text.length, normalize, test2) {
        this.test = test2;
        this.value = { from: 0, to: 0 };
        this.done = false;
        this.matches = [];
        this.buffer = "";
        this.bufferPos = 0;
        this.iter = text.iterRange(from2, to2);
        this.bufferStart = from2;
        this.normalize = normalize ? (x) => normalize(basicNormalize(x)) : basicNormalize;
        this.query = this.normalize(query);
      }
      peek() {
        if (this.bufferPos == this.buffer.length) {
          this.bufferStart += this.buffer.length;
          this.iter.next();
          if (this.iter.done)
            return -1;
          this.bufferPos = 0;
          this.buffer = this.iter.value;
        }
        return codePointAt(this.buffer, this.bufferPos);
      }
      /**
      Look for the next match. Updates the iterator's
      [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
      [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
      at least once before using the cursor.
      */
      next() {
        while (this.matches.length)
          this.matches.pop();
        return this.nextOverlapping();
      }
      /**
      The `next` method will ignore matches that partially overlap a
      previous match. This method behaves like `next`, but includes
      such matches.
      */
      nextOverlapping() {
        for (; ; ) {
          let next = this.peek();
          if (next < 0) {
            this.done = true;
            return this;
          }
          let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
          this.bufferPos += codePointSize(next);
          let norm = this.normalize(str);
          if (norm.length)
            for (let i2 = 0, pos = start; ; i2++) {
              let code2 = norm.charCodeAt(i2);
              let match = this.match(code2, pos, this.bufferPos + this.bufferStart);
              if (i2 == norm.length - 1) {
                if (match) {
                  this.value = match;
                  return this;
                }
                break;
              }
              if (pos == start && i2 < str.length && str.charCodeAt(i2) == code2)
                pos++;
            }
        }
      }
      match(code2, pos, end) {
        let match = null;
        for (let i2 = 0; i2 < this.matches.length; i2 += 2) {
          let index2 = this.matches[i2], keep = false;
          if (this.query.charCodeAt(index2) == code2) {
            if (index2 == this.query.length - 1) {
              match = { from: this.matches[i2 + 1], to: end };
            } else {
              this.matches[i2]++;
              keep = true;
            }
          }
          if (!keep) {
            this.matches.splice(i2, 2);
            i2 -= 2;
          }
        }
        if (this.query.charCodeAt(0) == code2) {
          if (this.query.length == 1)
            match = { from: pos, to: end };
          else
            this.matches.push(1, pos);
        }
        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))
          match = null;
        return match;
      }
    }
    if (typeof Symbol != "undefined")
      SearchCursor.prototype[Symbol.iterator] = function() {
        return this;
      };
    const empty = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") };
    const baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
    class RegExpCursor {
      /**
      Create a cursor that will search the given range in the given
      document. `query` should be the raw pattern (as you'd pass it to
      `new RegExp`).
      */
      constructor(text, query, options, from2 = 0, to2 = text.length) {
        this.text = text;
        this.to = to2;
        this.curLine = "";
        this.done = false;
        this.value = empty;
        if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
          return new MultilineRegExpCursor(text, query, options, from2, to2);
        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
        this.test = options === null || options === void 0 ? void 0 : options.test;
        this.iter = text.iter();
        let startLine = text.lineAt(from2);
        this.curLineStart = startLine.from;
        this.matchPos = toCharEnd(text, from2);
        this.getLine(this.curLineStart);
      }
      getLine(skip2) {
        this.iter.next(skip2);
        if (this.iter.lineBreak) {
          this.curLine = "";
        } else {
          this.curLine = this.iter.value;
          if (this.curLineStart + this.curLine.length > this.to)
            this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
          this.iter.next();
        }
      }
      nextLine() {
        this.curLineStart = this.curLineStart + this.curLine.length + 1;
        if (this.curLineStart > this.to)
          this.curLine = "";
        else
          this.getLine(0);
      }
      /**
      Move to the next match, if there is one.
      */
      next() {
        for (let off = this.matchPos - this.curLineStart; ; ) {
          this.re.lastIndex = off;
          let match = this.matchPos <= this.to && this.re.exec(this.curLine);
          if (match) {
            let from2 = this.curLineStart + match.index, to2 = from2 + match[0].length;
            this.matchPos = toCharEnd(this.text, to2 + (from2 == to2 ? 1 : 0));
            if (from2 == this.curLineStart + this.curLine.length)
              this.nextLine();
            if ((from2 < to2 || from2 > this.value.to) && (!this.test || this.test(from2, to2, match))) {
              this.value = { from: from2, to: to2, match };
              return this;
            }
            off = this.matchPos - this.curLineStart;
          } else if (this.curLineStart + this.curLine.length < this.to) {
            this.nextLine();
            off = 0;
          } else {
            this.done = true;
            return this;
          }
        }
      }
    }
    const flattened = /* @__PURE__ */ new WeakMap();
    class FlattenedDoc {
      constructor(from2, text) {
        this.from = from2;
        this.text = text;
      }
      get to() {
        return this.from + this.text.length;
      }
      static get(doc2, from2, to2) {
        let cached = flattened.get(doc2);
        if (!cached || cached.from >= to2 || cached.to <= from2) {
          let flat = new FlattenedDoc(from2, doc2.sliceString(from2, to2));
          flattened.set(doc2, flat);
          return flat;
        }
        if (cached.from == from2 && cached.to == to2)
          return cached;
        let { text, from: cachedFrom } = cached;
        if (cachedFrom > from2) {
          text = doc2.sliceString(from2, cachedFrom) + text;
          cachedFrom = from2;
        }
        if (cached.to < to2)
          text += doc2.sliceString(cached.to, to2);
        flattened.set(doc2, new FlattenedDoc(cachedFrom, text));
        return new FlattenedDoc(from2, text.slice(from2 - cachedFrom, to2 - cachedFrom));
      }
    }
    class MultilineRegExpCursor {
      constructor(text, query, options, from2, to2) {
        this.text = text;
        this.to = to2;
        this.done = false;
        this.value = empty;
        this.matchPos = toCharEnd(text, from2);
        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
        this.test = options === null || options === void 0 ? void 0 : options.test;
        this.flat = FlattenedDoc.get(text, from2, this.chunkEnd(
          from2 + 5e3
          /* Chunk.Base */
        ));
      }
      chunkEnd(pos) {
        return pos >= this.to ? this.to : this.text.lineAt(pos).to;
      }
      next() {
        for (; ; ) {
          let off = this.re.lastIndex = this.matchPos - this.flat.from;
          let match = this.re.exec(this.flat.text);
          if (match && !match[0] && match.index == off) {
            this.re.lastIndex = off + 1;
            match = this.re.exec(this.flat.text);
          }
          if (match) {
            let from2 = this.flat.from + match.index, to2 = from2 + match[0].length;
            if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from2, to2, match))) {
              this.value = { from: from2, to: to2, match };
              this.matchPos = toCharEnd(this.text, to2 + (from2 == to2 ? 1 : 0));
              return this;
            }
          }
          if (this.flat.to == this.to) {
            this.done = true;
            return this;
          }
          this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
        }
      }
    }
    if (typeof Symbol != "undefined") {
      RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
        return this;
      };
    }
    function validRegExp(source2) {
      try {
        new RegExp(source2, baseFlags);
        return true;
      } catch (_a2) {
        return false;
      }
    }
    function toCharEnd(text, pos) {
      if (pos >= text.length)
        return pos;
      let line = text.lineAt(pos), next;
      while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
        pos++;
      return pos;
    }
    function createLineDialog(view) {
      let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);
      let input = crelt("input", { class: "cm-textfield", name: "line", value: line });
      let dom = crelt("form", {
        class: "cm-gotoLine",
        onkeydown: (event) => {
          if (event.keyCode == 27) {
            event.preventDefault();
            view.dispatch({ effects: dialogEffect.of(false) });
            view.focus();
          } else if (event.keyCode == 13) {
            event.preventDefault();
            go();
          }
        },
        onsubmit: (event) => {
          event.preventDefault();
          go();
        }
      }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")), crelt("button", {
        name: "close",
        onclick: () => {
          view.dispatch({ effects: dialogEffect.of(false) });
          view.focus();
        },
        "aria-label": view.state.phrase("close"),
        type: "button"
      }, [""]));
      function go() {
        let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
        if (!match)
          return;
        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
        let [, sign2, ln, cl, percent] = match;
        let col = cl ? +cl.slice(1) : 0;
        let line2 = ln ? +ln : startLine.number;
        if (ln && percent) {
          let pc = line2 / 100;
          if (sign2)
            pc = pc * (sign2 == "-" ? -1 : 1) + startLine.number / state.doc.lines;
          line2 = Math.round(state.doc.lines * pc);
        } else if (ln && sign2) {
          line2 = line2 * (sign2 == "-" ? -1 : 1) + startLine.number;
        }
        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line2)));
        let selection2 = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
        view.dispatch({
          effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection2.from, { y: "center" })],
          selection: selection2
        });
        view.focus();
      }
      return { dom };
    }
    const dialogEffect = /* @__PURE__ */ StateEffect.define();
    const dialogField = /* @__PURE__ */ StateField.define({
      create() {
        return true;
      },
      update(value, tr) {
        for (let e of tr.effects)
          if (e.is(dialogEffect))
            value = e.value;
        return value;
      },
      provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
    });
    const gotoLine = (view) => {
      let panel = getPanel(view, createLineDialog);
      if (!panel) {
        let effects2 = [dialogEffect.of(true)];
        if (view.state.field(dialogField, false) == null)
          effects2.push(StateEffect.appendConfig.of([dialogField, baseTheme$1$1]));
        view.dispatch({ effects: effects2 });
        panel = getPanel(view, createLineDialog);
      }
      if (panel)
        panel.dom.querySelector("input").select();
      return true;
    };
    const baseTheme$1$1 = /* @__PURE__ */ EditorView.baseTheme({
      ".cm-panel.cm-gotoLine": {
        padding: "2px 6px 4px",
        position: "relative",
        "& label": { fontSize: "80%" },
        "& [name=close]": {
          position: "absolute",
          top: "0",
          bottom: "0",
          right: "4px",
          backgroundColor: "inherit",
          border: "none",
          font: "inherit",
          padding: "0"
        }
      }
    });
    const defaultHighlightOptions = {
      highlightWordAroundCursor: false,
      minSelectionLength: 1,
      maxMatches: 100,
      wholeWords: false
    };
    const highlightConfig = /* @__PURE__ */ Facet.define({
      combine(options) {
        return combineConfig(options, defaultHighlightOptions, {
          highlightWordAroundCursor: (a, b) => a || b,
          minSelectionLength: Math.min,
          maxMatches: Math.min
        });
      }
    });
    function highlightSelectionMatches(options) {
      let ext = [defaultTheme, matchHighlighter];
      return ext;
    }
    const matchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch" });
    const mainMatchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
    function insideWordBoundaries(check, state, from2, to2) {
      return (from2 == 0 || check(state.sliceDoc(from2 - 1, from2)) != CharCategory.Word) && (to2 == state.doc.length || check(state.sliceDoc(to2, to2 + 1)) != CharCategory.Word);
    }
    function insideWord(check, state, from2, to2) {
      return check(state.sliceDoc(from2, from2 + 1)) == CharCategory.Word && check(state.sliceDoc(to2 - 1, to2)) == CharCategory.Word;
    }
    const matchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
      constructor(view) {
        this.decorations = this.getDeco(view);
      }
      update(update) {
        if (update.selectionSet || update.docChanged || update.viewportChanged)
          this.decorations = this.getDeco(update.view);
      }
      getDeco(view) {
        let conf = view.state.facet(highlightConfig);
        let { state } = view, sel = state.selection;
        if (sel.ranges.length > 1)
          return Decoration.none;
        let range = sel.main, query, check = null;
        if (range.empty) {
          if (!conf.highlightWordAroundCursor)
            return Decoration.none;
          let word = state.wordAt(range.head);
          if (!word)
            return Decoration.none;
          check = state.charCategorizer(range.head);
          query = state.sliceDoc(word.from, word.to);
        } else {
          let len = range.to - range.from;
          if (len < conf.minSelectionLength || len > 200)
            return Decoration.none;
          if (conf.wholeWords) {
            query = state.sliceDoc(range.from, range.to);
            check = state.charCategorizer(range.head);
            if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to)))
              return Decoration.none;
          } else {
            query = state.sliceDoc(range.from, range.to);
            if (!query)
              return Decoration.none;
          }
        }
        let deco = [];
        for (let part of view.visibleRanges) {
          let cursor2 = new SearchCursor(state.doc, query, part.from, part.to);
          while (!cursor2.next().done) {
            let { from: from2, to: to2 } = cursor2.value;
            if (!check || insideWordBoundaries(check, state, from2, to2)) {
              if (range.empty && from2 <= range.from && to2 >= range.to)
                deco.push(mainMatchDeco.range(from2, to2));
              else if (from2 >= range.to || to2 <= range.from)
                deco.push(matchDeco.range(from2, to2));
              if (deco.length > conf.maxMatches)
                return Decoration.none;
            }
          }
        }
        return Decoration.set(deco);
      }
    }, {
      decorations: (v) => v.decorations
    });
    const defaultTheme = /* @__PURE__ */ EditorView.baseTheme({
      ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
      ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
    });
    const selectWord = ({ state, dispatch }) => {
      let { selection: selection2 } = state;
      let newSel = EditorSelection.create(selection2.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection2.mainIndex);
      if (newSel.eq(selection2))
        return false;
      dispatch(state.update({ selection: newSel }));
      return true;
    };
    function findNextOccurrence(state, query) {
      let { main, ranges } = state.selection;
      let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
      for (let cycled = false, cursor2 = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
        cursor2.next();
        if (cursor2.done) {
          if (cycled)
            return null;
          cursor2 = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
          cycled = true;
        } else {
          if (cycled && ranges.some((r) => r.from == cursor2.value.from))
            continue;
          if (fullWord) {
            let word2 = state.wordAt(cursor2.value.from);
            if (!word2 || word2.from != cursor2.value.from || word2.to != cursor2.value.to)
              continue;
          }
          return cursor2.value;
        }
      }
    }
    const selectNextOccurrence = ({ state, dispatch }) => {
      let { ranges } = state.selection;
      if (ranges.some((sel) => sel.from === sel.to))
        return selectWord({ state, dispatch });
      let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
      if (state.selection.ranges.some((r) => state.sliceDoc(r.from, r.to) != searchedText))
        return false;
      let range = findNextOccurrence(state, searchedText);
      if (!range)
        return false;
      dispatch(state.update({
        selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
        effects: EditorView.scrollIntoView(range.to)
      }));
      return true;
    };
    const searchConfigFacet = /* @__PURE__ */ Facet.define({
      combine(configs) {
        return combineConfig(configs, {
          top: false,
          caseSensitive: false,
          literal: false,
          regexp: false,
          wholeWord: false,
          createPanel: (view) => new SearchPanel(view),
          scrollToMatch: (range) => EditorView.scrollIntoView(range)
        });
      }
    });
    function search(config2) {
      return config2 ? [searchConfigFacet.of(config2), searchExtensions] : searchExtensions;
    }
    class SearchQuery {
      /**
      Create a query object.
      */
      constructor(config2) {
        this.search = config2.search;
        this.caseSensitive = !!config2.caseSensitive;
        this.literal = !!config2.literal;
        this.regexp = !!config2.regexp;
        this.replace = config2.replace || "";
        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
        this.unquoted = this.unquote(this.search);
        this.wholeWord = !!config2.wholeWord;
      }
      /**
      @internal
      */
      unquote(text) {
        return this.literal ? text : text.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
      }
      /**
      Compare this query to another query.
      */
      eq(other) {
        return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
      }
      /**
      @internal
      */
      create() {
        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
      }
      /**
      Get a search cursor for this query, searching through the given
      range in the given state.
      */
      getCursor(state, from2 = 0, to2) {
        let st = state.doc ? state : EditorState.create({ doc: state });
        if (to2 == null)
          to2 = st.doc.length;
        return this.regexp ? regexpCursor(this, st, from2, to2) : stringCursor(this, st, from2, to2);
      }
    }
    class QueryType {
      constructor(spec) {
        this.spec = spec;
      }
    }
    function stringCursor(spec, state, from2, to2) {
      return new SearchCursor(state.doc, spec.unquoted, from2, to2, spec.caseSensitive ? void 0 : (x) => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
    }
    function stringWordTest(doc2, categorizer) {
      return (from2, to2, buf, bufPos) => {
        if (bufPos > from2 || bufPos + buf.length < to2) {
          bufPos = Math.max(0, from2 - 2);
          buf = doc2.sliceString(bufPos, Math.min(doc2.length, to2 + 2));
        }
        return (categorizer(charBefore(buf, from2 - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from2 - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to2 - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to2 - bufPos)) != CharCategory.Word);
      };
    }
    class StringQuery extends QueryType {
      constructor(spec) {
        super(spec);
      }
      nextMatch(state, curFrom, curTo) {
        let cursor2 = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
        if (cursor2.done) {
          let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);
          cursor2 = stringCursor(this.spec, state, 0, end).nextOverlapping();
        }
        return cursor2.done || cursor2.value.from == curFrom && cursor2.value.to == curTo ? null : cursor2.value;
      }
      // Searching in reverse is, rather than implementing an inverted search
      // cursor, done by scanning chunk after chunk forward.
      prevMatchInRange(state, from2, to2) {
        for (let pos = to2; ; ) {
          let start = Math.max(from2, pos - 1e4 - this.spec.unquoted.length);
          let cursor2 = stringCursor(this.spec, state, start, pos), range = null;
          while (!cursor2.nextOverlapping().done)
            range = cursor2.value;
          if (range)
            return range;
          if (start == from2)
            return null;
          pos -= 1e4;
        }
      }
      prevMatch(state, curFrom, curTo) {
        let found = this.prevMatchInRange(state, 0, curFrom);
        if (!found)
          found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);
        return found && (found.from != curFrom || found.to != curTo) ? found : null;
      }
      getReplacement(_result) {
        return this.spec.unquote(this.spec.replace);
      }
      matchAll(state, limit) {
        let cursor2 = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
        while (!cursor2.next().done) {
          if (ranges.length >= limit)
            return null;
          ranges.push(cursor2.value);
        }
        return ranges;
      }
      highlight(state, from2, to2, add2) {
        let cursor2 = stringCursor(this.spec, state, Math.max(0, from2 - this.spec.unquoted.length), Math.min(to2 + this.spec.unquoted.length, state.doc.length));
        while (!cursor2.next().done)
          add2(cursor2.value.from, cursor2.value.to);
      }
    }
    function regexpCursor(spec, state, from2, to2) {
      return new RegExpCursor(state.doc, spec.search, {
        ignoreCase: !spec.caseSensitive,
        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
      }, from2, to2);
    }
    function charBefore(str, index2) {
      return str.slice(findClusterBreak(str, index2, false), index2);
    }
    function charAfter(str, index2) {
      return str.slice(index2, findClusterBreak(str, index2));
    }
    function regexpWordTest(categorizer) {
      return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
    }
    class RegExpQuery extends QueryType {
      nextMatch(state, curFrom, curTo) {
        let cursor2 = regexpCursor(this.spec, state, curTo, state.doc.length).next();
        if (cursor2.done)
          cursor2 = regexpCursor(this.spec, state, 0, curFrom).next();
        return cursor2.done ? null : cursor2.value;
      }
      prevMatchInRange(state, from2, to2) {
        for (let size = 1; ; size++) {
          let start = Math.max(
            from2,
            to2 - size * 1e4
            /* FindPrev.ChunkSize */
          );
          let cursor2 = regexpCursor(this.spec, state, start, to2), range = null;
          while (!cursor2.next().done)
            range = cursor2.value;
          if (range && (start == from2 || range.from > start + 10))
            return range;
          if (start == from2)
            return null;
        }
      }
      prevMatch(state, curFrom, curTo) {
        return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
      }
      getReplacement(result) {
        return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (m, i2) => {
          if (i2 == "&")
            return result.match[0];
          if (i2 == "$")
            return "$";
          for (let l = i2.length; l > 0; l--) {
            let n = +i2.slice(0, l);
            if (n > 0 && n < result.match.length)
              return result.match[n] + i2.slice(l);
          }
          return m;
        });
      }
      matchAll(state, limit) {
        let cursor2 = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
        while (!cursor2.next().done) {
          if (ranges.length >= limit)
            return null;
          ranges.push(cursor2.value);
        }
        return ranges;
      }
      highlight(state, from2, to2, add2) {
        let cursor2 = regexpCursor(this.spec, state, Math.max(
          0,
          from2 - 250
          /* RegExp.HighlightMargin */
        ), Math.min(to2 + 250, state.doc.length));
        while (!cursor2.next().done)
          add2(cursor2.value.from, cursor2.value.to);
      }
    }
    const setSearchQuery = /* @__PURE__ */ StateEffect.define();
    const togglePanel$1 = /* @__PURE__ */ StateEffect.define();
    const searchState = /* @__PURE__ */ StateField.define({
      create(state) {
        return new SearchState(defaultQuery(state).create(), null);
      },
      update(value, tr) {
        for (let effect of tr.effects) {
          if (effect.is(setSearchQuery))
            value = new SearchState(effect.value.create(), value.panel);
          else if (effect.is(togglePanel$1))
            value = new SearchState(value.query, effect.value ? createSearchPanel : null);
        }
        return value;
      },
      provide: (f) => showPanel.from(f, (val) => val.panel)
    });
    class SearchState {
      constructor(query, panel) {
        this.query = query;
        this.panel = panel;
      }
    }
    const matchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch" }), selectedMatchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
    const searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.decorations = this.highlight(view.state.field(searchState));
      }
      update(update) {
        let state = update.state.field(searchState);
        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
          this.decorations = this.highlight(state);
      }
      highlight({ query, panel }) {
        if (!panel || !query.spec.valid)
          return Decoration.none;
        let { view } = this;
        let builder = new RangeSetBuilder();
        for (let i2 = 0, ranges = view.visibleRanges, l = ranges.length; i2 < l; i2++) {
          let { from: from2, to: to2 } = ranges[i2];
          while (i2 < l - 1 && to2 > ranges[i2 + 1].from - 2 * 250)
            to2 = ranges[++i2].to;
          query.highlight(view.state, from2, to2, (from3, to3) => {
            let selected = view.state.selection.ranges.some((r) => r.from == from3 && r.to == to3);
            builder.add(from3, to3, selected ? selectedMatchMark : matchMark);
          });
        }
        return builder.finish();
      }
    }, {
      decorations: (v) => v.decorations
    });
    function searchCommand(f) {
      return (view) => {
        let state = view.state.field(searchState, false);
        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
      };
    }
    const findNext = /* @__PURE__ */ searchCommand((view, { query }) => {
      let { to: to2 } = view.state.selection.main;
      let next = query.nextMatch(view.state, to2, to2);
      if (!next)
        return false;
      let selection2 = EditorSelection.single(next.from, next.to);
      let config2 = view.state.facet(searchConfigFacet);
      view.dispatch({
        selection: selection2,
        effects: [announceMatch(view, next), config2.scrollToMatch(selection2.main, view)],
        userEvent: "select.search"
      });
      selectSearchInput(view);
      return true;
    });
    const findPrevious = /* @__PURE__ */ searchCommand((view, { query }) => {
      let { state } = view, { from: from2 } = state.selection.main;
      let prev = query.prevMatch(state, from2, from2);
      if (!prev)
        return false;
      let selection2 = EditorSelection.single(prev.from, prev.to);
      let config2 = view.state.facet(searchConfigFacet);
      view.dispatch({
        selection: selection2,
        effects: [announceMatch(view, prev), config2.scrollToMatch(selection2.main, view)],
        userEvent: "select.search"
      });
      selectSearchInput(view);
      return true;
    });
    const selectMatches = /* @__PURE__ */ searchCommand((view, { query }) => {
      let ranges = query.matchAll(view.state, 1e3);
      if (!ranges || !ranges.length)
        return false;
      view.dispatch({
        selection: EditorSelection.create(ranges.map((r) => EditorSelection.range(r.from, r.to))),
        userEvent: "select.search.matches"
      });
      return true;
    });
    const selectSelectionMatches = ({ state, dispatch }) => {
      let sel = state.selection;
      if (sel.ranges.length > 1 || sel.main.empty)
        return false;
      let { from: from2, to: to2 } = sel.main;
      let ranges = [], main = 0;
      for (let cur2 = new SearchCursor(state.doc, state.sliceDoc(from2, to2)); !cur2.next().done; ) {
        if (ranges.length > 1e3)
          return false;
        if (cur2.value.from == from2)
          main = ranges.length;
        ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
      }
      dispatch(state.update({
        selection: EditorSelection.create(ranges, main),
        userEvent: "select.search.matches"
      }));
      return true;
    };
    const replaceNext = /* @__PURE__ */ searchCommand((view, { query }) => {
      let { state } = view, { from: from2, to: to2 } = state.selection.main;
      if (state.readOnly)
        return false;
      let match = query.nextMatch(state, from2, from2);
      if (!match)
        return false;
      let next = match;
      let changes = [], selection2, replacement;
      let effects2 = [];
      if (next.from == from2 && next.to == to2) {
        replacement = state.toText(query.getReplacement(next));
        changes.push({ from: next.from, to: next.to, insert: replacement });
        next = query.nextMatch(state, next.from, next.to);
        effects2.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from2).number) + "."));
      }
      let changeSet = view.state.changes(changes);
      if (next) {
        selection2 = EditorSelection.single(next.from, next.to).map(changeSet);
        effects2.push(announceMatch(view, next));
        effects2.push(state.facet(searchConfigFacet).scrollToMatch(selection2.main, view));
      }
      view.dispatch({
        changes: changeSet,
        selection: selection2,
        effects: effects2,
        userEvent: "input.replace"
      });
      return true;
    });
    const replaceAll = /* @__PURE__ */ searchCommand((view, { query }) => {
      if (view.state.readOnly)
        return false;
      let changes = query.matchAll(view.state, 1e9).map((match) => {
        let { from: from2, to: to2 } = match;
        return { from: from2, to: to2, insert: query.getReplacement(match) };
      });
      if (!changes.length)
        return false;
      let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
      view.dispatch({
        changes,
        effects: EditorView.announce.of(announceText),
        userEvent: "input.replace.all"
      });
      return true;
    });
    function createSearchPanel(view) {
      return view.state.facet(searchConfigFacet).createPanel(view);
    }
    function defaultQuery(state, fallback) {
      var _a2, _b, _c, _d, _e;
      let sel = state.selection.main;
      let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
      if (fallback && !selText)
        return fallback;
      let config2 = state.facet(searchConfigFacet);
      return new SearchQuery({
        search: ((_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a2 !== void 0 ? _a2 : config2.literal) ? selText : selText.replace(/\n/g, "\\n"),
        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config2.caseSensitive,
        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config2.literal,
        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config2.regexp,
        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config2.wholeWord
      });
    }
    function getSearchInput(view) {
      let panel = getPanel(view, createSearchPanel);
      return panel && panel.dom.querySelector("[main-field]");
    }
    function selectSearchInput(view) {
      let input = getSearchInput(view);
      if (input && input == view.root.activeElement)
        input.select();
    }
    const openSearchPanel = (view) => {
      let state = view.state.field(searchState, false);
      if (state && state.panel) {
        let searchInput2 = getSearchInput(view);
        if (searchInput2 && searchInput2 != view.root.activeElement) {
          let query = defaultQuery(view.state, state.query.spec);
          if (query.valid)
            view.dispatch({ effects: setSearchQuery.of(query) });
          searchInput2.focus();
          searchInput2.select();
        }
      } else {
        view.dispatch({ effects: [
          togglePanel$1.of(true),
          state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
        ] });
      }
      return true;
    };
    const closeSearchPanel = (view) => {
      let state = view.state.field(searchState, false);
      if (!state || !state.panel)
        return false;
      let panel = getPanel(view, createSearchPanel);
      if (panel && panel.dom.contains(view.root.activeElement))
        view.focus();
      view.dispatch({ effects: togglePanel$1.of(false) });
      return true;
    };
    const searchKeymap = [
      { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
      { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
      { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
      { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
      { key: "Mod-Shift-l", run: selectSelectionMatches },
      { key: "Mod-Alt-g", run: gotoLine },
      { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
    ];
    class SearchPanel {
      constructor(view) {
        this.view = view;
        let query = this.query = view.state.field(searchState).query.spec;
        this.commit = this.commit.bind(this);
        this.searchField = crelt("input", {
          value: query.search,
          placeholder: phrase(view, "Find"),
          "aria-label": phrase(view, "Find"),
          class: "cm-textfield",
          name: "search",
          form: "",
          "main-field": "true",
          onchange: this.commit,
          onkeyup: this.commit
        });
        this.replaceField = crelt("input", {
          value: query.replace,
          placeholder: phrase(view, "Replace"),
          "aria-label": phrase(view, "Replace"),
          class: "cm-textfield",
          name: "replace",
          form: "",
          onchange: this.commit,
          onkeyup: this.commit
        });
        this.caseField = crelt("input", {
          type: "checkbox",
          name: "case",
          form: "",
          checked: query.caseSensitive,
          onchange: this.commit
        });
        this.reField = crelt("input", {
          type: "checkbox",
          name: "re",
          form: "",
          checked: query.regexp,
          onchange: this.commit
        });
        this.wordField = crelt("input", {
          type: "checkbox",
          name: "word",
          form: "",
          checked: query.wholeWord,
          onchange: this.commit
        });
        function button(name2, onclick, content2) {
          return crelt("button", { class: "cm-button", name: name2, onclick, type: "button" }, content2);
        }
        this.dom = crelt("div", { onkeydown: (e) => this.keydown(e), class: "cm-search" }, [
          this.searchField,
          button("next", () => findNext(view), [phrase(view, "next")]),
          button("prev", () => findPrevious(view), [phrase(view, "previous")]),
          button("select", () => selectMatches(view), [phrase(view, "all")]),
          crelt("label", null, [this.caseField, phrase(view, "match case")]),
          crelt("label", null, [this.reField, phrase(view, "regexp")]),
          crelt("label", null, [this.wordField, phrase(view, "by word")]),
          ...view.state.readOnly ? [] : [
            crelt("br"),
            this.replaceField,
            button("replace", () => replaceNext(view), [phrase(view, "replace")]),
            button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
          ],
          crelt("button", {
            name: "close",
            onclick: () => closeSearchPanel(view),
            "aria-label": phrase(view, "close"),
            type: "button"
          }, [""])
        ]);
      }
      commit() {
        let query = new SearchQuery({
          search: this.searchField.value,
          caseSensitive: this.caseField.checked,
          regexp: this.reField.checked,
          wholeWord: this.wordField.checked,
          replace: this.replaceField.value
        });
        if (!query.eq(this.query)) {
          this.query = query;
          this.view.dispatch({ effects: setSearchQuery.of(query) });
        }
      }
      keydown(e) {
        if (runScopeHandlers(this.view, e, "search-panel")) {
          e.preventDefault();
        } else if (e.keyCode == 13 && e.target == this.searchField) {
          e.preventDefault();
          (e.shiftKey ? findPrevious : findNext)(this.view);
        } else if (e.keyCode == 13 && e.target == this.replaceField) {
          e.preventDefault();
          replaceNext(this.view);
        }
      }
      update(update) {
        for (let tr of update.transactions)
          for (let effect of tr.effects) {
            if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
              this.setQuery(effect.value);
          }
      }
      setQuery(query) {
        this.query = query;
        this.searchField.value = query.search;
        this.replaceField.value = query.replace;
        this.caseField.checked = query.caseSensitive;
        this.reField.checked = query.regexp;
        this.wordField.checked = query.wholeWord;
      }
      mount() {
        this.searchField.select();
      }
      get pos() {
        return 80;
      }
      get top() {
        return this.view.state.facet(searchConfigFacet).top;
      }
    }
    function phrase(view, phrase2) {
      return view.state.phrase(phrase2);
    }
    const AnnounceMargin = 30;
    const Break = /[\s\.,:;?!]/;
    function announceMatch(view, { from: from2, to: to2 }) {
      let line = view.state.doc.lineAt(from2), lineEnd = view.state.doc.lineAt(to2).to;
      let start = Math.max(line.from, from2 - AnnounceMargin), end = Math.min(lineEnd, to2 + AnnounceMargin);
      let text = view.state.sliceDoc(start, end);
      if (start != line.from) {
        for (let i2 = 0; i2 < AnnounceMargin; i2++)
          if (!Break.test(text[i2 + 1]) && Break.test(text[i2])) {
            text = text.slice(i2);
            break;
          }
      }
      if (end != lineEnd) {
        for (let i2 = text.length - 1; i2 > text.length - AnnounceMargin; i2--)
          if (!Break.test(text[i2 - 1]) && Break.test(text[i2])) {
            text = text.slice(0, i2);
            break;
          }
      }
      return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
    }
    const baseTheme$2 = /* @__PURE__ */ EditorView.baseTheme({
      ".cm-panel.cm-search": {
        padding: "2px 6px 4px",
        position: "relative",
        "& [name=close]": {
          position: "absolute",
          top: "0",
          right: "4px",
          backgroundColor: "inherit",
          border: "none",
          font: "inherit",
          padding: 0,
          margin: 0
        },
        "& input, & button, & label": {
          margin: ".2em .6em .2em 0"
        },
        "& input[type=checkbox]": {
          marginRight: ".2em"
        },
        "& label": {
          fontSize: "80%",
          whiteSpace: "pre"
        }
      },
      "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
      "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
      "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
      "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
    });
    const searchExtensions = [
      searchState,
      /* @__PURE__ */ Prec.low(searchHighlighter),
      baseTheme$2
    ];
    class CompletionContext {
      /**
      Create a new completion context. (Mostly useful for testing
      completion sourcesin the editor, the extension will create
      these for you.)
      */
      constructor(state, pos, explicit, view) {
        this.state = state;
        this.pos = pos;
        this.explicit = explicit;
        this.view = view;
        this.abortListeners = [];
        this.abortOnDocChange = false;
      }
      /**
      Get the extent, content, and (if there is a token) type of the
      token before `this.pos`.
      */
      tokenBefore(types2) {
        let token = syntaxTree(this.state).resolveInner(this.pos, -1);
        while (token && types2.indexOf(token.name) < 0)
          token = token.parent;
        return token ? {
          from: token.from,
          to: this.pos,
          text: this.state.sliceDoc(token.from, this.pos),
          type: token.type
        } : null;
      }
      /**
      Get the match of the given expression directly before the
      cursor.
      */
      matchBefore(expr) {
        let line = this.state.doc.lineAt(this.pos);
        let start = Math.max(line.from, this.pos - 250);
        let str = line.text.slice(start - line.from, this.pos - line.from);
        let found = str.search(ensureAnchor(expr, false));
        return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
      }
      /**
      Yields true when the query has been aborted. Can be useful in
      asynchronous queries to avoid doing work that will be ignored.
      */
      get aborted() {
        return this.abortListeners == null;
      }
      /**
      Allows you to register abort handlers, which will be called when
      the query is
      [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
      
      By default, running queries will not be aborted for regular
      typing or backspacing, on the assumption that they are likely to
      return a result with a
      [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
      allows the result to be used after all. Passing `onDocChange:
      true` will cause this query to be aborted for any document
      change.
      */
      addEventListener(type, listener, options) {
        if (type == "abort" && this.abortListeners) {
          this.abortListeners.push(listener);
          if (options && options.onDocChange)
            this.abortOnDocChange = true;
        }
      }
    }
    function toSet(chars2) {
      let flat = Object.keys(chars2).join("");
      let words = /\w/.test(flat);
      if (words)
        flat = flat.replace(/\w/g, "");
      return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
    }
    function prefixMatch(options) {
      let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
      for (let { label } of options) {
        first[label[0]] = true;
        for (let i2 = 1; i2 < label.length; i2++)
          rest[label[i2]] = true;
      }
      let source2 = toSet(first) + toSet(rest) + "*$";
      return [new RegExp("^" + source2), new RegExp(source2)];
    }
    function completeFromList(list) {
      let options = list.map((o) => typeof o == "string" ? { label: o } : o);
      let [validFor, match] = options.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
      return (context) => {
        let token = context.matchBefore(match);
        return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;
      };
    }
    class Option {
      constructor(completion, source2, match, score2) {
        this.completion = completion;
        this.source = source2;
        this.match = match;
        this.score = score2;
      }
    }
    function cur(state) {
      return state.selection.main.from;
    }
    function ensureAnchor(expr, start) {
      var _a2;
      let { source: source2 } = expr;
      let addStart = start && source2[0] != "^", addEnd = source2[source2.length - 1] != "$";
      if (!addStart && !addEnd)
        return expr;
      return new RegExp(`${addStart ? "^" : ""}(?:${source2})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
    }
    const pickedCompletion = /* @__PURE__ */ Annotation.define();
    function insertCompletionText(state, text, from2, to2) {
      let { main } = state.selection, fromOff = from2 - main.from, toOff = to2 - main.from;
      return __spreadProps(__spreadValues({}, state.changeByRange((range) => {
        if (range != main && from2 != to2 && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from2, to2))
          return { range };
        let lines = state.toText(text);
        return {
          changes: { from: range.from + fromOff, to: to2 == main.from ? range.to : range.from + toOff, insert: lines },
          range: EditorSelection.cursor(range.from + fromOff + lines.length)
        };
      })), {
        scrollIntoView: true,
        userEvent: "input.complete"
      });
    }
    const SourceCache = /* @__PURE__ */ new WeakMap();
    function asSource(source2) {
      if (!Array.isArray(source2))
        return source2;
      let known = SourceCache.get(source2);
      if (!known)
        SourceCache.set(source2, known = completeFromList(source2));
      return known;
    }
    const startCompletionEffect = /* @__PURE__ */ StateEffect.define();
    const closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
    class FuzzyMatcher {
      constructor(pattern) {
        this.pattern = pattern;
        this.chars = [];
        this.folded = [];
        this.any = [];
        this.precise = [];
        this.byWord = [];
        this.score = 0;
        this.matched = [];
        for (let p = 0; p < pattern.length; ) {
          let char = codePointAt(pattern, p), size = codePointSize(char);
          this.chars.push(char);
          let part = pattern.slice(p, p + size), upper = part.toUpperCase();
          this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
          p += size;
        }
        this.astral = pattern.length != this.chars.length;
      }
      ret(score2, matched) {
        this.score = score2;
        this.matched = matched;
        return this;
      }
      // Matches a given word (completion) against the pattern (input).
      // Will return a boolean indicating whether there was a match and,
      // on success, set `this.score` to the score, `this.matched` to an
      // array of `from, to` pairs indicating the matched parts of `word`.
      //
      // The score is a number that is more negative the worse the match
      // is. See `Penalty` above.
      match(word) {
        if (this.pattern.length == 0)
          return this.ret(-100, []);
        if (word.length < this.pattern.length)
          return null;
        let { chars: chars2, folded, any, precise, byWord } = this;
        if (chars2.length == 1) {
          let first = codePointAt(word, 0), firstSize = codePointSize(first);
          let score2 = firstSize == word.length ? 0 : -100;
          if (first == chars2[0]) ;
          else if (first == folded[0])
            score2 += -200;
          else
            return null;
          return this.ret(score2, [0, firstSize]);
        }
        let direct = word.indexOf(this.pattern);
        if (direct == 0)
          return this.ret(word.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
        let len = chars2.length, anyTo = 0;
        if (direct < 0) {
          for (let i2 = 0, e = Math.min(word.length, 200); i2 < e && anyTo < len; ) {
            let next = codePointAt(word, i2);
            if (next == chars2[anyTo] || next == folded[anyTo])
              any[anyTo++] = i2;
            i2 += codePointSize(next);
          }
          if (anyTo < len)
            return null;
        }
        let preciseTo = 0;
        let byWordTo = 0, byWordFolded = false;
        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
        let hasLower = /[a-z]/.test(word), wordAdjacent = true;
        for (let i2 = 0, e = Math.min(word.length, 200), prevType = 0; i2 < e && byWordTo < len; ) {
          let next = codePointAt(word, i2);
          if (direct < 0) {
            if (preciseTo < len && next == chars2[preciseTo])
              precise[preciseTo++] = i2;
            if (adjacentTo < len) {
              if (next == chars2[adjacentTo] || next == folded[adjacentTo]) {
                if (adjacentTo == 0)
                  adjacentStart = i2;
                adjacentEnd = i2 + 1;
                adjacentTo++;
              } else {
                adjacentTo = 0;
              }
            }
          }
          let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
          if (!i2 || type == 1 && hasLower || prevType == 0 && type != 0) {
            if (chars2[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
              byWord[byWordTo++] = i2;
            else if (byWord.length)
              wordAdjacent = false;
          }
          prevType = type;
          i2 += codePointSize(next);
        }
        if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
          return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
        if (adjacentTo == len && adjacentStart == 0)
          return this.ret(-200 - word.length + (adjacentEnd == word.length ? 0 : -100), [0, adjacentEnd]);
        if (direct > -1)
          return this.ret(-700 - word.length, [direct, direct + this.pattern.length]);
        if (adjacentTo == len)
          return this.ret(-200 + -700 - word.length, [adjacentStart, adjacentEnd]);
        if (byWordTo == len)
          return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
        return chars2.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
      }
      result(score2, positions2, word) {
        let result = [], i2 = 0;
        for (let pos of positions2) {
          let to2 = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
          if (i2 && result[i2 - 1] == pos)
            result[i2 - 1] = to2;
          else {
            result[i2++] = pos;
            result[i2++] = to2;
          }
        }
        return this.ret(score2 - word.length, result);
      }
    }
    class StrictMatcher {
      constructor(pattern) {
        this.pattern = pattern;
        this.matched = [];
        this.score = 0;
        this.folded = pattern.toLowerCase();
      }
      match(word) {
        if (word.length < this.pattern.length)
          return null;
        let start = word.slice(0, this.pattern.length);
        let match = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 : null;
        if (match == null)
          return null;
        this.matched = [0, start.length];
        this.score = match + (word.length == this.pattern.length ? 0 : -100);
        return this;
      }
    }
    const completionConfig = /* @__PURE__ */ Facet.define({
      combine(configs) {
        return combineConfig(configs, {
          activateOnTyping: true,
          activateOnCompletion: () => false,
          activateOnTypingDelay: 100,
          selectOnOpen: true,
          override: null,
          closeOnBlur: true,
          maxRenderedOptions: 100,
          defaultKeymap: true,
          tooltipClass: () => "",
          optionClass: () => "",
          aboveCursor: false,
          icons: true,
          addToOptions: [],
          positionInfo: defaultPositionInfo,
          filterStrict: false,
          compareCompletions: (a, b) => (a.sortText || a.label).localeCompare(b.sortText || b.label),
          interactionDelay: 75,
          updateSyncTime: 100
        }, {
          defaultKeymap: (a, b) => a && b,
          closeOnBlur: (a, b) => a && b,
          icons: (a, b) => a && b,
          tooltipClass: (a, b) => (c) => joinClass(a(c), b(c)),
          optionClass: (a, b) => (c) => joinClass(a(c), b(c)),
          addToOptions: (a, b) => a.concat(b),
          filterStrict: (a, b) => a || b
        });
      }
    });
    function joinClass(a, b) {
      return a ? b ? a + " " + b : a : b;
    }
    function defaultPositionInfo(view, list, option, info, space, tooltip) {
      let rtl = view.textDirection == Direction.RTL, left = rtl, narrow = false;
      let side = "top", offset, maxWidth;
      let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;
      let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
      if (left && spaceLeft < Math.min(infoWidth, spaceRight))
        left = false;
      else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))
        left = true;
      if (infoWidth <= (left ? spaceLeft : spaceRight)) {
        offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;
        maxWidth = Math.min(400, left ? spaceLeft : spaceRight);
      } else {
        narrow = true;
        maxWidth = Math.min(
          400,
          (rtl ? list.right : space.right - list.left) - 30
          /* Info.Margin */
        );
        let spaceBelow = space.bottom - list.bottom;
        if (spaceBelow >= infoHeight || spaceBelow > list.top) {
          offset = option.bottom - list.top;
        } else {
          side = "bottom";
          offset = list.bottom - option.top;
        }
      }
      let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
      let scaleX = (list.right - list.left) / tooltip.offsetWidth;
      return {
        style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,
        class: "cm-completionInfo-" + (narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right")
      };
    }
    function optionContent(config2) {
      let content2 = config2.addToOptions.slice();
      if (config2.icons)
        content2.push({
          render(completion) {
            let icon = document.createElement("div");
            icon.classList.add("cm-completionIcon");
            if (completion.type)
              icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
            icon.setAttribute("aria-hidden", "true");
            return icon;
          },
          position: 20
        });
      content2.push({
        render(completion, _s, _v, match) {
          let labelElt = document.createElement("span");
          labelElt.className = "cm-completionLabel";
          let label = completion.displayLabel || completion.label, off = 0;
          for (let j = 0; j < match.length; ) {
            let from2 = match[j++], to2 = match[j++];
            if (from2 > off)
              labelElt.appendChild(document.createTextNode(label.slice(off, from2)));
            let span = labelElt.appendChild(document.createElement("span"));
            span.appendChild(document.createTextNode(label.slice(from2, to2)));
            span.className = "cm-completionMatchedText";
            off = to2;
          }
          if (off < label.length)
            labelElt.appendChild(document.createTextNode(label.slice(off)));
          return labelElt;
        },
        position: 50
      }, {
        render(completion) {
          if (!completion.detail)
            return null;
          let detailElt = document.createElement("span");
          detailElt.className = "cm-completionDetail";
          detailElt.textContent = completion.detail;
          return detailElt;
        },
        position: 80
      });
      return content2.sort((a, b) => a.position - b.position).map((a) => a.render);
    }
    function rangeAroundSelected(total, selected, max) {
      if (total <= max)
        return { from: 0, to: total };
      if (selected < 0)
        selected = 0;
      if (selected <= total >> 1) {
        let off2 = Math.floor(selected / max);
        return { from: off2 * max, to: (off2 + 1) * max };
      }
      let off = Math.floor((total - selected) / max);
      return { from: total - (off + 1) * max, to: total - off * max };
    }
    class CompletionTooltip {
      constructor(view, stateField, applyCompletion2) {
        this.view = view;
        this.stateField = stateField;
        this.applyCompletion = applyCompletion2;
        this.info = null;
        this.infoDestroy = null;
        this.placeInfoReq = {
          read: () => this.measureInfo(),
          write: (pos) => this.placeInfo(pos),
          key: this
        };
        this.space = null;
        this.currentClass = "";
        let cState = view.state.field(stateField);
        let { options, selected } = cState.open;
        let config2 = view.state.facet(completionConfig);
        this.optionContent = optionContent(config2);
        this.optionClass = config2.optionClass;
        this.tooltipClass = config2.tooltipClass;
        this.range = rangeAroundSelected(options.length, selected, config2.maxRenderedOptions);
        this.dom = document.createElement("div");
        this.dom.className = "cm-tooltip-autocomplete";
        this.updateTooltipClass(view.state);
        this.dom.addEventListener("mousedown", (e) => {
          let { options: options2 } = view.state.field(stateField).open;
          for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
            if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options2.length) {
              this.applyCompletion(view, options2[+match[1]]);
              e.preventDefault();
              return;
            }
          }
        });
        this.dom.addEventListener("focusout", (e) => {
          let state = view.state.field(this.stateField, false);
          if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e.relatedTarget != view.contentDOM)
            view.dispatch({ effects: closeCompletionEffect.of(null) });
        });
        this.showOptions(options, cState.id);
      }
      mount() {
        this.updateSel();
      }
      showOptions(options, id2) {
        if (this.list)
          this.list.remove();
        this.list = this.dom.appendChild(this.createListBox(options, id2, this.range));
        this.list.addEventListener("scroll", () => {
          if (this.info)
            this.view.requestMeasure(this.placeInfoReq);
        });
      }
      update(update) {
        var _a2;
        let cState = update.state.field(this.stateField);
        let prevState = update.startState.field(this.stateField);
        this.updateTooltipClass(update.state);
        if (cState != prevState) {
          let { options, selected, disabled } = cState.open;
          if (!prevState.open || prevState.open.options != options) {
            this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);
            this.showOptions(options, cState.id);
          }
          this.updateSel();
          if (disabled != ((_a2 = prevState.open) === null || _a2 === void 0 ? void 0 : _a2.disabled))
            this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled);
        }
      }
      updateTooltipClass(state) {
        let cls = this.tooltipClass(state);
        if (cls != this.currentClass) {
          for (let c of this.currentClass.split(" "))
            if (c)
              this.dom.classList.remove(c);
          for (let c of cls.split(" "))
            if (c)
              this.dom.classList.add(c);
          this.currentClass = cls;
        }
      }
      positioned(space) {
        this.space = space;
        if (this.info)
          this.view.requestMeasure(this.placeInfoReq);
      }
      updateSel() {
        let cState = this.view.state.field(this.stateField), open = cState.open;
        if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
          this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
          this.showOptions(open.options, cState.id);
        }
        let newSel = this.updateSelectedOption(open.selected);
        if (newSel) {
          this.destroyInfo();
          let { completion } = open.options[open.selected];
          let { info } = completion;
          if (!info)
            return;
          let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
          if (!infoResult)
            return;
          if ("then" in infoResult) {
            infoResult.then((obj) => {
              if (obj && this.view.state.field(this.stateField, false) == cState)
                this.addInfoPane(obj, completion);
            }).catch((e) => logException(this.view.state, e, "completion info"));
          } else {
            this.addInfoPane(infoResult, completion);
            newSel.setAttribute("aria-describedby", this.info.id);
          }
        }
      }
      addInfoPane(content2, completion) {
        this.destroyInfo();
        let wrap = this.info = document.createElement("div");
        wrap.className = "cm-tooltip cm-completionInfo";
        wrap.id = "cm-completionInfo-" + Math.floor(Math.random() * 65535).toString(16);
        if (content2.nodeType != null) {
          wrap.appendChild(content2);
          this.infoDestroy = null;
        } else {
          let { dom, destroy } = content2;
          wrap.appendChild(dom);
          this.infoDestroy = destroy || null;
        }
        this.dom.appendChild(wrap);
        this.view.requestMeasure(this.placeInfoReq);
      }
      updateSelectedOption(selected) {
        let set2 = null;
        for (let opt = this.list.firstChild, i2 = this.range.from; opt; opt = opt.nextSibling, i2++) {
          if (opt.nodeName != "LI" || !opt.id) {
            i2--;
          } else if (i2 == selected) {
            if (!opt.hasAttribute("aria-selected")) {
              opt.setAttribute("aria-selected", "true");
              set2 = opt;
            }
          } else {
            if (opt.hasAttribute("aria-selected")) {
              opt.removeAttribute("aria-selected");
              opt.removeAttribute("aria-describedby");
            }
          }
        }
        if (set2)
          scrollIntoView(this.list, set2);
        return set2;
      }
      measureInfo() {
        let sel = this.dom.querySelector("[aria-selected]");
        if (!sel || !this.info)
          return null;
        let listRect = this.dom.getBoundingClientRect();
        let infoRect = this.info.getBoundingClientRect();
        let selRect = sel.getBoundingClientRect();
        let space = this.space;
        if (!space) {
          let docElt = this.dom.ownerDocument.documentElement;
          space = { left: 0, top: 0, right: docElt.clientWidth, bottom: docElt.clientHeight };
        }
        if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10)
          return null;
        return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);
      }
      placeInfo(pos) {
        if (this.info) {
          if (pos) {
            if (pos.style)
              this.info.style.cssText = pos.style;
            this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
          } else {
            this.info.style.cssText = "top: -1e6px";
          }
        }
      }
      createListBox(options, id2, range) {
        const ul = document.createElement("ul");
        ul.id = id2;
        ul.setAttribute("role", "listbox");
        ul.setAttribute("aria-expanded", "true");
        ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
        ul.addEventListener("mousedown", (e) => {
          if (e.target == ul)
            e.preventDefault();
        });
        let curSection = null;
        for (let i2 = range.from; i2 < range.to; i2++) {
          let { completion, match } = options[i2], { section } = completion;
          if (section) {
            let name2 = typeof section == "string" ? section : section.name;
            if (name2 != curSection && (i2 > range.from || range.from == 0)) {
              curSection = name2;
              if (typeof section != "string" && section.header) {
                ul.appendChild(section.header(section));
              } else {
                let header2 = ul.appendChild(document.createElement("completion-section"));
                header2.textContent = name2;
              }
            }
          }
          const li = ul.appendChild(document.createElement("li"));
          li.id = id2 + "-" + i2;
          li.setAttribute("role", "option");
          let cls = this.optionClass(completion);
          if (cls)
            li.className = cls;
          for (let source2 of this.optionContent) {
            let node = source2(completion, this.view.state, this.view, match);
            if (node)
              li.appendChild(node);
          }
        }
        if (range.from)
          ul.classList.add("cm-completionListIncompleteTop");
        if (range.to < options.length)
          ul.classList.add("cm-completionListIncompleteBottom");
        return ul;
      }
      destroyInfo() {
        if (this.info) {
          if (this.infoDestroy)
            this.infoDestroy();
          this.info.remove();
          this.info = null;
        }
      }
      destroy() {
        this.destroyInfo();
      }
    }
    function completionTooltip(stateField, applyCompletion2) {
      return (view) => new CompletionTooltip(view, stateField, applyCompletion2);
    }
    function scrollIntoView(container2, element) {
      let parent = container2.getBoundingClientRect();
      let self2 = element.getBoundingClientRect();
      let scaleY = parent.height / container2.offsetHeight;
      if (self2.top < parent.top)
        container2.scrollTop -= (parent.top - self2.top) / scaleY;
      else if (self2.bottom > parent.bottom)
        container2.scrollTop += (self2.bottom - parent.bottom) / scaleY;
    }
    function score(option) {
      return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
    }
    function sortOptions(active, state) {
      let options = [];
      let sections = null, dynamicSectionScore = null;
      let addOption = (option) => {
        options.push(option);
        let { section } = option.completion;
        if (section) {
          if (!sections)
            sections = [];
          let name2 = typeof section == "string" ? section : section.name;
          if (!sections.some((s) => s.name == name2))
            sections.push(typeof section == "string" ? { name: name2 } : section);
        }
      };
      let conf = state.facet(completionConfig);
      for (let a of active)
        if (a.hasResult()) {
          let getMatch = a.result.getMatch;
          if (a.result.filter === false) {
            for (let option of a.result.options) {
              addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));
            }
          } else {
            let pattern = state.sliceDoc(a.from, a.to), match;
            let matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);
            for (let option of a.result.options)
              if (match = matcher.match(option.label)) {
                let matched = !option.displayLabel ? match.matched : getMatch ? getMatch(option, match.matched) : [];
                let score2 = match.score + (option.boost || 0);
                addOption(new Option(option, a.source, matched, score2));
                if (typeof option.section == "object" && option.section.rank === "dynamic") {
                  let { name: name2 } = option.section;
                  if (!dynamicSectionScore)
                    dynamicSectionScore = /* @__PURE__ */ Object.create(null);
                  dynamicSectionScore[name2] = Math.max(score2, dynamicSectionScore[name2] || -1e9);
                }
              }
          }
        }
      if (sections) {
        let sectionOrder = /* @__PURE__ */ Object.create(null), pos = 0;
        let cmp = (a, b) => {
          return (a.rank === "dynamic" && b.rank === "dynamic" ? dynamicSectionScore[b.name] - dynamicSectionScore[a.name] : 0) || (typeof a.rank == "number" ? a.rank : 1e9) - (typeof b.rank == "number" ? b.rank : 1e9) || (a.name < b.name ? -1 : 1);
        };
        for (let s of sections.sort(cmp)) {
          pos -= 1e5;
          sectionOrder[s.name] = pos;
        }
        for (let option of options) {
          let { section } = option.completion;
          if (section)
            option.score += sectionOrder[typeof section == "string" ? section : section.name];
        }
      }
      let result = [], prev = null;
      let compare2 = conf.compareCompletions;
      for (let opt of options.sort((a, b) => b.score - a.score || compare2(a.completion, b.completion))) {
        let cur2 = opt.completion;
        if (!prev || prev.label != cur2.label || prev.detail != cur2.detail || prev.type != null && cur2.type != null && prev.type != cur2.type || prev.apply != cur2.apply || prev.boost != cur2.boost)
          result.push(opt);
        else if (score(opt.completion) > score(prev))
          result[result.length - 1] = opt;
        prev = opt.completion;
      }
      return result;
    }
    class CompletionDialog {
      constructor(options, attrs, tooltip, timestamp2, selected, disabled) {
        this.options = options;
        this.attrs = attrs;
        this.tooltip = tooltip;
        this.timestamp = timestamp2;
        this.selected = selected;
        this.disabled = disabled;
      }
      setSelected(selected, id2) {
        return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id2, selected), this.tooltip, this.timestamp, selected, this.disabled);
      }
      static build(active, state, id2, prev, conf, didSetActive) {
        if (prev && !didSetActive && active.some((s) => s.isPending))
          return prev.setDisabled();
        let options = sortOptions(active, state);
        if (!options.length)
          return prev && active.some((a) => a.isPending) ? prev.setDisabled() : null;
        let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
        if (prev && prev.selected != selected && prev.selected != -1) {
          let selectedValue = prev.options[prev.selected].completion;
          for (let i2 = 0; i2 < options.length; i2++)
            if (options[i2].completion == selectedValue) {
              selected = i2;
              break;
            }
        }
        return new CompletionDialog(options, makeAttrs(id2, selected), {
          pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
          create: createTooltip,
          above: conf.aboveCursor
        }, prev ? prev.timestamp : Date.now(), selected, false);
      }
      map(changes) {
        return new CompletionDialog(this.options, this.attrs, __spreadProps(__spreadValues({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
      }
      setDisabled() {
        return new CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
      }
    }
    class CompletionState {
      constructor(active, id2, open) {
        this.active = active;
        this.id = id2;
        this.open = open;
      }
      static start() {
        return new CompletionState(none, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
      }
      update(tr) {
        let { state } = tr, conf = state.facet(completionConfig);
        let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
        let active = sources.map((source2) => {
          let value = this.active.find((s) => s.source == source2) || new ActiveSource(
            source2,
            this.active.some(
              (a) => a.state != 0
              /* State.Inactive */
            ) ? 1 : 0
            /* State.Inactive */
          );
          return value.update(tr, conf);
        });
        if (active.length == this.active.length && active.every((a, i2) => a == this.active[i2]))
          active = this.active;
        let open = this.open, didSet = tr.effects.some((e) => e.is(setActiveEffect));
        if (open && tr.docChanged)
          open = open.map(tr.changes);
        if (tr.selection || active.some((a) => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active) || didSet)
          open = CompletionDialog.build(active, state, this.id, open, conf, didSet);
        else if (open && open.disabled && !active.some((a) => a.isPending))
          open = null;
        if (!open && active.every((a) => !a.isPending) && active.some((a) => a.hasResult()))
          active = active.map((a) => a.hasResult() ? new ActiveSource(
            a.source,
            0
            /* State.Inactive */
          ) : a);
        for (let effect of tr.effects)
          if (effect.is(setSelectedEffect))
            open = open && open.setSelected(effect.value, this.id);
        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
      }
      get tooltip() {
        return this.open ? this.open.tooltip : null;
      }
      get attrs() {
        return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs;
      }
    }
    function sameResults(a, b) {
      if (a == b)
        return true;
      for (let iA = 0, iB = 0; ; ) {
        while (iA < a.length && !a[iA].hasResult())
          iA++;
        while (iB < b.length && !b[iB].hasResult())
          iB++;
        let endA = iA == a.length, endB = iB == b.length;
        if (endA || endB)
          return endA == endB;
        if (a[iA++].result != b[iB++].result)
          return false;
      }
    }
    const baseAttrs = {
      "aria-autocomplete": "list"
    };
    const noAttrs = {};
    function makeAttrs(id2, selected) {
      let result = {
        "aria-autocomplete": "list",
        "aria-haspopup": "listbox",
        "aria-controls": id2
      };
      if (selected > -1)
        result["aria-activedescendant"] = id2 + "-" + selected;
      return result;
    }
    const none = [];
    function getUpdateType(tr, conf) {
      if (tr.isUserEvent("input.complete")) {
        let completion = tr.annotation(pickedCompletion);
        if (completion && conf.activateOnCompletion(completion))
          return 4 | 8;
      }
      let typing = tr.isUserEvent("input.type");
      return typing && conf.activateOnTyping ? 4 | 1 : typing ? 1 : tr.isUserEvent("delete.backward") ? 2 : tr.selection ? 8 : tr.docChanged ? 16 : 0;
    }
    class ActiveSource {
      constructor(source2, state, explicit = false) {
        this.source = source2;
        this.state = state;
        this.explicit = explicit;
      }
      hasResult() {
        return false;
      }
      get isPending() {
        return this.state == 1;
      }
      update(tr, conf) {
        let type = getUpdateType(tr, conf), value = this;
        if (type & 8 || type & 16 && this.touches(tr))
          value = new ActiveSource(
            value.source,
            0
            /* State.Inactive */
          );
        if (type & 4 && value.state == 0)
          value = new ActiveSource(
            this.source,
            1
            /* State.Pending */
          );
        value = value.updateFor(tr, type);
        for (let effect of tr.effects) {
          if (effect.is(startCompletionEffect))
            value = new ActiveSource(value.source, 1, effect.value);
          else if (effect.is(closeCompletionEffect))
            value = new ActiveSource(
              value.source,
              0
              /* State.Inactive */
            );
          else if (effect.is(setActiveEffect)) {
            for (let active of effect.value)
              if (active.source == value.source)
                value = active;
          }
        }
        return value;
      }
      updateFor(tr, type) {
        return this.map(tr.changes);
      }
      map(changes) {
        return this;
      }
      touches(tr) {
        return tr.changes.touchesRange(cur(tr.state));
      }
    }
    class ActiveResult extends ActiveSource {
      constructor(source2, explicit, limit, result, from2, to2) {
        super(source2, 3, explicit);
        this.limit = limit;
        this.result = result;
        this.from = from2;
        this.to = to2;
      }
      hasResult() {
        return true;
      }
      updateFor(tr, type) {
        var _a2;
        if (!(type & 3))
          return this.map(tr.changes);
        let result = this.result;
        if (result.map && !tr.changes.empty)
          result = result.map(result, tr.changes);
        let from2 = tr.changes.mapPos(this.from), to2 = tr.changes.mapPos(this.to, 1);
        let pos = cur(tr.state);
        if (pos > to2 || !result || type & 2 && (cur(tr.startState) == this.from || pos < this.limit))
          return new ActiveSource(
            this.source,
            type & 4 ? 1 : 0
            /* State.Inactive */
          );
        let limit = tr.changes.mapPos(this.limit);
        if (checkValid(result.validFor, tr.state, from2, to2))
          return new ActiveResult(this.source, this.explicit, limit, result, from2, to2);
        if (result.update && (result = result.update(result, from2, to2, new CompletionContext(tr.state, pos, false))))
          return new ActiveResult(this.source, this.explicit, limit, result, result.from, (_a2 = result.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state));
        return new ActiveSource(this.source, 1, this.explicit);
      }
      map(mapping) {
        if (mapping.empty)
          return this;
        let result = this.result.map ? this.result.map(this.result, mapping) : this.result;
        if (!result)
          return new ActiveSource(
            this.source,
            0
            /* State.Inactive */
          );
        return new ActiveResult(this.source, this.explicit, mapping.mapPos(this.limit), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
      }
      touches(tr) {
        return tr.changes.touchesRange(this.from, this.to);
      }
    }
    function checkValid(validFor, state, from2, to2) {
      if (!validFor)
        return false;
      let text = state.sliceDoc(from2, to2);
      return typeof validFor == "function" ? validFor(text, from2, to2, state) : ensureAnchor(validFor, true).test(text);
    }
    const setActiveEffect = /* @__PURE__ */ StateEffect.define({
      map(sources, mapping) {
        return sources.map((s) => s.map(mapping));
      }
    });
    const setSelectedEffect = /* @__PURE__ */ StateEffect.define();
    const completionState = /* @__PURE__ */ StateField.define({
      create() {
        return CompletionState.start();
      },
      update(value, tr) {
        return value.update(tr);
      },
      provide: (f) => [
        showTooltip.from(f, (val) => val.tooltip),
        EditorView.contentAttributes.from(f, (state) => state.attrs)
      ]
    });
    function applyCompletion(view, option) {
      const apply = option.completion.apply || option.completion.label;
      let result = view.state.field(completionState).active.find((a) => a.source == option.source);
      if (!(result instanceof ActiveResult))
        return false;
      if (typeof apply == "string")
        view.dispatch(__spreadProps(__spreadValues({}, insertCompletionText(view.state, apply, result.from, result.to)), {
          annotations: pickedCompletion.of(option.completion)
        }));
      else
        apply(view, option.completion, result.from, result.to);
      return true;
    }
    const createTooltip = /* @__PURE__ */ completionTooltip(completionState, applyCompletion);
    function moveCompletionSelection(forward, by = "option") {
      return (view) => {
        let cState = view.state.field(completionState, false);
        if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
          return false;
        let step = 1, tooltip;
        if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
          step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
        let { length } = cState.open.options;
        let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
        if (selected < 0)
          selected = by == "page" ? 0 : length - 1;
        else if (selected >= length)
          selected = by == "page" ? length - 1 : 0;
        view.dispatch({ effects: setSelectedEffect.of(selected) });
        return true;
      };
    }
    const acceptCompletion = (view) => {
      let cState = view.state.field(completionState, false);
      if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
        return false;
      return applyCompletion(view, cState.open.options[cState.open.selected]);
    };
    const startCompletion = (view) => {
      let cState = view.state.field(completionState, false);
      if (!cState)
        return false;
      view.dispatch({ effects: startCompletionEffect.of(true) });
      return true;
    };
    const closeCompletion = (view) => {
      let cState = view.state.field(completionState, false);
      if (!cState || !cState.active.some(
        (a) => a.state != 0
        /* State.Inactive */
      ))
        return false;
      view.dispatch({ effects: closeCompletionEffect.of(null) });
      return true;
    };
    class RunningQuery {
      constructor(active, context) {
        this.active = active;
        this.context = context;
        this.time = Date.now();
        this.updates = [];
        this.done = void 0;
      }
    }
    const MaxUpdateCount = 50, MinAbortTime = 1e3;
    const completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.debounceUpdate = -1;
        this.running = [];
        this.debounceAccept = -1;
        this.pendingStart = false;
        this.composing = 0;
        for (let active of view.state.field(completionState).active)
          if (active.isPending)
            this.startQuery(active);
      }
      update(update) {
        let cState = update.state.field(completionState);
        let conf = update.state.facet(completionConfig);
        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
          return;
        let doesReset = update.transactions.some((tr) => {
          let type = getUpdateType(tr, conf);
          return type & 8 || (tr.selection || tr.docChanged) && !(type & 3);
        });
        for (let i2 = 0; i2 < this.running.length; i2++) {
          let query = this.running[i2];
          if (doesReset || query.context.abortOnDocChange && update.docChanged || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
            for (let handler of query.context.abortListeners) {
              try {
                handler();
              } catch (e) {
                logException(this.view.state, e);
              }
            }
            query.context.abortListeners = null;
            this.running.splice(i2--, 1);
          } else {
            query.updates.push(...update.transactions);
          }
        }
        if (this.debounceUpdate > -1)
          clearTimeout(this.debounceUpdate);
        if (update.transactions.some((tr) => tr.effects.some((e) => e.is(startCompletionEffect))))
          this.pendingStart = true;
        let delay = this.pendingStart ? 50 : conf.activateOnTypingDelay;
        this.debounceUpdate = cState.active.some((a) => a.isPending && !this.running.some((q) => q.active.source == a.source)) ? setTimeout(() => this.startUpdate(), delay) : -1;
        if (this.composing != 0)
          for (let tr of update.transactions) {
            if (tr.isUserEvent("input.type"))
              this.composing = 2;
            else if (this.composing == 2 && tr.selection)
              this.composing = 3;
          }
      }
      startUpdate() {
        this.debounceUpdate = -1;
        this.pendingStart = false;
        let { state } = this.view, cState = state.field(completionState);
        for (let active of cState.active) {
          if (active.isPending && !this.running.some((r) => r.active.source == active.source))
            this.startQuery(active);
        }
        if (this.running.length && cState.open && cState.open.disabled)
          this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
      }
      startQuery(active) {
        let { state } = this.view, pos = cur(state);
        let context = new CompletionContext(state, pos, active.explicit, this.view);
        let pending = new RunningQuery(active, context);
        this.running.push(pending);
        Promise.resolve(active.source(context)).then((result) => {
          if (!pending.context.aborted) {
            pending.done = result || null;
            this.scheduleAccept();
          }
        }, (err) => {
          this.view.dispatch({ effects: closeCompletionEffect.of(null) });
          logException(this.view.state, err);
        });
      }
      scheduleAccept() {
        if (this.running.every((q) => q.done !== void 0))
          this.accept();
        else if (this.debounceAccept < 0)
          this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
      }
      // For each finished query in this.running, try to create a result
      // or, if appropriate, restart the query.
      accept() {
        var _a2;
        if (this.debounceAccept > -1)
          clearTimeout(this.debounceAccept);
        this.debounceAccept = -1;
        let updated = [];
        let conf = this.view.state.facet(completionConfig), cState = this.view.state.field(completionState);
        for (let i2 = 0; i2 < this.running.length; i2++) {
          let query = this.running[i2];
          if (query.done === void 0)
            continue;
          this.running.splice(i2--, 1);
          if (query.done) {
            let pos = cur(query.updates.length ? query.updates[0].startState : this.view.state);
            let limit = Math.min(pos, query.done.from + (query.active.explicit ? 0 : 1));
            let active = new ActiveResult(query.active.source, query.active.explicit, limit, query.done, query.done.from, (_a2 = query.done.to) !== null && _a2 !== void 0 ? _a2 : pos);
            for (let tr of query.updates)
              active = active.update(tr, conf);
            if (active.hasResult()) {
              updated.push(active);
              continue;
            }
          }
          let current = cState.active.find((a) => a.source == query.active.source);
          if (current && current.isPending) {
            if (query.done == null) {
              let active = new ActiveSource(
                query.active.source,
                0
                /* State.Inactive */
              );
              for (let tr of query.updates)
                active = active.update(tr, conf);
              if (!active.isPending)
                updated.push(active);
            } else {
              this.startQuery(current);
            }
          }
        }
        if (updated.length || cState.open && cState.open.disabled)
          this.view.dispatch({ effects: setActiveEffect.of(updated) });
      }
    }, {
      eventHandlers: {
        blur(event) {
          let state = this.view.state.field(completionState, false);
          if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
            let dialog = state.open && getTooltip(this.view, state.open.tooltip);
            if (!dialog || !dialog.dom.contains(event.relatedTarget))
              setTimeout(() => this.view.dispatch({ effects: closeCompletionEffect.of(null) }), 10);
          }
        },
        compositionstart() {
          this.composing = 1;
        },
        compositionend() {
          if (this.composing == 3) {
            setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
          }
          this.composing = 0;
        }
      }
    });
    const windows = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform);
    const commitCharacters = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.domEventHandlers({
      keydown(event, view) {
        let field = view.state.field(completionState, false);
        if (!field || !field.open || field.open.disabled || field.open.selected < 0 || event.key.length > 1 || event.ctrlKey && !(windows && event.altKey) || event.metaKey)
          return false;
        let option = field.open.options[field.open.selected];
        let result = field.active.find((a) => a.source == option.source);
        let commitChars = option.completion.commitCharacters || result.result.commitCharacters;
        if (commitChars && commitChars.indexOf(event.key) > -1)
          applyCompletion(view, option);
        return false;
      }
    }));
    const baseTheme$1 = /* @__PURE__ */ EditorView.baseTheme({
      ".cm-tooltip.cm-tooltip-autocomplete": {
        "& > ul": {
          fontFamily: "monospace",
          whiteSpace: "nowrap",
          overflow: "hidden auto",
          maxWidth_fallback: "700px",
          maxWidth: "min(700px, 95vw)",
          minWidth: "250px",
          maxHeight: "10em",
          height: "100%",
          listStyle: "none",
          margin: 0,
          padding: 0,
          "& > li, & > completion-section": {
            padding: "1px 3px",
            lineHeight: 1.2
          },
          "& > li": {
            overflowX: "hidden",
            textOverflow: "ellipsis",
            cursor: "pointer"
          },
          "& > completion-section": {
            display: "list-item",
            borderBottom: "1px solid silver",
            paddingLeft: "0.5em",
            opacity: 0.7
          }
        }
      },
      "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
        background: "#17c",
        color: "white"
      },
      "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
        background: "#777"
      },
      "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
        background: "#347",
        color: "white"
      },
      "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
        background: "#444"
      },
      ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
        content: '""',
        opacity: 0.5,
        display: "block",
        textAlign: "center"
      },
      ".cm-tooltip.cm-completionInfo": {
        position: "absolute",
        padding: "3px 9px",
        width: "max-content",
        maxWidth: `${400}px`,
        boxSizing: "border-box",
        whiteSpace: "pre-line"
      },
      ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
      ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
      ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
      ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
      "&light .cm-snippetField": { backgroundColor: "#00000022" },
      "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
      ".cm-snippetFieldPosition": {
        verticalAlign: "text-top",
        width: 0,
        height: "1.15em",
        display: "inline-block",
        margin: "0 -0.7px -.7em",
        borderLeft: "1.4px dotted #888"
      },
      ".cm-completionMatchedText": {
        textDecoration: "underline"
      },
      ".cm-completionDetail": {
        marginLeft: "0.5em",
        fontStyle: "italic"
      },
      ".cm-completionIcon": {
        fontSize: "90%",
        width: ".8em",
        display: "inline-block",
        textAlign: "center",
        paddingRight: ".6em",
        opacity: "0.6",
        boxSizing: "content-box"
      },
      ".cm-completionIcon-function, .cm-completionIcon-method": {
        "&:after": { content: "''" }
      },
      ".cm-completionIcon-class": {
        "&:after": { content: "''" }
      },
      ".cm-completionIcon-interface": {
        "&:after": { content: "''" }
      },
      ".cm-completionIcon-variable": {
        "&:after": { content: "''" }
      },
      ".cm-completionIcon-constant": {
        "&:after": { content: "''" }
      },
      ".cm-completionIcon-type": {
        "&:after": { content: "''" }
      },
      ".cm-completionIcon-enum": {
        "&:after": { content: "''" }
      },
      ".cm-completionIcon-property": {
        "&:after": { content: "''" }
      },
      ".cm-completionIcon-keyword": {
        "&:after": { content: "''" }
        // Disable emoji rendering
      },
      ".cm-completionIcon-namespace": {
        "&:after": { content: "''" }
      },
      ".cm-completionIcon-text": {
        "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
      }
    });
    const defaults = {
      brackets: ["(", "[", "{", "'", '"'],
      before: ")]}:;>",
      stringPrefixes: []
    };
    const closeBracketEffect = /* @__PURE__ */ StateEffect.define({
      map(value, mapping) {
        let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
        return mapped == null ? void 0 : mapped;
      }
    });
    const closedBracket = /* @__PURE__ */ new class extends RangeValue {
    }();
    closedBracket.startSide = 1;
    closedBracket.endSide = -1;
    const bracketState = /* @__PURE__ */ StateField.define({
      create() {
        return RangeSet.empty;
      },
      update(value, tr) {
        value = value.map(tr.changes);
        if (tr.selection) {
          let line = tr.state.doc.lineAt(tr.selection.main.head);
          value = value.update({ filter: (from2) => from2 >= line.from && from2 <= line.to });
        }
        for (let effect of tr.effects)
          if (effect.is(closeBracketEffect))
            value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
        return value;
      }
    });
    function closeBrackets() {
      return [inputHandler, bracketState];
    }
    const definedClosing = "()[]{}<>";
    function closing(ch) {
      for (let i2 = 0; i2 < definedClosing.length; i2 += 2)
        if (definedClosing.charCodeAt(i2) == ch)
          return definedClosing.charAt(i2 + 1);
      return fromCodePoint(ch < 128 ? ch : ch + 1);
    }
    function config(state, pos) {
      return state.languageDataAt("closeBrackets", pos)[0] || defaults;
    }
    const android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
    const inputHandler = /* @__PURE__ */ EditorView.inputHandler.of((view, from2, to2, insert2) => {
      if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
        return false;
      let sel = view.state.selection.main;
      if (insert2.length > 2 || insert2.length == 2 && codePointSize(codePointAt(insert2, 0)) == 1 || from2 != sel.from || to2 != sel.to)
        return false;
      let tr = insertBracket(view.state, insert2);
      if (!tr)
        return false;
      view.dispatch(tr);
      return true;
    });
    const deleteBracketPair = ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      let conf = config(state, state.selection.main.head);
      let tokens = conf.brackets || defaults.brackets;
      let dont = null, changes = state.changeByRange((range) => {
        if (range.empty) {
          let before = prevChar(state.doc, range.head);
          for (let token of tokens) {
            if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0)))
              return {
                changes: { from: range.head - token.length, to: range.head + token.length },
                range: EditorSelection.cursor(range.head - token.length)
              };
          }
        }
        return { range: dont = range };
      });
      if (!dont)
        dispatch(state.update(changes, { scrollIntoView: true, userEvent: "delete.backward" }));
      return !dont;
    };
    const closeBracketsKeymap = [
      { key: "Backspace", run: deleteBracketPair }
    ];
    function insertBracket(state, bracket2) {
      let conf = config(state, state.selection.main.head);
      let tokens = conf.brackets || defaults.brackets;
      for (let tok of tokens) {
        let closed = closing(codePointAt(tok, 0));
        if (bracket2 == tok)
          return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults.before);
        if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
          return handleClose(state, tok, closed);
      }
      return null;
    }
    function closedBracketAt(state, pos) {
      let found = false;
      state.field(bracketState).between(0, state.doc.length, (from2) => {
        if (from2 == pos)
          found = true;
      });
      return found;
    }
    function nextChar(doc2, pos) {
      let next = doc2.sliceString(pos, pos + 2);
      return next.slice(0, codePointSize(codePointAt(next, 0)));
    }
    function prevChar(doc2, pos) {
      let prev = doc2.sliceString(pos - 2, pos);
      return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
    }
    function handleOpen(state, open, close, closeBefore) {
      let dont = null, changes = state.changeByRange((range) => {
        if (!range.empty)
          return {
            changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
            effects: closeBracketEffect.of(range.to + open.length),
            range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
          };
        let next = nextChar(state.doc, range.head);
        if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
          return {
            changes: { insert: open + close, from: range.head },
            effects: closeBracketEffect.of(range.head + open.length),
            range: EditorSelection.cursor(range.head + open.length)
          };
        return { range: dont = range };
      });
      return dont ? null : state.update(changes, {
        scrollIntoView: true,
        userEvent: "input.type"
      });
    }
    function handleClose(state, _open, close) {
      let dont = null, changes = state.changeByRange((range) => {
        if (range.empty && nextChar(state.doc, range.head) == close)
          return {
            changes: { from: range.head, to: range.head + close.length, insert: close },
            range: EditorSelection.cursor(range.head + close.length)
          };
        return dont = { range };
      });
      return dont ? null : state.update(changes, {
        scrollIntoView: true,
        userEvent: "input.type"
      });
    }
    function handleSame(state, token, allowTriple, config2) {
      let stringPrefixes = config2.stringPrefixes || defaults.stringPrefixes;
      let dont = null, changes = state.changeByRange((range) => {
        if (!range.empty)
          return {
            changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
            effects: closeBracketEffect.of(range.to + token.length),
            range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
          };
        let pos = range.head, next = nextChar(state.doc, pos), start;
        if (next == token) {
          if (nodeStart(state, pos)) {
            return {
              changes: { insert: token + token, from: pos },
              effects: closeBracketEffect.of(pos + token.length),
              range: EditorSelection.cursor(pos + token.length)
            };
          } else if (closedBracketAt(state, pos)) {
            let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
            let content2 = isTriple ? token + token + token : token;
            return {
              changes: { from: pos, to: pos + content2.length, insert: content2 },
              range: EditorSelection.cursor(pos + content2.length)
            };
          }
        } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
          return {
            changes: { insert: token + token + token + token, from: pos },
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
        } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
          if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
            return {
              changes: { insert: token + token, from: pos },
              effects: closeBracketEffect.of(pos + token.length),
              range: EditorSelection.cursor(pos + token.length)
            };
        }
        return { range: dont = range };
      });
      return dont ? null : state.update(changes, {
        scrollIntoView: true,
        userEvent: "input.type"
      });
    }
    function nodeStart(state, pos) {
      let tree = syntaxTree(state).resolveInner(pos + 1);
      return tree.parent && tree.from == pos;
    }
    function probablyInString(state, pos, quoteToken, prefixes) {
      let node = syntaxTree(state).resolveInner(pos, -1);
      let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);
      for (let i2 = 0; i2 < 5; i2++) {
        let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
        let quotePos = start.indexOf(quoteToken);
        if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
          let first = node.firstChild;
          while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
            if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
              return false;
            first = first.firstChild;
          }
          return true;
        }
        let parent = node.to == pos && node.parent;
        if (!parent)
          break;
        node = parent;
      }
      return false;
    }
    function canStartStringAt(state, pos, prefixes) {
      let charCat = state.charCategorizer(pos);
      if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
        return pos;
      for (let prefix of prefixes) {
        let start = pos - prefix.length;
        if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)
          return start;
      }
      return -1;
    }
    function autocompletion(config2 = {}) {
      return [
        commitCharacters,
        completionState,
        completionConfig.of(config2),
        completionPlugin,
        completionKeymapExt,
        baseTheme$1
      ];
    }
    const completionKeymap = [
      { key: "Ctrl-Space", run: startCompletion },
      { mac: "Alt-`", run: startCompletion },
      { mac: "Alt-i", run: startCompletion },
      { key: "Escape", run: closeCompletion },
      { key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true) },
      { key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false) },
      { key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page") },
      { key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page") },
      { key: "Enter", run: acceptCompletion }
    ];
    const completionKeymapExt = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));
    class SelectedDiagnostic {
      constructor(from2, to2, diagnostic) {
        this.from = from2;
        this.to = to2;
        this.diagnostic = diagnostic;
      }
    }
    class LintState {
      constructor(diagnostics, panel, selected) {
        this.diagnostics = diagnostics;
        this.panel = panel;
        this.selected = selected;
      }
      static init(diagnostics, panel, state) {
        let diagnosticFilter = state.facet(lintConfig).markerFilter;
        if (diagnosticFilter)
          diagnostics = diagnosticFilter(diagnostics, state);
        let sorted = diagnostics.slice().sort((a, b) => a.from - b.from || a.to - b.to);
        let deco = new RangeSetBuilder(), active = [], pos = 0;
        let scan = state.doc.iter(), scanPos = 0, docLen = state.doc.length;
        for (let i2 = 0; ; ) {
          let next = i2 == sorted.length ? null : sorted[i2];
          if (!next && !active.length)
            break;
          let from2, to2;
          if (active.length) {
            from2 = pos;
            to2 = active.reduce((p, d) => Math.min(p, d.to), next && next.from > from2 ? next.from : 1e8);
          } else {
            from2 = next.from;
            if (from2 > docLen)
              break;
            to2 = next.to;
            active.push(next);
            i2++;
          }
          while (i2 < sorted.length) {
            let next2 = sorted[i2];
            if (next2.from == from2 && (next2.to > next2.from || next2.to == from2)) {
              active.push(next2);
              i2++;
              to2 = Math.min(next2.to, to2);
            } else {
              to2 = Math.min(next2.from, to2);
              break;
            }
          }
          to2 = Math.min(to2, docLen);
          let widget = false;
          if (active.some((d) => d.from == from2 && (d.to == to2 || to2 == docLen))) {
            widget = from2 == to2;
            if (!widget && to2 - from2 < 10) {
              let behind = from2 - (scanPos + scan.value.length);
              if (behind > 0) {
                scan.next(behind);
                scanPos = from2;
              }
              for (let check = from2; ; ) {
                if (check >= to2) {
                  widget = true;
                  break;
                }
                if (!scan.lineBreak && scanPos + scan.value.length > check)
                  break;
                check = scanPos + scan.value.length;
                scanPos += scan.value.length;
                scan.next();
              }
            }
          }
          let sev = maxSeverity(active);
          if (widget) {
            deco.add(from2, from2, Decoration.widget({
              widget: new DiagnosticWidget(sev),
              diagnostics: active.slice()
            }));
          } else {
            let markClass = active.reduce((c, d) => d.markClass ? c + " " + d.markClass : c, "");
            deco.add(from2, to2, Decoration.mark({
              class: "cm-lintRange cm-lintRange-" + sev + markClass,
              diagnostics: active.slice(),
              inclusiveEnd: active.some((a) => a.to > to2)
            }));
          }
          pos = to2;
          if (pos == docLen)
            break;
          for (let i3 = 0; i3 < active.length; i3++)
            if (active[i3].to <= pos)
              active.splice(i3--, 1);
        }
        let set2 = deco.finish();
        return new LintState(set2, panel, findDiagnostic(set2));
      }
    }
    function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
      let found = null;
      diagnostics.between(after, 1e9, (from2, to2, { spec }) => {
        if (diagnostic && spec.diagnostics.indexOf(diagnostic) < 0)
          return;
        if (!found)
          found = new SelectedDiagnostic(from2, to2, diagnostic || spec.diagnostics[0]);
        else if (spec.diagnostics.indexOf(found.diagnostic) < 0)
          return false;
        else
          found = new SelectedDiagnostic(found.from, to2, found.diagnostic);
      });
      return found;
    }
    function hideTooltip(tr, tooltip) {
      let from2 = tooltip.pos, to2 = tooltip.end || from2;
      let result = tr.state.facet(lintConfig).hideOn(tr, from2, to2);
      if (result != null)
        return result;
      let line = tr.startState.doc.lineAt(tooltip.pos);
      return !!(tr.effects.some((e) => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, Math.max(line.to, to2)));
    }
    function maybeEnableLint(state, effects2) {
      return state.field(lintState, false) ? effects2 : effects2.concat(StateEffect.appendConfig.of(lintExtensions));
    }
    const setDiagnosticsEffect = /* @__PURE__ */ StateEffect.define();
    const togglePanel = /* @__PURE__ */ StateEffect.define();
    const movePanelSelection = /* @__PURE__ */ StateEffect.define();
    const lintState = /* @__PURE__ */ StateField.define({
      create() {
        return new LintState(Decoration.none, null, null);
      },
      update(value, tr) {
        if (tr.docChanged && value.diagnostics.size) {
          let mapped = value.diagnostics.map(tr.changes), selected = null, panel = value.panel;
          if (value.selected) {
            let selPos = tr.changes.mapPos(value.selected.from, 1);
            selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
          }
          if (!mapped.size && panel && tr.state.facet(lintConfig).autoPanel)
            panel = null;
          value = new LintState(mapped, panel, selected);
        }
        for (let effect of tr.effects) {
          if (effect.is(setDiagnosticsEffect)) {
            let panel = !tr.state.facet(lintConfig).autoPanel ? value.panel : effect.value.length ? LintPanel.open : null;
            value = LintState.init(effect.value, panel, tr.state);
          } else if (effect.is(togglePanel)) {
            value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
          } else if (effect.is(movePanelSelection)) {
            value = new LintState(value.diagnostics, value.panel, effect.value);
          }
        }
        return value;
      },
      provide: (f) => [
        showPanel.from(f, (val) => val.panel),
        EditorView.decorations.from(f, (s) => s.diagnostics)
      ]
    });
    const activeMark = /* @__PURE__ */ Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
    function lintTooltip(view, pos, side) {
      let { diagnostics } = view.state.field(lintState);
      let found, start = -1, end = -1;
      diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from2, to2, { spec }) => {
        if (pos >= from2 && pos <= to2 && (from2 == to2 || (pos > from2 || side > 0) && (pos < to2 || side < 0))) {
          found = spec.diagnostics;
          start = from2;
          end = to2;
          return false;
        }
      });
      let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
      if (found && diagnosticFilter)
        found = diagnosticFilter(found, view.state);
      if (!found)
        return null;
      return {
        pos: start,
        end,
        above: view.state.doc.lineAt(start).to < end,
        create() {
          return { dom: diagnosticsTooltip(view, found) };
        }
      };
    }
    function diagnosticsTooltip(view, diagnostics) {
      return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d) => renderDiagnostic(view, d, false)));
    }
    const openLintPanel = (view) => {
      let field = view.state.field(lintState, false);
      if (!field || !field.panel)
        view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel.of(true)]) });
      let panel = getPanel(view, LintPanel.open);
      if (panel)
        panel.dom.querySelector(".cm-panel-lint ul").focus();
      return true;
    };
    const closeLintPanel = (view) => {
      let field = view.state.field(lintState, false);
      if (!field || !field.panel)
        return false;
      view.dispatch({ effects: togglePanel.of(false) });
      return true;
    };
    const nextDiagnostic = (view) => {
      let field = view.state.field(lintState, false);
      if (!field)
        return false;
      let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
      if (!next.value) {
        next = field.diagnostics.iter(0);
        if (!next.value || next.from == sel.from && next.to == sel.to)
          return false;
      }
      view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
      return true;
    };
    const lintKeymap = [
      { key: "Mod-Shift-m", run: openLintPanel, preventDefault: true },
      { key: "F8", run: nextDiagnostic }
    ];
    const lintConfig = /* @__PURE__ */ Facet.define({
      combine(input) {
        return __spreadValues({
          sources: input.map((i2) => i2.source).filter((x) => x != null)
        }, combineConfig(input.map((i2) => i2.config), {
          delay: 750,
          markerFilter: null,
          tooltipFilter: null,
          needsRefresh: null,
          hideOn: () => null
        }, {
          delay: Math.max,
          markerFilter: combineFilter,
          tooltipFilter: combineFilter,
          needsRefresh: (a, b) => !a ? b : !b ? a : (u) => a(u) || b(u),
          hideOn: (a, b) => !a ? b : !b ? a : (t2, x, y) => a(t2, x, y) || b(t2, x, y),
          autoPanel: (a, b) => a || b
        }));
      }
    });
    function combineFilter(a, b) {
      return !a ? b : !b ? a : (d, s) => b(a(d, s), s);
    }
    function assignKeys(actions2) {
      let assigned = [];
      if (actions2)
        actions: for (let { name: name2 } of actions2) {
          for (let i2 = 0; i2 < name2.length; i2++) {
            let ch = name2[i2];
            if (/[a-zA-Z]/.test(ch) && !assigned.some((c) => c.toLowerCase() == ch.toLowerCase())) {
              assigned.push(ch);
              continue actions;
            }
          }
          assigned.push("");
        }
      return assigned;
    }
    function renderDiagnostic(view, diagnostic, inPanel) {
      var _a2;
      let keys2 = inPanel ? assignKeys(diagnostic.actions) : [];
      return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action, i2) => {
        let fired = false, click = (e) => {
          e.preventDefault();
          if (fired)
            return;
          fired = true;
          let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
          if (found)
            action.apply(view, found.from, found.to);
        };
        let { name: name2 } = action, keyIndex = keys2[i2] ? name2.indexOf(keys2[i2]) : -1;
        let nameElt = keyIndex < 0 ? name2 : [
          name2.slice(0, keyIndex),
          crelt("u", name2.slice(keyIndex, keyIndex + 1)),
          name2.slice(keyIndex + 1)
        ];
        let markClass = action.markClass ? " " + action.markClass : "";
        return crelt("button", {
          type: "button",
          class: "cm-diagnosticAction" + markClass,
          onclick: click,
          onmousedown: click,
          "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys2[i2]})"`}.`
        }, nameElt);
      }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
    }
    class DiagnosticWidget extends WidgetType {
      constructor(sev) {
        super();
        this.sev = sev;
      }
      eq(other) {
        return other.sev == this.sev;
      }
      toDOM() {
        return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
      }
    }
    class PanelItem {
      constructor(view, diagnostic) {
        this.diagnostic = diagnostic;
        this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
        this.dom = renderDiagnostic(view, diagnostic, true);
        this.dom.id = this.id;
        this.dom.setAttribute("role", "option");
      }
    }
    class LintPanel {
      constructor(view) {
        this.view = view;
        this.items = [];
        let onkeydown = (event) => {
          if (event.keyCode == 27) {
            closeLintPanel(this.view);
            this.view.focus();
          } else if (event.keyCode == 38 || event.keyCode == 33) {
            this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
          } else if (event.keyCode == 40 || event.keyCode == 34) {
            this.moveSelection((this.selectedIndex + 1) % this.items.length);
          } else if (event.keyCode == 36) {
            this.moveSelection(0);
          } else if (event.keyCode == 35) {
            this.moveSelection(this.items.length - 1);
          } else if (event.keyCode == 13) {
            this.view.focus();
          } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
            let { diagnostic } = this.items[this.selectedIndex], keys2 = assignKeys(diagnostic.actions);
            for (let i2 = 0; i2 < keys2.length; i2++)
              if (keys2[i2].toUpperCase().charCodeAt(0) == event.keyCode) {
                let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
                if (found)
                  diagnostic.actions[i2].apply(view, found.from, found.to);
              }
          } else {
            return;
          }
          event.preventDefault();
        };
        let onclick = (event) => {
          for (let i2 = 0; i2 < this.items.length; i2++) {
            if (this.items[i2].dom.contains(event.target))
              this.moveSelection(i2);
          }
        };
        this.list = crelt("ul", {
          tabIndex: 0,
          role: "listbox",
          "aria-label": this.view.state.phrase("Diagnostics"),
          onkeydown,
          onclick
        });
        this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
          type: "button",
          name: "close",
          "aria-label": this.view.state.phrase("close"),
          onclick: () => closeLintPanel(this.view)
        }, ""));
        this.update();
      }
      get selectedIndex() {
        let selected = this.view.state.field(lintState).selected;
        if (!selected)
          return -1;
        for (let i2 = 0; i2 < this.items.length; i2++)
          if (this.items[i2].diagnostic == selected.diagnostic)
            return i2;
        return -1;
      }
      update() {
        let { diagnostics, selected } = this.view.state.field(lintState);
        let i2 = 0, needsSync = false, newSelectedItem = null;
        let seen = /* @__PURE__ */ new Set();
        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
          for (let diagnostic of spec.diagnostics) {
            if (seen.has(diagnostic))
              continue;
            seen.add(diagnostic);
            let found = -1, item;
            for (let j = i2; j < this.items.length; j++)
              if (this.items[j].diagnostic == diagnostic) {
                found = j;
                break;
              }
            if (found < 0) {
              item = new PanelItem(this.view, diagnostic);
              this.items.splice(i2, 0, item);
              needsSync = true;
            } else {
              item = this.items[found];
              if (found > i2) {
                this.items.splice(i2, found - i2);
                needsSync = true;
              }
            }
            if (selected && item.diagnostic == selected.diagnostic) {
              if (!item.dom.hasAttribute("aria-selected")) {
                item.dom.setAttribute("aria-selected", "true");
                newSelectedItem = item;
              }
            } else if (item.dom.hasAttribute("aria-selected")) {
              item.dom.removeAttribute("aria-selected");
            }
            i2++;
          }
        });
        while (i2 < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
          needsSync = true;
          this.items.pop();
        }
        if (this.items.length == 0) {
          this.items.push(new PanelItem(this.view, {
            from: -1,
            to: -1,
            severity: "info",
            message: this.view.state.phrase("No diagnostics")
          }));
          needsSync = true;
        }
        if (newSelectedItem) {
          this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
          this.view.requestMeasure({
            key: this,
            read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
            write: ({ sel, panel }) => {
              let scaleY = panel.height / this.list.offsetHeight;
              if (sel.top < panel.top)
                this.list.scrollTop -= (panel.top - sel.top) / scaleY;
              else if (sel.bottom > panel.bottom)
                this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
            }
          });
        } else if (this.selectedIndex < 0) {
          this.list.removeAttribute("aria-activedescendant");
        }
        if (needsSync)
          this.sync();
      }
      sync() {
        let domPos = this.list.firstChild;
        function rm2() {
          let prev = domPos;
          domPos = prev.nextSibling;
          prev.remove();
        }
        for (let item of this.items) {
          if (item.dom.parentNode == this.list) {
            while (domPos != item.dom)
              rm2();
            domPos = item.dom.nextSibling;
          } else {
            this.list.insertBefore(item.dom, domPos);
          }
        }
        while (domPos)
          rm2();
      }
      moveSelection(selectedIndex) {
        if (this.selectedIndex < 0)
          return;
        let field = this.view.state.field(lintState);
        let selection2 = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
        if (!selection2)
          return;
        this.view.dispatch({
          selection: { anchor: selection2.from, head: selection2.to },
          scrollIntoView: true,
          effects: movePanelSelection.of(selection2)
        });
      }
      static open(view) {
        return new LintPanel(view);
      }
    }
    function svg(content2, attrs = `viewBox="0 0 40 40"`) {
      return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
    }
    function underline(color2) {
      return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color2}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
    }
    const baseTheme = /* @__PURE__ */ EditorView.baseTheme({
      ".cm-diagnostic": {
        padding: "3px 6px 3px 8px",
        marginLeft: "-1px",
        display: "block",
        whiteSpace: "pre-wrap"
      },
      ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
      ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
      ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
      ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
      ".cm-diagnosticAction": {
        font: "inherit",
        border: "none",
        padding: "2px 4px",
        backgroundColor: "#444",
        color: "white",
        borderRadius: "3px",
        marginLeft: "8px",
        cursor: "pointer"
      },
      ".cm-diagnosticSource": {
        fontSize: "70%",
        opacity: 0.7
      },
      ".cm-lintRange": {
        backgroundPosition: "left bottom",
        backgroundRepeat: "repeat-x",
        paddingBottom: "0.7px"
      },
      ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ underline("#d11") },
      ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ underline("orange") },
      ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ underline("#999") },
      ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ underline("#66d") },
      ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
      ".cm-tooltip-lint": {
        padding: 0,
        margin: 0
      },
      ".cm-lintPoint": {
        position: "relative",
        "&:after": {
          content: '""',
          position: "absolute",
          bottom: 0,
          left: "-2px",
          borderLeft: "3px solid transparent",
          borderRight: "3px solid transparent",
          borderBottom: "4px solid #d11"
        }
      },
      ".cm-lintPoint-warning": {
        "&:after": { borderBottomColor: "orange" }
      },
      ".cm-lintPoint-info": {
        "&:after": { borderBottomColor: "#999" }
      },
      ".cm-lintPoint-hint": {
        "&:after": { borderBottomColor: "#66d" }
      },
      ".cm-panel.cm-panel-lint": {
        position: "relative",
        "& ul": {
          maxHeight: "100px",
          overflowY: "auto",
          "& [aria-selected]": {
            backgroundColor: "#ddd",
            "& u": { textDecoration: "underline" }
          },
          "&:focus [aria-selected]": {
            background_fallback: "#bdf",
            backgroundColor: "Highlight",
            color_fallback: "white",
            color: "HighlightText"
          },
          "& u": { textDecoration: "none" },
          padding: 0,
          margin: 0
        },
        "& [name=close]": {
          position: "absolute",
          top: "0",
          right: "2px",
          background: "inherit",
          border: "none",
          font: "inherit",
          padding: 0,
          margin: 0
        }
      }
    });
    function severityWeight(sev) {
      return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
    }
    function maxSeverity(diagnostics) {
      let sev = "hint", weight = 1;
      for (let d of diagnostics) {
        let w = severityWeight(d.severity);
        if (w > weight) {
          weight = w;
          sev = d.severity;
        }
      }
      return sev;
    }
    const lintExtensions = [
      lintState,
      /* @__PURE__ */ EditorView.decorations.compute([lintState], (state) => {
        let { selected, panel } = state.field(lintState);
        return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
          activeMark.range(selected.from, selected.to)
        ]);
      }),
      /* @__PURE__ */ hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
      baseTheme
    ];
    var basicSetup = function basicSetup2(options) {
      if (options === void 0) {
        options = {};
      }
      var {
        crosshairCursor: initCrosshairCursor = false
      } = options;
      var keymaps = [];
      if (options.closeBracketsKeymap !== false) {
        keymaps = keymaps.concat(closeBracketsKeymap);
      }
      if (options.defaultKeymap !== false) {
        keymaps = keymaps.concat(defaultKeymap);
      }
      if (options.searchKeymap !== false) {
        keymaps = keymaps.concat(searchKeymap);
      }
      if (options.historyKeymap !== false) {
        keymaps = keymaps.concat(historyKeymap);
      }
      if (options.foldKeymap !== false) {
        keymaps = keymaps.concat(foldKeymap);
      }
      if (options.completionKeymap !== false) {
        keymaps = keymaps.concat(completionKeymap);
      }
      if (options.lintKeymap !== false) {
        keymaps = keymaps.concat(lintKeymap);
      }
      var extensions = [];
      if (options.lineNumbers !== false) extensions.push(lineNumbers());
      if (options.highlightActiveLineGutter !== false) extensions.push(highlightActiveLineGutter());
      if (options.highlightSpecialChars !== false) extensions.push(highlightSpecialChars());
      if (options.history !== false) extensions.push(history());
      if (options.foldGutter !== false) extensions.push(foldGutter());
      if (options.drawSelection !== false) extensions.push(drawSelection());
      if (options.dropCursor !== false) extensions.push(dropCursor());
      if (options.allowMultipleSelections !== false) extensions.push(EditorState.allowMultipleSelections.of(true));
      if (options.indentOnInput !== false) extensions.push(indentOnInput());
      if (options.syntaxHighlighting !== false) extensions.push(syntaxHighlighting(defaultHighlightStyle, {
        fallback: true
      }));
      if (options.bracketMatching !== false) extensions.push(bracketMatching());
      if (options.closeBrackets !== false) extensions.push(closeBrackets());
      if (options.autocompletion !== false) extensions.push(autocompletion());
      if (options.rectangularSelection !== false) extensions.push(rectangularSelection());
      if (initCrosshairCursor !== false) extensions.push(crosshairCursor());
      if (options.highlightActiveLine !== false) extensions.push(highlightActiveLine());
      if (options.highlightSelectionMatches !== false) extensions.push(highlightSelectionMatches());
      if (options.tabSize && typeof options.tabSize === "number") extensions.push(indentUnit.of(" ".repeat(options.tabSize)));
      return extensions.concat([keymap.of(keymaps.flat())]).filter(Boolean);
    };
    const chalky = "#e5c07b", coral = "#e06c75", cyan = "#56b6c2", invalid = "#ffffff", ivory = "#abb2bf", stone = "#7d8799", malibu = "#61afef", sage = "#98c379", whiskey = "#d19a66", violet = "#c678dd", darkBackground = "#21252b", highlightBackground = "#2c313a", background = "#282c34", tooltipBackground = "#353a42", selection = "#3E4451", cursor = "#528bff";
    const oneDarkTheme = /* @__PURE__ */ EditorView.theme({
      "&": {
        color: ivory,
        backgroundColor: background
      },
      ".cm-content": {
        caretColor: cursor
      },
      ".cm-cursor, .cm-dropCursor": { borderLeftColor: cursor },
      "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection },
      ".cm-panels": { backgroundColor: darkBackground, color: ivory },
      ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
      ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
      ".cm-searchMatch": {
        backgroundColor: "#72a1ff59",
        outline: "1px solid #457dff"
      },
      ".cm-searchMatch.cm-searchMatch-selected": {
        backgroundColor: "#6199ff2f"
      },
      ".cm-activeLine": { backgroundColor: "#6699ff0b" },
      ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
      "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
        backgroundColor: "#bad0f847"
      },
      ".cm-gutters": {
        backgroundColor: background,
        color: stone,
        border: "none"
      },
      ".cm-activeLineGutter": {
        backgroundColor: highlightBackground
      },
      ".cm-foldPlaceholder": {
        backgroundColor: "transparent",
        border: "none",
        color: "#ddd"
      },
      ".cm-tooltip": {
        border: "none",
        backgroundColor: tooltipBackground
      },
      ".cm-tooltip .cm-tooltip-arrow:before": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      },
      ".cm-tooltip .cm-tooltip-arrow:after": {
        borderTopColor: tooltipBackground,
        borderBottomColor: tooltipBackground
      },
      ".cm-tooltip-autocomplete": {
        "& > ul > li[aria-selected]": {
          backgroundColor: highlightBackground,
          color: ivory
        }
      }
    }, { dark: true });
    const oneDarkHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
      {
        tag: tags.keyword,
        color: violet
      },
      {
        tag: [tags.name, tags.deleted, tags.character, tags.propertyName, tags.macroName],
        color: coral
      },
      {
        tag: [/* @__PURE__ */ tags.function(tags.variableName), tags.labelName],
        color: malibu
      },
      {
        tag: [tags.color, /* @__PURE__ */ tags.constant(tags.name), /* @__PURE__ */ tags.standard(tags.name)],
        color: whiskey
      },
      {
        tag: [/* @__PURE__ */ tags.definition(tags.name), tags.separator],
        color: ivory
      },
      {
        tag: [tags.typeName, tags.className, tags.number, tags.changed, tags.annotation, tags.modifier, tags.self, tags.namespace],
        color: chalky
      },
      {
        tag: [tags.operator, tags.operatorKeyword, tags.url, tags.escape, tags.regexp, tags.link, /* @__PURE__ */ tags.special(tags.string)],
        color: cyan
      },
      {
        tag: [tags.meta, tags.comment],
        color: stone
      },
      {
        tag: tags.strong,
        fontWeight: "bold"
      },
      {
        tag: tags.emphasis,
        fontStyle: "italic"
      },
      {
        tag: tags.strikethrough,
        textDecoration: "line-through"
      },
      {
        tag: tags.link,
        color: stone,
        textDecoration: "underline"
      },
      {
        tag: tags.heading,
        fontWeight: "bold",
        color: coral
      },
      {
        tag: [tags.atom, tags.bool, /* @__PURE__ */ tags.special(tags.variableName)],
        color: whiskey
      },
      {
        tag: [tags.processingInstruction, tags.string, tags.inserted],
        color: sage
      },
      {
        tag: tags.invalid,
        color: invalid
      }
    ]);
    const oneDark = [oneDarkTheme, /* @__PURE__ */ syntaxHighlighting(oneDarkHighlightStyle)];
    var defaultLightThemeOption = EditorView.theme({
      "&": {
        backgroundColor: "#fff"
      }
    }, {
      dark: false
    });
    var getDefaultExtensions = function getDefaultExtensions2(optios) {
      if (optios === void 0) {
        optios = {};
      }
      var {
        indentWithTab: defaultIndentWithTab = true,
        editable: editable2 = true,
        readOnly: readOnly2 = false,
        theme: theme2 = "light",
        placeholder: placeholderStr = "",
        basicSetup: defaultBasicSetup = true
      } = optios;
      var getExtensions = [];
      if (defaultIndentWithTab) {
        getExtensions.unshift(keymap.of([indentWithTab]));
      }
      if (defaultBasicSetup) {
        if (typeof defaultBasicSetup === "boolean") {
          getExtensions.unshift(basicSetup());
        } else {
          getExtensions.unshift(basicSetup(defaultBasicSetup));
        }
      }
      if (placeholderStr) {
        getExtensions.unshift(placeholder(placeholderStr));
      }
      switch (theme2) {
        case "light":
          getExtensions.push(defaultLightThemeOption);
          break;
        case "dark":
          getExtensions.push(oneDark);
          break;
        case "none":
          break;
        default:
          getExtensions.push(theme2);
          break;
      }
      if (editable2 === false) {
        getExtensions.push(EditorView.editable.of(false));
      }
      if (readOnly2) {
        getExtensions.push(EditorState.readOnly.of(true));
      }
      return [...getExtensions];
    };
    var getStatistics = (view) => {
      return {
        line: view.state.doc.lineAt(view.state.selection.main.from),
        lineCount: view.state.doc.lines,
        lineBreak: view.state.lineBreak,
        length: view.state.doc.length,
        readOnly: view.state.readOnly,
        tabSize: view.state.tabSize,
        selection: view.state.selection,
        selectionAsSingle: view.state.selection.asSingle().main,
        ranges: view.state.selection.ranges,
        selectionCode: view.state.sliceDoc(view.state.selection.main.from, view.state.selection.main.to),
        selections: view.state.selection.ranges.map((r) => view.state.sliceDoc(r.from, r.to)),
        selectedText: view.state.selection.ranges.some((r) => !r.empty)
      };
    };
    class TimeoutLatch {
      constructor(callback2, timeoutMS) {
        this.timeLeftMS = void 0;
        this.timeoutMS = void 0;
        this.isCancelled = false;
        this.isTimeExhausted = false;
        this.callbacks = [];
        this.timeLeftMS = timeoutMS;
        this.timeoutMS = timeoutMS;
        this.callbacks.push(callback2);
      }
      tick() {
        if (!this.isCancelled && !this.isTimeExhausted) {
          this.timeLeftMS--;
          if (this.timeLeftMS <= 0) {
            this.isTimeExhausted = true;
            var callbacks = this.callbacks.slice();
            this.callbacks.length = 0;
            callbacks.forEach((callback2) => {
              try {
                callback2();
              } catch (error2) {
                console.error("TimeoutLatch callback error:", error2);
              }
            });
          }
        }
      }
      cancel() {
        this.isCancelled = true;
        this.callbacks.length = 0;
      }
      reset() {
        this.timeLeftMS = this.timeoutMS;
        this.isCancelled = false;
        this.isTimeExhausted = false;
      }
      get isDone() {
        return this.isCancelled || this.isTimeExhausted;
      }
    }
    class Scheduler {
      constructor() {
        this.interval = null;
        this.latches = /* @__PURE__ */ new Set();
      }
      add(latch) {
        this.latches.add(latch);
        this.start();
      }
      remove(latch) {
        this.latches.delete(latch);
        if (this.latches.size === 0) {
          this.stop();
        }
      }
      start() {
        if (this.interval === null) {
          this.interval = setInterval(() => {
            this.latches.forEach((latch) => {
              latch.tick();
              if (latch.isDone) {
                this.remove(latch);
              }
            });
          }, 1);
        }
      }
      stop() {
        if (this.interval !== null) {
          clearInterval(this.interval);
          this.interval = null;
        }
      }
    }
    var globalScheduler = null;
    var getScheduler = () => {
      if (typeof window === "undefined") {
        return new Scheduler();
      }
      if (!globalScheduler) {
        globalScheduler = new Scheduler();
      }
      return globalScheduler;
    };
    var ExternalChange = Annotation.define();
    var TYPING_TIMOUT = 200;
    var emptyExtensions = [];
    function useCodeMirror(props) {
      var {
        value,
        selection: selection2,
        onChange,
        onStatistics,
        onCreateEditor,
        onUpdate,
        extensions = emptyExtensions,
        autoFocus,
        theme: theme2 = "light",
        height = null,
        minHeight = null,
        maxHeight = null,
        width = null,
        minWidth = null,
        maxWidth = null,
        placeholder: placeholderStr = "",
        editable: editable2 = true,
        readOnly: readOnly2 = false,
        indentWithTab: defaultIndentWithTab = true,
        basicSetup: defaultBasicSetup = true,
        root,
        initialState
      } = props;
      var [container2, setContainer] = reactExports.useState();
      var [view, setView] = reactExports.useState();
      var [state, setState] = reactExports.useState();
      var typingLatch = reactExports.useState(() => ({
        current: null
      }))[0];
      var pendingUpdate = reactExports.useState(() => ({
        current: null
      }))[0];
      var defaultThemeOption = EditorView.theme({
        "&": {
          height,
          minHeight,
          maxHeight,
          width,
          minWidth,
          maxWidth
        },
        "& .cm-scroller": {
          height: "100% !important"
        }
      });
      var updateListener2 = EditorView.updateListener.of((vu) => {
        if (vu.docChanged && typeof onChange === "function" && // Fix echoing of the remote changes:
        // If transaction is market as remote we don't have to call `onChange` handler again
        !vu.transactions.some((tr) => tr.annotation(ExternalChange))) {
          if (typingLatch.current) {
            typingLatch.current.reset();
          } else {
            typingLatch.current = new TimeoutLatch(() => {
              if (pendingUpdate.current) {
                var forceUpdate = pendingUpdate.current;
                pendingUpdate.current = null;
                forceUpdate();
              }
              typingLatch.current = null;
            }, TYPING_TIMOUT);
            getScheduler().add(typingLatch.current);
          }
          var doc2 = vu.state.doc;
          var _value = doc2.toString();
          onChange(_value, vu);
        }
        onStatistics && onStatistics(getStatistics(vu));
      });
      var defaultExtensions = getDefaultExtensions({
        theme: theme2,
        editable: editable2,
        readOnly: readOnly2,
        placeholder: placeholderStr,
        indentWithTab: defaultIndentWithTab,
        basicSetup: defaultBasicSetup
      });
      var getExtensions = [updateListener2, defaultThemeOption, ...defaultExtensions];
      if (onUpdate && typeof onUpdate === "function") {
        getExtensions.push(EditorView.updateListener.of(onUpdate));
      }
      getExtensions = getExtensions.concat(extensions);
      reactExports.useLayoutEffect(() => {
        if (container2 && !state) {
          var config2 = {
            doc: value,
            selection: selection2,
            extensions: getExtensions
          };
          var stateCurrent = initialState ? EditorState.fromJSON(initialState.json, config2, initialState.fields) : EditorState.create(config2);
          setState(stateCurrent);
          if (!view) {
            var viewCurrent = new EditorView({
              state: stateCurrent,
              parent: container2,
              root
            });
            setView(viewCurrent);
            onCreateEditor && onCreateEditor(viewCurrent, stateCurrent);
          }
        }
        return () => {
          if (view) {
            setState(void 0);
            setView(void 0);
          }
        };
      }, [container2, state]);
      reactExports.useEffect(() => {
        if (props.container) {
          setContainer(props.container);
        }
      }, [props.container]);
      reactExports.useEffect(() => () => {
        if (view) {
          view.destroy();
          setView(void 0);
        }
        if (typingLatch.current) {
          typingLatch.current.cancel();
          typingLatch.current = null;
        }
      }, [view]);
      reactExports.useEffect(() => {
        if (autoFocus && view) {
          view.focus();
        }
      }, [autoFocus, view]);
      reactExports.useEffect(() => {
        if (view) {
          view.dispatch({
            effects: StateEffect.reconfigure.of(getExtensions)
          });
        }
      }, [theme2, extensions, height, minHeight, maxHeight, width, minWidth, maxWidth, placeholderStr, editable2, readOnly2, defaultIndentWithTab, defaultBasicSetup, onChange, onUpdate]);
      reactExports.useEffect(() => {
        if (value === void 0) {
          return;
        }
        var currentValue = view ? view.state.doc.toString() : "";
        if (view && value !== currentValue) {
          var isTyping = typingLatch.current && !typingLatch.current.isDone;
          var forceUpdate = () => {
            if (view && value !== view.state.doc.toString()) {
              view.dispatch({
                changes: {
                  from: 0,
                  to: view.state.doc.toString().length,
                  insert: value || ""
                },
                annotations: [ExternalChange.of(true)]
              });
            }
          };
          if (!isTyping) {
            forceUpdate();
          } else {
            pendingUpdate.current = forceUpdate;
          }
        }
      }, [value, view]);
      return {
        state,
        setState,
        view,
        setView,
        container: container2,
        setContainer
      };
    }
    var _excluded = ["className", "value", "selection", "extensions", "onChange", "onStatistics", "onCreateEditor", "onUpdate", "autoFocus", "theme", "height", "minHeight", "maxHeight", "width", "minWidth", "maxWidth", "basicSetup", "placeholder", "indentWithTab", "editable", "readOnly", "root", "initialState"];
    var ReactCodeMirror = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var {
        className,
        value = "",
        selection: selection2,
        extensions = [],
        onChange,
        onStatistics,
        onCreateEditor,
        onUpdate,
        autoFocus,
        theme: theme2 = "light",
        height,
        minHeight,
        maxHeight,
        width,
        minWidth,
        maxWidth,
        basicSetup: basicSetup2,
        placeholder: placeholder2,
        indentWithTab: indentWithTab2,
        editable: editable2,
        readOnly: readOnly2,
        root,
        initialState
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
      var editor = reactExports.useRef(null);
      var {
        state,
        view,
        container: container2,
        setContainer
      } = useCodeMirror({
        root,
        value,
        autoFocus,
        theme: theme2,
        height,
        minHeight,
        maxHeight,
        width,
        minWidth,
        maxWidth,
        basicSetup: basicSetup2,
        placeholder: placeholder2,
        indentWithTab: indentWithTab2,
        editable: editable2,
        readOnly: readOnly2,
        selection: selection2,
        onChange,
        onStatistics,
        onCreateEditor,
        onUpdate,
        extensions,
        initialState
      });
      reactExports.useImperativeHandle(ref, () => ({
        editor: editor.current,
        state,
        view
      }), [editor, container2, state, view]);
      var setEditorRef = reactExports.useCallback((el) => {
        editor.current = el;
        setContainer(el);
      }, [setContainer]);
      if (typeof value !== "string") {
        throw new Error("value must be typeof string but got " + typeof value);
      }
      var defaultClassNames = typeof theme2 === "string" ? "cm-theme-" + theme2 : "cm-theme";
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", _extends({
        ref: setEditorRef,
        className: "" + defaultClassNames + (className ? " " + className : "")
      }, other));
    });
    ReactCodeMirror.displayName = "CodeMirror";
    var define_process_env_default = {};
    class Stack {
      /**
      @internal
      */
      constructor(p, stack, state, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent) {
        this.p = p;
        this.stack = stack;
        this.state = state;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score2;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.curContext = curContext;
        this.lookAhead = lookAhead;
        this.parent = parent;
      }
      /**
      @internal
      */
      toString() {
        return `[${this.stack.filter((_, i2) => i2 % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
      }
      // Start an empty stack
      /**
      @internal
      */
      static start(p, state, pos = 0) {
        let cx = p.parser.context;
        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
      }
      /**
      The stack's current [context](#lr.ContextTracker) value, if
      any. Its type will depend on the context tracker's type
      parameter, or it will be `null` if there is no context
      tracker.
      */
      get context() {
        return this.curContext ? this.curContext.context : null;
      }
      // Push a state onto the stack, tracking its start position as well
      // as the buffer base at that point.
      /**
      @internal
      */
      pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
      }
      // Apply a reduce action
      /**
      @internal
      */
      reduce(action) {
        var _a2;
        let depth = action >> 19, type = action & 65535;
        let { parser: parser2 } = this.p;
        let lookaheadRecord = this.reducePos < this.pos - 25 && this.setLookAhead(this.pos);
        let dPrec = parser2.dynamicPrecedence(type);
        if (dPrec)
          this.score += dPrec;
        if (depth == 0) {
          this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
          if (type < parser2.minRepeatTerm)
            this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
          this.reduceContext(type, this.reducePos);
          return;
        }
        let base2 = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
        let start = base2 ? this.stack[base2 - 2] : this.p.ranges[0].from, size = this.reducePos - start;
        if (size >= 2e3 && !((_a2 = this.p.parser.nodeSet.types[type]) === null || _a2 === void 0 ? void 0 : _a2.isAnonymous)) {
          if (start == this.p.lastBigReductionStart) {
            this.p.bigReductionCount++;
            this.p.lastBigReductionSize = size;
          } else if (this.p.lastBigReductionSize < size) {
            this.p.bigReductionCount = 1;
            this.p.lastBigReductionStart = start;
            this.p.lastBigReductionSize = size;
          }
        }
        let bufferBase = base2 ? this.stack[base2 - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
        if (type < parser2.minRepeatTerm || action & 131072) {
          let pos = parser2.stateFlag(
            this.state,
            1
            /* StateFlag.Skipped */
          ) ? this.pos : this.reducePos;
          this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & 262144) {
          this.state = this.stack[base2];
        } else {
          let baseStateID = this.stack[base2 - 3];
          this.state = parser2.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base2)
          this.stack.pop();
        this.reduceContext(type, start);
      }
      // Shift a value into the buffer
      /**
      @internal
      */
      storeNode(term, start, end, size = 4, mustSink = false) {
        if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
          let cur2 = this, top2 = this.buffer.length;
          if (top2 == 0 && cur2.parent) {
            top2 = cur2.bufferBase - cur2.parent.bufferBase;
            cur2 = cur2.parent;
          }
          if (top2 > 0 && cur2.buffer[top2 - 4] == 0 && cur2.buffer[top2 - 1] > -1) {
            if (start == end)
              return;
            if (cur2.buffer[top2 - 2] >= start) {
              cur2.buffer[top2 - 2] = end;
              return;
            }
          }
        }
        if (!mustSink || this.pos == end) {
          this.buffer.push(term, start, end, size);
        } else {
          let index2 = this.buffer.length;
          if (index2 > 0 && (this.buffer[index2 - 4] != 0 || this.buffer[index2 - 1] < 0)) {
            let mustMove = false;
            for (let scan = index2; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {
              if (this.buffer[scan - 1] >= 0) {
                mustMove = true;
                break;
              }
            }
            if (mustMove)
              while (index2 > 0 && this.buffer[index2 - 2] > end) {
                this.buffer[index2] = this.buffer[index2 - 4];
                this.buffer[index2 + 1] = this.buffer[index2 - 3];
                this.buffer[index2 + 2] = this.buffer[index2 - 2];
                this.buffer[index2 + 3] = this.buffer[index2 - 1];
                index2 -= 4;
                if (size > 4)
                  size -= 4;
              }
          }
          this.buffer[index2] = term;
          this.buffer[index2 + 1] = start;
          this.buffer[index2 + 2] = end;
          this.buffer[index2 + 3] = size;
        }
      }
      // Apply a shift action
      /**
      @internal
      */
      shift(action, type, start, end) {
        if (action & 131072) {
          this.pushState(action & 65535, this.pos);
        } else if ((action & 262144) == 0) {
          let nextState = action, { parser: parser2 } = this.p;
          if (end > this.pos || type <= parser2.maxNode) {
            this.pos = end;
            if (!parser2.stateFlag(
              nextState,
              1
              /* StateFlag.Skipped */
            ))
              this.reducePos = end;
          }
          this.pushState(nextState, start);
          this.shiftContext(type, start);
          if (type <= parser2.maxNode)
            this.buffer.push(type, start, end, 4);
        } else {
          this.pos = end;
          this.shiftContext(type, start);
          if (type <= this.p.parser.maxNode)
            this.buffer.push(type, start, end, 4);
        }
      }
      // Apply an action
      /**
      @internal
      */
      apply(action, next, nextStart, nextEnd) {
        if (action & 65536)
          this.reduce(action);
        else
          this.shift(action, next, nextStart, nextEnd);
      }
      // Add a prebuilt (reused) node into the buffer.
      /**
      @internal
      */
      useNode(value, next) {
        let index2 = this.p.reused.length - 1;
        if (index2 < 0 || this.p.reused[index2] != value) {
          this.p.reused.push(value);
          index2++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(
          index2,
          start,
          this.reducePos,
          -1
          /* size == -1 means this is a reused value */
        );
        if (this.curContext)
          this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
      }
      // Split the stack. Due to the buffer sharing and the fact
      // that `this.stack` tends to stay quite shallow, this isn't very
      // expensive.
      /**
      @internal
      */
      split() {
        let parent = this;
        let off = parent.buffer.length;
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
          off -= 4;
        let buffer = parent.buffer.slice(off), base2 = parent.bufferBase + off;
        while (parent && base2 == parent.bufferBase)
          parent = parent.parent;
        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
      }
      // Try to recover from an error by 'deleting' (ignoring) one token.
      /**
      @internal
      */
      recoverByDelete(next, nextEnd) {
        let isNode = next <= this.p.parser.maxNode;
        if (isNode)
          this.storeNode(next, this.pos, nextEnd, 4);
        this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 190;
      }
      /**
      Check if the given term would be able to be shifted (optionally
      after some reductions) on this stack. This can be useful for
      external tokenizers that want to make sure they only provide a
      given token when it applies.
      */
      canShift(term) {
        for (let sim = new SimulatedStack(this); ; ) {
          let action = this.p.parser.stateSlot(
            sim.state,
            4
            /* ParseState.DefaultReduce */
          ) || this.p.parser.hasAction(sim.state, term);
          if (action == 0)
            return false;
          if ((action & 65536) == 0)
            return true;
          sim.reduce(action);
        }
      }
      // Apply up to Recover.MaxNext recovery actions that conceptually
      // inserts some missing token or rule.
      /**
      @internal
      */
      recoverByInsert(next) {
        if (this.stack.length >= 300)
          return [];
        let nextStates = this.p.parser.nextStates(this.state);
        if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
          let best = [];
          for (let i2 = 0, s; i2 < nextStates.length; i2 += 2) {
            if ((s = nextStates[i2 + 1]) != this.state && this.p.parser.hasAction(s, next))
              best.push(nextStates[i2], s);
          }
          if (this.stack.length < 120)
            for (let i2 = 0; best.length < 4 << 1 && i2 < nextStates.length; i2 += 2) {
              let s = nextStates[i2 + 1];
              if (!best.some((v, i22) => i22 & 1 && v == s))
                best.push(nextStates[i2], s);
            }
          nextStates = best;
        }
        let result = [];
        for (let i2 = 0; i2 < nextStates.length && result.length < 4; i2 += 2) {
          let s = nextStates[i2 + 1];
          if (s == this.state)
            continue;
          let stack = this.split();
          stack.pushState(s, this.pos);
          stack.storeNode(0, stack.pos, stack.pos, 4, true);
          stack.shiftContext(nextStates[i2], this.pos);
          stack.reducePos = this.pos;
          stack.score -= 200;
          result.push(stack);
        }
        return result;
      }
      // Force a reduce, if possible. Return false if that can't
      // be done.
      /**
      @internal
      */
      forceReduce() {
        let { parser: parser2 } = this.p;
        let reduce = parser2.stateSlot(
          this.state,
          5
          /* ParseState.ForcedReduce */
        );
        if ((reduce & 65536) == 0)
          return false;
        if (!parser2.validAction(this.state, reduce)) {
          let depth = reduce >> 19, term = reduce & 65535;
          let target = this.stack.length - depth * 3;
          if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0) {
            let backup = this.findForcedReduction();
            if (backup == null)
              return false;
            reduce = backup;
          }
          this.storeNode(0, this.pos, this.pos, 4, true);
          this.score -= 100;
        }
        this.reducePos = this.pos;
        this.reduce(reduce);
        return true;
      }
      /**
      Try to scan through the automaton to find some kind of reduction
      that can be applied. Used when the regular ForcedReduce field
      isn't a valid action. @internal
      */
      findForcedReduction() {
        let { parser: parser2 } = this.p, seen = [];
        let explore = (state, depth) => {
          if (seen.includes(state))
            return;
          seen.push(state);
          return parser2.allActions(state, (action) => {
            if (action & (262144 | 131072)) ;
            else if (action & 65536) {
              let rDepth = (action >> 19) - depth;
              if (rDepth > 1) {
                let term = action & 65535, target = this.stack.length - rDepth * 3;
                if (target >= 0 && parser2.getGoto(this.stack[target], term, false) >= 0)
                  return rDepth << 19 | 65536 | term;
              }
            } else {
              let found = explore(action, depth + 1);
              if (found != null)
                return found;
            }
          });
        };
        return explore(this.state, 0);
      }
      /**
      @internal
      */
      forceAll() {
        while (!this.p.parser.stateFlag(
          this.state,
          2
          /* StateFlag.Accepting */
        )) {
          if (!this.forceReduce()) {
            this.storeNode(0, this.pos, this.pos, 4, true);
            break;
          }
        }
        return this;
      }
      /**
      Check whether this state has no further actions (assumed to be a direct descendant of the
      top state, since any other states must be able to continue
      somehow). @internal
      */
      get deadEnd() {
        if (this.stack.length != 3)
          return false;
        let { parser: parser2 } = this.p;
        return parser2.data[parser2.stateSlot(
          this.state,
          1
          /* ParseState.Actions */
        )] == 65535 && !parser2.stateSlot(
          this.state,
          4
          /* ParseState.DefaultReduce */
        );
      }
      /**
      Restart the stack (put it back in its start state). Only safe
      when this.stack.length == 3 (state is directly below the top
      state). @internal
      */
      restart() {
        this.storeNode(0, this.pos, this.pos, 4, true);
        this.state = this.stack[0];
        this.stack.length = 0;
      }
      /**
      @internal
      */
      sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length)
          return false;
        for (let i2 = 0; i2 < this.stack.length; i2 += 3)
          if (this.stack[i2] != other.stack[i2])
            return false;
        return true;
      }
      /**
      Get the parser used by this stack.
      */
      get parser() {
        return this.p.parser;
      }
      /**
      Test whether a given dialect (by numeric ID, as exported from
      the terms file) is enabled.
      */
      dialectEnabled(dialectID) {
        return this.p.parser.dialect.flags[dialectID];
      }
      shiftContext(term, start) {
        if (this.curContext)
          this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
      }
      reduceContext(term, start) {
        if (this.curContext)
          this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
      }
      /**
      @internal
      */
      emitContext() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -3)
          this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
      }
      /**
      @internal
      */
      emitLookAhead() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -4)
          this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
      }
      updateContext(context) {
        if (context != this.curContext.context) {
          let newCx = new StackContext(this.curContext.tracker, context);
          if (newCx.hash != this.curContext.hash)
            this.emitContext();
          this.curContext = newCx;
        }
      }
      /**
      @internal
      */
      setLookAhead(lookAhead) {
        if (lookAhead <= this.lookAhead)
          return false;
        this.emitLookAhead();
        this.lookAhead = lookAhead;
        return true;
      }
      /**
      @internal
      */
      close() {
        if (this.curContext && this.curContext.tracker.strict)
          this.emitContext();
        if (this.lookAhead > 0)
          this.emitLookAhead();
      }
    }
    class StackContext {
      constructor(tracker, context) {
        this.tracker = tracker;
        this.context = context;
        this.hash = tracker.strict ? tracker.hash(context) : 0;
      }
    }
    class SimulatedStack {
      constructor(start) {
        this.start = start;
        this.state = start.state;
        this.stack = start.stack;
        this.base = this.stack.length;
      }
      reduce(action) {
        let term = action & 65535, depth = action >> 19;
        if (depth == 0) {
          if (this.stack == this.start.stack)
            this.stack = this.stack.slice();
          this.stack.push(this.state, 0, 0);
          this.base += 3;
        } else {
          this.base -= (depth - 1) * 3;
        }
        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
        this.state = goto;
      }
    }
    class StackBufferCursor {
      constructor(stack, pos, index2) {
        this.stack = stack;
        this.pos = pos;
        this.index = index2;
        this.buffer = stack.buffer;
        if (this.index == 0)
          this.maybeNext();
      }
      static create(stack, pos = stack.bufferBase + stack.buffer.length) {
        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
      }
      maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
          this.index = this.stack.bufferBase - next.bufferBase;
          this.stack = next;
          this.buffer = next.buffer;
        }
      }
      get id() {
        return this.buffer[this.index - 4];
      }
      get start() {
        return this.buffer[this.index - 3];
      }
      get end() {
        return this.buffer[this.index - 2];
      }
      get size() {
        return this.buffer[this.index - 1];
      }
      next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0)
          this.maybeNext();
      }
      fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
      }
    }
    function decodeArray(input, Type = Uint16Array) {
      if (typeof input != "string")
        return input;
      let array = null;
      for (let pos = 0, out = 0; pos < input.length; ) {
        let value = 0;
        for (; ; ) {
          let next = input.charCodeAt(pos++), stop = false;
          if (next == 126) {
            value = 65535;
            break;
          }
          if (next >= 92)
            next--;
          if (next >= 34)
            next--;
          let digit = next - 32;
          if (digit >= 46) {
            digit -= 46;
            stop = true;
          }
          value += digit;
          if (stop)
            break;
          value *= 46;
        }
        if (array)
          array[out++] = value;
        else
          array = new Type(value);
      }
      return array;
    }
    class CachedToken {
      constructor() {
        this.start = -1;
        this.value = -1;
        this.end = -1;
        this.extended = -1;
        this.lookAhead = 0;
        this.mask = 0;
        this.context = 0;
      }
    }
    const nullToken = new CachedToken();
    class InputStream {
      /**
      @internal
      */
      constructor(input, ranges) {
        this.input = input;
        this.ranges = ranges;
        this.chunk = "";
        this.chunkOff = 0;
        this.chunk2 = "";
        this.chunk2Pos = 0;
        this.next = -1;
        this.token = nullToken;
        this.rangeIndex = 0;
        this.pos = this.chunkPos = ranges[0].from;
        this.range = ranges[0];
        this.end = ranges[ranges.length - 1].to;
        this.readNext();
      }
      /**
      @internal
      */
      resolveOffset(offset, assoc) {
        let range = this.range, index2 = this.rangeIndex;
        let pos = this.pos + offset;
        while (pos < range.from) {
          if (!index2)
            return null;
          let next = this.ranges[--index2];
          pos -= range.from - next.to;
          range = next;
        }
        while (assoc < 0 ? pos > range.to : pos >= range.to) {
          if (index2 == this.ranges.length - 1)
            return null;
          let next = this.ranges[++index2];
          pos += next.from - range.to;
          range = next;
        }
        return pos;
      }
      /**
      @internal
      */
      clipPos(pos) {
        if (pos >= this.range.from && pos < this.range.to)
          return pos;
        for (let range of this.ranges)
          if (range.to > pos)
            return Math.max(pos, range.from);
        return this.end;
      }
      /**
      Look at a code unit near the stream position. `.peek(0)` equals
      `.next`, `.peek(-1)` gives you the previous character, and so
      on.
      
      Note that looking around during tokenizing creates dependencies
      on potentially far-away content, which may reduce the
      effectiveness incremental parsingwhen looking forwardor even
      cause invalid reparses when looking backward more than 25 code
      units, since the library does not track lookbehind.
      */
      peek(offset) {
        let idx = this.chunkOff + offset, pos, result;
        if (idx >= 0 && idx < this.chunk.length) {
          pos = this.pos + offset;
          result = this.chunk.charCodeAt(idx);
        } else {
          let resolved = this.resolveOffset(offset, 1);
          if (resolved == null)
            return -1;
          pos = resolved;
          if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
            result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
          } else {
            let i2 = this.rangeIndex, range = this.range;
            while (range.to <= pos)
              range = this.ranges[++i2];
            this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
            if (pos + this.chunk2.length > range.to)
              this.chunk2 = this.chunk2.slice(0, range.to - pos);
            result = this.chunk2.charCodeAt(0);
          }
        }
        if (pos >= this.token.lookAhead)
          this.token.lookAhead = pos + 1;
        return result;
      }
      /**
      Accept a token. By default, the end of the token is set to the
      current stream position, but you can pass an offset (relative to
      the stream position) to change that.
      */
      acceptToken(token, endOffset = 0) {
        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
        if (end == null || end < this.token.start)
          throw new RangeError("Token end out of bounds");
        this.token.value = token;
        this.token.end = end;
      }
      /**
      Accept a token ending at a specific given position.
      */
      acceptTokenTo(token, endPos) {
        this.token.value = token;
        this.token.end = endPos;
      }
      getChunk() {
        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
          let { chunk, chunkPos } = this;
          this.chunk = this.chunk2;
          this.chunkPos = this.chunk2Pos;
          this.chunk2 = chunk;
          this.chunk2Pos = chunkPos;
          this.chunkOff = this.pos - this.chunkPos;
        } else {
          this.chunk2 = this.chunk;
          this.chunk2Pos = this.chunkPos;
          let nextChunk = this.input.chunk(this.pos);
          let end = this.pos + nextChunk.length;
          this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
          this.chunkPos = this.pos;
          this.chunkOff = 0;
        }
      }
      readNext() {
        if (this.chunkOff >= this.chunk.length) {
          this.getChunk();
          if (this.chunkOff == this.chunk.length)
            return this.next = -1;
        }
        return this.next = this.chunk.charCodeAt(this.chunkOff);
      }
      /**
      Move the stream forward N (defaults to 1) code units. Returns
      the new value of [`next`](#lr.InputStream.next).
      */
      advance(n = 1) {
        this.chunkOff += n;
        while (this.pos + n >= this.range.to) {
          if (this.rangeIndex == this.ranges.length - 1)
            return this.setDone();
          n -= this.range.to - this.pos;
          this.range = this.ranges[++this.rangeIndex];
          this.pos = this.range.from;
        }
        this.pos += n;
        if (this.pos >= this.token.lookAhead)
          this.token.lookAhead = this.pos + 1;
        return this.readNext();
      }
      setDone() {
        this.pos = this.chunkPos = this.end;
        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
        this.chunk = "";
        return this.next = -1;
      }
      /**
      @internal
      */
      reset(pos, token) {
        if (token) {
          this.token = token;
          token.start = pos;
          token.lookAhead = pos + 1;
          token.value = token.extended = -1;
        } else {
          this.token = nullToken;
        }
        if (this.pos != pos) {
          this.pos = pos;
          if (pos == this.end) {
            this.setDone();
            return this;
          }
          while (pos < this.range.from)
            this.range = this.ranges[--this.rangeIndex];
          while (pos >= this.range.to)
            this.range = this.ranges[++this.rangeIndex];
          if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
            this.chunkOff = pos - this.chunkPos;
          } else {
            this.chunk = "";
            this.chunkOff = 0;
          }
          this.readNext();
        }
        return this;
      }
      /**
      @internal
      */
      read(from2, to2) {
        if (from2 >= this.chunkPos && to2 <= this.chunkPos + this.chunk.length)
          return this.chunk.slice(from2 - this.chunkPos, to2 - this.chunkPos);
        if (from2 >= this.chunk2Pos && to2 <= this.chunk2Pos + this.chunk2.length)
          return this.chunk2.slice(from2 - this.chunk2Pos, to2 - this.chunk2Pos);
        if (from2 >= this.range.from && to2 <= this.range.to)
          return this.input.read(from2, to2);
        let result = "";
        for (let r of this.ranges) {
          if (r.from >= to2)
            break;
          if (r.to > from2)
            result += this.input.read(Math.max(r.from, from2), Math.min(r.to, to2));
        }
        return result;
      }
    }
    class TokenGroup {
      constructor(data, id2) {
        this.data = data;
        this.id = id2;
      }
      token(input, stack) {
        let { parser: parser2 } = stack.p;
        readToken(this.data, input, stack, this.id, parser2.data, parser2.tokenPrecTable);
      }
    }
    TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
    TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
    class ExternalTokenizer {
      /**
      Create a tokenizer. The first argument is the function that,
      given an input stream, scans for the types of tokens it
      recognizes at the stream's position, and calls
      [`acceptToken`](#lr.InputStream.acceptToken) when it finds
      one.
      */
      constructor(token, options = {}) {
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
      }
    }
    function readToken(data, input, stack, group, precTable, precOffset) {
      let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
      scan: for (; ; ) {
        if ((groupMask & data[state]) == 0)
          break;
        let accEnd = data[state + 1];
        for (let i2 = state + 3; i2 < accEnd; i2 += 2)
          if ((data[i2 + 1] & groupMask) > 0) {
            let term = data[i2];
            if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
              input.acceptToken(term);
              break;
            }
          }
        let next = input.next, low = 0, high = data[state + 2];
        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535) {
          state = data[accEnd + high * 3 - 1];
          continue scan;
        }
        for (; low < high; ) {
          let mid = low + high >> 1;
          let index2 = accEnd + mid + (mid << 1);
          let from2 = data[index2], to2 = data[index2 + 1] || 65536;
          if (next < from2)
            high = mid;
          else if (next >= to2)
            low = mid + 1;
          else {
            state = data[index2 + 2];
            input.advance();
            continue scan;
          }
        }
        break;
      }
    }
    function findOffset(data, start, term) {
      for (let i2 = start, next; (next = data[i2]) != 65535; i2++)
        if (next == term)
          return i2 - start;
      return -1;
    }
    function overrides(token, prev, tableData, tableOffset) {
      let iPrev = findOffset(tableData, tableOffset, prev);
      return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
    }
    const verbose = typeof process != "undefined" && define_process_env_default && /\bparse\b/.test(define_process_env_default.LOG);
    let stackIDs = null;
    function cutAt(tree, pos, side) {
      let cursor2 = tree.cursor(IterMode.IncludeAnonymous);
      cursor2.moveTo(pos);
      for (; ; ) {
        if (!(side < 0 ? cursor2.childBefore(pos) : cursor2.childAfter(pos)))
          for (; ; ) {
            if ((side < 0 ? cursor2.to < pos : cursor2.from > pos) && !cursor2.type.isError)
              return side < 0 ? Math.max(0, Math.min(
                cursor2.to - 1,
                pos - 25
                /* Lookahead.Margin */
              )) : Math.min(tree.length, Math.max(
                cursor2.from + 1,
                pos + 25
                /* Lookahead.Margin */
              ));
            if (side < 0 ? cursor2.prevSibling() : cursor2.nextSibling())
              break;
            if (!cursor2.parent())
              return side < 0 ? 0 : tree.length;
          }
      }
    }
    class FragmentCursor {
      constructor(fragments, nodeSet) {
        this.fragments = fragments;
        this.nodeSet = nodeSet;
        this.i = 0;
        this.fragment = null;
        this.safeFrom = -1;
        this.safeTo = -1;
        this.trees = [];
        this.start = [];
        this.index = [];
        this.nextFragment();
      }
      nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
          this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
          this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
          while (this.trees.length) {
            this.trees.pop();
            this.start.pop();
            this.index.pop();
          }
          this.trees.push(fr.tree);
          this.start.push(-fr.offset);
          this.index.push(0);
          this.nextStart = this.safeFrom;
        } else {
          this.nextStart = 1e9;
        }
      }
      // `pos` must be >= any previously given `pos` for this cursor
      nodeAt(pos) {
        if (pos < this.nextStart)
          return null;
        while (this.fragment && this.safeTo <= pos)
          this.nextFragment();
        if (!this.fragment)
          return null;
        for (; ; ) {
          let last = this.trees.length - 1;
          if (last < 0) {
            this.nextFragment();
            return null;
          }
          let top2 = this.trees[last], index2 = this.index[last];
          if (index2 == top2.children.length) {
            this.trees.pop();
            this.start.pop();
            this.index.pop();
            continue;
          }
          let next = top2.children[index2];
          let start = this.start[last] + top2.positions[index2];
          if (start > pos) {
            this.nextStart = start;
            return null;
          }
          if (next instanceof Tree) {
            if (start == pos) {
              if (start < this.safeFrom)
                return null;
              let end = start + next.length;
              if (end <= this.safeTo) {
                let lookAhead = next.prop(NodeProp.lookAhead);
                if (!lookAhead || end + lookAhead < this.fragment.to)
                  return next;
              }
            }
            this.index[last]++;
            if (start + next.length >= Math.max(this.safeFrom, pos)) {
              this.trees.push(next);
              this.start.push(start);
              this.index.push(0);
            }
          } else {
            this.index[last]++;
            this.nextStart = start + next.length;
          }
        }
      }
    }
    class TokenCache {
      constructor(parser2, stream) {
        this.stream = stream;
        this.tokens = [];
        this.mainToken = null;
        this.actions = [];
        this.tokens = parser2.tokenizers.map((_) => new CachedToken());
      }
      getActions(stack) {
        let actionIndex = 0;
        let main = null;
        let { parser: parser2 } = stack.p, { tokenizers } = parser2;
        let mask = parser2.stateSlot(
          stack.state,
          3
          /* ParseState.TokenizerMask */
        );
        let context = stack.curContext ? stack.curContext.hash : 0;
        let lookAhead = 0;
        for (let i2 = 0; i2 < tokenizers.length; i2++) {
          if ((1 << i2 & mask) == 0)
            continue;
          let tokenizer = tokenizers[i2], token = this.tokens[i2];
          if (main && !tokenizer.fallback)
            continue;
          if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
            this.updateCachedToken(token, tokenizer, stack);
            token.mask = mask;
            token.context = context;
          }
          if (token.lookAhead > token.end + 25)
            lookAhead = Math.max(token.lookAhead, lookAhead);
          if (token.value != 0) {
            let startIndex = actionIndex;
            if (token.extended > -1)
              actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
            actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
            if (!tokenizer.extend) {
              main = token;
              if (actionIndex > startIndex)
                break;
            }
          }
        }
        while (this.actions.length > actionIndex)
          this.actions.pop();
        if (lookAhead)
          stack.setLookAhead(lookAhead);
        if (!main && stack.pos == this.stream.end) {
          main = new CachedToken();
          main.value = stack.p.parser.eofTerm;
          main.start = main.end = stack.pos;
          actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
        }
        this.mainToken = main;
        return this.actions;
      }
      getMainToken(stack) {
        if (this.mainToken)
          return this.mainToken;
        let main = new CachedToken(), { pos, p } = stack;
        main.start = pos;
        main.end = Math.min(pos + 1, p.stream.end);
        main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
        return main;
      }
      updateCachedToken(token, tokenizer, stack) {
        let start = this.stream.clipPos(stack.pos);
        tokenizer.token(this.stream.reset(start, token), stack);
        if (token.value > -1) {
          let { parser: parser2 } = stack.p;
          for (let i2 = 0; i2 < parser2.specialized.length; i2++)
            if (parser2.specialized[i2] == token.value) {
              let result = parser2.specializers[i2](this.stream.read(token.start, token.end), stack);
              if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                if ((result & 1) == 0)
                  token.value = result >> 1;
                else
                  token.extended = result >> 1;
                break;
              }
            }
        } else {
          token.value = 0;
          token.end = this.stream.clipPos(start + 1);
        }
      }
      putAction(action, token, end, index2) {
        for (let i2 = 0; i2 < index2; i2 += 3)
          if (this.actions[i2] == action)
            return index2;
        this.actions[index2++] = action;
        this.actions[index2++] = token;
        this.actions[index2++] = end;
        return index2;
      }
      addActions(stack, token, end, index2) {
        let { state } = stack, { parser: parser2 } = stack.p, { data } = parser2;
        for (let set2 = 0; set2 < 2; set2++) {
          for (let i2 = parser2.stateSlot(
            state,
            set2 ? 2 : 1
            /* ParseState.Actions */
          ); ; i2 += 3) {
            if (data[i2] == 65535) {
              if (data[i2 + 1] == 1) {
                i2 = pair(data, i2 + 2);
              } else {
                if (index2 == 0 && data[i2 + 1] == 2)
                  index2 = this.putAction(pair(data, i2 + 2), token, end, index2);
                break;
              }
            }
            if (data[i2] == token)
              index2 = this.putAction(pair(data, i2 + 1), token, end, index2);
          }
        }
        return index2;
      }
    }
    class Parse {
      constructor(parser2, input, fragments, ranges) {
        this.parser = parser2;
        this.input = input;
        this.ranges = ranges;
        this.recovering = 0;
        this.nextStackID = 9812;
        this.minStackPos = 0;
        this.reused = [];
        this.stoppedAt = null;
        this.lastBigReductionStart = -1;
        this.lastBigReductionSize = 0;
        this.bigReductionCount = 0;
        this.stream = new InputStream(input, ranges);
        this.tokens = new TokenCache(parser2, this.stream);
        this.topTerm = parser2.top[1];
        let { from: from2 } = ranges[0];
        this.stacks = [Stack.start(this, parser2.top[0], from2)];
        this.fragments = fragments.length && this.stream.end - from2 > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
      }
      get parsedPos() {
        return this.minStackPos;
      }
      // Move the parser forward. This will process all parse stacks at
      // `this.pos` and try to advance them to a further position. If no
      // stack for such a position is found, it'll start error-recovery.
      //
      // When the parse is finished, this will return a syntax tree. When
      // not, it returns `null`.
      advance() {
        let stacks = this.stacks, pos = this.minStackPos;
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        if (this.bigReductionCount > 300 && stacks.length == 1) {
          let [s] = stacks;
          while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) {
          }
          this.bigReductionCount = this.lastBigReductionSize = 0;
        }
        for (let i2 = 0; i2 < stacks.length; i2++) {
          let stack = stacks[i2];
          for (; ; ) {
            this.tokens.mainToken = null;
            if (stack.pos > pos) {
              newStacks.push(stack);
            } else if (this.advanceStack(stack, newStacks, stacks)) {
              continue;
            } else {
              if (!stopped) {
                stopped = [];
                stoppedTokens = [];
              }
              stopped.push(stack);
              let tok = this.tokens.getMainToken(stack);
              stoppedTokens.push(tok.value, tok.end);
            }
            break;
          }
        }
        if (!newStacks.length) {
          let finished = stopped && findFinished(stopped);
          if (finished) {
            if (verbose)
              console.log("Finish with " + this.stackID(finished));
            return this.stackToTree(finished);
          }
          if (this.parser.strict) {
            if (verbose && stopped)
              console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
            throw new SyntaxError("No parse at " + pos);
          }
          if (!this.recovering)
            this.recovering = 5;
        }
        if (this.recovering && stopped) {
          let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
          if (finished) {
            if (verbose)
              console.log("Force-finish " + this.stackID(finished));
            return this.stackToTree(finished.forceAll());
          }
        }
        if (this.recovering) {
          let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
          if (newStacks.length > maxRemaining) {
            newStacks.sort((a, b) => b.score - a.score);
            while (newStacks.length > maxRemaining)
              newStacks.pop();
          }
          if (newStacks.some((s) => s.reducePos > pos))
            this.recovering--;
        } else if (newStacks.length > 1) {
          outer: for (let i2 = 0; i2 < newStacks.length - 1; i2++) {
            let stack = newStacks[i2];
            for (let j = i2 + 1; j < newStacks.length; j++) {
              let other = newStacks[j];
              if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
                if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                  newStacks.splice(j--, 1);
                } else {
                  newStacks.splice(i2--, 1);
                  continue outer;
                }
              }
            }
          }
          if (newStacks.length > 12)
            newStacks.splice(
              12,
              newStacks.length - 12
              /* Rec.MaxStackCount */
            );
        }
        this.minStackPos = newStacks[0].pos;
        for (let i2 = 1; i2 < newStacks.length; i2++)
          if (newStacks[i2].pos < this.minStackPos)
            this.minStackPos = newStacks[i2].pos;
        return null;
      }
      stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos)
          throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = pos;
      }
      // Returns an updated version of the given stack, or null if the
      // stack can't advance normally. When `split` and `stacks` are
      // given, stacks split off by ambiguous operations will be pushed to
      // `split`, or added to `stacks` if they move `pos` forward.
      advanceStack(stack, stacks, split) {
        let start = stack.pos, { parser: parser2 } = this;
        let base2 = verbose ? this.stackID(stack) + " -> " : "";
        if (this.stoppedAt != null && start > this.stoppedAt)
          return stack.forceReduce() ? stack : null;
        if (this.fragments) {
          let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
          for (let cached = this.fragments.nodeAt(start); cached; ) {
            let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
            if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
              stack.useNode(cached, match);
              if (verbose)
                console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
              return true;
            }
            if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
              break;
            let inner = cached.children[0];
            if (inner instanceof Tree && cached.positions[0] == 0)
              cached = inner;
            else
              break;
          }
        }
        let defaultReduce = parser2.stateSlot(
          stack.state,
          4
          /* ParseState.DefaultReduce */
        );
        if (defaultReduce > 0) {
          stack.reduce(defaultReduce);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser2.getName(
              defaultReduce & 65535
              /* Action.ValueMask */
            )})`);
          return true;
        }
        if (stack.stack.length >= 8400) {
          while (stack.stack.length > 6e3 && stack.forceReduce()) {
          }
        }
        let actions2 = this.tokens.getActions(stack);
        for (let i2 = 0; i2 < actions2.length; ) {
          let action = actions2[i2++], term = actions2[i2++], end = actions2[i2++];
          let last = i2 == actions2.length || !split;
          let localStack = last ? stack : stack.split();
          let main = this.tokens.mainToken;
          localStack.apply(action, term, main ? main.start : localStack.pos, end);
          if (verbose)
            console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(
              action & 65535
              /* Action.ValueMask */
            )}`} for ${parser2.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
          if (last)
            return true;
          else if (localStack.pos > start)
            stacks.push(localStack);
          else
            split.push(localStack);
        }
        return false;
      }
      // Advance a given stack forward as far as it will go. Returns the
      // (possibly updated) stack if it got stuck, or null if it moved
      // forward and was given to `pushStackDedup`.
      advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for (; ; ) {
          if (!this.advanceStack(stack, null, null))
            return false;
          if (stack.pos > pos) {
            pushStackDedup(stack, newStacks);
            return true;
          }
        }
      }
      runRecovery(stacks, tokens, newStacks) {
        let finished = null, restarted = false;
        for (let i2 = 0; i2 < stacks.length; i2++) {
          let stack = stacks[i2], token = tokens[i2 << 1], tokenEnd = tokens[(i2 << 1) + 1];
          let base2 = verbose ? this.stackID(stack) + " -> " : "";
          if (stack.deadEnd) {
            if (restarted)
              continue;
            restarted = true;
            stack.restart();
            if (verbose)
              console.log(base2 + this.stackID(stack) + " (restarted)");
            let done = this.advanceFully(stack, newStacks);
            if (done)
              continue;
          }
          let force = stack.split(), forceBase = base2;
          for (let j = 0; j < 10 && force.forceReduce(); j++) {
            if (verbose)
              console.log(forceBase + this.stackID(force) + " (via force-reduce)");
            let done = this.advanceFully(force, newStacks);
            if (done)
              break;
            if (verbose)
              forceBase = this.stackID(force) + " -> ";
          }
          for (let insert2 of stack.recoverByInsert(token)) {
            if (verbose)
              console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
            this.advanceFully(insert2, newStacks);
          }
          if (this.stream.end > stack.pos) {
            if (tokenEnd == stack.pos) {
              tokenEnd++;
              token = 0;
            }
            stack.recoverByDelete(token, tokenEnd);
            if (verbose)
              console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
            pushStackDedup(stack, newStacks);
          } else if (!finished || finished.score < stack.score) {
            finished = stack;
          }
        }
        return finished;
      }
      // Convert the stack's buffer to a syntax tree.
      stackToTree(stack) {
        stack.close();
        return Tree.build({
          buffer: StackBufferCursor.create(stack),
          nodeSet: this.parser.nodeSet,
          topID: this.topTerm,
          maxBufferLength: this.parser.bufferLength,
          reused: this.reused,
          start: this.ranges[0].from,
          length: stack.pos - this.ranges[0].from,
          minRepeatType: this.parser.minRepeatTerm
        });
      }
      stackID(stack) {
        let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
        if (!id2)
          stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
        return id2 + stack;
      }
    }
    function pushStackDedup(stack, newStacks) {
      for (let i2 = 0; i2 < newStacks.length; i2++) {
        let other = newStacks[i2];
        if (other.pos == stack.pos && other.sameState(stack)) {
          if (newStacks[i2].score < stack.score)
            newStacks[i2] = stack;
          return;
        }
      }
      newStacks.push(stack);
    }
    class Dialect {
      constructor(source2, flags, disabled) {
        this.source = source2;
        this.flags = flags;
        this.disabled = disabled;
      }
      allows(term) {
        return !this.disabled || this.disabled[term] == 0;
      }
    }
    const id = (x) => x;
    class ContextTracker {
      /**
      Define a context tracker.
      */
      constructor(spec) {
        this.start = spec.start;
        this.shift = spec.shift || id;
        this.reduce = spec.reduce || id;
        this.reuse = spec.reuse || id;
        this.hash = spec.hash || (() => 0);
        this.strict = spec.strict !== false;
      }
    }
    class LRParser extends Parser {
      /**
      @internal
      */
      constructor(spec) {
        super();
        this.wrappers = [];
        if (spec.version != 14)
          throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for (let i2 = 0; i2 < spec.repeatNodeCount; i2++)
          nodeNames.push("");
        let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
        let nodeProps = [];
        for (let i2 = 0; i2 < nodeNames.length; i2++)
          nodeProps.push([]);
        function setProp(nodeID, prop, value) {
          nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
        }
        if (spec.nodeProps)
          for (let propSpec of spec.nodeProps) {
            let prop = propSpec[0];
            if (typeof prop == "string")
              prop = NodeProp[prop];
            for (let i2 = 1; i2 < propSpec.length; ) {
              let next = propSpec[i2++];
              if (next >= 0) {
                setProp(next, prop, propSpec[i2++]);
              } else {
                let value = propSpec[i2 + -next];
                for (let j = -next; j > 0; j--)
                  setProp(propSpec[i2++], prop, value);
                i2++;
              }
            }
          }
        this.nodeSet = new NodeSet(nodeNames.map((name2, i2) => NodeType.define({
          name: i2 >= this.minRepeatTerm ? void 0 : name2,
          id: i2,
          props: nodeProps[i2],
          top: topTerms.indexOf(i2) > -1,
          error: i2 == 0,
          skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i2) > -1
        })));
        if (spec.propSources)
          this.nodeSet = this.nodeSet.extend(...spec.propSources);
        this.strict = false;
        this.bufferLength = DefaultBufferLength;
        let tokenArray = decodeArray(spec.tokenData);
        this.context = spec.context;
        this.specializerSpecs = spec.specialized || [];
        this.specialized = new Uint16Array(this.specializerSpecs.length);
        for (let i2 = 0; i2 < this.specializerSpecs.length; i2++)
          this.specialized[i2] = this.specializerSpecs[i2].term;
        this.specializers = this.specializerSpecs.map(getSpecializer);
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
        this.topRules = spec.topRules;
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
      }
      createParse(input, fragments, ranges) {
        let parse2 = new Parse(this, input, fragments, ranges);
        for (let w of this.wrappers)
          parse2 = w(parse2, input, fragments, ranges);
        return parse2;
      }
      /**
      Get a goto table entry @internal
      */
      getGoto(state, term, loose = false) {
        let table2 = this.goto;
        if (term >= table2[0])
          return -1;
        for (let pos = table2[term + 1]; ; ) {
          let groupTag = table2[pos++], last = groupTag & 1;
          let target = table2[pos++];
          if (last && loose)
            return target;
          for (let end = pos + (groupTag >> 1); pos < end; pos++)
            if (table2[pos] == state)
              return target;
          if (last)
            return -1;
        }
      }
      /**
      Check if this state has an action for a given terminal @internal
      */
      hasAction(state, terminal) {
        let data = this.data;
        for (let set2 = 0; set2 < 2; set2++) {
          for (let i2 = this.stateSlot(
            state,
            set2 ? 2 : 1
            /* ParseState.Actions */
          ), next; ; i2 += 3) {
            if ((next = data[i2]) == 65535) {
              if (data[i2 + 1] == 1)
                next = data[i2 = pair(data, i2 + 2)];
              else if (data[i2 + 1] == 2)
                return pair(data, i2 + 2);
              else
                break;
            }
            if (next == terminal || next == 0)
              return pair(data, i2 + 1);
          }
        }
        return 0;
      }
      /**
      @internal
      */
      stateSlot(state, slot) {
        return this.states[state * 6 + slot];
      }
      /**
      @internal
      */
      stateFlag(state, flag) {
        return (this.stateSlot(
          state,
          0
          /* ParseState.Flags */
        ) & flag) > 0;
      }
      /**
      @internal
      */
      validAction(state, action) {
        return !!this.allActions(state, (a) => a == action ? true : null);
      }
      /**
      @internal
      */
      allActions(state, action) {
        let deflt = this.stateSlot(
          state,
          4
          /* ParseState.DefaultReduce */
        );
        let result = deflt ? action(deflt) : void 0;
        for (let i2 = this.stateSlot(
          state,
          1
          /* ParseState.Actions */
        ); result == null; i2 += 3) {
          if (this.data[i2] == 65535) {
            if (this.data[i2 + 1] == 1)
              i2 = pair(this.data, i2 + 2);
            else
              break;
          }
          result = action(pair(this.data, i2 + 1));
        }
        return result;
      }
      /**
      Get the states that can follow this one through shift actions or
      goto jumps. @internal
      */
      nextStates(state) {
        let result = [];
        for (let i2 = this.stateSlot(
          state,
          1
          /* ParseState.Actions */
        ); ; i2 += 3) {
          if (this.data[i2] == 65535) {
            if (this.data[i2 + 1] == 1)
              i2 = pair(this.data, i2 + 2);
            else
              break;
          }
          if ((this.data[i2 + 2] & 65536 >> 16) == 0) {
            let value = this.data[i2 + 1];
            if (!result.some((v, i22) => i22 & 1 && v == value))
              result.push(this.data[i2], value);
          }
        }
        return result;
      }
      /**
      Configure the parser. Returns a new parser instance that has the
      given settings modified. Settings not provided in `config` are
      kept from the original parser.
      */
      configure(config2) {
        let copy2 = Object.assign(Object.create(LRParser.prototype), this);
        if (config2.props)
          copy2.nodeSet = this.nodeSet.extend(...config2.props);
        if (config2.top) {
          let info = this.topRules[config2.top];
          if (!info)
            throw new RangeError(`Invalid top rule name ${config2.top}`);
          copy2.top = info;
        }
        if (config2.tokenizers)
          copy2.tokenizers = this.tokenizers.map((t2) => {
            let found = config2.tokenizers.find((r) => r.from == t2);
            return found ? found.to : t2;
          });
        if (config2.specializers) {
          copy2.specializers = this.specializers.slice();
          copy2.specializerSpecs = this.specializerSpecs.map((s, i2) => {
            let found = config2.specializers.find((r) => r.from == s.external);
            if (!found)
              return s;
            let spec = Object.assign(Object.assign({}, s), { external: found.to });
            copy2.specializers[i2] = getSpecializer(spec);
            return spec;
          });
        }
        if (config2.contextTracker)
          copy2.context = config2.contextTracker;
        if (config2.dialect)
          copy2.dialect = this.parseDialect(config2.dialect);
        if (config2.strict != null)
          copy2.strict = config2.strict;
        if (config2.wrap)
          copy2.wrappers = copy2.wrappers.concat(config2.wrap);
        if (config2.bufferLength != null)
          copy2.bufferLength = config2.bufferLength;
        return copy2;
      }
      /**
      Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
      are registered for this parser.
      */
      hasWrappers() {
        return this.wrappers.length > 0;
      }
      /**
      Returns the name associated with a given term. This will only
      work for all terms when the parser was generated with the
      `--names` option. By default, only the names of tagged terms are
      stored.
      */
      getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
      }
      /**
      The eof term id is always allocated directly after the node
      types. @internal
      */
      get eofTerm() {
        return this.maxNode + 1;
      }
      /**
      The type of top node produced by the parser.
      */
      get topNode() {
        return this.nodeSet.types[this.top[1]];
      }
      /**
      @internal
      */
      dynamicPrecedence(term) {
        let prec2 = this.dynamicPrecedences;
        return prec2 == null ? 0 : prec2[term] || 0;
      }
      /**
      @internal
      */
      parseDialect(dialect) {
        let values = Object.keys(this.dialects), flags = values.map(() => false);
        if (dialect)
          for (let part of dialect.split(" ")) {
            let id2 = values.indexOf(part);
            if (id2 >= 0)
              flags[id2] = true;
          }
        let disabled = null;
        for (let i2 = 0; i2 < values.length; i2++)
          if (!flags[i2]) {
            for (let j = this.dialects[values[i2]], id2; (id2 = this.data[j++]) != 65535; )
              (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
          }
        return new Dialect(dialect, flags, disabled);
      }
      /**
      Used by the output of the parser generator. Not available to
      user code. @hide
      */
      static deserialize(spec) {
        return new LRParser(spec);
      }
    }
    function pair(data, off) {
      return data[off] | data[off + 1] << 16;
    }
    function findFinished(stacks) {
      let best = null;
      for (let stack of stacks) {
        let stopped = stack.p.stoppedAt;
        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(
          stack.state,
          2
          /* StateFlag.Accepting */
        ) && (!best || best.score < stack.score))
          best = stack;
      }
      return best;
    }
    function getSpecializer(spec) {
      if (spec.external) {
        let mask = spec.extend ? 1 : 0;
        return (value, stack) => spec.external(value, stack) << 1 | mask;
      }
      return spec.get;
    }
    const blockEnd = 63, eof = 64, DirectiveEnd = 1, DocEnd = 2, sequenceStartMark = 3, sequenceContinueMark = 4, explicitMapStartMark = 5, explicitMapContinueMark = 6, flowMapMark = 7, mapStartMark = 65, mapContinueMark = 66, Literal = 8, QuotedLiteral = 9, Anchor = 10, Alias = 11, Tag = 12, BlockLiteralContent = 13, BracketL = 19, FlowSequence = 20, Colon = 29, BraceL = 33, FlowMapping = 34, BlockLiteralHeader = 47;
    const type_Top = 0, type_Seq = 1, type_Map = 2, type_Flow = 3, type_Lit = 4;
    class Context {
      constructor(parent, depth, type) {
        this.parent = parent;
        this.depth = depth;
        this.type = type;
        this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + depth + (depth << 4) + type;
      }
    }
    Context.top = new Context(null, -1, type_Top);
    function findColumn(input, pos) {
      for (let col = 0, p = pos - input.pos - 1; ; p--, col++) {
        let ch = input.peek(p);
        if (isBreakSpace(ch) || ch == -1) return col;
      }
    }
    function isNonBreakSpace(ch) {
      return ch == 32 || ch == 9;
    }
    function isBreakSpace(ch) {
      return ch == 10 || ch == 13;
    }
    function isSpace(ch) {
      return isNonBreakSpace(ch) || isBreakSpace(ch);
    }
    function isSep(ch) {
      return ch < 0 || isSpace(ch);
    }
    const indentation = new ContextTracker({
      start: Context.top,
      reduce(context, term) {
        return context.type == type_Flow && (term == FlowSequence || term == FlowMapping) ? context.parent : context;
      },
      shift(context, term, stack, input) {
        if (term == sequenceStartMark)
          return new Context(context, findColumn(input, input.pos), type_Seq);
        if (term == mapStartMark || term == explicitMapStartMark)
          return new Context(context, findColumn(input, input.pos), type_Map);
        if (term == blockEnd)
          return context.parent;
        if (term == BracketL || term == BraceL)
          return new Context(context, 0, type_Flow);
        if (term == BlockLiteralContent && context.type == type_Lit)
          return context.parent;
        if (term == BlockLiteralHeader) {
          let indent = /[1-9]/.exec(input.read(input.pos, stack.pos));
          if (indent) return new Context(context, context.depth + +indent[0], type_Lit);
        }
        return context;
      },
      hash(context) {
        return context.hash;
      }
    });
    function three(input, ch, off = 0) {
      return input.peek(off) == ch && input.peek(off + 1) == ch && input.peek(off + 2) == ch && isSep(input.peek(off + 3));
    }
    const newlines = new ExternalTokenizer((input, stack) => {
      if (input.next == -1 && stack.canShift(eof))
        return input.acceptToken(eof);
      let prev = input.peek(-1);
      if ((isBreakSpace(prev) || prev < 0) && stack.context.type != type_Flow) {
        if (three(
          input,
          45
          /* '-' */
        )) {
          if (stack.canShift(blockEnd)) input.acceptToken(blockEnd);
          else return input.acceptToken(DirectiveEnd, 3);
        }
        if (three(
          input,
          46
          /* '.' */
        )) {
          if (stack.canShift(blockEnd)) input.acceptToken(blockEnd);
          else return input.acceptToken(DocEnd, 3);
        }
        let depth = 0;
        while (input.next == 32) {
          depth++;
          input.advance();
        }
        if ((depth < stack.context.depth || depth == stack.context.depth && stack.context.type == type_Seq && (input.next != 45 || !isSep(input.peek(1)))) && // Not blank
        input.next != -1 && !isBreakSpace(input.next) && input.next != 35)
          input.acceptToken(blockEnd, -depth);
      }
    }, { contextual: true });
    const blockMark = new ExternalTokenizer((input, stack) => {
      if (stack.context.type == type_Flow) {
        if (input.next == 63) {
          input.advance();
          if (isSep(input.next)) input.acceptToken(flowMapMark);
        }
        return;
      }
      if (input.next == 45) {
        input.advance();
        if (isSep(input.next))
          input.acceptToken(stack.context.type == type_Seq && stack.context.depth == findColumn(input, input.pos - 1) ? sequenceContinueMark : sequenceStartMark);
      } else if (input.next == 63) {
        input.advance();
        if (isSep(input.next))
          input.acceptToken(stack.context.type == type_Map && stack.context.depth == findColumn(input, input.pos - 1) ? explicitMapContinueMark : explicitMapStartMark);
      } else {
        let start = input.pos;
        for (; ; ) {
          if (isNonBreakSpace(input.next)) {
            if (input.pos == start) return;
            input.advance();
          } else if (input.next == 33) {
            readTag(input);
          } else if (input.next == 38) {
            readAnchor(input);
          } else if (input.next == 42) {
            readAnchor(input);
            break;
          } else if (input.next == 39 || input.next == 34) {
            if (readQuoted(input, true)) break;
            return;
          } else if (input.next == 91 || input.next == 123) {
            if (!scanBrackets(input)) return;
            break;
          } else {
            readPlain(input, true, false, 0);
            break;
          }
        }
        while (isNonBreakSpace(input.next)) input.advance();
        if (input.next == 58) {
          if (input.pos == start && stack.canShift(Colon)) return;
          let after = input.peek(1);
          if (isSep(after))
            input.acceptTokenTo(stack.context.type == type_Map && stack.context.depth == findColumn(input, start) ? mapContinueMark : mapStartMark, start);
        }
      }
    }, { contextual: true });
    function uriChar(ch) {
      return ch > 32 && ch < 127 && ch != 34 && ch != 37 && ch != 44 && ch != 60 && ch != 62 && ch != 92 && ch != 94 && ch != 96 && ch != 123 && ch != 124 && ch != 125;
    }
    function hexChar(ch) {
      return ch >= 48 && ch <= 57 || ch >= 97 && ch <= 102 || ch >= 65 && ch <= 70;
    }
    function readUriChar(input, quoted) {
      if (input.next == 37) {
        input.advance();
        if (hexChar(input.next)) input.advance();
        if (hexChar(input.next)) input.advance();
        return true;
      } else if (uriChar(input.next) || quoted && input.next == 44) {
        input.advance();
        return true;
      }
      return false;
    }
    function readTag(input) {
      input.advance();
      if (input.next == 60) {
        input.advance();
        for (; ; ) {
          if (!readUriChar(input, true)) {
            if (input.next == 62) input.advance();
            break;
          }
        }
      } else {
        while (readUriChar(input, false)) {
        }
      }
    }
    function readAnchor(input) {
      input.advance();
      while (!isSep(input.next) && charTag(input.tag) != "f") input.advance();
    }
    function readQuoted(input, scan) {
      let quote = input.next, lineBreak = false, start = input.pos;
      input.advance();
      for (; ; ) {
        let ch = input.next;
        if (ch < 0) break;
        input.advance();
        if (ch == quote) {
          if (ch == 39) {
            if (input.next == 39) input.advance();
            else break;
          } else {
            break;
          }
        } else if (ch == 92 && quote == 34) {
          if (input.next >= 0) input.advance();
        } else if (isBreakSpace(ch)) {
          if (scan) return false;
          lineBreak = true;
        } else if (scan && input.pos >= start + 1024) {
          return false;
        }
      }
      return !lineBreak;
    }
    function scanBrackets(input) {
      for (let stack = [], end = input.pos + 1024; ; ) {
        if (input.next == 91 || input.next == 123) {
          stack.push(input.next);
          input.advance();
        } else if (input.next == 39 || input.next == 34) {
          if (!readQuoted(input, true)) return false;
        } else if (input.next == 93 || input.next == 125) {
          if (stack[stack.length - 1] != input.next - 2) return false;
          stack.pop();
          input.advance();
          if (!stack.length) return true;
        } else if (input.next < 0 || input.pos > end || isBreakSpace(input.next)) {
          return false;
        } else {
          input.advance();
        }
      }
    }
    const charTable = "iiisiiissisfissssssssssssisssiiissssssssssssssssssssssssssfsfssissssssssssssssssssssssssssfif";
    function charTag(ch) {
      if (ch < 33) return "u";
      if (ch > 125) return "s";
      return charTable[ch - 33];
    }
    function isSafe(ch, inFlow) {
      let tag = charTag(ch);
      return tag != "u" && !(inFlow && tag == "f");
    }
    function readPlain(input, scan, inFlow, indent) {
      if (charTag(input.next) == "s" || (input.next == 63 || input.next == 58 || input.next == 45) && isSafe(input.peek(1), inFlow)) {
        input.advance();
      } else {
        return false;
      }
      let start = input.pos;
      for (; ; ) {
        let next = input.next, off = 0, lineIndent = indent + 1;
        while (isSpace(next)) {
          if (isBreakSpace(next)) {
            if (scan) return false;
            lineIndent = 0;
          } else {
            lineIndent++;
          }
          next = input.peek(++off);
        }
        let safe = next >= 0 && (next == 58 ? isSafe(input.peek(off + 1), inFlow) : next == 35 ? input.peek(off - 1) != 32 : isSafe(next, inFlow));
        if (!safe || !inFlow && lineIndent <= indent || lineIndent == 0 && !inFlow && (three(input, 45, off) || three(input, 46, off)))
          break;
        if (scan && charTag(next) == "f") return false;
        for (let i2 = off; i2 >= 0; i2--) input.advance();
        if (scan && input.pos > start + 1024) return false;
      }
      return true;
    }
    const literals = new ExternalTokenizer((input, stack) => {
      if (input.next == 33) {
        readTag(input);
        input.acceptToken(Tag);
      } else if (input.next == 38 || input.next == 42) {
        let token = input.next == 38 ? Anchor : Alias;
        readAnchor(input);
        input.acceptToken(token);
      } else if (input.next == 39 || input.next == 34) {
        readQuoted(input, false);
        input.acceptToken(QuotedLiteral);
      } else if (readPlain(input, false, stack.context.type == type_Flow, stack.context.depth)) {
        input.acceptToken(Literal);
      }
    });
    const blockLiteral = new ExternalTokenizer((input, stack) => {
      let indent = stack.context.type == type_Lit ? stack.context.depth : -1, upto = input.pos;
      scan: for (; ; ) {
        let depth = 0, next = input.next;
        while (next == 32) next = input.peek(++depth);
        if (!depth && (three(input, 45, depth) || three(input, 46, depth))) break;
        if (!isBreakSpace(next)) {
          if (indent < 0) indent = Math.max(stack.context.depth + 1, depth);
          if (depth < indent) break;
        }
        for (; ; ) {
          if (input.next < 0) break scan;
          let isBreak = isBreakSpace(input.next);
          input.advance();
          if (isBreak) continue scan;
          upto = input.pos;
        }
      }
      input.acceptTokenTo(BlockLiteralContent, upto);
    });
    const yamlHighlighting = styleTags({
      DirectiveName: tags.keyword,
      DirectiveContent: tags.attributeValue,
      "DirectiveEnd DocEnd": tags.meta,
      QuotedLiteral: tags.string,
      BlockLiteralHeader: tags.special(tags.string),
      BlockLiteralContent: tags.content,
      Literal: tags.content,
      "Key/Literal Key/QuotedLiteral": tags.definition(tags.propertyName),
      "Anchor Alias": tags.labelName,
      Tag: tags.typeName,
      Comment: tags.lineComment,
      ": , -": tags.separator,
      "?": tags.punctuation,
      "[ ]": tags.squareBracket,
      "{ }": tags.brace
    });
    const parser = LRParser.deserialize({
      version: 14,
      states: "5lQ!ZQgOOO#PQfO'#CpO#uQfO'#DOOOQR'#Dv'#DvO$qQgO'#DRO%gQdO'#DUO%nQgO'#DUO&ROaO'#D[OOQR'#Du'#DuO&{QgO'#D^O'rQgO'#D`OOQR'#Dt'#DtO(iOqO'#DbOOQP'#Dj'#DjO(zQaO'#CmO)YQgO'#CmOOQP'#Cm'#CmQ)jQaOOQ)uQgOOQ]QgOOO*PQdO'#CrO*nQdO'#CtOOQO'#Dw'#DwO+]Q`O'#CxO+hQdO'#CwO+rQ`O'#CwOOQO'#Cv'#CvO+wQdO'#CvOOQO'#Cq'#CqO,UQ`O,59[O,^QfO,59[OOQR,59[,59[OOQO'#Cx'#CxO,eQ`O'#DPO,pQdO'#DPOOQO'#Dx'#DxO,zQdO'#DxO-XQ`O,59jO-aQfO,59jOOQR,59j,59jOOQR'#DS'#DSO-hQcO,59mO-sQgO'#DVO.TQ`O'#DVO.YQcO,59pOOQR'#DX'#DXO#|QfO'#DWO.hQcO'#DWOOQR,59v,59vO.yOWO,59vO/OOaO,59vO/WOaO,59vO/cQgO'#D_OOQR,59x,59xO0VQgO'#DaOOQR,59z,59zOOQP,59|,59|O0yOaO,59|O1ROaO,59|O1aOqO,59|OOQP-E7h-E7hO1oQgO,59XOOQP,59X,59XO2PQaO'#DeO2_QgO'#DeO2oQgO'#DkOOQP'#Dk'#DkQ)jQaOOO3PQdO'#CsOOQO,59^,59^O3kQdO'#CuOOQO,59`,59`OOQO,59c,59cO4VQdO,59cO4aQdO'#CzO4kQ`O'#CzOOQO,59b,59bOOQU,5:Q,5:QOOQR1G.v1G.vO4pQ`O1G.vOOQU-E7d-E7dO4xQdO,59kOOQO,59k,59kO5SQdO'#DQO5^Q`O'#DQOOQO,5:d,5:dOOQU,5:R,5:ROOQR1G/U1G/UO5cQ`O1G/UOOQU-E7e-E7eO5kQgO'#DhO5xQcO1G/XOOQR1G/X1G/XOOQR,59q,59qO6TQgO,59qO6eQdO'#DiO6lQgO'#DiO7PQcO1G/[OOQR1G/[1G/[OOQR,59r,59rO#|QfO,59rOOQR1G/b1G/bO7_OWO1G/bO7dOaO1G/bOOQR,59y,59yOOQR,59{,59{OOQP1G/h1G/hO7lOaO1G/hO7tOaO1G/hO8POaO1G/hOOQP1G.s1G.sO8_QgO,5:POOQP,5:P,5:POOQP,5:V,5:VOOQP-E7i-E7iOOQO,59_,59_OOQO,59a,59aOOQO1G.}1G.}OOQO,59f,59fO8oQdO,59fOOQR7+$b7+$bP,XQ`O'#DfOOQO1G/V1G/VOOQO,59l,59lO8yQdO,59lOOQR7+$p7+$pP9TQ`O'#DgOOQR'#DT'#DTOOQR,5:S,5:SOOQR-E7f-E7fOOQR7+$s7+$sOOQR1G/]1G/]O9YQgO'#DYO9jQ`O'#DYOOQR,5:T,5:TO#|QfO'#DZO9oQcO'#DZOOQR-E7g-E7gOOQR7+$v7+$vOOQR1G/^1G/^OOQR7+$|7+$|O:QOWO7+$|OOQP7+%S7+%SO:VOaO7+%SO:_OaO7+%SOOQP1G/k1G/kOOQO1G/Q1G/QOOQO1G/W1G/WOOQR,59t,59tO:jQgO,59tOOQR,59u,59uO#|QfO,59uOOQR<<Hh<<HhOOQP<<Hn<<HnO:zOaO<<HnOOQR1G/`1G/`OOQR1G/a1G/aOOQPAN>YAN>Y",
      stateData: ";S~O!fOS!gOS^OS~OP_OQbORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!V[O!cTO~O`cO~P]OVkOWROXROYeOZfO[dOcPOmhOqQO~OboO~P!bOVtOWROXROYeOZfO[dOcPOmrOqQO~OpwO~P#WORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!cTO~OSvP!avP!bvP~P#|OWROXROYeOZfO[dOcPOqQO~OmzO~P%OOm!OOUzP!azP!bzP!dzP~P#|O^!SO!b!QO!f!TO!g!RO~ORSOTUOWROXROcPOqQO!PVO!cTO~OY!UOP!QXQ!QX!V!QX!`!QXS!QX!a!QX!b!QXU!QXm!QX!d!QX~P&aO[!WOP!SXQ!SX!V!SX!`!SXS!SX!a!SX!b!SXU!SXm!SX!d!SX~P&aO^!ZO!W![O!b!YO!f!]O!g!YO~OP!_O!V[OQaX!`aX~OPaXQaX!VaX!`aX~P#|OP!bOQ!cO!V[O~OP_O!V[O~P#|OWROXROY!fOcPOqQObfXmfXofXpfX~OWROXRO[!hOcPOqQObhXmhXohXphX~ObeXmlXoeX~ObkXokX~P%OOm!kO~Om!lObnPonP~P%OOb!pOo!oO~Ob!pO~P!bOm!sOosXpsX~OosXpsX~P%OOm!uOotPptP~P%OOo!xOp!yO~Op!yO~P#WOS!|O!a#OO!b#OO~OUyX!ayX!byX!dyX~P#|Om#QO~OU#SO!a#UO!b#UO!d#RO~Om#WOUzX!azX!bzX!dzX~O]#XO~O!b#XO!g#YO~O^#ZO!b#XO!g#YO~OP!RXQ!RX!V!RX!`!RXS!RX!a!RX!b!RXU!RXm!RX!d!RX~P&aOP!TXQ!TX!V!TX!`!TXS!TX!a!TX!b!TXU!TXm!TX!d!TX~P&aO!b#^O!g#^O~O^#_O!b#^O!f#`O!g#^O~O^#_O!W#aO!b#^O!g#^O~OPaaQaa!Vaa!`aa~P#|OP#cO!V[OQ!XX!`!XX~OP!XXQ!XX!V!XX!`!XX~P#|OP_O!V[OQ!_X!`!_X~P#|OWROXROcPOqQObgXmgXogXpgX~OWROXROcPOqQObiXmiXoiXpiX~Obkaoka~P%OObnXonX~P%OOm#kO~Ob#lOo!oO~Oosapsa~P%OOotXptX~P%OOm#pO~Oo!xOp#qO~OSwP!awP!bwP~P#|OS!|O!a#vO!b#vO~OUya!aya!bya!dya~P#|Om#xO~P%OOm#{OU}P!a}P!b}P!d}P~P#|OU#SO!a$OO!b$OO!d#RO~O]$QO~O!b$QO!g$RO~O!b$SO!g$SO~O^$TO!b$SO!g$SO~O^$TO!b$SO!f$UO!g$SO~OP!XaQ!Xa!V!Xa!`!Xa~P#|Obnaona~P%OOotapta~P%OOo!xO~OU|X!a|X!b|X!d|X~P#|Om$ZO~Om$]OU}X!a}X!b}X!d}X~O]$^O~O!b$_O!g$_O~O^$`O!b$_O!g$_O~OU|a!a|a!b|a!d|a~P#|O!b$cO!g$cO~O",
      goto: ",]!mPPPPPPPPPPPPPPPPP!nPP!v#v#|$`#|$c$f$j$nP%VPPP!v%Y%^%a%{&O%a&R&U&X&_&b%aP&e&{&e'O'RPP']'a'g'm's'y(XPPPPPPPP(_)e*X+c,VUaObcR#e!c!{ROPQSTUXY_bcdehknrtvz!O!U!W!_!b!c!f!h!k!l!s!u!|#Q#R#S#W#c#k#p#x#{$Z$]QmPR!qnqfPQThknrtv!k!l!s!u#R#k#pR!gdR!ieTlPnTjPnSiPnSqQvQ{TQ!mkQ!trQ!vtR#y#RR!nkTsQvR!wt!RWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]RySR#t!|R|TR|UQ!PUR#|#SR#z#RR#z#SyZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]R!VXR!XYa]O^abc!a!c!eT!da!eQnPR!rnQvQR!{vQ!}yR#u!}Q#T|R#}#TW^Obc!cS!^^!aT!aa!eQ!eaR#f!eW`Obc!cQxSS}U#SQ!`_Q#PzQ#V!OQ#b!_Q#d!bQ#s!|Q#w#QQ$P#WQ$V#cQ$Y#xQ$[#{Q$a$ZR$b$]xZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]Q!VXQ!XYQ#[!UR#]!W!QWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]pfPQThknrtv!k!l!s!u#R#k#pQ!gdQ!ieQ#g!fR#h!hSgPn^pQTkrtv#RQ!jhQ#i!kQ#j!lQ#n!sQ#o!uQ$W#kR$X#pQuQR!zv",
      nodeNames: " DirectiveEnd DocEnd - - ? ? ? Literal QuotedLiteral Anchor Alias Tag BlockLiteralContent Comment Stream BOM Document ] [ FlowSequence Item Tagged Anchored Anchored Tagged FlowMapping Pair Key : Pair , } { FlowMapping Pair Pair BlockSequence Item Item BlockMapping Pair Pair Key Pair Pair BlockLiteral BlockLiteralHeader Tagged Anchored Anchored Tagged Directive DirectiveName DirectiveContent Document",
      maxTerm: 74,
      context: indentation,
      nodeProps: [
        ["isolate", -3, 8, 9, 14, ""],
        ["openedBy", 18, "[", 32, "{"],
        ["closedBy", 19, "]", 33, "}"]
      ],
      propSources: [yamlHighlighting],
      skippedNodes: [0],
      repeatNodeCount: 6,
      tokenData: "-Y~RnOX#PXY$QYZ$]Z]#P]^$]^p#Ppq$Qqs#Pst$btu#Puv$yv|#P|}&e}![#P![!]'O!]!`#P!`!a'i!a!}#P!}#O*g#O#P#P#P#Q+Q#Q#o#P#o#p+k#p#q'i#q#r,U#r;'S#P;'S;=`#z<%l?HT#P?HT?HU,o?HUO#PQ#UU!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PQ#kTOY#PZs#Pt;'S#P;'S;=`#z<%lO#PQ#}P;=`<%l#P~$VQ!f~XY$Qpq$Q~$bO!g~~$gS^~OY$bZ;'S$b;'S;=`$s<%lO$b~$vP;=`<%l$bR%OX!WQOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR%rX!WQ!VPOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR&bP;=`<%l%kR&lUoP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'VUmP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'p[!PP!WQOY#PZp#Ppq#hq{#P{|(f|}#P}!O(f!O!R#P!R![)p![;'S#P;'S;=`#z<%lO#PR(mW!PP!WQOY#PZp#Ppq#hq!R#P!R![)V![;'S#P;'S;=`#z<%lO#PR)^U!PP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR)wY!PP!WQOY#PZp#Ppq#hq{#P{|)V|}#P}!O)V!O;'S#P;'S;=`#z<%lO#PR*nUcP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+XUbP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+rUqP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,]UpP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,vU`P!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#P",
      tokenizers: [newlines, blockMark, literals, blockLiteral, 0, 1],
      topRules: { "Stream": [0, 15] },
      tokenPrec: 0
    });
    const yamlLanguage = /* @__PURE__ */ LRLanguage.define({
      name: "yaml",
      parser: /* @__PURE__ */ parser.configure({
        props: [
          /* @__PURE__ */ indentNodeProp.add({
            Stream: (cx) => {
              for (let before = cx.node.resolve(cx.pos, -1); before && before.to >= cx.pos; before = before.parent) {
                if (before.name == "BlockLiteralContent" && before.from < before.to)
                  return cx.baseIndentFor(before);
                if (before.name == "BlockLiteral")
                  return cx.baseIndentFor(before) + cx.unit;
                if (before.name == "BlockSequence" || before.name == "BlockMapping")
                  return cx.column(before.from, 1);
                if (before.name == "QuotedLiteral")
                  return null;
                if (before.name == "Literal") {
                  let col = cx.column(before.from, 1);
                  if (col == cx.lineIndent(before.from, 1))
                    return col;
                  if (before.to > cx.pos)
                    return null;
                }
              }
              return null;
            },
            FlowMapping: /* @__PURE__ */ delimitedIndent({ closing: "}" }),
            FlowSequence: /* @__PURE__ */ delimitedIndent({ closing: "]" })
          }),
          /* @__PURE__ */ foldNodeProp.add({
            "FlowMapping FlowSequence": foldInside,
            "Item Pair BlockLiteral": (node, state) => ({ from: state.doc.lineAt(node.from).to, to: node.to })
          })
        ]
      }),
      languageData: {
        commentTokens: { line: "#" },
        indentOnInput: /^\s*[\]\}]$/
      }
    });
    function yaml() {
      return new LanguageSupport(yamlLanguage);
    }
    const container$2 = "ConfigPage-module__container___5kN-Y";
    const pageTitle$2 = "ConfigPage-module__pageTitle___BoVLE";
    const description = "ConfigPage-module__description___qruwQ";
    const content$2 = "ConfigPage-module__content___PgFbt";
    const searchInputWrapper = "ConfigPage-module__searchInputWrapper___-GeEQ";
    const searchInput$1 = "ConfigPage-module__searchInput___ock8o";
    const searchCount = "ConfigPage-module__searchCount___AIry7";
    const searchRight = "ConfigPage-module__searchRight___pwWBV";
    const searchButton = "ConfigPage-module__searchButton___GRbfi";
    const searchActions = "ConfigPage-module__searchActions___ZGITa";
    const controls = "ConfigPage-module__controls___OTpD4";
    const status = "ConfigPage-module__status___QYXYr";
    const modified = "ConfigPage-module__modified___4mzgT";
    const saved = "ConfigPage-module__saved___zmZx2";
    const error = "ConfigPage-module__error___qlpX1";
    const editorWrapper = "ConfigPage-module__editorWrapper___yBudn";
    const floatingControls = "ConfigPage-module__floatingControls___RqBnu";
    const actions = "ConfigPage-module__actions___4RDYM";
    const styles$2 = {
      container: container$2,
      pageTitle: pageTitle$2,
      description,
      content: content$2,
      searchInputWrapper,
      searchInput: searchInput$1,
      searchCount,
      searchRight,
      searchButton,
      searchActions,
      controls,
      status,
      modified,
      saved,
      error,
      editorWrapper,
      floatingControls,
      actions
    };
    function ConfigPage() {
      const { t: t2 } = useTranslation();
      const { showNotification } = useNotificationStore();
      const connectionStatus = useAuthStore((state) => state.connectionStatus);
      const theme2 = useThemeStore((state) => state.theme);
      const [content2, setContent] = reactExports.useState("");
      const [loading, setLoading] = reactExports.useState(true);
      const [saving, setSaving] = reactExports.useState(false);
      const [error2, setError] = reactExports.useState("");
      const [dirty, setDirty] = reactExports.useState(false);
      const [searchQuery, setSearchQuery2] = reactExports.useState("");
      const [searchResults, setSearchResults] = reactExports.useState({ current: 0, total: 0 });
      const [lastSearchedQuery, setLastSearchedQuery] = reactExports.useState("");
      const editorRef = reactExports.useRef(null);
      const floatingControlsRef = reactExports.useRef(null);
      const editorWrapperRef = reactExports.useRef(null);
      const disableControls = connectionStatus !== "connected";
      const loadConfig = reactExports.useCallback(() => __async(null, null, function* () {
        setLoading(true);
        setError("");
        try {
          const data = yield configFileApi.fetchConfigYaml();
          setContent(data);
          setDirty(false);
        } catch (err) {
          const message2 = err instanceof Error ? err.message : t2("notification.refresh_failed");
          setError(message2);
        } finally {
          setLoading(false);
        }
      }), [t2]);
      reactExports.useEffect(() => {
        loadConfig();
      }, [loadConfig]);
      const handleSave = () => __async(null, null, function* () {
        setSaving(true);
        try {
          yield configFileApi.saveConfigYaml(content2);
          setDirty(false);
          showNotification(t2("config_management.save_success"), "success");
        } catch (err) {
          const message2 = err instanceof Error ? err.message : "";
          showNotification(`${t2("notification.save_failed")}: ${message2}`, "error");
        } finally {
          setSaving(false);
        }
      });
      const handleChange = reactExports.useCallback((value) => {
        setContent(value);
        setDirty(true);
      }, []);
      const performSearch = reactExports.useCallback((query, direction = "next") => {
        var _a2;
        if (!query || !((_a2 = editorRef.current) == null ? void 0 : _a2.view)) return;
        const view = editorRef.current.view;
        const doc2 = view.state.doc.toString();
        const matches = [];
        const lowerQuery = query.toLowerCase();
        const lowerDoc = doc2.toLowerCase();
        let pos = 0;
        while (pos < lowerDoc.length) {
          const index2 = lowerDoc.indexOf(lowerQuery, pos);
          if (index2 === -1) break;
          matches.push(index2);
          pos = index2 + 1;
        }
        if (matches.length === 0) {
          setSearchResults({ current: 0, total: 0 });
          return;
        }
        const selection2 = view.state.selection.main;
        const cursorPos = direction === "prev" ? selection2.from : selection2.to;
        let currentIndex = 0;
        if (direction === "next") {
          for (let i2 = 0; i2 < matches.length; i2++) {
            if (matches[i2] > cursorPos) {
              currentIndex = i2;
              break;
            }
            if (i2 === matches.length - 1) {
              currentIndex = 0;
            }
          }
        } else {
          for (let i2 = matches.length - 1; i2 >= 0; i2--) {
            if (matches[i2] < cursorPos) {
              currentIndex = i2;
              break;
            }
            if (i2 === 0) {
              currentIndex = matches.length - 1;
            }
          }
        }
        const matchPos = matches[currentIndex];
        setSearchResults({ current: currentIndex + 1, total: matches.length });
        view.dispatch({
          selection: { anchor: matchPos, head: matchPos + query.length },
          scrollIntoView: true
        });
        view.focus();
      }, []);
      const handleSearchChange = reactExports.useCallback((value) => {
        setSearchQuery2(value);
        if (!value) {
          setSearchResults({ current: 0, total: 0 });
          setLastSearchedQuery("");
        } else {
          setSearchResults({ current: 0, total: 0 });
        }
      }, []);
      const executeSearch = reactExports.useCallback((direction = "next") => {
        if (!searchQuery) return;
        setLastSearchedQuery(searchQuery);
        performSearch(searchQuery, direction);
      }, [searchQuery, performSearch]);
      const handleSearchKeyDown = reactExports.useCallback((e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          executeSearch(e.shiftKey ? "prev" : "next");
        }
      }, [executeSearch]);
      const handlePrevMatch = reactExports.useCallback(() => {
        if (!lastSearchedQuery) return;
        performSearch(lastSearchedQuery, "prev");
      }, [lastSearchedQuery, performSearch]);
      const handleNextMatch = reactExports.useCallback(() => {
        if (!lastSearchedQuery) return;
        performSearch(lastSearchedQuery, "next");
      }, [lastSearchedQuery, performSearch]);
      reactExports.useLayoutEffect(() => {
        const controlsEl = floatingControlsRef.current;
        const wrapperEl = editorWrapperRef.current;
        if (!controlsEl || !wrapperEl) return;
        const updatePadding = () => {
          const height = controlsEl.getBoundingClientRect().height;
          wrapperEl.style.setProperty("--floating-controls-height", `${height}px`);
        };
        updatePadding();
        window.addEventListener("resize", updatePadding);
        const ro = typeof ResizeObserver === "undefined" ? null : new ResizeObserver(updatePadding);
        ro == null ? void 0 : ro.observe(controlsEl);
        return () => {
          ro == null ? void 0 : ro.disconnect();
          window.removeEventListener("resize", updatePadding);
        };
      }, []);
      const extensions = reactExports.useMemo(() => [
        yaml(),
        search(),
        highlightSelectionMatches(),
        keymap.of(searchKeymap)
      ], []);
      const getStatusText = () => {
        if (disableControls) return t2("config_management.status_disconnected");
        if (loading) return t2("config_management.status_loading");
        if (error2) return t2("config_management.status_load_failed");
        if (saving) return t2("config_management.status_saving");
        if (dirty) return t2("config_management.status_dirty");
        return t2("config_management.status_loaded");
      };
      const getStatusClass = () => {
        if (error2) return styles$2.error;
        if (dirty) return styles$2.modified;
        if (!loading && !saving) return styles$2.saved;
        return "";
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.container, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$2.pageTitle, children: t2("config_management.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$2.description, children: t2("config_management.description") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.content, children: [
          error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-box", children: error2 }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.editorWrapper, ref: editorWrapperRef, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.floatingControls, ref: floatingControlsRef, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2.searchInputWrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  value: searchQuery,
                  onChange: (e) => handleSearchChange(e.target.value),
                  onKeyDown: handleSearchKeyDown,
                  placeholder: t2("config_management.search_placeholder", {
                    defaultValue: "..."
                  }),
                  disabled: disableControls || loading,
                  className: styles$2.searchInput,
                  rightElement: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.searchRight, children: [
                    searchQuery && lastSearchedQuery === searchQuery && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$2.searchCount, children: searchResults.total > 0 ? `${searchResults.current} / ${searchResults.total}` : t2("config_management.search_no_results", { defaultValue: "" }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        type: "button",
                        className: styles$2.searchButton,
                        onClick: () => executeSearch("next"),
                        disabled: !searchQuery || disableControls || loading,
                        title: t2("config_management.search_button", { defaultValue: "" }),
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconSearch, { size: 16 })
                      }
                    )
                  ] })
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.searchActions, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "secondary",
                    size: "sm",
                    onClick: handlePrevMatch,
                    disabled: !searchQuery || lastSearchedQuery !== searchQuery || searchResults.total === 0,
                    title: t2("config_management.search_prev", { defaultValue: "" }),
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconChevronUp, { size: 16 })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "secondary",
                    size: "sm",
                    onClick: handleNextMatch,
                    disabled: !searchQuery || lastSearchedQuery !== searchQuery || searchResults.total === 0,
                    title: t2("config_management.search_next", { defaultValue: "" }),
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconChevronDown, { size: 16 })
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ReactCodeMirror,
              {
                ref: editorRef,
                value: content2,
                onChange: handleChange,
                extensions,
                theme: theme2 === "dark" ? "dark" : "light",
                editable: !disableControls && !loading,
                placeholder: t2("config_management.editor_placeholder"),
                height: "100%",
                style: { height: "100%" },
                basicSetup: {
                  lineNumbers: true,
                  highlightActiveLineGutter: true,
                  highlightActiveLine: true,
                  foldGutter: true,
                  dropCursor: true,
                  allowMultipleSelections: true,
                  indentOnInput: true,
                  bracketMatching: true,
                  closeBrackets: true,
                  autocompletion: false,
                  rectangularSelection: true,
                  crosshairCursor: false,
                  highlightSelectionMatches: true,
                  closeBracketsKeymap: true,
                  searchKeymap: true,
                  foldKeymap: true,
                  completionKeymap: false,
                  lintKeymap: true
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.controls, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${styles$2.status} ${getStatusClass()}`, children: getStatusText() }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.actions, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", size: "sm", onClick: loadConfig, disabled: loading, children: t2("config_management.reload") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "sm", onClick: handleSave, loading: saving, disabled: disableControls || loading || !dirty, children: t2("config_management.save") })
            ] })
          ] })
        ] }) })
      ] });
    }
    const container$1 = "LogsPage-module__container___aQ0JL";
    const pageTitle$1 = "LogsPage-module__pageTitle___vZY55";
    const content$1 = "LogsPage-module__content___hGaGn";
    const toolbar = "LogsPage-module__toolbar___9dY5F";
    const filters = "LogsPage-module__filters___nUahU";
    const searchWrapper = "LogsPage-module__searchWrapper___mrEmr";
    const searchInput = "LogsPage-module__searchInput___eoPij";
    const searchIcon = "LogsPage-module__searchIcon___73cvF";
    const searchClear = "LogsPage-module__searchClear___yTM1y";
    const filterStats = "LogsPage-module__filterStats___IaTXF";
    const removedCount = "LogsPage-module__removedCount___bNgxC";
    const actionButton = "LogsPage-module__actionButton___aYJPR";
    const buttonContent = "LogsPage-module__buttonContent___qjHrB";
    const switchLabel = "LogsPage-module__switchLabel___EfB3d";
    const logPanel = "LogsPage-module__logPanel___2wjiP";
    const loadMoreBanner = "LogsPage-module__loadMoreBanner___BUD0t";
    const loadMoreCount = "LogsPage-module__loadMoreCount___UsdBd";
    const logList = "LogsPage-module__logList___lFt6f";
    const logRow = "LogsPage-module__logRow___rxZS5";
    const rowWarn = "LogsPage-module__rowWarn___Lhg4M";
    const rowError = "LogsPage-module__rowError___XQ3Qi";
    const timestamp = "LogsPage-module__timestamp___TZvLq";
    const rowMain = "LogsPage-module__rowMain___f--We";
    const rowMeta = "LogsPage-module__rowMeta___1ZIIi";
    const badge = "LogsPage-module__badge___tR566";
    const pill = "LogsPage-module__pill___vGA2z";
    const source = "LogsPage-module__source___nv7Zu";
    const statusBadge = "LogsPage-module__statusBadge___hj08j";
    const statusSuccess = "LogsPage-module__statusSuccess___3llcn";
    const statusInfo = "LogsPage-module__statusInfo___B6DaE";
    const statusWarn = "LogsPage-module__statusWarn___1Dwki";
    const statusError = "LogsPage-module__statusError___xxTDc";
    const levelInfo = "LogsPage-module__levelInfo___oZMOp";
    const levelWarn = "LogsPage-module__levelWarn___DsCD0";
    const levelError = "LogsPage-module__levelError___8VjWc";
    const levelDebug = "LogsPage-module__levelDebug___l-5yk";
    const levelTrace = "LogsPage-module__levelTrace___XvRLF";
    const methodBadge = "LogsPage-module__methodBadge___Cf9jC";
    const path = "LogsPage-module__path___frHAs";
    const message = "LogsPage-module__message___bNHRw";
    const styles$1 = {
      container: container$1,
      pageTitle: pageTitle$1,
      content: content$1,
      toolbar,
      filters,
      searchWrapper,
      searchInput,
      searchIcon,
      searchClear,
      filterStats,
      removedCount,
      actionButton,
      buttonContent,
      switchLabel,
      logPanel,
      loadMoreBanner,
      loadMoreCount,
      logList,
      logRow,
      rowWarn,
      rowError,
      timestamp,
      rowMain,
      rowMeta,
      badge,
      pill,
      source,
      statusBadge,
      statusSuccess,
      statusInfo,
      statusWarn,
      statusError,
      levelInfo,
      levelWarn,
      levelError,
      levelDebug,
      levelTrace,
      methodBadge,
      path,
      message
    };
    const INITIAL_DISPLAY_LINES = 100;
    const LOAD_MORE_LINES = 200;
    const MAX_BUFFER_LINES = 1e4;
    const LOAD_MORE_THRESHOLD_PX = 72;
    const HTTP_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"];
    const HTTP_METHOD_REGEX = new RegExp(`\\b(${HTTP_METHODS.join("|")})\\b`);
    const LOG_TIMESTAMP_REGEX = /^\[?(\d{4}-\d{2}-\d{2}[ T]\d{2}:\d{2}:\d{2}(?:\.\d{1,3})?)\]?/;
    const LOG_LEVEL_REGEX = /^\[?(trace|debug|info|warn|warning|error|fatal)\]?(?=\s|\[|$)\s*/i;
    const LOG_SOURCE_REGEX = /^\[([^\]]+)\]/;
    const LOG_LATENCY_REGEX = /\b(\d+(?:\.\d+)?)(?:\s*)(s|us|ms|s)\b/i;
    const LOG_IPV4_REGEX = /\b(?:\d{1,3}\.){3}\d{1,3}\b/;
    const LOG_IPV6_REGEX = /\b(?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}\b/i;
    const LOG_TIME_OF_DAY_REGEX = /^\d{1,2}:\d{2}:\d{2}(?:\.\d{1,3})?$/;
    const GIN_TIMESTAMP_SEGMENT_REGEX = /^\[GIN\]\s+(\d{4})\/(\d{2})\/(\d{2})\s*-\s*(\d{2}:\d{2}:\d{2}(?:\.\d{1,3})?)\s*$/;
    const HTTP_STATUS_PATTERNS = [
      /\|\s*([1-5]\d{2})\s*\|/,
      /\b([1-5]\d{2})\s*-/,
      new RegExp(`\\b(?:${HTTP_METHODS.join("|")})\\s+\\S+\\s+([1-5]\\d{2})\\b`),
      /\b(?:status|code|http)[:\s]+([1-5]\d{2})\b/i,
      /\b([1-5]\d{2})\s+(?:OK|Created|Accepted|No Content|Moved|Found|Bad Request|Unauthorized|Forbidden|Not Found|Method Not Allowed|Internal Server Error|Bad Gateway|Service Unavailable|Gateway Timeout)\b/i
    ];
    const detectHttpStatusCode = (text) => {
      for (const pattern of HTTP_STATUS_PATTERNS) {
        const match = text.match(pattern);
        if (!match) continue;
        const code2 = Number.parseInt(match[1], 10);
        if (!Number.isFinite(code2)) continue;
        if (code2 >= 100 && code2 <= 599) return code2;
      }
      return void 0;
    };
    const extractIp = (text) => {
      const ipv4Match = text.match(LOG_IPV4_REGEX);
      if (ipv4Match) return ipv4Match[0];
      const ipv6Match = text.match(LOG_IPV6_REGEX);
      if (!ipv6Match) return void 0;
      const candidate = ipv6Match[0];
      if (LOG_TIME_OF_DAY_REGEX.test(candidate)) return void 0;
      if (!candidate.includes("::") && candidate.split(":").length !== 8) return void 0;
      return candidate;
    };
    const normalizeTimestampToSeconds = (value) => {
      const trimmed = value.trim();
      const match = trimmed.match(/^(\d{4}-\d{2}-\d{2})[ T](\d{2}:\d{2}:\d{2})/);
      if (!match) return trimmed;
      return `${match[1]} ${match[2]}`;
    };
    const extractLogLevel = (value) => {
      const normalized = value.trim().toLowerCase();
      if (normalized === "warning") return "warn";
      if (normalized === "warn") return "warn";
      if (normalized === "info") return "info";
      if (normalized === "error") return "error";
      if (normalized === "fatal") return "fatal";
      if (normalized === "debug") return "debug";
      if (normalized === "trace") return "trace";
      return void 0;
    };
    const inferLogLevel = (line) => {
      const lowered = line.toLowerCase();
      if (/\bfatal\b/.test(lowered)) return "fatal";
      if (/\berror\b/.test(lowered)) return "error";
      if (/\bwarn(?:ing)?\b/.test(lowered) || line.includes("")) return "warn";
      if (/\binfo\b/.test(lowered)) return "info";
      if (/\bdebug\b/.test(lowered)) return "debug";
      if (/\btrace\b/.test(lowered)) return "trace";
      return void 0;
    };
    const extractHttpMethodAndPath = (text) => {
      var _a2;
      const match = text.match(HTTP_METHOD_REGEX);
      if (!match) return {};
      const method = match[1];
      const index2 = (_a2 = match.index) != null ? _a2 : 0;
      const after = text.slice(index2 + match[0].length).trim();
      const path2 = after ? after.split(/\s+/)[0] : void 0;
      return { method, path: path2 };
    };
    const parseLogLine = (raw) => {
      let remaining = raw.trim();
      let timestamp2;
      const tsMatch = remaining.match(LOG_TIMESTAMP_REGEX);
      if (tsMatch) {
        timestamp2 = tsMatch[1];
        remaining = remaining.slice(tsMatch[0].length).trim();
      }
      let level;
      const lvlMatch = remaining.match(LOG_LEVEL_REGEX);
      if (lvlMatch) {
        level = extractLogLevel(lvlMatch[1]);
        remaining = remaining.slice(lvlMatch[0].length).trim();
      }
      let source2;
      const sourceMatch = remaining.match(LOG_SOURCE_REGEX);
      if (sourceMatch) {
        source2 = sourceMatch[1];
        remaining = remaining.slice(sourceMatch[0].length).trim();
      }
      let statusCode;
      let latency;
      let ip;
      let method;
      let path2;
      let message2 = remaining;
      if (remaining.includes("|")) {
        const segments = remaining.split("|").map((segment) => segment.trim()).filter(Boolean);
        const consumed = /* @__PURE__ */ new Set();
        const ginIndex = segments.findIndex((segment) => GIN_TIMESTAMP_SEGMENT_REGEX.test(segment));
        if (ginIndex >= 0) {
          const match = segments[ginIndex].match(GIN_TIMESTAMP_SEGMENT_REGEX);
          if (match) {
            const ginTimestamp = `${match[1]}-${match[2]}-${match[3]} ${match[4]}`;
            const normalizedGin = normalizeTimestampToSeconds(ginTimestamp);
            const normalizedParsed = timestamp2 ? normalizeTimestampToSeconds(timestamp2) : void 0;
            if (!timestamp2) {
              timestamp2 = ginTimestamp;
              consumed.add(ginIndex);
            } else if (normalizedParsed === normalizedGin) {
              consumed.add(ginIndex);
            }
          }
        }
        const statusIndex = segments.findIndex((segment) => /^\d{3}\b/.test(segment));
        if (statusIndex >= 0) {
          const match = segments[statusIndex].match(/^(\d{3})\b/);
          if (match) {
            const code2 = Number.parseInt(match[1], 10);
            if (code2 >= 100 && code2 <= 599) {
              statusCode = code2;
              consumed.add(statusIndex);
            }
          }
        }
        const latencyIndex = segments.findIndex((segment) => LOG_LATENCY_REGEX.test(segment));
        if (latencyIndex >= 0) {
          const match = segments[latencyIndex].match(LOG_LATENCY_REGEX);
          if (match) {
            latency = `${match[1]}${match[2]}`;
            consumed.add(latencyIndex);
          }
        }
        const ipIndex = segments.findIndex((segment) => Boolean(extractIp(segment)));
        if (ipIndex >= 0) {
          const extracted = extractIp(segments[ipIndex]);
          if (extracted) {
            ip = extracted;
            consumed.add(ipIndex);
          }
        }
        const methodIndex = segments.findIndex((segment) => {
          const { method: parsedMethod } = extractHttpMethodAndPath(segment);
          return Boolean(parsedMethod);
        });
        if (methodIndex >= 0) {
          const parsed = extractHttpMethodAndPath(segments[methodIndex]);
          method = parsed.method;
          path2 = parsed.path;
          consumed.add(methodIndex);
        }
        message2 = segments.filter((_, index2) => !consumed.has(index2)).join(" | ");
      } else {
        statusCode = detectHttpStatusCode(remaining);
        const latencyMatch = remaining.match(LOG_LATENCY_REGEX);
        if (latencyMatch) latency = `${latencyMatch[1]}${latencyMatch[2]}`;
        ip = extractIp(remaining);
        const parsed = extractHttpMethodAndPath(remaining);
        method = parsed.method;
        path2 = parsed.path;
      }
      if (!level) level = inferLogLevel(raw);
      if (message2) {
        const match = message2.match(GIN_TIMESTAMP_SEGMENT_REGEX);
        if (match) {
          const ginTimestamp = `${match[1]}-${match[2]}-${match[3]} ${match[4]}`;
          if (!timestamp2) timestamp2 = ginTimestamp;
          if (normalizeTimestampToSeconds(timestamp2) === normalizeTimestampToSeconds(ginTimestamp)) {
            message2 = "";
          }
        }
      }
      return {
        raw,
        timestamp: timestamp2,
        level,
        source: source2,
        statusCode,
        latency,
        ip,
        method,
        path: path2,
        message: message2
      };
    };
    const getErrorMessage = (err) => {
      if (err instanceof Error) return err.message;
      if (typeof err === "string") return err;
      if (typeof err !== "object" || err === null) return "";
      if (!("message" in err)) return "";
      const message2 = err.message;
      return typeof message2 === "string" ? message2 : "";
    };
    const copyToClipboard = (text) => __async(null, null, function* () {
      try {
        yield navigator.clipboard.writeText(text);
        return true;
      } catch (e) {
        try {
          const textarea2 = document.createElement("textarea");
          textarea2.value = text;
          textarea2.style.position = "fixed";
          textarea2.style.opacity = "0";
          textarea2.style.left = "-9999px";
          textarea2.style.top = "0";
          document.body.appendChild(textarea2);
          textarea2.focus();
          textarea2.select();
          const ok = document.execCommand("copy");
          document.body.removeChild(textarea2);
          return ok;
        } catch (e2) {
          return false;
        }
      }
    });
    function LogsPage() {
      const { t: t2 } = useTranslation();
      const { showNotification } = useNotificationStore();
      const connectionStatus = useAuthStore((state) => state.connectionStatus);
      const [logState, setLogState] = reactExports.useState({ buffer: [], visibleFrom: 0 });
      const [loading, setLoading] = reactExports.useState(true);
      const [error2, setError] = reactExports.useState("");
      const [autoRefresh, setAutoRefresh] = reactExports.useState(false);
      const [searchQuery, setSearchQuery2] = reactExports.useState("");
      const deferredSearchQuery = reactExports.useDeferredValue(searchQuery);
      const [hideManagementLogs, setHideManagementLogs] = reactExports.useState(false);
      const [errorLogs, setErrorLogs] = reactExports.useState([]);
      const [loadingErrors, setLoadingErrors] = reactExports.useState(false);
      const logViewerRef = reactExports.useRef(null);
      const pendingScrollToBottomRef = reactExports.useRef(false);
      const pendingPrependScrollRef = reactExports.useRef(null);
      const latestTimestampRef = reactExports.useRef(0);
      const disableControls = connectionStatus !== "connected";
      const isNearBottom = (node) => {
        if (!node) return true;
        const threshold = 24;
        return node.scrollHeight - node.scrollTop - node.clientHeight <= threshold;
      };
      const scrollToBottom = () => {
        const node = logViewerRef.current;
        if (!node) return;
        node.scrollTop = node.scrollHeight;
      };
      const loadLogs = (incremental = false) => __async(null, null, function* () {
        if (connectionStatus !== "connected") {
          setLoading(false);
          return;
        }
        if (!incremental) {
          setLoading(true);
        }
        setError("");
        try {
          pendingScrollToBottomRef.current = !incremental || isNearBottom(logViewerRef.current);
          const params = incremental && latestTimestampRef.current > 0 ? { after: latestTimestampRef.current } : {};
          const data = yield logsApi.fetchLogs(params);
          if (data["latest-timestamp"]) {
            latestTimestampRef.current = data["latest-timestamp"];
          }
          const newLines = Array.isArray(data.lines) ? data.lines : [];
          if (incremental && newLines.length > 0) {
            setLogState((prev) => {
              const prevRenderedCount = prev.buffer.length - prev.visibleFrom;
              const combined = [...prev.buffer, ...newLines];
              const dropCount = Math.max(combined.length - MAX_BUFFER_LINES, 0);
              const buffer = dropCount > 0 ? combined.slice(dropCount) : combined;
              let visibleFrom = Math.max(prev.visibleFrom - dropCount, 0);
              if (pendingScrollToBottomRef.current) {
                visibleFrom = Math.max(buffer.length - prevRenderedCount, 0);
              }
              return { buffer, visibleFrom };
            });
          } else if (!incremental) {
            const buffer = newLines.slice(-MAX_BUFFER_LINES);
            const visibleFrom = Math.max(buffer.length - INITIAL_DISPLAY_LINES, 0);
            setLogState({ buffer, visibleFrom });
          }
        } catch (err) {
          console.error("Failed to load logs:", err);
          if (!incremental) {
            setError(getErrorMessage(err) || t2("logs.load_error"));
          }
        } finally {
          if (!incremental) {
            setLoading(false);
          }
        }
      });
      const clearLogs = () => __async(null, null, function* () {
        if (!window.confirm(t2("logs.clear_confirm"))) return;
        try {
          yield logsApi.clearLogs();
          setLogState({ buffer: [], visibleFrom: 0 });
          latestTimestampRef.current = 0;
          showNotification(t2("logs.clear_success"), "success");
        } catch (err) {
          const message2 = getErrorMessage(err);
          showNotification(
            `${t2("notification.delete_failed")}${message2 ? `: ${message2}` : ""}`,
            "error"
          );
        }
      });
      const downloadLogs = () => {
        const text = logState.buffer.join("\n");
        const blob = new Blob([text], { type: "text/plain" });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "logs.txt";
        a.click();
        window.URL.revokeObjectURL(url);
        showNotification(t2("logs.download_success"), "success");
      };
      const loadErrorLogs = () => __async(null, null, function* () {
        if (connectionStatus !== "connected") {
          setLoadingErrors(false);
          return;
        }
        setLoadingErrors(true);
        try {
          const res = yield logsApi.fetchErrorLogs();
          setErrorLogs(Array.isArray(res.files) ? res.files : []);
        } catch (err) {
          console.error("Failed to load error logs:", err);
          setErrorLogs([]);
        } finally {
          setLoadingErrors(false);
        }
      });
      const downloadErrorLog = (name2) => __async(null, null, function* () {
        try {
          const response = yield logsApi.downloadErrorLog(name2);
          const blob = new Blob([response.data], { type: "text/plain" });
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = name2;
          a.click();
          window.URL.revokeObjectURL(url);
          showNotification(t2("logs.error_log_download_success"), "success");
        } catch (err) {
          const message2 = getErrorMessage(err);
          showNotification(
            `${t2("notification.download_failed")}${message2 ? `: ${message2}` : ""}`,
            "error"
          );
        }
      });
      reactExports.useEffect(() => {
        if (connectionStatus === "connected") {
          latestTimestampRef.current = 0;
          loadLogs(false);
          loadErrorLogs();
        }
      }, [connectionStatus]);
      reactExports.useEffect(() => {
        if (!autoRefresh || connectionStatus !== "connected") {
          return;
        }
        const id2 = window.setInterval(() => {
          loadLogs(true);
        }, 8e3);
        return () => window.clearInterval(id2);
      }, [autoRefresh, connectionStatus]);
      reactExports.useEffect(() => {
        if (!pendingScrollToBottomRef.current) return;
        if (loading) return;
        if (!logViewerRef.current) return;
        scrollToBottom();
        pendingScrollToBottomRef.current = false;
      }, [loading, logState.buffer, logState.visibleFrom]);
      const visibleLines = reactExports.useMemo(
        () => logState.buffer.slice(logState.visibleFrom),
        [logState.buffer, logState.visibleFrom]
      );
      const trimmedSearchQuery = deferredSearchQuery.trim();
      const isSearching = trimmedSearchQuery.length > 0;
      const baseLines = isSearching ? logState.buffer : visibleLines;
      const { filteredLines, removedCount: removedCount2 } = reactExports.useMemo(() => {
        let working = baseLines;
        let removed = 0;
        if (hideManagementLogs) {
          const next = [];
          for (const line of working) {
            if (line.includes(MANAGEMENT_API_PREFIX)) {
              removed += 1;
            } else {
              next.push(line);
            }
          }
          working = next;
        }
        if (trimmedSearchQuery) {
          const queryLowered = trimmedSearchQuery.toLowerCase();
          const next = [];
          for (const line of working) {
            if (line.toLowerCase().includes(queryLowered)) {
              next.push(line);
            } else {
              removed += 1;
            }
          }
          working = next;
        }
        return { filteredLines: working, removedCount: removed };
      }, [baseLines, hideManagementLogs, trimmedSearchQuery]);
      const parsedVisibleLines = reactExports.useMemo(
        () => filteredLines.map((line) => parseLogLine(line)),
        [filteredLines]
      );
      const canLoadMore = !isSearching && logState.visibleFrom > 0;
      const handleLogScroll = () => {
        const node = logViewerRef.current;
        if (!node) return;
        if (isSearching) return;
        if (!canLoadMore) return;
        if (pendingPrependScrollRef.current) return;
        if (node.scrollTop > LOAD_MORE_THRESHOLD_PX) return;
        pendingPrependScrollRef.current = {
          scrollHeight: node.scrollHeight,
          scrollTop: node.scrollTop
        };
        setLogState((prev) => __spreadProps(__spreadValues({}, prev), {
          visibleFrom: Math.max(prev.visibleFrom - LOAD_MORE_LINES, 0)
        }));
      };
      reactExports.useLayoutEffect(() => {
        const node = logViewerRef.current;
        const pending = pendingPrependScrollRef.current;
        if (!node || !pending) return;
        const delta = node.scrollHeight - pending.scrollHeight;
        node.scrollTop = pending.scrollTop + delta;
        pendingPrependScrollRef.current = null;
      }, [logState.visibleFrom]);
      const copyLogLine = (raw) => __async(null, null, function* () {
        const ok = yield copyToClipboard(raw);
        if (ok) {
          showNotification(t2("logs.copy_success", { defaultValue: "Copied to clipboard" }), "success");
        } else {
          showNotification(t2("logs.copy_failed", { defaultValue: "Copy failed" }), "error");
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.container, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$1.pageTitle, children: t2("logs.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.content, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Card,
            {
              title: t2("logs.log_content"),
              extra: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.toolbar, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "secondary",
                    size: "sm",
                    onClick: () => loadLogs(false),
                    disabled: disableControls || loading,
                    className: styles$1.actionButton,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$1.buttonContent, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(IconRefreshCw, { size: 16 }),
                      t2("logs.refresh_button")
                    ] })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ToggleSwitch,
                  {
                    checked: autoRefresh,
                    onChange: (value) => setAutoRefresh(value),
                    disabled: disableControls,
                    label: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$1.switchLabel, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(IconTimer, { size: 16 }),
                      t2("logs.auto_refresh")
                    ] })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "secondary",
                    size: "sm",
                    onClick: downloadLogs,
                    disabled: logState.buffer.length === 0,
                    className: styles$1.actionButton,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$1.buttonContent, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(IconDownload, { size: 16 }),
                      t2("logs.download_button")
                    ] })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "danger",
                    size: "sm",
                    onClick: clearLogs,
                    disabled: disableControls,
                    className: styles$1.actionButton,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$1.buttonContent, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(IconTrash2, { size: 16 }),
                      t2("logs.clear_button")
                    ] })
                  }
                )
              ] }),
              children: [
                error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-box", children: error2 }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.filters, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1.searchWrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      value: searchQuery,
                      onChange: (e) => setSearchQuery2(e.target.value),
                      placeholder: t2("logs.search_placeholder"),
                      className: styles$1.searchInput,
                      rightElement: searchQuery ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "button",
                        {
                          type: "button",
                          className: styles$1.searchClear,
                          onClick: () => setSearchQuery2(""),
                          title: "Clear",
                          "aria-label": "Clear",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconX, { size: 16 })
                        }
                      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(IconSearch, { size: 16, className: styles$1.searchIcon })
                    }
                  ) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ToggleSwitch,
                    {
                      checked: hideManagementLogs,
                      onChange: setHideManagementLogs,
                      label: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$1.switchLabel, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(IconEyeOff, { size: 16 }),
                        t2("logs.hide_management_logs", { prefix: MANAGEMENT_API_PREFIX })
                      ] })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.filterStats, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      parsedVisibleLines.length,
                      " ",
                      t2("logs.lines")
                    ] }),
                    removedCount2 > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$1.removedCount, children: [
                      t2("logs.removed"),
                      " ",
                      removedCount2
                    ] })
                  ] })
                ] }),
                loading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("logs.loading") }) : logState.buffer.length > 0 && parsedVisibleLines.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: logViewerRef, className: styles$1.logPanel, onScroll: handleLogScroll, children: [
                  canLoadMore && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.loadMoreBanner, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("logs.load_more_hint") }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$1.loadMoreCount, children: t2("logs.hidden_lines", { count: logState.visibleFrom }) })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1.logList, children: parsedVisibleLines.map((line, index2) => {
                    const rowClassNames = [styles$1.logRow];
                    if (line.level === "warn") rowClassNames.push(styles$1.rowWarn);
                    if (line.level === "error" || line.level === "fatal")
                      rowClassNames.push(styles$1.rowError);
                    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "div",
                      {
                        className: rowClassNames.join(" "),
                        onDoubleClick: () => {
                          void copyLogLine(line.raw);
                        },
                        title: t2("logs.double_click_copy_hint", {
                          defaultValue: "Double-click to copy"
                        }),
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1.timestamp, children: line.timestamp || "" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.rowMain, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.rowMeta, children: [
                              line.level && /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "span",
                                {
                                  className: [
                                    styles$1.badge,
                                    line.level === "info" ? styles$1.levelInfo : "",
                                    line.level === "warn" ? styles$1.levelWarn : "",
                                    line.level === "error" || line.level === "fatal" ? styles$1.levelError : "",
                                    line.level === "debug" ? styles$1.levelDebug : "",
                                    line.level === "trace" ? styles$1.levelTrace : ""
                                  ].filter(Boolean).join(" "),
                                  children: line.level.toUpperCase()
                                }
                              ),
                              line.source && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$1.source, title: line.source, children: line.source }),
                              typeof line.statusCode === "number" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "span",
                                {
                                  className: [
                                    styles$1.badge,
                                    styles$1.statusBadge,
                                    line.statusCode >= 200 && line.statusCode < 300 ? styles$1.statusSuccess : line.statusCode >= 300 && line.statusCode < 400 ? styles$1.statusInfo : line.statusCode >= 400 && line.statusCode < 500 ? styles$1.statusWarn : styles$1.statusError
                                  ].join(" "),
                                  children: line.statusCode
                                }
                              ),
                              line.latency && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$1.pill, children: line.latency }),
                              line.ip && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$1.pill, children: line.ip }),
                              line.method && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: [styles$1.badge, styles$1.methodBadge].join(" "), children: line.method }),
                              line.path && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$1.path, title: line.path, children: line.path })
                            ] }),
                            line.message && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1.message, children: line.message })
                          ] })
                        ]
                      },
                      `${logState.visibleFrom + index2}-${line.raw}`
                    );
                  }) })
                ] }) : logState.buffer.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  EmptyState,
                  {
                    title: t2("logs.search_empty_title"),
                    description: t2("logs.search_empty_desc")
                  }
                ) : /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyState, { title: t2("logs.empty_title"), description: t2("logs.empty_desc") })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Card,
            {
              title: t2("logs.error_logs_modal_title"),
              extra: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", size: "sm", onClick: loadErrorLogs, loading: loadingErrors, children: t2("common.refresh") }),
              children: errorLogs.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("logs.error_logs_empty") }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-list", children: errorLogs.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-row", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-meta", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-title", children: item.name }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-subtitle", children: [
                    item.size ? `${(item.size / 1024).toFixed(1)} KB` : "",
                    " ",
                    item.modified ? formatUnixTimestamp(item.modified) : ""
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-actions", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "secondary",
                    size: "sm",
                    onClick: () => downloadErrorLog(item.name),
                    children: t2("logs.error_logs_download")
                  }
                ) })
              ] }, item.name)) })
            }
          )
        ] })
      ] });
    }
    const container = "SystemPage-module__container___KAydo";
    const pageTitle = "SystemPage-module__pageTitle___DiF5E";
    const content = "SystemPage-module__content___SauLn";
    const sectionDescription = "SystemPage-module__sectionDescription___nI7Jo";
    const modelTags = "SystemPage-module__modelTags___M0sci";
    const modelTag = "SystemPage-module__modelTag___5Ar53";
    const modelName = "SystemPage-module__modelName___LKdAK";
    const modelAlias = "SystemPage-module__modelAlias___zioM-";
    const quickLinks = "SystemPage-module__quickLinks___QTmT3";
    const linkCard = "SystemPage-module__linkCard___iSrVF";
    const linkIcon = "SystemPage-module__linkIcon___gNqz2";
    const github = "SystemPage-module__github___V8I3m";
    const docs = "SystemPage-module__docs___cA-rG";
    const linkContent = "SystemPage-module__linkContent___Rfh7h";
    const linkTitle = "SystemPage-module__linkTitle___Zpr4Q";
    const linkDesc = "SystemPage-module__linkDesc___KKavC";
    const styles = {
      container,
      pageTitle,
      content,
      sectionDescription,
      modelTags,
      modelTag,
      modelName,
      modelAlias,
      quickLinks,
      linkCard,
      linkIcon,
      github,
      docs,
      linkContent,
      linkTitle,
      linkDesc
    };
    function SystemPage() {
      const { t: t2, i18n } = useTranslation();
      const { showNotification } = useNotificationStore();
      const auth = useAuthStore();
      const config2 = useConfigStore((state) => state.config);
      const fetchConfig = useConfigStore((state) => state.fetchConfig);
      const models = useModelsStore((state) => state.models);
      const modelsLoading = useModelsStore((state) => state.loading);
      const modelsError = useModelsStore((state) => state.error);
      const fetchModelsFromStore = useModelsStore((state) => state.fetchModels);
      const [modelStatus, setModelStatus] = reactExports.useState();
      const apiKeysCache = reactExports.useRef([]);
      const otherLabel = reactExports.useMemo(
        () => {
          var _a2;
          return ((_a2 = i18n.language) == null ? void 0 : _a2.toLowerCase().startsWith("zh")) ? "" : "Other";
        },
        [i18n.language]
      );
      const groupedModels = reactExports.useMemo(() => classifyModels(models, { otherLabel }), [models, otherLabel]);
      const normalizeApiKeyList = (input) => {
        if (!Array.isArray(input)) return [];
        const seen = /* @__PURE__ */ new Set();
        const keys2 = [];
        input.forEach((item) => {
          var _a2, _b;
          const value = typeof item === "string" ? item : (_b = (_a2 = item == null ? void 0 : item["api-key"]) != null ? _a2 : item == null ? void 0 : item.apiKey) != null ? _b : "";
          const trimmed = String(value || "").trim();
          if (!trimmed || seen.has(trimmed)) return;
          seen.add(trimmed);
          keys2.push(trimmed);
        });
        return keys2;
      };
      const resolveApiKeysForModels = reactExports.useCallback(() => __async(null, null, function* () {
        if (apiKeysCache.current.length) {
          return apiKeysCache.current;
        }
        const configKeys = normalizeApiKeyList(config2 == null ? void 0 : config2.apiKeys);
        if (configKeys.length) {
          apiKeysCache.current = configKeys;
          return configKeys;
        }
        try {
          const list = yield apiKeysApi.list();
          const normalized = normalizeApiKeyList(list);
          if (normalized.length) {
            apiKeysCache.current = normalized;
          }
          return normalized;
        } catch (err) {
          console.warn("Auto loading API keys for models failed:", err);
          return [];
        }
      }), [config2 == null ? void 0 : config2.apiKeys]);
      const fetchModels = (..._0) => __async(null, [..._0], function* ({ forceRefresh = false } = {}) {
        if (auth.connectionStatus !== "connected") {
          setModelStatus({
            type: "warning",
            message: t2("notification.connection_required")
          });
          return;
        }
        if (!auth.apiBase) {
          showNotification(t2("notification.connection_required"), "warning");
          return;
        }
        if (forceRefresh) {
          apiKeysCache.current = [];
        }
        setModelStatus({ type: "muted", message: t2("system_info.models_loading") });
        try {
          const apiKeys = yield resolveApiKeysForModels();
          const primaryKey = apiKeys[0];
          const list = yield fetchModelsFromStore(auth.apiBase, primaryKey, forceRefresh);
          const hasModels = list.length > 0;
          setModelStatus({
            type: hasModels ? "success" : "warning",
            message: hasModels ? t2("system_info.models_count", { count: list.length }) : t2("system_info.models_empty")
          });
        } catch (err) {
          const message2 = `${t2("system_info.models_error")}: ${(err == null ? void 0 : err.message) || ""}`;
          setModelStatus({ type: "error", message: message2 });
        }
      });
      reactExports.useEffect(() => {
        fetchConfig().catch(() => {
        });
      }, [fetchConfig]);
      reactExports.useEffect(() => {
        fetchModels();
      }, [auth.connectionStatus, auth.apiBase]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.container, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles.pageTitle, children: t2("system_info.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.content, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Card,
            {
              title: t2("system_info.connection_status_title"),
              extra: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", size: "sm", onClick: () => fetchConfig(void 0, true), children: t2("common.refresh") }),
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid cols-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: t2("connection.server_address") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: auth.apiBase || "-" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: t2("footer.api_version") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: auth.serverVersion || t2("system_info.version_unknown") })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: t2("footer.build_date") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: auth.serverBuildDate ? new Date(auth.serverBuildDate).toLocaleString() : t2("system_info.version_unknown") })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: t2("connection.status") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: t2(`common.${auth.connectionStatus}_status`) })
                ] })
              ] })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { title: t2("system_info.quick_links_title"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.sectionDescription, children: t2("system_info.quick_links_desc") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.quickLinks, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "a",
                {
                  href: "https://github.com/router-for-me/CLIProxyAPI",
                  target: "_blank",
                  rel: "noopener noreferrer",
                  className: styles.linkCard,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${styles.linkIcon} ${styles.github}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconGithub, { size: 22 }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.linkContent, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.linkTitle, children: [
                        t2("system_info.link_main_repo"),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(IconExternalLink, { size: 14 })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles.linkDesc, children: t2("system_info.link_main_repo_desc") })
                    ] })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "a",
                {
                  href: "https://github.com/router-for-me/Cli-Proxy-API-Management-Center",
                  target: "_blank",
                  rel: "noopener noreferrer",
                  className: styles.linkCard,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${styles.linkIcon} ${styles.github}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconCode, { size: 22 }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.linkContent, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.linkTitle, children: [
                        t2("system_info.link_webui_repo"),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(IconExternalLink, { size: 14 })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles.linkDesc, children: t2("system_info.link_webui_repo_desc") })
                    ] })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "a",
                {
                  href: "https://help.router-for.me/",
                  target: "_blank",
                  rel: "noopener noreferrer",
                  className: styles.linkCard,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${styles.linkIcon} ${styles.docs}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBookOpen, { size: 22 }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.linkContent, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.linkTitle, children: [
                        t2("system_info.link_docs"),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(IconExternalLink, { size: 14 })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles.linkDesc, children: t2("system_info.link_docs_desc") })
                    ] })
                  ]
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Card,
            {
              title: t2("system_info.models_title"),
              extra: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", size: "sm", onClick: () => fetchModels({ forceRefresh: true }), loading: modelsLoading, children: t2("common.refresh") }),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.sectionDescription, children: t2("system_info.models_desc") }),
                modelStatus && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `status-badge ${modelStatus.type}`, children: modelStatus.message }),
                modelsError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-box", children: modelsError }),
                modelsLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("common.loading") }) : models.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hint", children: t2("system_info.models_empty") }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-list", children: groupedModels.map((group) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-row", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-meta", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-title", children: group.label }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-subtitle", children: t2("system_info.models_count", { count: group.items.length }) })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles.modelTags, children: group.items.map((model) => {
                    var _a2;
                    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "span",
                      {
                        className: styles.modelTag,
                        title: model.description || "",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles.modelName, children: model.name }),
                          model.alias && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles.modelAlias, children: model.alias })
                        ]
                      },
                      `${model.name}-${(_a2 = model.alias) != null ? _a2 : "default"}`
                    );
                  }) })
                ] }, group.id)) })
              ]
            }
          )
        ] })
      ] });
    }
    const ANIMATION_DURATION = 300;
    function NotificationContainer() {
      const { notifications, removeNotification } = useNotificationStore();
      const [animatedNotifications, setAnimatedNotifications] = reactExports.useState([]);
      const prevNotificationsRef = reactExports.useRef([]);
      reactExports.useEffect(() => {
        const prevNotifications = prevNotificationsRef.current;
        const prevIds = new Set(prevNotifications.map((n) => n.id));
        const currentIds = new Set(notifications.map((n) => n.id));
        const newNotifications = notifications.filter((n) => !prevIds.has(n.id));
        const removedIds = new Set(
          prevNotifications.filter((n) => !currentIds.has(n.id)).map((n) => n.id)
        );
        setAnimatedNotifications((prev) => {
          let updated = prev.map(
            (n) => removedIds.has(n.id) ? __spreadProps(__spreadValues({}, n), { isExiting: true }) : n
          );
          newNotifications.forEach((n) => {
            if (!updated.find((an) => an.id === n.id)) {
              updated.push(__spreadProps(__spreadValues({}, n), { isExiting: false }));
            }
          });
          updated = updated.filter(
            (n) => currentIds.has(n.id) || n.isExiting
          );
          return updated;
        });
        if (removedIds.size > 0) {
          setTimeout(() => {
            setAnimatedNotifications(
              (prev) => prev.filter((n) => !removedIds.has(n.id))
            );
          }, ANIMATION_DURATION);
        }
        prevNotificationsRef.current = notifications;
      }, [notifications]);
      const handleClose2 = (id2) => {
        setAnimatedNotifications(
          (prev) => prev.map((n) => n.id === id2 ? __spreadProps(__spreadValues({}, n), { isExiting: true }) : n)
        );
        setTimeout(() => {
          removeNotification(id2);
        }, ANIMATION_DURATION);
      };
      if (!animatedNotifications.length) return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "notification-container", children: animatedNotifications.map((notification2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `notification ${notification2.type} ${notification2.isExiting ? "exiting" : "entering"}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "message", children: notification2.message }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-btn", onClick: () => handleClose2(notification2.id), "aria-label": "Close", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconX, { size: 16 }) })
          ]
        },
        notification2.id
      )) });
    }
    const sidebarIcons = {
      settings: /* @__PURE__ */ jsxRuntimeExports.jsx(IconSlidersHorizontal, { size: 18 }),
      apiKeys: /* @__PURE__ */ jsxRuntimeExports.jsx(IconKey, { size: 18 }),
      aiProviders: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBot, { size: 18 }),
      authFiles: /* @__PURE__ */ jsxRuntimeExports.jsx(IconFileText, { size: 18 }),
      oauth: /* @__PURE__ */ jsxRuntimeExports.jsx(IconShield, { size: 18 }),
      usage: /* @__PURE__ */ jsxRuntimeExports.jsx(IconChartLine, { size: 18 }),
      config: /* @__PURE__ */ jsxRuntimeExports.jsx(IconSettings, { size: 18 }),
      logs: /* @__PURE__ */ jsxRuntimeExports.jsx(IconScrollText, { size: 18 }),
      system: /* @__PURE__ */ jsxRuntimeExports.jsx(IconInfo, { size: 18 })
    };
    const headerIconProps = {
      width: 16,
      height: 16,
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round",
      "aria-hidden": "true",
      focusable: "false"
    };
    const headerIcons = {
      refresh: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues({}, headerIconProps), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 3v5h-5" })
      ] })),
      update: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues({}, headerIconProps), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 19V5" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m5 12 7-7 7 7" })
      ] })),
      menu: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues({}, headerIconProps), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4 7h16" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4 12h16" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4 17h16" })
      ] })),
      chevronLeft: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", __spreadProps(__spreadValues({}, headerIconProps), { children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m14 18-6-6 6-6" }) })),
      chevronRight: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", __spreadProps(__spreadValues({}, headerIconProps), { children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m10 6 6 6-6 6" }) })),
      language: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues({}, headerIconProps), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2 12h20" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" })
      ] })),
      sun: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues({}, headerIconProps), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2v2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 20v2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m4.93 4.93 1.41 1.41" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m17.66 17.66 1.41 1.41" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2 12h2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20 12h2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m6.34 17.66-1.41 1.41" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m19.07 4.93-1.41 1.41" })
      ] })),
      moon: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", __spreadProps(__spreadValues({}, headerIconProps), { children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9z" }) })),
      logout: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", __spreadProps(__spreadValues({}, headerIconProps), { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m16 17 5-5-5-5" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 12H9" })
      ] }))
    };
    const parseVersionSegments = (version2) => {
      if (!version2) return null;
      const cleaned = version2.trim().replace(/^v/i, "");
      if (!cleaned) return null;
      const parts = cleaned.split(/[^0-9]+/).filter(Boolean).map((segment) => Number.parseInt(segment, 10)).filter(Number.isFinite);
      return parts.length ? parts : null;
    };
    const compareVersions = (latest, current) => {
      const latestParts = parseVersionSegments(latest);
      const currentParts = parseVersionSegments(current);
      if (!latestParts || !currentParts) return null;
      const length = Math.max(latestParts.length, currentParts.length);
      for (let i2 = 0; i2 < length; i2++) {
        const l = latestParts[i2] || 0;
        const c = currentParts[i2] || 0;
        if (l > c) return 1;
        if (l < c) return -1;
      }
      return 0;
    };
    function MainLayout() {
      const { t: t2, i18n } = useTranslation();
      const { showNotification } = useNotificationStore();
      const apiBase = useAuthStore((state) => state.apiBase);
      const serverVersion = useAuthStore((state) => state.serverVersion);
      const serverBuildDate = useAuthStore((state) => state.serverBuildDate);
      const connectionStatus = useAuthStore((state) => state.connectionStatus);
      const logout = useAuthStore((state) => state.logout);
      const config2 = useConfigStore((state) => state.config);
      const fetchConfig = useConfigStore((state) => state.fetchConfig);
      const clearCache = useConfigStore((state) => state.clearCache);
      const theme2 = useThemeStore((state) => state.theme);
      const toggleTheme = useThemeStore((state) => state.toggleTheme);
      const toggleLanguage = useLanguageStore((state) => state.toggleLanguage);
      const [sidebarOpen, setSidebarOpen] = reactExports.useState(false);
      const [sidebarCollapsed, setSidebarCollapsed] = reactExports.useState(false);
      const [checkingVersion, setCheckingVersion] = reactExports.useState(false);
      const [brandExpanded, setBrandExpanded] = reactExports.useState(true);
      const brandCollapseTimer = reactExports.useRef(null);
      const headerRef = reactExports.useRef(null);
      const fullBrandName = "CLI Proxy API Management Center";
      const abbrBrandName = t2("title.abbr");
      reactExports.useLayoutEffect(() => {
        const updateHeaderHeight = () => {
          var _a2;
          const height = (_a2 = headerRef.current) == null ? void 0 : _a2.offsetHeight;
          if (height) {
            document.documentElement.style.setProperty("--header-height", `${height}px`);
          }
        };
        updateHeaderHeight();
        const resizeObserver = typeof ResizeObserver !== "undefined" && headerRef.current ? new ResizeObserver(updateHeaderHeight) : null;
        if (resizeObserver && headerRef.current) {
          resizeObserver.observe(headerRef.current);
        }
        window.addEventListener("resize", updateHeaderHeight);
        return () => {
          if (resizeObserver) {
            resizeObserver.disconnect();
          }
          window.removeEventListener("resize", updateHeaderHeight);
        };
      }, []);
      reactExports.useEffect(() => {
        brandCollapseTimer.current = setTimeout(() => {
          setBrandExpanded(false);
        }, 5e3);
        return () => {
          if (brandCollapseTimer.current) {
            clearTimeout(brandCollapseTimer.current);
          }
        };
      }, []);
      const handleBrandClick = reactExports.useCallback(() => {
        if (!brandExpanded) {
          setBrandExpanded(true);
          if (brandCollapseTimer.current) {
            clearTimeout(brandCollapseTimer.current);
          }
          brandCollapseTimer.current = setTimeout(() => {
            setBrandExpanded(false);
          }, 5e3);
        }
      }, [brandExpanded]);
      reactExports.useEffect(() => {
        fetchConfig().catch(() => {
        });
      }, [fetchConfig]);
      const statusClass = connectionStatus === "connected" ? "success" : connectionStatus === "connecting" ? "warning" : connectionStatus === "error" ? "error" : "muted";
      const navItems = [
        { path: "/settings", label: t2("nav.basic_settings"), icon: sidebarIcons.settings },
        { path: "/api-keys", label: t2("nav.api_keys"), icon: sidebarIcons.apiKeys },
        { path: "/ai-providers", label: t2("nav.ai_providers"), icon: sidebarIcons.aiProviders },
        { path: "/auth-files", label: t2("nav.auth_files"), icon: sidebarIcons.authFiles },
        { path: "/oauth", label: t2("nav.oauth", { defaultValue: "OAuth" }), icon: sidebarIcons.oauth },
        { path: "/usage", label: t2("nav.usage_stats"), icon: sidebarIcons.usage },
        { path: "/config", label: t2("nav.config_management"), icon: sidebarIcons.config },
        ...(config2 == null ? void 0 : config2.loggingToFile) ? [{ path: "/logs", label: t2("nav.logs"), icon: sidebarIcons.logs }] : [],
        { path: "/system", label: t2("nav.system_info"), icon: sidebarIcons.system }
      ];
      const handleRefreshAll = () => __async(null, null, function* () {
        clearCache();
        try {
          yield fetchConfig(void 0, true);
          showNotification(t2("notification.data_refreshed"), "success");
        } catch (error2) {
          showNotification(`${t2("notification.refresh_failed")}: ${(error2 == null ? void 0 : error2.message) || ""}`, "error");
        }
      });
      const handleVersionCheck = () => __async(null, null, function* () {
        var _a2, _b, _c;
        setCheckingVersion(true);
        try {
          const data = yield versionApi.checkLatest();
          const latest = (_c = (_b = (_a2 = data == null ? void 0 : data["latest-version"]) != null ? _a2 : data == null ? void 0 : data.latest_version) != null ? _b : data == null ? void 0 : data.latest) != null ? _c : "";
          const comparison = compareVersions(latest, serverVersion);
          if (!latest) {
            showNotification(t2("system_info.version_check_error"), "error");
            return;
          }
          if (comparison === null) {
            showNotification(t2("system_info.version_current_missing"), "warning");
            return;
          }
          if (comparison > 0) {
            showNotification(t2("system_info.version_update_available", { version: latest }), "warning");
          } else {
            showNotification(t2("system_info.version_is_latest"), "success");
          }
        } catch (error2) {
          showNotification(`${t2("system_info.version_check_error")}: ${(error2 == null ? void 0 : error2.message) || ""}`, "error");
        } finally {
          setCheckingVersion(false);
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app-shell", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: "main-header", ref: headerRef, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "sidebar-toggle-header",
                onClick: () => setSidebarCollapsed((prev) => !prev),
                title: sidebarCollapsed ? t2("sidebar.expand", { defaultValue: "" }) : t2("sidebar.collapse", { defaultValue: "" }),
                children: sidebarCollapsed ? headerIcons.chevronRight : headerIcons.chevronLeft
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: INLINE_LOGO_JPEG, alt: "CPAMC logo", className: "brand-logo" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: `brand-header ${brandExpanded ? "expanded" : "collapsed"}`,
                onClick: handleBrandClick,
                title: brandExpanded ? void 0 : fullBrandName,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "brand-full", children: fullBrandName }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "brand-abbr", children: abbrBrandName })
                ]
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "right", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "connection", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `status-badge ${statusClass}`, children: t2(
                connectionStatus === "connected" ? "common.connected_status" : connectionStatus === "connecting" ? "common.connecting_status" : "common.disconnected_status"
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "base", children: apiBase || "-" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-actions", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "mobile-menu-btn", variant: "ghost", size: "sm", onClick: () => setSidebarOpen((prev) => !prev), children: headerIcons.menu }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", size: "sm", onClick: handleRefreshAll, title: t2("header.refresh_all"), children: headerIcons.refresh }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", size: "sm", onClick: handleVersionCheck, loading: checkingVersion, title: t2("system_info.version_check_button"), children: headerIcons.update }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", size: "sm", onClick: toggleLanguage, title: t2("language.switch"), children: headerIcons.language }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", size: "sm", onClick: toggleTheme, title: t2("theme.switch"), children: theme2 === "dark" ? headerIcons.sun : headerIcons.moon }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", size: "sm", onClick: logout, title: t2("header.logout"), children: headerIcons.logout })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "main-body", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("aside", { className: `sidebar ${sidebarOpen ? "open" : ""} ${sidebarCollapsed ? "collapsed" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nav-section", children: navItems.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            NavLink,
            {
              to: item.path,
              className: ({ isActive }) => `nav-item ${isActive ? "active" : ""}`,
              onClick: () => setSidebarOpen(false),
              title: sidebarCollapsed ? item.label : void 0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "nav-icon", children: item.icon }),
                !sidebarCollapsed && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "nav-label", children: item.label })
              ]
            },
            item.path
          )) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: "main-content", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("footer", { className: "footer", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                t2("footer.api_version"),
                ": ",
                serverVersion || t2("system_info.version_unknown")
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                t2("footer.version"),
                ": ",
                "v6.6.33-3-g588d8ac"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                t2("footer.build_date"),
                ":",
                " ",
                serverBuildDate ? new Date(serverBuildDate).toLocaleString(i18n.language) : t2("system_info.version_unknown")
              ] })
            ] })
          ] })
        ] })
      ] });
    }
    function ProtectedRoute({ children }) {
      const location = useLocation();
      const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
      const managementKey = useAuthStore((state) => state.managementKey);
      const apiBase = useAuthStore((state) => state.apiBase);
      const checkAuth = useAuthStore((state) => state.checkAuth);
      const [checking, setChecking] = reactExports.useState(false);
      reactExports.useEffect(() => {
        const tryRestore = () => __async(null, null, function* () {
          if (!isAuthenticated && managementKey && apiBase) {
            setChecking(true);
            try {
              yield checkAuth();
            } finally {
              setChecking(false);
            }
          }
        });
        tryRestore();
      }, [apiBase, isAuthenticated, managementKey, checkAuth]);
      if (checking) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "main-content", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, {}) });
      }
      if (!isAuthenticated) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/login", replace: true, state: { from: location } });
      }
      return children;
    }
    function App() {
      const initializeTheme = useThemeStore((state) => state.initializeTheme);
      const language2 = useLanguageStore((state) => state.language);
      const setLanguage = useLanguageStore((state) => state.setLanguage);
      const restoreSession = useAuthStore((state) => state.restoreSession);
      reactExports.useEffect(() => {
        initializeTheme();
        restoreSession();
      }, [initializeTheme, restoreSession]);
      reactExports.useEffect(() => {
        setLanguage(language2);
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(HashRouter, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(NotificationContainer, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/login", element: /* @__PURE__ */ jsxRuntimeExports.jsx(LoginPage, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Route,
            {
              path: "/",
              element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MainLayout, {}) }),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: true, element: /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/settings", replace: true }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "settings", element: /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsPage, {}) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "api-keys", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ApiKeysPage, {}) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "ai-providers", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AiProvidersPage, {}) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "auth-files", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthFilesPage, {}) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "oauth", element: /* @__PURE__ */ jsxRuntimeExports.jsx(OAuthPage, {}) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "usage", element: /* @__PURE__ */ jsxRuntimeExports.jsx(UsagePage, {}) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "config", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ConfigPage, {}) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "logs", element: /* @__PURE__ */ jsxRuntimeExports.jsx(LogsPage, {}) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "system", element: /* @__PURE__ */ jsxRuntimeExports.jsx(SystemPage, {}) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/settings", replace: true }) })
              ]
            }
          )
        ] })
      ] });
    }
    document.title = "CLI Proxy API Management Center";
    const faviconEl = document.querySelector('link[rel="icon"]');
    if (faviconEl) {
      faviconEl.href = INLINE_LOGO_JPEG;
      faviconEl.type = "image/jpeg";
    } else {
      const newFavicon = document.createElement("link");
      newFavicon.rel = "icon";
      newFavicon.type = "image/jpeg";
      newFavicon.href = INLINE_LOGO_JPEG;
      document.head.appendChild(newFavicon);
    }
    clientExports.createRoot(document.getElementById("root")).render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
    );
  }
});
export default require_index_001();</script>
    <style rel="stylesheet" crossorigin>/**
 * SCSS 
 */
/**
* 
*/
/**
 * SCSS 
 */
/**
 * CSS Reset
 */
*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html,
body {
  height: 100%;
  width: 100%;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  line-height: 1.5;
}

#root {
  height: 100%;
  width: 100%;
}

button,
input,
textarea,
select {
  font: inherit;
}

a {
  color: inherit;
  text-decoration: none;
}

ul,
ol {
  list-style: none;
}

/**
 * 
 */
:root {
  --bg-primary: #ffffff;
  --bg-secondary: #f3f4f6;
  --bg-tertiary: #e5e7eb;
  --text-primary: #1f2937;
  --text-secondary: #6b7280;
  --text-tertiary: #9ca3af;
  --border-color: #e5e7eb;
  --border-hover: #d1d5db;
  --primary-color: #3b82f6;
  --primary-hover: #2563eb;
  --primary-active: #1d4ed8;
  --success-color: #10b981;
  --warning-color: #f59e0b;
  --error-color: #ef4444;
  --info-color: #3b82f6;
  --success-badge-bg: #d1fae5;
  --success-badge-text: #065f46;
  --success-badge-border: #6ee7b7;
  --failure-badge-bg: #fee2e2;
  --failure-badge-text: #991b1b;
  --failure-badge-border: #fca5a5;
  --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
}

[data-theme=dark] {
  --bg-primary: #202020;
  --bg-secondary: #191919;
  --bg-tertiary: #262626;
  --text-primary: #fafafa;
  --text-secondary: #a3a3a3;
  --text-tertiary: #737373;
  --border-color: #262626;
  --border-hover: #404040;
  --primary-color: #3b82f6;
  --primary-hover: #60a5fa;
  --primary-active: #93c5fd;
  --success-color: #10b981;
  --warning-color: #f59e0b;
  --error-color: #ef4444;
  --info-color: #3b82f6;
  --success-badge-bg: rgba(6, 78, 59, 0.3);
  --success-badge-text: #6ee7b7;
  --success-badge-border: #059669;
  --failure-badge-bg: rgba(153, 27, 27, 0.3);
  --failure-badge-text: #fca5a5;
  --failure-badge-border: #dc2626;
  --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.3);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
}

.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  border: 1px solid transparent;
  border-radius: 8px;
  padding: 10px 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 150ms ease;
  background-color: var(--bg-secondary);
  color: var(--text-primary);
}
.btn.btn-primary {
  background-color: var(--primary-color);
  color: #fff;
  border-color: var(--primary-color);
}
.btn.btn-primary:hover {
  background-color: var(--primary-hover);
  border-color: var(--primary-hover);
}
.btn.btn-secondary {
  background-color: var(--bg-tertiary);
  border-color: var(--border-color);
  color: var(--text-primary);
}
.btn.btn-secondary:hover {
  border-color: var(--border-hover);
}
.btn.btn-ghost {
  background: transparent;
  border-color: transparent;
  color: var(--text-secondary);
}
.btn.btn-ghost:hover {
  color: var(--text-primary);
  background: var(--bg-secondary);
}
.btn.btn-danger {
  background-color: #ef4444;
  border-color: #ef4444;
  color: #fff;
}
.btn.btn-danger:hover {
  background-color: rgb(236.9901477833, 44.5098522167, 44.5098522167);
}
.btn.btn-full {
  width: 100%;
}
.btn.btn-sm {
  padding: 8px 10px;
  font-size: 14px;
}
.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.input,
textarea {
  width: 100%;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 10px 12px;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  transition: border-color 150ms ease, box-shadow 150ms ease;
}
.input:focus,
textarea:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 16px;
}
.form-group label {
  font-weight: 600;
  color: var(--text-primary);
}
.form-group .hint {
  color: var(--text-secondary);
  font-size: 13px;
}

.card {
  background-color: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  box-shadow: var(--shadow);
  padding: 24px;
}

.card-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 16px;
}
.card-header .title {
  font-size: 18px;
  font-weight: 700;
  color: var(--text-primary);
}

.status-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  border-radius: 9999px;
  font-size: 13px;
  border: 1px solid var(--border-color);
  margin-bottom: 16px;
}
.status-badge + * {
  display: block;
}
.status-badge.success {
  color: #10b981;
  border-color: rgba(16, 185, 129, 0.35);
  background: rgba(16, 185, 129, 0.08);
}
.status-badge.warning {
  color: #f59e0b;
  border-color: rgba(245, 158, 11, 0.35);
  background: rgba(245, 158, 11, 0.08);
}
.status-badge.error {
  color: #ef4444;
  border-color: rgba(239, 68, 68, 0.35);
  background: rgba(239, 68, 68, 0.08);
}
.status-badge.muted {
  color: var(--text-secondary);
}

.notification-container {
  position: fixed;
  top: 24px;
  right: 24px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 3000;
  max-width: 360px;
}

@keyframes notification-enter {
  from {
    opacity: 0;
    transform: translateX(100%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}
@keyframes notification-exit {
  from {
    opacity: 1;
    transform: translateX(0);
  }
  to {
    opacity: 0;
    transform: translateX(100%);
  }
}
.notification {
  padding: 16px;
  border-radius: 8px;
  box-shadow: var(--shadow);
  border: 1px solid var(--border-color);
  background: var(--bg-primary);
  color: var(--text-primary);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
}
.notification.entering {
  animation: notification-enter 0.3s ease-out forwards;
}
.notification.exiting {
  animation: notification-exit 0.3s ease-in forwards;
}
.notification.success {
  border-color: rgba(16, 185, 129, 0.4);
}
.notification.warning {
  border-color: rgba(245, 158, 11, 0.4);
}
.notification.error {
  border-color: rgba(239, 68, 68, 0.4);
}
.notification .message {
  flex: 1;
  font-weight: 500;
}
.notification .close-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 30px;
  height: 30px;
  padding: 0;
  background: transparent;
  border: none;
  color: var(--text-secondary);
  border-radius: 8px;
  cursor: pointer;
  transition: color 0.15s ease, background-color 0.15s ease;
}
.notification .close-btn svg {
  display: block;
}
.notification .close-btn:hover {
  color: var(--text-primary);
  background: var(--bg-secondary);
}

.switch {
  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
}
.switch input {
  width: 0;
  height: 0;
  opacity: 0;
  position: absolute;
}
.switch .track {
  width: 44px;
  height: 24px;
  background: var(--border-color);
  border-radius: 9999px;
  position: relative;
  transition: background 150ms ease;
}
.switch .thumb {
  position: absolute;
  top: 3px;
  left: 3px;
  width: 18px;
  height: 18px;
  background: #fff;
  border-radius: 9999px;
  box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  transition: transform 150ms ease;
}
.switch input:checked + .track {
  background: var(--primary-color);
}
.switch input:checked + .track .thumb {
  transform: translateX(20px);
}
.switch .label {
  color: var(--text-primary);
  font-weight: 600;
}

.pill {
  padding: 4px 10px;
  border-radius: 9999px;
  background: var(--bg-secondary);
  color: var(--text-secondary);
  border: 1px solid var(--border-color);
  font-size: 12px;
}

.loading-spinner {
  border: 3px solid rgba(255, 255, 255, 0.2);
  border-top-color: #fff;
  border-radius: 50%;
  width: 16px;
  height: 16px;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.35);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
  padding: 24px;
}

.modal {
  background: var(--bg-primary);
  border-radius: 12px;
  border: 1px solid var(--border-color);
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
  max-height: 90vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 24px;
  border-bottom: 1px solid var(--border-color);
}
.modal-header .modal-title {
  font-weight: 700;
  font-size: 18px;
  color: var(--text-primary);
}
.modal-header .modal-close {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  padding: 0;
  background: transparent;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  border-radius: 8px;
  transition: color 0.15s ease, background-color 0.15s ease;
}
.modal-header .modal-close svg {
  display: block;
}
.modal-header .modal-close:hover {
  color: var(--text-primary);
  background: var(--bg-secondary);
}

.modal-body {
  padding: 24px;
  overflow: auto;
  max-height: 65vh;
}

.modal-footer {
  padding: 16px 24px;
  border-top: 1px solid var(--border-color);
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  background: var(--bg-primary);
}

.empty-state {
  border: 1px dashed var(--border-color);
  border-radius: 12px;
  padding: 24px;
  background: var(--bg-secondary);
  display: flex;
  justify-content: space-between;
  gap: 16px;
  align-items: center;
}
.empty-state .empty-content {
  display: flex;
  align-items: center;
  gap: 16px;
}
.empty-state .empty-icon {
  width: 42px;
  height: 42px;
  border-radius: 9999px;
  border: 2px solid var(--border-color);
  display: grid;
  place-items: center;
  color: var(--text-secondary);
}
.empty-state .empty-icon svg {
  display: block;
}
.empty-state .empty-title {
  font-weight: 700;
  color: var(--text-primary);
}
.empty-state .empty-desc {
  color: var(--text-secondary);
  margin-top: 4px;
}

.header-input-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.header-input-list .header-input-row {
  display: grid;
  grid-template-columns: 1fr auto 1fr auto;
  align-items: center;
  gap: 8px;
}
.header-input-list .header-separator {
  color: var(--text-secondary);
  text-align: center;
}
.header-input-list .align-start {
  width: fit-content;
}

.item-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.item-row {
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 16px;
  background: var(--bg-primary);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  flex-wrap: wrap;
}
.item-row .item-meta {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.item-row .item-title {
  font-weight: 700;
  color: var(--text-primary);
}
.item-row .item-subtitle {
  color: var(--text-secondary);
  font-family: ui-monospace, SFMono-Regular, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  word-break: break-all;
}
.item-row .item-actions {
  display: flex;
  gap: 8px;
}

.error-box {
  background: rgba(239, 68, 68, 0.1);
  border: 1px solid rgba(239, 68, 68, 0.4);
  border-radius: 8px;
  padding: 8px 16px;
  color: #ef4444;
}

.stack {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.filters {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 16px;
  margin-bottom: 16px;
}
.filters .filter-item {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.table {
  display: flex;
  flex-direction: column;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  overflow: hidden;
}
.table .table-header,
.table .table-row {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: 8px;
  padding: 8px 16px;
  align-items: center;
}
.table .table-header {
  background: var(--bg-secondary);
  font-weight: 700;
  color: var(--text-primary);
}
.table .table-row {
  border-top: 1px solid var(--border-color);
}
.table .cell {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

.pagination {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 16px;
}

.stat-card {
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 16px;
  background: var(--bg-primary);
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.stat-card .stat-label {
  color: var(--text-secondary);
  font-size: 14px;
}
.stat-card .stat-value {
  font-weight: 800;
  color: var(--text-primary);
  font-size: 18px;
}

.log-viewer {
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 16px;
  max-height: 520px;
  overflow: auto;
  white-space: pre-wrap;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  color: var(--text-primary);
}

.log-viewer-lines .log-line {
  display: block;
  padding: 1px 0;
}
.log-viewer-lines .log-line-warning {
  color: var(--warning-text, #92400e);
  background: var(--warning-bg, rgba(251, 191, 36, 0.18));
  border-radius: 4px;
  padding: 2px 6px;
}

.hint {
  color: var(--text-secondary);
}

:root {
  --header-height: 64px;
}

.app-shell {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  height: 100vh;
  overflow: hidden;
  background: var(--bg-secondary);
  color: var(--text-primary);
}

.main-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  padding: 16px 24px;
  background: var(--bg-primary);
  border-bottom: 1px solid var(--border-color);
  position: sticky;
  top: 0;
  z-index: 10;
  width: 100%;
}
@media (max-width: 768px) {
  .main-header {
    padding: 8px 16px;
    gap: 8px;
  }
}
.main-header .left {
  display: flex;
  align-items: center;
  gap: 8px;
  min-width: 0;
  flex: 0 1 auto;
}
.main-header .left .brand-logo {
  height: 32px;
  width: 32px;
  object-fit: contain;
  flex-shrink: 0;
  border-radius: 4px;
}
.main-header .right {
  display: flex;
  align-items: center;
  gap: 16px;
  min-width: 0;
  flex: 1 1 auto;
  justify-content: flex-end;
}
@media (max-width: 768px) {
  .main-header .right {
    flex: 0 1 auto;
    gap: 8px;
  }
}
.main-header .sidebar-toggle-header {
  padding: 0;
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 16px;
  font-weight: bold;
  transition: background 150ms ease, color 150ms ease;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  flex-shrink: 0;
  line-height: 1;
}
.main-header .sidebar-toggle-header:hover {
  background: var(--bg-tertiary, var(--border-color));
  color: var(--text-primary);
}
@media (max-width: 768px) {
  .main-header .sidebar-toggle-header {
    display: none;
  }
}
.main-header .brand-header {
  display: flex;
  align-items: center;
  gap: 4px;
  font-weight: 800;
  font-size: 18px;
  color: var(--text-primary);
  margin-right: 16px;
  cursor: pointer;
  overflow: hidden;
  white-space: nowrap;
  flex-shrink: 0;
}
.main-header .brand-header .brand-full {
  display: inline-block;
  max-width: 320px;
  opacity: 1;
  transform: translateX(0);
  transition: max-width 0.4s ease, opacity 0.4s ease, transform 0.4s ease;
}
.main-header .brand-header .brand-abbr {
  display: inline-block;
  transform: translateX(12px);
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.4s ease, transform 0.4s ease;
}
.main-header .brand-header.collapsed .brand-full {
  max-width: 0;
  opacity: 0;
  transform: translateX(-12px);
}
.main-header .brand-header.collapsed .brand-abbr {
  transform: translateX(0);
  opacity: 1;
  pointer-events: auto;
}
.main-header .brand-header:hover {
  color: var(--primary-color);
}
@media (max-width: 768px) {
  .main-header .brand-header {
    cursor: default;
    flex-shrink: 1;
    min-width: 0;
    margin-right: 0;
  }
  .main-header .brand-header .brand-full,
  .main-header .brand-header .brand-abbr {
    transition: none;
  }
  .main-header .brand-header .brand-full {
    display: none;
  }
  .main-header .brand-header .brand-abbr {
    transform: translateX(0);
    opacity: 1;
    pointer-events: auto;
  }
  .main-header .brand-header:hover {
    color: var(--text-primary);
  }
}
.main-header .mobile-menu-btn {
  display: none;
  flex-shrink: 0;
}
@media (max-width: 768px) {
  .main-header .mobile-menu-btn {
    display: inline-flex;
  }
}
.main-header .header-actions {
  display: flex;
  align-items: center;
  gap: 4px;
  flex-shrink: 0;
}
.main-header .header-actions svg {
  display: block;
}
@media (max-width: 768px) {
  .main-header .header-actions {
    gap: 2px;
  }
}
.main-header .connection {
  display: flex;
  align-items: center;
  gap: 8px;
  color: var(--text-secondary);
  min-width: 0;
  flex-shrink: 1;
  overflow: hidden;
}
.main-header .connection .status-badge {
  flex-shrink: 0;
  white-space: nowrap;
  margin-bottom: 0;
}
.main-header .connection .base {
  font-weight: 600;
  color: var(--text-primary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  min-width: 80px;
}
@media (max-width: 768px) {
  .main-header .connection {
    display: none;
  }
}

.main-body {
  display: flex;
  flex: 1;
  min-height: 0;
  height: calc(100vh - var(--header-height));
  overflow: hidden;
  position: relative;
}
@supports (height: 100dvh) {
  .main-body {
    height: calc(100dvh - var(--header-height));
  }
}

.sidebar {
  width: 240px;
  background: var(--bg-primary);
  border-right: 1px solid var(--border-color);
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 24px;
  transition: width 300ms ease, transform 300ms ease;
  overflow-y: auto;
  flex-shrink: 0;
  height: 100%;
}
.sidebar.collapsed {
  width: 60px;
  padding: 16px 8px;
}
.sidebar.collapsed .nav-item {
  justify-content: center;
  padding: 10px;
}
.sidebar .nav-section {
  display: flex;
  flex-direction: column;
  gap: 8px;
  flex: 1;
}
.sidebar .nav-item {
  padding: 10px 12px;
  border-radius: 8px;
  color: var(--text-primary);
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  transition: background 150ms ease, color 150ms ease;
}
.sidebar .nav-item .nav-icon {
  width: 20px;
  height: 20px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  opacity: 0.9;
}
.sidebar .nav-item .nav-icon svg {
  width: 18px;
  height: 18px;
  display: block;
}
.sidebar .nav-item .nav-label {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.sidebar .nav-item:hover {
  background: var(--bg-secondary);
}
.sidebar .nav-item.active {
  background: rgba(59, 130, 246, 0.12);
  color: var(--primary-color);
  border: 1px solid rgba(59, 130, 246, 0.3);
}
@media (max-width: 768px) {
  .sidebar {
    position: fixed;
    z-index: 1000;
    left: 0;
    top: var(--header-height);
    bottom: 0;
    transform: translateX(-100%);
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
  }
  .sidebar.open {
    transform: translateX(0);
  }
}

.content {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-width: 0;
  overflow-y: auto;
  height: 100%;
}

.main-content {
  flex: 1;
  padding: 24px;
  display: flex;
  flex-direction: column;
  gap: 24px;
}
@media (max-width: 768px) {
  .main-content {
    padding: 16px;
  }
}

.footer {
  padding: 16px 24px;
  border-top: 1px solid var(--border-color);
  background: var(--bg-primary);
  display: flex;
  justify-content: space-between;
  align-items: center;
  color: var(--text-secondary);
  font-size: 14px;
  flex-wrap: wrap;
  gap: 8px;
}

.login-page {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--bg-secondary);
  padding: 24px;
}
.login-page .login-card {
  width: 100%;
  max-width: 520px;
  background: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  box-shadow: var(--shadow-lg);
  padding: 32px;
  display: flex;
  flex-direction: column;
  gap: 24px;
}
.login-page .login-header {
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.login-page .login-header .title {
  font-size: 22px;
  font-weight: 800;
  color: var(--text-primary);
}
.login-page .login-header .subtitle {
  color: var(--text-secondary);
}
.login-page .connection-box {
  background: var(--bg-secondary);
  border: 1px dashed var(--border-color);
  border-radius: 8px;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.login-page .connection-box .label {
  color: var(--text-secondary);
  font-size: 14px;
}
.login-page .connection-box .value {
  font-weight: 700;
  color: var(--text-primary);
}
.login-page .connection-box .item-actions {
  display: flex;
  gap: 16px;
}
.login-page .toggle-advanced {
  display: flex;
  justify-content: flex-start;
  align-items: center;
  gap: 4px;
  color: var(--text-secondary);
  cursor: pointer;
}
.login-page .error-box {
  background: rgba(239, 68, 68, 0.1);
  border: 1px solid rgba(239, 68, 68, 0.4);
  border-radius: 8px;
  padding: 8px 16px;
  color: #ef4444;
}

.grid {
  display: grid;
  gap: 24px;
}

@media (min-width: 1024px) {
  .grid.cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
}
body {
  background-color: var(--bg-secondary);
  color: var(--text-primary);
  transition: background-color 300ms ease, color 300ms ease;
}

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg-secondary);
}

::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 9999px;
}
::-webkit-scrollbar-thumb:hover {
  background: var(--border-hover);
}

.container {
  width: 100%;
  max-width: 1280px;
  margin: 0 auto;
  padding: 0 16px;
}

.flex-center {
  display: flex;
  align-items: center;
  justify-content: center;
}

.text-ellipsis {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.fade-enter {
  opacity: 0;
}

.fade-enter-active {
  opacity: 1;
  transition: opacity 300ms ease;
}

.fade-exit {
  opacity: 1;
}

.fade-exit-active {
  opacity: 0;
  transition: opacity 300ms ease;
}
/**
 * SCSS 
 */
/**
 * SCSS 
 */
.Settings-module__container___UY8S9 {
  width: 100%;
}

.Settings-module__pageTitle___ADRp3 {
  font-size: 28px;
  font-weight: 700;
  color: var(--text-primary);
  margin: 0 0 32px 0;
}

.Settings-module__grid___WziyQ {
  display: grid;
  gap: 24px;
  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
}
@media (max-width: 768px) {
  .Settings-module__grid___WziyQ {
    grid-template-columns: 1fr;
  }
}

.Settings-module__settingRow___Gtlz1 {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
}

.Settings-module__settingInfo___PV73p {
  flex: 1;
}
.Settings-module__settingInfo___PV73p h4 {
  font-size: 16px;
  font-weight: 600;
  color: var(--text-primary);
  margin: 0 0 4px 0;
}
.Settings-module__settingInfo___PV73p p {
  font-size: 14px;
  color: var(--text-secondary);
  margin: 0;
}

.Settings-module__switch___HMHFi {
  position: relative;
  display: inline-block;
  width: 52px;
  height: 28px;
  flex-shrink: 0;
}
.Settings-module__switch___HMHFi input {
  opacity: 0;
  width: 0;
  height: 0;
}
.Settings-module__switch___HMHFi input:checked + .Settings-module__slider___jRppi {
  background-color: var(--primary-color);
}
.Settings-module__switch___HMHFi input:checked + .Settings-module__slider___jRppi:before {
  transform: translateX(24px);
}
.Settings-module__switch___HMHFi input:focus + .Settings-module__slider___jRppi {
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
}

.Settings-module__slider___jRppi {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: var(--border-color);
  transition: 150ms ease;
  border-radius: 9999px;
}
.Settings-module__slider___jRppi:before {
  position: absolute;
  content: "";
  height: 20px;
  width: 20px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: 150ms ease;
  border-radius: 9999px;
}

.Settings-module__formGroup___eylVJ {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.Settings-module__buttonGroup___rTmJv {
  display: flex;
  gap: 8px;
}

.Settings-module__retryRow___fKNn1 {
  display: flex;
  align-items: flex-end;
  gap: 16px;
  flex-wrap: wrap;
}
.Settings-module__retryRow___fKNn1 .form-group {
  margin-bottom: 0;
}
@media (max-width: 768px) {
  .Settings-module__retryRow___fKNn1 {
    flex-direction: column;
    align-items: stretch;
  }
}

.Settings-module__retryInput___-fsAl {
  width: 140px;
}
@media (max-width: 768px) {
  .Settings-module__retryInput___-fsAl {
    width: 100%;
  }
}

@media (max-width: 768px) {
  .Settings-module__retryButton___hpjto {
    width: 100%;
  }
}
/**
 * SCSS 
 */
/**
 * SCSS 
 */
.ApiKeysPage-module__container___tdy0z {
  width: 100%;
}

.ApiKeysPage-module__pageTitle___nLQ41 {
  font-size: 28px;
  font-weight: 700;
  color: var(--text-primary);
  margin: 0 0 32px 0;
}

.ApiKeysPage-module__content___6Ohlw {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.ApiKeysPage-module__header___S42XE {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 16px;
}
@media (max-width: 768px) {
  .ApiKeysPage-module__header___S42XE {
    flex-direction: column;
    align-items: stretch;
  }
}

.ApiKeysPage-module__actions___aO4gS {
  display: flex;
  gap: 8px;
}

.ApiKeysPage-module__emptyState___KD5nP {
  text-align: center;
  padding: 48px;
  color: var(--text-secondary);
}
.ApiKeysPage-module__emptyState___KD5nP i {
  font-size: 48px;
  margin-bottom: 16px;
  opacity: 0.5;
}
.ApiKeysPage-module__emptyState___KD5nP h3 {
  margin: 0 0 8px 0;
  color: var(--text-primary);
}
.ApiKeysPage-module__emptyState___KD5nP p {
  margin: 0;
}
/**
 * SCSS 
 */
/**
 * SCSS 
 */
.AiProvidersPage-module__container___y-jfS {
  width: 100%;
}

.AiProvidersPage-module__pageTitle___DoSv8 {
  font-size: 28px;
  font-weight: 700;
  color: var(--text-primary);
  margin: 0 0 32px 0;
}

.AiProvidersPage-module__content___E2Czu {
  display: flex;
  flex-direction: column;
  gap: 32px;
}

.AiProvidersPage-module__section___IvT9j {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.AiProvidersPage-module__sectionHeader___DP-H3 {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 16px;
}
.AiProvidersPage-module__sectionHeader___DP-H3 h3 {
  margin: 0;
  font-size: 20px;
  font-weight: 600;
  color: var(--text-primary);
}

.AiProvidersPage-module__providerList___mKQc1 {
  display: grid;
  gap: 16px;
  grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
}
@media (max-width: 768px) {
  .AiProvidersPage-module__providerList___mKQc1 {
    grid-template-columns: 1fr;
  }
}

.AiProvidersPage-module__cardStats___rELY1 {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 8px;
  padding-top: 4px;
}

.AiProvidersPage-module__statPill___d812A {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  border-radius: 999px;
  font-size: 13px;
  font-weight: 600;
  line-height: 1.1;
  border: 1px solid transparent;
  background-color: var(--bg-tertiary);
  color: var(--text-primary);
  white-space: nowrap;
}

.AiProvidersPage-module__statSuccess___5dRtj {
  background-color: var(--success-badge-bg, #d1fae5);
  color: var(--success-badge-text, #065f46);
  border-color: var(--success-badge-border, #6ee7b7);
}

.AiProvidersPage-module__statFailure___krDjY {
  background-color: var(--failure-badge-bg, #fee2e2);
  color: var(--failure-badge-text, #991b1b);
  border-color: var(--failure-badge-border, #fca5a5);
}

.AiProvidersPage-module__fieldRow___XK6hX {
  display: flex;
  flex-wrap: wrap;
  align-items: baseline;
  gap: 6px;
  margin-bottom: 4px;
  font-size: 13px;
  line-height: 1.4;
}

.AiProvidersPage-module__fieldLabel___cLX9f {
  color: var(--text-tertiary);
  font-weight: 500;
  white-space: nowrap;
  flex-shrink: 0;
}

.AiProvidersPage-module__fieldValue___VdFCH {
  color: var(--text-primary);
  font-weight: 600;
  word-break: break-all;
  font-family: "Monaco", "Menlo", "Consolas", "Ubuntu Mono", monospace;
}

.AiProvidersPage-module__headerBadgeList___kwkIM {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 6px;
}

.AiProvidersPage-module__headerBadge___eN0Fd {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  background: var(--accent-tertiary, #f3f4f6);
  border: 1px solid var(--border-primary);
  border-radius: 12px;
  padding: 4px 10px;
  font-size: 12px;
  color: var(--text-secondary);
}
.AiProvidersPage-module__headerBadge___eN0Fd strong {
  font-weight: 600;
  color: var(--text-primary);
}

.AiProvidersPage-module__modelTagList___shUnj {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 8px;
  align-items: center;
}

.AiProvidersPage-module__modelCountLabel___uV8s- {
  display: inline-flex;
  align-items: center;
  font-size: 13px;
  font-weight: 500;
  line-height: 1.4;
  color: var(--text-tertiary);
  white-space: nowrap;
  flex-shrink: 0;
}

.AiProvidersPage-module__modelTag___k-VuJ {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  background: var(--bg-quinary, #f8f9fa);
  color: var(--text-secondary);
  border: 1px solid var(--border-secondary);
  border-radius: 14px;
  padding: 4px 10px;
  font-size: 12px;
  transition: all 0.15s ease;
}
.AiProvidersPage-module__modelTag___k-VuJ:hover {
  background: var(--bg-tertiary);
  border-color: var(--primary-color);
}

.AiProvidersPage-module__modelName___-6r4h {
  font-weight: 600;
  color: var(--text-primary);
}

.AiProvidersPage-module__modelAlias___ljQjM {
  color: var(--text-tertiary);
  font-style: italic;
}
.AiProvidersPage-module__modelAlias___ljQjM::before {
  content: " ";
}

.AiProvidersPage-module__excludedModelTag___emTfi {
  background: var(--warning-bg, #fef3c7);
  border-color: var(--warning-border, #fbbf24);
  color: var(--warning-text, #92400e);
}
.AiProvidersPage-module__excludedModelTag___emTfi .AiProvidersPage-module__modelName___-6r4h {
  color: var(--warning-text, #92400e);
}

.AiProvidersPage-module__excludedModelsSection___XFykq {
  margin-top: 8px;
}

.AiProvidersPage-module__excludedModelsLabel___Drdds {
  font-size: 12px;
  font-weight: 500;
  color: var(--warning-text, #92400e);
  margin-bottom: 4px;
}

.AiProvidersPage-module__apiKeyEntriesSection___60ydj {
  margin-top: 10px;
}

.AiProvidersPage-module__apiKeyEntriesLabel___c5W8h {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 6px;
}

.AiProvidersPage-module__apiKeyEntryList___-xrgk {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.AiProvidersPage-module__apiKeyEntryCard___Y5gRi {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  background: var(--bg-secondary, #f9fafb);
  border: 1px solid var(--border-secondary);
  border-radius: 8px;
  font-size: 12px;
}

.AiProvidersPage-module__apiKeyEntryIndex___h8oWW {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--primary-color);
  color: white;
  font-size: 11px;
  font-weight: 600;
  flex-shrink: 0;
}

.AiProvidersPage-module__apiKeyEntryKey___JgU0c {
  font-family: "Monaco", "Menlo", "Consolas", "Ubuntu Mono", monospace;
  font-weight: 600;
  color: var(--text-primary);
  word-break: break-all;
}

.AiProvidersPage-module__apiKeyEntryProxy___gy9Vu {
  color: var(--text-tertiary);
  font-size: 11px;
}
.AiProvidersPage-module__apiKeyEntryProxy___gy9Vu::before {
  content: "| Proxy: ";
  color: var(--text-quaternary);
}

.AiProvidersPage-module__apiKeyEntryStats___Whq5E {
  display: flex;
  gap: 6px;
  margin-left: auto;
}

.AiProvidersPage-module__apiKeyEntryStat___rwvkB {
  display: inline-flex;
  align-items: center;
  gap: 3px;
  padding: 2px 6px;
  border-radius: 10px;
  font-size: 10px;
  font-weight: 600;
}
.AiProvidersPage-module__apiKeyEntryStat___rwvkB svg {
  display: block;
}

.AiProvidersPage-module__apiKeyEntryStatSuccess___GXIwG {
  background: var(--success-badge-bg, #d1fae5);
  color: var(--success-badge-text, #065f46);
}

.AiProvidersPage-module__apiKeyEntryStatFailure___XV9wg {
  background: var(--failure-badge-bg, #fee2e2);
  color: var(--failure-badge-text, #991b1b);
}

.AiProvidersPage-module__modelDiscoveryList___HKeOb {
  display: flex;
  flex-direction: column;
  gap: 6px;
  max-height: 360px;
  overflow-y: auto;
  margin-top: 8px;
  padding-right: 4px;
}

.AiProvidersPage-module__modelDiscoveryRow___3J8pc {
  display: flex;
  align-items: flex-start;
  gap: 8px;
  padding: 8px 10px;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  background: var(--bg-primary);
  cursor: pointer;
  transition: background 0.15s ease, border-color 0.15s ease;
}
.AiProvidersPage-module__modelDiscoveryRow___3J8pc input[type=checkbox] {
  margin-top: 2px;
  cursor: pointer;
}
.AiProvidersPage-module__modelDiscoveryRow___3J8pc:hover {
  border-color: var(--primary-color);
  background: var(--bg-secondary);
}

.AiProvidersPage-module__modelDiscoveryRowSelected___VLfIp {
  border-color: var(--primary-color);
  background: var(--bg-tertiary);
}

.AiProvidersPage-module__modelDiscoveryMeta___7D6Y5 {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.AiProvidersPage-module__modelDiscoveryName___yf70V {
  font-weight: 600;
  color: var(--text-primary);
}

.AiProvidersPage-module__modelDiscoveryAlias___N2nU7 {
  margin-left: 6px;
  color: var(--text-tertiary);
  font-style: italic;
}

.AiProvidersPage-module__modelDiscoveryDesc___nsrtd {
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.4;
}

.AiProvidersPage-module__openaiTestButtonSuccess___ZiymQ {
  background-color: var(--success-badge-bg, #d1fae5);
  border-color: var(--success-badge-border, #6ee7b7);
  color: var(--success-badge-text, #065f46);
}
.AiProvidersPage-module__openaiTestButtonSuccess___ZiymQ:hover {
  background-color: var(--success-badge-bg, #d1fae5);
  border-color: var(--success-badge-border, #6ee7b7);
}

.AiProvidersPage-module__openaiTestSelect___7-Upw {
  flex: 1 1 0;
  min-width: 0;
}

.AiProvidersPage-module__openaiTestButton___IEmjD {
  flex: 1 1 0;
  padding: 8px 12px;
  font-size: 14px;
  line-height: 1.5;
}

[data-theme='dark'] .AiProvidersPage-module__headerBadge___eN0Fd {
  background: rgba(59, 130, 246, 0.15);
  border-color: rgba(59, 130, 246, 0.3);
  color: var(--text-secondary);
}
[data-theme='dark'] .AiProvidersPage-module__headerBadge___eN0Fd strong {
  color: var(--text-secondary);
}
[data-theme='dark'] .AiProvidersPage-module__modelTag___k-VuJ {
  background: rgba(59, 130, 246, 0.1);
  border-color: var(--border-secondary);
}
[data-theme='dark'] .AiProvidersPage-module__excludedModelTag___emTfi {
  background: rgba(251, 191, 36, 0.22);
  border-color: rgba(251, 191, 36, 0.55);
  color: #fde68a;
}
[data-theme='dark'] .AiProvidersPage-module__excludedModelTag___emTfi .AiProvidersPage-module__modelName___-6r4h {
  color: #fde68a;
}
[data-theme='dark'] .AiProvidersPage-module__excludedModelsLabel___Drdds {
  color: #fde68a;
}
[data-theme='dark'] .AiProvidersPage-module__apiKeyEntryCard___Y5gRi {
  background: var(--bg-tertiary);
  border-color: var(--border-primary);
}
[data-theme='dark'] .AiProvidersPage-module__apiKeyEntryIndex___h8oWW {
  background: var(--primary-color);
}
/**
 * SCSS 
 */
/**
 * SCSS 
 */
.AuthFilesPage-module__container___u1c4k {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.AuthFilesPage-module__pageHeader___DVV58 {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.AuthFilesPage-module__pageTitle___1TOZn {
  font-size: 28px;
  font-weight: 700;
  color: var(--text-primary);
  margin: 0;
}

.AuthFilesPage-module__description___N3RjR {
  font-size: 14px;
  color: var(--text-secondary);
  margin: 0;
}

.AuthFilesPage-module__headerActions___j0ROO {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.AuthFilesPage-module__errorBox___A9vF2 {
  padding: 16px;
  background-color: rgba(239, 68, 68, 0.1);
  border: 1px solid var(--danger-color);
  border-radius: 8px;
  color: var(--danger-color);
  font-size: 14px;
  margin-bottom: 16px;
}

.AuthFilesPage-module__filterSection___qQ3Zo {
  display: flex;
  flex-direction: column;
  gap: 16px;
  margin-bottom: 24px;
}

.AuthFilesPage-module__filterTags___A24A3 {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
}

.AuthFilesPage-module__filterTag___-YnCU {
  padding: 6px 14px;
  border-radius: 20px;
  font-size: 13px;
  font-weight: 500;
  border: 1px solid transparent;
  cursor: pointer;
  transition: all 150ms ease;
}
.AuthFilesPage-module__filterTag___-YnCU:hover {
  transform: translateY(-1px);
  box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
}

.AuthFilesPage-module__filterTagActive___Rnbcs {
  font-weight: 600;
}

.AuthFilesPage-module__filterControls___PfZDU {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
  align-items: flex-end;
}
.AuthFilesPage-module__filterControls___PfZDU .form-group {
  margin: 0;
}
.AuthFilesPage-module__filterControls___PfZDU .input {
  height: 38px;
  box-sizing: border-box;
}

.AuthFilesPage-module__filterItem___Kko4o {
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.AuthFilesPage-module__filterItem___Kko4o label {
  font-size: 12px;
  color: var(--text-secondary);
  font-weight: 500;
  white-space: nowrap;
}
.AuthFilesPage-module__filterItem___Kko4o:first-child {
  min-width: 220px;
  flex: 1;
  max-width: 320px;
}
.AuthFilesPage-module__filterItem___Kko4o:not(:first-child) {
  min-width: auto;
}

.AuthFilesPage-module__pageSizeSelect___yEBvp {
  padding: 8px 12px;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  font-size: 14px;
  cursor: pointer;
  height: 38px;
  box-sizing: border-box;
}
.AuthFilesPage-module__pageSizeSelect___yEBvp:focus {
  outline: none;
  border-color: var(--primary-color);
}

.AuthFilesPage-module__statsInfo___ALHH7 {
  padding: 8px 12px;
  background-color: var(--bg-secondary);
  border-radius: 8px;
  font-size: 13px;
  color: var(--text-secondary);
  white-space: nowrap;
  height: 38px;
  box-sizing: border-box;
  display: flex;
  align-items: center;
}

.AuthFilesPage-module__fileGrid___ajvi5 {
  display: grid;
  gap: 16px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}
@media (min-width: 769px) and (max-width: 1024px) {
  .AuthFilesPage-module__fileGrid___ajvi5 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
}
@media (max-width: 768px) {
  .AuthFilesPage-module__fileGrid___ajvi5 {
    grid-template-columns: 1fr;
  }
}

.AuthFilesPage-module__fileCard___j9Jtq {
  background-color: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  transition: transform 150ms ease, box-shadow 150ms ease, border-color 150ms ease;
}
.AuthFilesPage-module__fileCard___j9Jtq:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  border-color: rgba(37, 99, 235, 0.2);
}

.AuthFilesPage-module__cardHeader___uJMtL {
  display: flex;
  align-items: center;
  gap: 8px;
  min-height: 28px;
}

.AuthFilesPage-module__typeBadge___Dtm6A {
  padding: 4px 10px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 600;
  white-space: nowrap;
  flex-shrink: 0;
}

.AuthFilesPage-module__fileName___DZ39s {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
  word-break: break-all;
  line-height: 1.4;
}

.AuthFilesPage-module__cardMeta___H6kAQ {
  display: flex;
  flex-direction: column;
  gap: 2px;
  font-size: 12px;
  color: var(--text-secondary);
  padding: 4px 0;
  border-top: 1px solid var(--border-color);
  border-bottom: 1px solid var(--border-color);
}

.AuthFilesPage-module__priorityWrapper___AiPqt {
  display: flex;
  align-items: center;
  gap: 4px;
}

.AuthFilesPage-module__priorityInput___nK62G {
  width: 60px;
  margin-left: 8px;
  padding: 2px 6px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background-color: var(--bg-secondary);
  color: var(--text-primary);
  font-size: 12px;
  text-align: center;
  transition: all 150ms ease;
}
.AuthFilesPage-module__priorityInput___nK62G:hover:not(:disabled) {
  border-color: var(--primary-color);
}
.AuthFilesPage-module__priorityInput___nK62G:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
}
.AuthFilesPage-module__priorityInput___nK62G:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.AuthFilesPage-module__priorityConfirmBtn___9jbyA {
  width: 24px;
  height: 24px;
  padding: 0;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background-color: var(--primary-color);
  color: white;
  font-size: 14px;
  font-weight: bold;
  cursor: pointer;
  transition: all 150ms ease;
  display: flex;
  align-items: center;
  justify-content: center;
}
.AuthFilesPage-module__priorityConfirmBtn___9jbyA:hover:not(:disabled) {
  background-color: #1d4ed8;
  transform: scale(1.05);
}
.AuthFilesPage-module__priorityConfirmBtn___9jbyA:active:not(:disabled) {
  transform: scale(0.95);
}
.AuthFilesPage-module__priorityConfirmBtn___9jbyA:disabled {
  opacity: 0.3;
  cursor: not-allowed;
  background-color: var(--bg-tertiary);
  color: var(--text-tertiary);
}

.AuthFilesPage-module__cardStats___JQ4ig {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  padding-top: 4px;
  margin-top: 4px;
}

.AuthFilesPage-module__statPill___wFsBu {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  border-radius: 999px;
  font-size: 13px;
  font-weight: 600;
  line-height: 1.1;
  border: 1px solid transparent;
  background-color: var(--bg-tertiary);
  color: var(--text-primary);
  white-space: nowrap;
}

.AuthFilesPage-module__statSuccess___mh8iR {
  background-color: var(--success-badge-bg, #d1fae5);
  color: var(--success-badge-text, #065f46);
  border-color: var(--success-badge-border, #6ee7b7);
}

.AuthFilesPage-module__statFailure___ivDGu {
  background-color: var(--failure-badge-bg, #fee2e2);
  color: var(--failure-badge-text, #991b1b);
  border-color: var(--failure-badge-border, #fca5a5);
}

.AuthFilesPage-module__cardActions___mJgkW {
  display: flex;
  gap: 4px;
  justify-content: flex-end;
  margin-top: auto;
  padding-top: 8px;
}

.AuthFilesPage-module__iconButton___XT5TY.btn.btn-sm {
  width: 34px;
  height: 34px;
  min-width: 34px;
  padding: 0;
  box-sizing: border-box;
  border-radius: 6px;
  gap: 0;
}

.AuthFilesPage-module__actionIcon___F2TRI {
  display: block;
}

.AuthFilesPage-module__virtualBadge___s32vc {
  font-size: 12px;
  color: var(--text-secondary);
  background-color: var(--bg-tertiary);
  padding: 4px 10px;
  border-radius: 4px;
  font-style: italic;
  display: inline-flex;
  align-items: center;
}

.AuthFilesPage-module__pagination___Hwpg2 {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 16px;
  margin-top: 24px;
  padding-top: 16px;
  border-top: 1px solid var(--border-color);
}

.AuthFilesPage-module__pageInfo___Fkfbg {
  font-size: 13px;
  color: var(--text-secondary);
  padding: 4px 16px;
  background-color: var(--bg-secondary);
  border-radius: 8px;
}

.AuthFilesPage-module__excludedList___9OGiS {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.AuthFilesPage-module__excludedItem___J3Xxa {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  background-color: var(--bg-secondary);
  border-radius: 8px;
  border: 1px solid var(--border-color);
  gap: 16px;
}
@media (max-width: 768px) {
  .AuthFilesPage-module__excludedItem___J3Xxa {
    flex-direction: column;
    align-items: flex-start;
  }
}

.AuthFilesPage-module__excludedInfo___0hKQa {
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 0;
  flex: 1;
}

.AuthFilesPage-module__excludedProvider___6pkYz {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 14px;
}

.AuthFilesPage-module__excludedModels___QdpJB {
  font-size: 12px;
  color: var(--text-secondary);
}

.AuthFilesPage-module__excludedActions___jP49M {
  display: flex;
  gap: 4px;
  flex-shrink: 0;
}

.AuthFilesPage-module__detailContent___K3wet {
  max-height: 400px;
  overflow: auto;
}

.AuthFilesPage-module__jsonContent___5lYBo {
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 16px;
  font-family: monospace;
  font-size: 12px;
  white-space: pre-wrap;
  word-break: break-all;
  color: var(--text-primary);
  margin: 0;
}

.AuthFilesPage-module__formGroup___1YGlp {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-top: 16px;
}
.AuthFilesPage-module__formGroup___1YGlp label {
  font-size: 14px;
  font-weight: 500;
  color: var(--text-primary);
}

.AuthFilesPage-module__textarea___IAg4a {
  width: 100%;
  padding: 8px 16px;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  font-size: 14px;
  font-family: monospace;
  resize: vertical;
}
.AuthFilesPage-module__textarea___IAg4a:focus {
  outline: none;
  border-color: var(--primary-color);
}
.AuthFilesPage-module__textarea___IAg4a::placeholder {
  color: var(--text-tertiary);
}

.AuthFilesPage-module__hint___YExGS {
  font-size: 12px;
  color: var(--text-tertiary);
  font-style: italic;
  text-align: center;
  padding: 24px;
}

.AuthFilesPage-module__modelsList___KKhRE {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.AuthFilesPage-module__modelItem___VMfPD {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  background-color: var(--bg-secondary);
  border-radius: 8px;
  border: 1px solid var(--border-color);
  flex-wrap: wrap;
  cursor: pointer;
  transition: all 150ms ease;
}
.AuthFilesPage-module__modelItem___VMfPD:hover {
  background-color: var(--bg-hover);
  border-color: var(--primary-color);
}
.AuthFilesPage-module__modelItem___VMfPD:active {
  transform: scale(0.98);
}

.AuthFilesPage-module__modelId___4wMUh {
  font-family: "Consolas", "Monaco", "Courier New", monospace;
  font-size: 13px;
  font-weight: 600;
  color: var(--text-primary);
  word-break: break-all;
}

.AuthFilesPage-module__modelDisplayName___znKrk {
  font-size: 12px;
  color: var(--text-secondary);
  flex-shrink: 0;
}

.AuthFilesPage-module__modelType___B0C7D {
  font-size: 11px;
  color: var(--text-tertiary);
  background-color: var(--bg-tertiary);
  padding: 2px 8px;
  border-radius: 10px;
  flex-shrink: 0;
  margin-left: auto;
}

.AuthFilesPage-module__modelItemExcluded___I5sBn {
  opacity: 0.6;
  background-color: var(--bg-tertiary);
  border-style: dashed;
}
.AuthFilesPage-module__modelItemExcluded___I5sBn .AuthFilesPage-module__modelId___4wMUh {
  text-decoration: line-through;
  color: var(--text-tertiary);
}
.AuthFilesPage-module__modelItemExcluded___I5sBn:hover {
  border-color: var(--danger-color);
}

.AuthFilesPage-module__modelExcludedBadge___FyRdH {
  font-size: 10px;
  color: var(--danger-color);
  background-color: rgba(239, 68, 68, 0.1);
  padding: 2px 6px;
  border-radius: 8px;
  border: 1px solid var(--danger-color);
  flex-shrink: 0;
}

.AuthFilesPage-module__quotaInfo___APAGI {
  margin-top: 8px;
  padding: 8px;
  background-color: var(--bg-secondary);
  border-radius: 8px;
  border: 1px solid var(--border-color);
}

.AuthFilesPage-module__quotaTitle___zf-Cs {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 8px;
}

.AuthFilesPage-module__quotaItem___HMmZr {
  margin-bottom: 4px;
}

.AuthFilesPage-module__quotaHeader___se3GH {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 4px;
  font-size: 11px;
}

.AuthFilesPage-module__quotaModel___huwv6 {
  color: var(--text-primary);
  font-family: "Consolas", "Monaco", "Courier New", monospace;
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  font-size: 10px;
}

.AuthFilesPage-module__quotaValue___0ADP8 {
  color: var(--text-secondary);
  font-weight: 600;
  margin-left: 4px;
  font-size: 10px;
}

.AuthFilesPage-module__progressBar___2jafj {
  height: 4px;
  background: var(--bg-tertiary);
  border-radius: 9999px;
  overflow: hidden;
  position: relative;
}

.AuthFilesPage-module__progressFill___LPOla {
  height: 100%;
  border-radius: 9999px;
  transition: width 0.3s ease;
}

.AuthFilesPage-module__progressNormal___zaTIT .AuthFilesPage-module__progressFill___LPOla {
  background: #10b981;
}

.AuthFilesPage-module__progressWarning___B0gsj .AuthFilesPage-module__progressFill___LPOla {
  background: #f59e0b;
}

.AuthFilesPage-module__progressDanger___2JoAM .AuthFilesPage-module__progressFill___LPOla {
  background: #ef4444;
}

.AuthFilesPage-module__quotaReset___bmEse {
  font-size: 9px;
  color: var(--text-tertiary);
  margin-top: 2px;
  font-style: italic;
}

.AuthFilesPage-module__quotaMore___UEkec {
  font-size: 11px;
  color: var(--text-tertiary);
  font-style: italic;
  margin-top: 4px;
  text-align: center;
}
/**
 * SCSS 
 */
/**
 * SCSS 
 */
.OAuthPage-module__container___LCCdH {
  width: 100%;
}

.OAuthPage-module__pageTitle___BQQ2z {
  font-size: 28px;
  font-weight: 700;
  color: var(--text-primary);
  margin: 0 0 32px 0;
}

.OAuthPage-module__content___Phg9V {
  display: flex;
  flex-direction: column;
  gap: 32px;
}

.OAuthPage-module__oauthSection___1olLq {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.OAuthPage-module__oauthGrid___wjAyh {
  display: grid;
  gap: 24px;
  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
}
@media (max-width: 768px) {
  .OAuthPage-module__oauthGrid___wjAyh {
    grid-template-columns: 1fr;
  }
}

.OAuthPage-module__oauthCard___CYTnC {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.OAuthPage-module__oauthStatus___h7bbL {
  padding: 16px;
  border-radius: 8px;
  font-size: 14px;
}
.OAuthPage-module__oauthStatus___h7bbL.OAuthPage-module__success___UHta0 {
  background-color: rgba(34, 197, 94, 0.1);
  color: #16a34a;
}
.OAuthPage-module__oauthStatus___h7bbL.OAuthPage-module__error___057CD {
  background-color: rgba(239, 68, 68, 0.1);
  color: #dc2626;
}
.OAuthPage-module__oauthStatus___h7bbL.OAuthPage-module__waiting___CbNSk {
  background-color: rgba(59, 130, 246, 0.1);
  color: #3b82f6;
}

.OAuthPage-module__callbackSection___8kA31 {
  margin-top: 16px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.OAuthPage-module__callbackActions___wtkMI {
  display: flex;
  gap: 16px;
}

.OAuthPage-module__authUrlBox___Iu1d4 {
  background: var(--bg-secondary);
  border: 1px dashed var(--border-color);
  border-radius: 8px;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.OAuthPage-module__authUrlLabel___mYFJB {
  color: var(--text-secondary);
  font-size: 14px;
}

.OAuthPage-module__authUrlValue___axvUJ {
  font-weight: 700;
  color: var(--text-primary);
  word-break: break-all;
  overflow-wrap: anywhere;
  line-height: 1.5;
  max-width: 100%;
}

.OAuthPage-module__authUrlActions___venPj {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
}
/**
 * SCSS 
 */
/**
 * SCSS 
 */
.UsagePage-module__container___nCAFc {
  width: 100%;
  min-height: 100%;
  display: flex;
  flex-direction: column;
  gap: 20px;
  position: relative;
}

.UsagePage-module__header___HxnC8 {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 10px;
}

.UsagePage-module__pageTitle___70rs5 {
  font-size: 28px;
  font-weight: 700;
  color: var(--text-primary);
  margin: 0;
}

.UsagePage-module__errorBox___gB8Rj {
  padding: 10px;
  background-color: rgba(239, 68, 68, 0.1);
  border: 1px solid var(--error-color);
  border-radius: 4px;
  color: var(--error-color);
  font-size: 12px;
}

.UsagePage-module__hint___pUQ06 {
  color: var(--text-secondary);
  font-size: 12px;
  text-align: center;
  padding: 16px;
}

.UsagePage-module__loadingOverlay___BuX9V {
  position: absolute;
  inset: 0;
  z-index: 20;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(243, 244, 246, 0.75);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}

[data-theme='dark'] .UsagePage-module__loadingOverlay___BuX9V {
  background: rgba(25, 25, 25, 0.72);
}

.UsagePage-module__loadingOverlayContent___3vf0S {
  display: inline-flex;
  align-items: center;
  gap: 10px;
  padding: 12px 16px;
  border-radius: 12px;
  border: 1px solid var(--border-color);
  background: var(--bg-primary);
  box-shadow: var(--shadow-lg);
}
.UsagePage-module__loadingOverlayContent___3vf0S .loading-spinner {
  border-color: rgba(59, 130, 246, 0.25);
  border-top-color: var(--primary-color);
}

.UsagePage-module__loadingOverlayText___64YIy {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
}

.UsagePage-module__statsGrid___Q0sW- {
  display: grid;
  gap: 14px;
  grid-template-columns: repeat(12, minmax(0, 1fr));
}
@media (max-width: 768px) {
  .UsagePage-module__statsGrid___Q0sW- {
    grid-template-columns: 1fr;
  }
}

.UsagePage-module__statCard___iCndn {
  --accent: #3b82f6;
  --accent-soft: rgba(59, 130, 246, 0.18);
  --accent-border: rgba(59, 130, 246, 0.35);
  grid-column: span 4;
  position: relative;
  padding: 18px;
  background: radial-gradient(120% 140% at 12% 0%, var(--accent-soft) 0%, rgba(0, 0, 0, 0) 62%), linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0)), var(--bg-primary);
  border-radius: 12px;
  border: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  gap: 10px;
  min-height: 176px;
  box-shadow: var(--shadow-lg);
  transition: transform 150ms ease, box-shadow 150ms ease, border-color 150ms ease;
  overflow: hidden;
}
.UsagePage-module__statCard___iCndn::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  height: 3px;
  width: 100%;
  background: linear-gradient(90deg, var(--accent), rgba(0, 0, 0, 0));
  opacity: 0.95;
}
.UsagePage-module__statCard___iCndn:hover {
  transform: translateY(-2px);
  border-color: var(--accent-border);
  box-shadow: 0 16px 40px rgba(0, 0, 0, 0.22);
}
@media (min-width: 769px) and (max-width: 1024px) {
  .UsagePage-module__statCard___iCndn {
    grid-column: span 6;
  }
}
@media (max-width: 768px) {
  .UsagePage-module__statCard___iCndn {
    grid-column: auto;
    min-height: 168px;
  }
}

.UsagePage-module__statCard___iCndn:nth-child(-n+2) {
  grid-column: span 6;
}
.UsagePage-module__statCard___iCndn:nth-child(-n+2) .UsagePage-module__statValue___duHNu {
  font-size: 32px;
}

@media (max-width: 768px) {
  .UsagePage-module__statCard___iCndn:nth-child(-n+2) {
    grid-column: auto;
  }
  .UsagePage-module__statCard___iCndn:nth-child(-n+2) .UsagePage-module__statValue___duHNu {
    font-size: 28px;
  }
}
.UsagePage-module__statCardHeader___IbBKW {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 12px;
}

.UsagePage-module__statLabelGroup___SMxKl {
  display: flex;
  flex-direction: column;
  gap: 1px;
}

.UsagePage-module__statIconBadge___bPCTx {
  width: 34px;
  height: 34px;
  border-radius: 8px;
  display: grid;
  place-items: center;
  color: #fff;
  font-size: 13px;
  background: var(--accent);
  border: 1px solid rgba(255, 255, 255, 0.08);
  box-shadow: 0 10px 22px rgba(0, 0, 0, 0.25);
  flex-shrink: 0;
}
.UsagePage-module__statIconBadge___bPCTx svg {
  display: block;
}

.UsagePage-module__statHeader___ieXhA {
  display: flex;
  align-items: center;
  gap: 8px;
}

.UsagePage-module__statIcon___hRQIn {
  font-size: 18px;
}

.UsagePage-module__statLabel___V2mir {
  font-size: 12px;
  color: var(--text-tertiary);
  font-weight: 700;
  letter-spacing: 0.02em;
}

.UsagePage-module__statValue___duHNu {
  font-size: 28px;
  font-weight: 800;
  color: var(--text-primary);
  line-height: 1.2;
  font-variant-numeric: tabular-nums;
}

.UsagePage-module__statValueRow___rjMSd {
  display: flex;
  gap: 24px;
}

.UsagePage-module__statValueSmall___QsRKt {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.UsagePage-module__statValueLabel___78BAI {
  font-size: 12px;
  color: var(--text-secondary);
}

.UsagePage-module__statValueNum___ve85a {
  font-size: 20px;
  font-weight: 700;
  color: var(--text-primary);
}

.UsagePage-module__statMeta___X-Pkf {
  display: flex;
  flex-direction: column;
  gap: 4px;
  font-size: 12px;
}

.UsagePage-module__statSuccess___AmaqC {
  color: var(--success-color, #22c55e);
}

.UsagePage-module__statFailure___jWtUQ {
  color: var(--danger-color, #ef4444);
}

.UsagePage-module__statNeutral___IhwNw {
  color: var(--text-secondary);
}

.UsagePage-module__statMetaRow___VB7gR {
  display: flex;
  flex-wrap: wrap;
  gap: 8px 10px;
  font-size: 12px;
  color: var(--text-secondary);
}

.UsagePage-module__statMetaItem___YIXw2 {
  display: inline-flex;
  align-items: center;
  gap: 4px;
}

.UsagePage-module__statMetaDot___daNGF {
  width: 7px;
  height: 7px;
  border-radius: 50%;
  background-color: var(--text-secondary);
}

.UsagePage-module__statSubtle___yXU7t {
  color: var(--text-tertiary);
}

.UsagePage-module__statTrend___ra06- {
  margin-top: auto;
  background: var(--bg-tertiary);
  border-radius: 8px;
  padding: 8px;
  height: 58px;
  border: 1px solid var(--border-color);
}

.UsagePage-module__statTrendPlaceholder___oRADx {
  width: 100%;
  height: 100%;
  background: var(--bg-secondary);
  border-radius: 8px;
}

.UsagePage-module__sparkline___1tqGF {
  width: 100%;
  height: 100% !important;
}

.UsagePage-module__statHint___HpsGj {
  color: var(--text-tertiary);
  font-style: italic;
}

.UsagePage-module__apiList___2kChf {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.UsagePage-module__apiItem___cyn0u {
  background-color: var(--bg-secondary);
  border-radius: 4px;
  border: 1px solid var(--border-color);
  overflow: hidden;
}

.UsagePage-module__apiHeader___tT8FK {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px;
  cursor: pointer;
  transition: background-color 0.15s ease;
}
.UsagePage-module__apiHeader___tT8FK:hover {
  background-color: var(--bg-tertiary);
}

.UsagePage-module__apiInfo___OFEK- {
  display: flex;
  flex-direction: column;
  gap: 3px;
  min-width: 0;
  flex: 1;
}

.UsagePage-module__apiEndpoint___J38DV {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 13px;
  word-break: break-all;
}

.UsagePage-module__apiStats___blw7G {
  display: flex;
  flex-wrap: wrap;
  gap: 3px;
}

.UsagePage-module__apiBadge___OAqI7 {
  font-size: 11px;
  color: var(--text-secondary);
  background-color: var(--bg-primary);
  border: 1px solid var(--border-color);
  padding: 2px 8px;
  border-radius: 9999px;
}

.UsagePage-module__expandIcon___5FU6h {
  color: var(--text-secondary);
  font-size: 12px;
  margin-left: 6px;
}

.UsagePage-module__apiModels___eZNUp {
  padding: 10px;
  padding-top: 0;
  display: flex;
  flex-direction: column;
  gap: 3px;
  border-top: 1px solid var(--border-color);
  margin-top: 0;
  padding-top: 10px;
}

.UsagePage-module__modelRow___ZKhXO {
  display: grid;
  grid-template-columns: 1fr auto auto;
  gap: 10px;
  padding: 8px 10px;
  background-color: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  font-size: 12px;
}
@media (max-width: 768px) {
  .UsagePage-module__modelRow___ZKhXO {
    grid-template-columns: 1fr;
    gap: 3px;
  }
}

.UsagePage-module__modelName___mlOFW {
  color: var(--text-primary);
  font-weight: 500;
  word-break: break-all;
}

.UsagePage-module__modelStat___9behg {
  color: var(--text-secondary);
  text-align: right;
}
@media (max-width: 768px) {
  .UsagePage-module__modelStat___9behg {
    text-align: left;
  }
}

.UsagePage-module__tableWrapper___Sax8l {
  overflow-x: auto;
}

.UsagePage-module__table___-sWaI {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}
.UsagePage-module__table___-sWaI th, .UsagePage-module__table___-sWaI td {
  padding: 10px 12px;
  text-align: left;
  border-bottom: 1px solid var(--border-color);
}
.UsagePage-module__table___-sWaI th {
  font-weight: 600;
  color: var(--text-tertiary);
  background-color: var(--bg-secondary);
  white-space: nowrap;
}
.UsagePage-module__table___-sWaI td {
  color: var(--text-primary);
}
.UsagePage-module__table___-sWaI tbody tr:hover {
  background-color: var(--bg-tertiary);
}

.UsagePage-module__modelCell___0d7fk {
  font-weight: 500;
  max-width: 240px;
  word-break: break-all;
}

.UsagePage-module__pricingSection___jk8kk {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.UsagePage-module__priceForm___OJwRe {
  padding: 10px;
  background-color: var(--bg-secondary);
  border-radius: 4px;
  border: 1px solid var(--border-color);
}

.UsagePage-module__formRow___sHXY2 {
  display: flex;
  gap: 10px;
  align-items: flex-end;
  flex-wrap: wrap;
}
@media (max-width: 768px) {
  .UsagePage-module__formRow___sHXY2 {
    flex-direction: column;
    align-items: stretch;
  }
}

.UsagePage-module__formField___Vf4b- {
  display: flex;
  flex-direction: column;
  gap: 3px;
  flex: 1;
  min-width: 120px;
}
.UsagePage-module__formField___Vf4b- label {
  font-size: 10px;
  color: var(--text-secondary);
  font-weight: 500;
}
.UsagePage-module__formField___Vf4b- .form-group {
  margin: 0;
}
.UsagePage-module__formField___Vf4b- .form-group > label {
  display: none;
}
.UsagePage-module__formField___Vf4b- .input {
  height: 40px;
  box-sizing: border-box;
}

.UsagePage-module__select___ZAWx- {
  padding: 10px 12px;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  font-size: 14px;
  cursor: pointer;
  height: 40px;
  box-sizing: border-box;
}
.UsagePage-module__select___ZAWx-:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
}

.UsagePage-module__pricesList___ys67C {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.UsagePage-module__pricesTitle___CJRmb {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-primary);
  margin: 0;
}

.UsagePage-module__pricesGrid___rCyGv {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.UsagePage-module__priceItem___I0JbD {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px;
  background-color: var(--bg-secondary);
  border-radius: 4px;
  border: 1px solid var(--border-color);
  gap: 10px;
}
@media (max-width: 768px) {
  .UsagePage-module__priceItem___I0JbD {
    flex-direction: column;
    align-items: flex-start;
  }
}

.UsagePage-module__priceInfo___TteL5 {
  display: flex;
  flex-direction: column;
  gap: 3px;
  min-width: 0;
  flex: 1;
}

.UsagePage-module__priceModel___GvFG8 {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 11px;
  word-break: break-all;
}

.UsagePage-module__priceMeta___V2rEi {
  display: flex;
  gap: 10px;
  font-size: 10px;
  color: var(--text-secondary);
}
@media (max-width: 768px) {
  .UsagePage-module__priceMeta___V2rEi {
    flex-direction: column;
    gap: 3px;
  }
}

.UsagePage-module__priceActions___2BFSQ {
  display: flex;
  gap: 3px;
  flex-shrink: 0;
}

.UsagePage-module__chartSection___Jugrm {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.UsagePage-module__chartControls___Be-or {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}
@media (max-width: 768px) {
  .UsagePage-module__chartControls___Be-or {
    flex-direction: column;
    align-items: stretch;
  }
}

.UsagePage-module__chartWrapper___lAIqa {
  padding: 14px;
  background-color: var(--bg-secondary);
  border-radius: 12px;
  border: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.UsagePage-module__chartLegend___OA6vI {
  display: flex;
  flex-wrap: wrap;
  gap: 6px 12px;
  align-items: center;
  min-width: 0;
}
@media (max-width: 768px) {
  .UsagePage-module__chartLegend___OA6vI {
    flex-wrap: nowrap;
    overflow-x: auto;
    overflow-y: hidden;
    -webkit-overflow-scrolling: touch;
    padding-bottom: 4px;
  }
}

.UsagePage-module__legendItem___g2pb0 {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  min-width: 0;
  max-width: 240px;
  padding: 4px 10px;
  border-radius: 9999px;
  border: 1px solid var(--border-color);
  background: var(--bg-primary);
  font-size: 12px;
  color: var(--text-secondary);
}
@media (max-width: 768px) {
  .UsagePage-module__legendItem___g2pb0 {
    max-width: 180px;
  }
}

.UsagePage-module__legendDot___Ehp8J {
  width: 10px;
  height: 10px;
  border-radius: 999px;
  flex-shrink: 0;
}

.UsagePage-module__legendLabel___pjtGV {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.UsagePage-module__chartArea___ZykTT {
  height: 280px;
}
@media (max-width: 768px) {
  .UsagePage-module__chartArea___ZykTT {
    height: 320px;
  }
}

.UsagePage-module__chartScroller___AtIi0 {
  width: 100%;
  height: 100%;
  overflow-x: auto;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;
}
.UsagePage-module__chartScroller___AtIi0 canvas {
  touch-action: pan-x pan-y !important;
}

.UsagePage-module__chartCanvas___NYz9z {
  position: relative;
  height: 100%;
  width: 100%;
}

.UsagePage-module__periodButtons___MD8jm {
  display: flex;
  gap: 6px;
}

.UsagePage-module__chartsGrid___k56wO {
  display: grid;
  gap: 20px;
  grid-template-columns: minmax(0, 1fr);
}
.UsagePage-module__chartsGrid___k56wO > * {
  min-width: 0;
}
@media (min-width: 1025px) {
  .UsagePage-module__chartsGrid___k56wO {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
}

.UsagePage-module__detailsGrid___zSOOI {
  display: grid;
  gap: 20px;
  grid-template-columns: minmax(0, 1fr);
}
.UsagePage-module__detailsGrid___zSOOI > * {
  min-width: 0;
}
@media (min-width: 1025px) {
  .UsagePage-module__detailsGrid___zSOOI {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
}

.UsagePage-module__chartLineHeader___xPk4F {
  display: inline-flex;
  align-items: center;
  gap: 10px;
}

.UsagePage-module__chartLineList___Le-PV {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 12px;
}
@media (max-width: 768px) {
  .UsagePage-module__chartLineList___Le-PV {
    grid-template-columns: 1fr;
  }
}

.UsagePage-module__chartLineItem___p7NYT {
  display: grid;
  grid-template-columns: auto 1fr auto;
  align-items: center;
  gap: 10px;
  padding: 12px;
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
}
@media (max-width: 768px) {
  .UsagePage-module__chartLineItem___p7NYT {
    grid-template-columns: 1fr;
    align-items: stretch;
    gap: 8px;
  }
}

.UsagePage-module__chartLineLabel___jA5Ww {
  font-size: 12px;
  color: var(--text-secondary);
  font-weight: 600;
  min-width: 64px;
}

.UsagePage-module__chartLineCount___yVkE2 {
  font-size: 12px;
  color: var(--text-secondary);
  font-weight: 500;
}

.UsagePage-module__chartLineHint___v7FGv {
  font-size: 12px;
  color: var(--text-tertiary);
  margin: 10px 0 0 0;
}
/**
 * SCSS 
 */
/**
 * SCSS 
 */
.ConfigPage-module__container___5kN-Y {
  width: 100%;
}

.ConfigPage-module__pageTitle___BoVLE {
  font-size: 28px;
  font-weight: 700;
  color: var(--text-primary);
  margin: 0 0 16px 0;
}

.ConfigPage-module__description___qruwQ {
  font-size: 14px;
  color: var(--text-secondary);
  margin: 0 0 32px 0;
}

.ConfigPage-module__content___PgFbt {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.ConfigPage-module__searchInputWrapper___-GeEQ {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}
.ConfigPage-module__searchInputWrapper___-GeEQ .form-group {
  margin-bottom: 0;
}

.ConfigPage-module__searchInput___ock8o {
  flex: 1;
  border-radius: 9999px !important;
  padding-right: 132px !important;
}

.ConfigPage-module__searchCount___AIry7 {
  font-size: 12px;
  color: var(--text-secondary);
  background: var(--bg-secondary);
  padding: 2px 8px;
  border-radius: 9999px;
  pointer-events: none;
  white-space: nowrap;
}

.ConfigPage-module__searchRight___pwWBV {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.ConfigPage-module__searchButton___GRbfi {
  border: none;
  background: none;
  padding: 0;
  margin: 0;
  cursor: pointer;
  font: inherit;
  color: inherit;
  outline: none;
}
.ConfigPage-module__searchButton___GRbfi:focus {
  outline: 2px solid #3b82f6;
  outline-offset: 2px;
}
.ConfigPage-module__searchButton___GRbfi {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border-radius: 9999px;
  background: var(--primary-color);
  border: 1px solid var(--primary-color);
  color: #fff;
  transition: background-color 150ms ease, border-color 150ms ease, opacity 150ms ease;
}
.ConfigPage-module__searchButton___GRbfi:hover:not(:disabled) {
  background: var(--primary-hover);
  border-color: var(--primary-hover);
}
.ConfigPage-module__searchButton___GRbfi:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.ConfigPage-module__searchActions___ZGITa {
  display: flex;
  gap: 4px;
  flex-shrink: 0;
}
.ConfigPage-module__searchActions___ZGITa button {
  min-width: 32px;
  width: 32px;
  height: 32px;
  padding: 0 !important;
  border-radius: 9999px;
}

.ConfigPage-module__controls___OTpD4 {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 16px;
}
@media (max-width: 768px) {
  .ConfigPage-module__controls___OTpD4 {
    flex-direction: column;
    align-items: stretch;
  }
}

.ConfigPage-module__status___QYXYr {
  font-size: 14px;
  color: var(--text-secondary);
}
.ConfigPage-module__status___QYXYr.ConfigPage-module__modified___4mzgT {
  color: #f59e0b;
}
.ConfigPage-module__status___QYXYr.ConfigPage-module__saved___zmZx2 {
  color: #16a34a;
}
.ConfigPage-module__status___QYXYr.ConfigPage-module__error___qlpX1 {
  color: #dc2626;
}

.ConfigPage-module__editorWrapper___yBudn {
  width: 100%;
  height: 500px;
  border: 1px solid var(--border-color);
  border-radius: 12px;
  overflow: hidden;
  position: relative;
  --floating-controls-height: 0px;
}
.ConfigPage-module__editorWrapper___yBudn .ConfigPage-module__floatingControls___RqBnu {
  position: absolute;
  top: 12px;
  left: 12px;
  right: 12px;
  z-index: 10;
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  pointer-events: auto;
}
.ConfigPage-module__editorWrapper___yBudn .cm-editor {
  height: 100%;
  font-size: 14px;
  font-family: "Consolas", "Monaco", "Menlo", monospace;
}
.ConfigPage-module__editorWrapper___yBudn .cm-scroller {
  overflow: auto;
  padding-top: calc(var(--floating-controls-height, 0px) + 16px);
}
.ConfigPage-module__editorWrapper___yBudn .cm-gutters {
  border-right: 1px solid var(--border-color);
  background: var(--bg-secondary);
}
.ConfigPage-module__editorWrapper___yBudn .cm-lineNumbers .cm-gutterElement {
  padding: 0 8px 0 12px;
  min-width: 40px;
  color: var(--text-muted);
}
.ConfigPage-module__editorWrapper___yBudn .cm-activeLine {
  background: var(--bg-hover);
}
.ConfigPage-module__editorWrapper___yBudn .cm-activeLineGutter {
  background: var(--bg-hover);
}
.ConfigPage-module__editorWrapper___yBudn .cm-selectionMatch {
  background: rgba(255, 193, 7, 0.3);
}
.ConfigPage-module__editorWrapper___yBudn .cm-searchMatch {
  background: rgba(255, 193, 7, 0.4);
  outline: 1px solid rgba(255, 193, 7, 0.6);
}
.ConfigPage-module__editorWrapper___yBudn .cm-searchMatch-selected {
  background: rgba(255, 152, 0, 0.5);
}
[data-theme=dark] .ConfigPage-module__editorWrapper___yBudn .cm-gutters {
  background: var(--bg-tertiary);
}
[data-theme=dark] .ConfigPage-module__editorWrapper___yBudn .cm-selectionMatch {
  background: rgba(255, 193, 7, 0.2);
}

.ConfigPage-module__actions___4RDYM {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}
@media (max-width: 768px) {
  .ConfigPage-module__actions___4RDYM {
    justify-content: stretch;
  }
  .ConfigPage-module__actions___4RDYM button {
    flex: 1;
  }
}
/**
 * SCSS 
 */
/**
 * SCSS 
 */
.LogsPage-module__container___aQ0JL {
  width: 100%;
}

.LogsPage-module__pageTitle___vZY55 {
  font-size: 28px;
  font-weight: 700;
  color: var(--text-primary);
  margin: 0 0 32px 0;
}

.LogsPage-module__content___hGaGn {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.LogsPage-module__toolbar___9dY5F {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}
@media (max-width: 768px) {
  .LogsPage-module__toolbar___9dY5F {
    align-items: flex-start;
  }
}

.LogsPage-module__filters___nUahU {
  display: flex;
  align-items: center;
  gap: 16px;
  flex-wrap: wrap;
  margin-bottom: 16px;
}
.LogsPage-module__filters___nUahU .form-group {
  margin: 0;
}

.LogsPage-module__searchWrapper___mrEmr {
  flex: 1;
  min-width: 220px;
  max-width: 420px;
}

.LogsPage-module__searchInput___eoPij {
  padding-right: 44px !important;
}

.LogsPage-module__searchIcon___73cvF {
  color: var(--text-tertiary);
  pointer-events: none;
}

.LogsPage-module__searchClear___yTM1y {
  border: none;
  background: none;
  padding: 0;
  margin: 0;
  cursor: pointer;
  font: inherit;
  color: inherit;
  outline: none;
}
.LogsPage-module__searchClear___yTM1y:focus {
  outline: 2px solid #3b82f6;
  outline-offset: 2px;
}
.LogsPage-module__searchClear___yTM1y {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  border-radius: 9999px;
  color: var(--text-secondary);
}
.LogsPage-module__searchClear___yTM1y:hover {
  background: var(--bg-secondary);
}

.LogsPage-module__filterStats___IaTXF {
  margin-left: auto;
  display: inline-flex;
  align-items: center;
  gap: 10px;
  font-size: 12px;
  color: var(--text-secondary);
  white-space: nowrap;
}

.LogsPage-module__removedCount___bNgxC {
  color: var(--text-tertiary);
}

.LogsPage-module__actionButton___aYJPR {
  white-space: nowrap;
}

.LogsPage-module__buttonContent___qjHrB {
  display: inline-flex;
  align-items: center;
  gap: 6px;
}
.LogsPage-module__buttonContent___qjHrB svg {
  flex: 0 0 auto;
}

.LogsPage-module__switchLabel___EfB3d {
  display: inline-flex;
  align-items: center;
  gap: 6px;
}
.LogsPage-module__switchLabel___EfB3d svg {
  flex: 0 0 auto;
}

.LogsPage-module__logPanel___2wjiP {
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  max-height: 620px;
  overflow: auto;
  position: relative;
}

.LogsPage-module__loadMoreBanner___BUD0t {
  position: sticky;
  top: 0;
  z-index: 1;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  padding: 8px 12px;
  border-bottom: 1px solid var(--border-color);
  background: var(--bg-primary);
  color: var(--text-secondary);
  font-size: 12px;
}

.LogsPage-module__loadMoreCount___UsdBd {
  color: var(--text-tertiary);
  white-space: nowrap;
}

.LogsPage-module__logList___lFt6f {
  display: flex;
  flex-direction: column;
}

.LogsPage-module__logRow___rxZS5 {
  display: grid;
  grid-template-columns: 170px 1fr;
  gap: 16px;
  padding: 10px 12px;
  border-bottom: 1px solid var(--border-color);
  border-left: 3px solid transparent;
  cursor: copy;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 12.5px;
  line-height: 1.45;
  color: var(--text-primary);
}
.LogsPage-module__logRow___rxZS5:hover {
  background: rgba(59, 130, 246, 0.06);
}
@media (max-width: 768px) {
  .LogsPage-module__logRow___rxZS5 {
    grid-template-columns: 1fr;
    gap: 4px;
  }
}

.LogsPage-module__rowWarn___Lhg4M {
  border-left-color: var(--warning-color);
}

.LogsPage-module__rowError___XQ3Qi {
  border-left-color: var(--error-color);
}

.LogsPage-module__timestamp___TZvLq {
  color: var(--text-tertiary);
  white-space: nowrap;
  padding-top: 2px;
}
@media (max-width: 768px) {
  .LogsPage-module__timestamp___TZvLq {
    white-space: normal;
  }
}

.LogsPage-module__rowMain___f--We {
  display: flex;
  flex-direction: column;
  gap: 4px;
  min-width: 0;
}

.LogsPage-module__rowMeta___1ZIIi {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 6px;
  min-width: 0;
}

.LogsPage-module__badge___tR566 {
  display: inline-flex;
  align-items: center;
  padding: 2px 8px;
  border-radius: 9999px;
  font-size: 12px;
  font-weight: 800;
  border: 1px solid var(--border-color);
  background: var(--bg-primary);
  color: var(--text-secondary);
  white-space: nowrap;
}

.LogsPage-module__pill___vGA2z {
  display: inline-flex;
  align-items: center;
  padding: 2px 8px;
  border-radius: 9999px;
  font-size: 12px;
  font-weight: 600;
  border: 1px solid var(--border-color);
  background: var(--bg-primary);
  color: var(--text-secondary);
  white-space: nowrap;
}

.LogsPage-module__source___nv7Zu {
  color: var(--text-secondary);
  max-width: 240px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
@media (max-width: 768px) {
  .LogsPage-module__source___nv7Zu {
    max-width: 100%;
  }
}

.LogsPage-module__statusBadge___hj08j {
  font-variant-numeric: tabular-nums;
}

.LogsPage-module__statusSuccess___3llcn {
  color: var(--success-badge-text);
  background: var(--success-badge-bg);
  border-color: var(--success-badge-border);
}

.LogsPage-module__statusInfo___B6DaE {
  color: var(--info-color);
  background: rgba(59, 130, 246, 0.12);
  border-color: rgba(59, 130, 246, 0.25);
}

.LogsPage-module__statusWarn___1Dwki {
  color: var(--warning-color);
  background: rgba(245, 158, 11, 0.14);
  border-color: rgba(245, 158, 11, 0.25);
}

.LogsPage-module__statusError___xxTDc {
  color: var(--failure-badge-text);
  background: var(--failure-badge-bg);
  border-color: var(--failure-badge-border);
}

.LogsPage-module__levelInfo___oZMOp {
  color: var(--info-color);
  background: rgba(59, 130, 246, 0.12);
  border-color: rgba(59, 130, 246, 0.25);
}

.LogsPage-module__levelWarn___DsCD0 {
  color: var(--warning-color);
  background: rgba(245, 158, 11, 0.14);
  border-color: rgba(245, 158, 11, 0.25);
}

.LogsPage-module__levelError___8VjWc {
  color: var(--error-color);
  background: rgba(239, 68, 68, 0.12);
  border-color: rgba(239, 68, 68, 0.25);
}

.LogsPage-module__levelDebug___l-5yk,
.LogsPage-module__levelTrace___XvRLF {
  color: var(--text-secondary);
  background: rgba(107, 114, 128, 0.12);
  border-color: rgba(107, 114, 128, 0.25);
}

.LogsPage-module__methodBadge___Cf9jC {
  color: var(--text-primary);
  background: rgba(59, 130, 246, 0.08);
  border-color: rgba(59, 130, 246, 0.22);
}

.LogsPage-module__path___frHAs {
  color: var(--text-primary);
  font-weight: 700;
  max-width: 520px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
@media (max-width: 768px) {
  .LogsPage-module__path___frHAs {
    max-width: 100%;
  }
}

.LogsPage-module__message___bNHRw {
  color: var(--text-secondary);
  white-space: pre-wrap;
  word-break: break-word;
}
/**
 * SCSS 
 */
.SystemPage-module__container___KAydo {
  width: 100%;
}

.SystemPage-module__pageTitle___DiF5E {
  font-size: 28px;
  font-weight: 700;
  color: var(--text-primary);
  margin: 0 0 32px 0;
}

.SystemPage-module__content___SauLn {
  display: flex;
  flex-direction: column;
  gap: 32px;
}

.SystemPage-module__section___Q6rCw {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.SystemPage-module__sectionTitle___GOXpQ {
  font-size: 20px;
  font-weight: 600;
  color: var(--text-primary);
  margin: 0 0 16px 0;
}

.SystemPage-module__sectionDescription___nI7Jo {
  font-size: 14px;
  color: var(--text-secondary);
  margin: 0 0 16px 0;
}

.SystemPage-module__infoGrid___NNFgo {
  display: grid;
  gap: 8px;
}
.SystemPage-module__infoGrid___NNFgo .SystemPage-module__infoRow___E8Q0J {
  display: flex;
  justify-content: space-between;
  padding: 8px 16px;
  background-color: var(--bg-secondary);
  border-radius: 8px;
}
.SystemPage-module__infoGrid___NNFgo .SystemPage-module__infoRow___E8Q0J .SystemPage-module__label___Xw4tZ {
  font-weight: 500;
  color: var(--text-secondary);
}
.SystemPage-module__infoGrid___NNFgo .SystemPage-module__infoRow___E8Q0J .SystemPage-module__value___pii6g {
  color: var(--text-primary);
  font-family: "Consolas", "Monaco", "Courier New", monospace;
}

.SystemPage-module__modelsList___id54Q {
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-height: 400px;
  overflow-y: auto;
}

.SystemPage-module__modelItem___ZTm4G {
  padding: 8px 16px;
  background-color: var(--bg-secondary);
  border-radius: 8px;
  font-family: "Consolas", "Monaco", "Courier New", monospace;
  font-size: 13px;
}
.SystemPage-module__modelItem___ZTm4G:hover {
  background-color: var(--bg-hover);
}

.SystemPage-module__modelTags___M0sci {
  display: flex;
  flex-wrap: wrap;
  flex: 0 0 100%;
  gap: 8px;
}

.SystemPage-module__modelTag___5Ar53 {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 10px;
  border-radius: 9999px;
  border: 1px solid var(--border-color);
  background-color: var(--bg-secondary);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}

.SystemPage-module__modelName___LKdAK {
  color: var(--text-primary);
  font-weight: 600;
}

.SystemPage-module__modelAlias___zioM- {
  color: var(--text-secondary);
  font-size: 12px;
}

.SystemPage-module__versionCheck___V09h4 {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.SystemPage-module__versionInfo___cmujE {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
}
.SystemPage-module__versionInfo___cmujE .SystemPage-module__versionItem___NmHd7 {
  padding: 16px;
  background-color: var(--bg-secondary);
  border-radius: 8px;
}
.SystemPage-module__versionInfo___cmujE .SystemPage-module__versionItem___NmHd7 .SystemPage-module__label___Xw4tZ {
  font-size: 12px;
  color: var(--text-secondary);
  margin-bottom: 4px;
}
.SystemPage-module__versionInfo___cmujE .SystemPage-module__versionItem___NmHd7 .SystemPage-module__version___XoIFT {
  font-size: 16px;
  font-weight: 600;
  color: var(--text-primary);
  font-family: "Consolas", "Monaco", "Courier New", monospace;
}

.SystemPage-module__quickLinks___QTmT3 {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 16px;
}

.SystemPage-module__linkCard___iSrVF {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 16px 24px;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  text-decoration: none;
  color: inherit;
  transition: all 0.2s ease;
}
.SystemPage-module__linkCard___iSrVF:hover {
  background-color: var(--bg-hover);
  border-color: var(--primary-color);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}
.SystemPage-module__linkCard___iSrVF:active {
  transform: translateY(0);
}

.SystemPage-module__linkIcon___gNqz2 {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 44px;
  height: 44px;
  border-radius: 8px;
  background-color: var(--primary-color);
  color: white;
  flex-shrink: 0;
}
.SystemPage-module__linkIcon___gNqz2.SystemPage-module__github___V8I3m {
  background-color: #24292f;
}
.SystemPage-module__linkIcon___gNqz2.SystemPage-module__docs___cA-rG {
  background-color: #10b981;
}

.SystemPage-module__linkContent___Rfh7h {
  flex: 1;
  min-width: 0;
}

.SystemPage-module__linkTitle___Zpr4Q {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 15px;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 2px;
}
.SystemPage-module__linkTitle___Zpr4Q svg {
  opacity: 0.5;
  flex-shrink: 0;
}

.SystemPage-module__linkDesc___KKavC {
  font-size: 13px;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}</style>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
